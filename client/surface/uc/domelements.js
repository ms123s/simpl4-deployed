/*
   Copyright 2008-2015 SpryMedia Ltd.

 This source file is free software, available under the following license:
   MIT license - http://datatables.net/license

 This source file is distributed in the hope that it will be useful, but
 WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.

 For details please refer to: http://www.datatables.net
   Copyright 2014-2016 SpryMedia Ltd.

 This source file is free software, available under the following license:
   MIT license - http://datatables.net/license/mit

 This source file is distributed in the hope that it will be useful, but
 WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.

 For details please refer to: http://www.datatables.net
   Copyright 2011-2016 SpryMedia Ltd.

 This source file is free software, available under the following license:
   MIT license - http://datatables.net/license/mit

 This source file is distributed in the hope that it will be useful, but
 WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.

 For details please refer to: http://www.datatables.net
 jquery.spinner v0.2.1 (https://vsn4ik.github.io/jquery.spinner/)
 Copyright 2013-2017 xixilive
 Licensed under the MIT license
 Cropper v3.0.0-rc.3
 https://github.com/fengyuanchen/cropper

 Copyright (c) 2017 Fengyuan Chen
 Released under the MIT license

 Date: 2017-07-07T13:00:47.346Z
 jQuery QueryBuilder 1.3.0
 Copyright 2014-2015 Damien "Mistic" Sorel (http://www.strangeplanet.fr)
 Licensed under MIT (http://opensource.org/licenses/MIT)
 DataTables 1.10.12
 ©2008-2015 SpryMedia Ltd - datatables.net/license
 Responsive 2.1.0
 2014-2016 SpryMedia Ltd - datatables.net/license
 Scroller 1.4.2
 ©2011-2016 SpryMedia Ltd - datatables.net/license
 toast.visible*/
(function() {
  function resolve() {
    document.body.removeAttribute("unresolved");
  }
  if (window.WebComponents) {
    addEventListener("WebComponentsReady", resolve);
  } else {
    if (document.readyState === "interactive" || document.readyState === "complete") {
      resolve();
    } else {
      addEventListener("DOMContentLoaded", resolve);
    }
  }
})();
window.Polymer = {Settings:function() {
  var settings = window.Polymer || {};
  var parts = location.search.slice(1).split("&");
  for (var i = 0, o; i < parts.length && (o = parts[i]); i++) {
    o = o.split("=");
    o[0] && (settings[o[0]] = o[1] || true);
  }
  settings.wantShadow = settings.dom === "shadow";
  settings.hasShadow = Boolean(Element.prototype.createShadowRoot);
  settings.nativeShadow = settings.hasShadow && !window.ShadowDOMPolyfill;
  settings.useShadow = settings.wantShadow && settings.hasShadow;
  settings.hasNativeImports = Boolean("import" in document.createElement("link"));
  settings.useNativeImports = settings.hasNativeImports;
  settings.useNativeCustomElements = !window.CustomElements || window.CustomElements.useNative;
  settings.useNativeShadow = settings.useShadow && settings.nativeShadow;
  settings.usePolyfillProto = !settings.useNativeCustomElements && !Object.__proto__;
  return settings;
}()};
(function() {
  var userPolymer = window.Polymer;
  window.Polymer = function(prototype) {
    if (typeof prototype === "function") {
      prototype = prototype.prototype;
    }
    if (!prototype) {
      prototype = {};
    }
    var factory = desugar(prototype);
    prototype = factory.prototype;
    var options = {prototype:prototype};
    if (prototype.extends) {
      options.extends = prototype.extends;
    }
    Polymer.telemetry._registrate(prototype);
    document.registerElement(prototype.is, options);
    return factory;
  };
  var desugar = function(prototype) {
    var base = Polymer.Base;
    if (prototype.extends) {
      base = Polymer.Base._getExtendedPrototype(prototype.extends);
    }
    prototype = Polymer.Base.chainObject(prototype, base);
    prototype.registerCallback();
    return prototype.constructor;
  };
  if (userPolymer) {
    for (var i in userPolymer) {
      Polymer[i] = userPolymer[i];
    }
  }
  Polymer.Class = desugar;
})();
Polymer.telemetry = {registrations:[], _regLog:function(prototype) {
  console.log("[" + prototype.is + "]: registered");
}, _registrate:function(prototype) {
  this.registrations.push(prototype);
  Polymer.log && this._regLog(prototype);
}, dumpRegistrations:function() {
  this.registrations.forEach(this._regLog);
}};
Object.defineProperty(window, "currentImport", {enumerable:true, configurable:true, get:function() {
  return (document._currentScript || document.currentScript).ownerDocument;
}});
Polymer.RenderStatus = {_ready:false, _callbacks:[], whenReady:function(cb) {
  if (this._ready) {
    cb();
  } else {
    this._callbacks.push(cb);
  }
}, _makeReady:function() {
  this._ready = true;
  for (var i = 0; i < this._callbacks.length; i++) {
    this._callbacks[i]();
  }
  this._callbacks = [];
}, _catchFirstRender:function() {
  requestAnimationFrame(function() {
    Polymer.RenderStatus._makeReady();
  });
}, _afterNextRenderQueue:[], _waitingNextRender:false, afterNextRender:function(element, fn, args) {
  this._watchNextRender();
  this._afterNextRenderQueue.push([element, fn, args]);
}, _watchNextRender:function() {
  if (!this._waitingNextRender) {
    this._waitingNextRender = true;
    var fn = function() {
      Polymer.RenderStatus._flushNextRender();
    };
    if (!this._ready) {
      this.whenReady(fn);
    } else {
      requestAnimationFrame(fn);
    }
  }
}, _flushNextRender:function() {
  var self = this;
  setTimeout(function() {
    self._flushRenderCallbacks(self._afterNextRenderQueue);
    self._afterNextRenderQueue = [];
    self._waitingNextRender = false;
  });
}, _flushRenderCallbacks:function(callbacks) {
  for (var i = 0, h; i < callbacks.length; i++) {
    h = callbacks[i];
    h[1].apply(h[0], h[2] || Polymer.nar);
  }
}};
if (window.HTMLImports) {
  HTMLImports.whenReady(function() {
    Polymer.RenderStatus._catchFirstRender();
  });
} else {
  Polymer.RenderStatus._catchFirstRender();
}
Polymer.ImportStatus = Polymer.RenderStatus;
Polymer.ImportStatus.whenLoaded = Polymer.ImportStatus.whenReady;
(function() {
  var settings = Polymer.Settings;
  Polymer.Base = {__isPolymerInstance__:true, _addFeature:function(feature) {
    this.extend(this, feature);
  }, registerCallback:function() {
    this._desugarBehaviors();
    this._doBehavior("beforeRegister");
    this._registerFeatures();
    if (!settings.lazyRegister) {
      this.ensureRegisterFinished();
    }
  }, createdCallback:function() {
    if (!this.__hasRegisterFinished) {
      this._ensureRegisterFinished(this.__proto__);
    }
    Polymer.telemetry.instanceCount++;
    this.root = this;
    this._doBehavior("created");
    this._initFeatures();
  }, ensureRegisterFinished:function() {
    this._ensureRegisterFinished(this);
  }, _ensureRegisterFinished:function(proto) {
    if (proto.__hasRegisterFinished !== proto.is) {
      proto.__hasRegisterFinished = proto.is;
      if (proto._finishRegisterFeatures) {
        proto._finishRegisterFeatures();
      }
      proto._doBehavior("registered");
    }
  }, attachedCallback:function() {
    var self = this;
    Polymer.RenderStatus.whenReady(function() {
      self.isAttached = true;
      self._doBehavior("attached");
    });
  }, detachedCallback:function() {
    this.isAttached = false;
    this._doBehavior("detached");
  }, attributeChangedCallback:function(name, oldValue, newValue) {
    this._attributeChangedImpl(name);
    this._doBehavior("attributeChanged", [name, oldValue, newValue]);
  }, _attributeChangedImpl:function(name) {
    this._setAttributeToProperty(this, name);
  }, extend:function(prototype, api) {
    if (prototype && api) {
      var n$ = Object.getOwnPropertyNames(api);
      for (var i = 0, n; i < n$.length && (n = n$[i]); i++) {
        this.copyOwnProperty(n, api, prototype);
      }
    }
    return prototype || api;
  }, mixin:function(target, source) {
    for (var i in source) {
      target[i] = source[i];
    }
    return target;
  }, copyOwnProperty:function(name, source, target) {
    var pd = Object.getOwnPropertyDescriptor(source, name);
    if (pd) {
      Object.defineProperty(target, name, pd);
    }
  }, _log:console.log.apply.bind(console.log, console), _warn:console.warn.apply.bind(console.warn, console), _error:console.error.apply.bind(console.error, console), _logf:function() {
    return this._logPrefix.concat([this.is]).concat(Array.prototype.slice.call(arguments, 0));
  }};
  Polymer.Base._logPrefix = function() {
    var color = window.chrome || /firefox/i.test(navigator.userAgent);
    return color ? ["%c[%s::%s]:", "font-weight: bold; background-color:#EEEE00;"] : ["[%s::%s]:"];
  }();
  Polymer.Base.chainObject = function(object, inherited) {
    if (object && inherited && object !== inherited) {
      if (!Object.__proto__) {
        object = Polymer.Base.extend(Object.create(inherited), object);
      }
      object.__proto__ = inherited;
    }
    return object;
  };
  Polymer.Base = Polymer.Base.chainObject(Polymer.Base, HTMLElement.prototype);
  if (window.CustomElements) {
    Polymer.instanceof = CustomElements.instanceof;
  } else {
    Polymer.instanceof = function(obj, ctor) {
      return obj instanceof ctor;
    };
  }
  Polymer.isInstance = function(obj) {
    return Boolean(obj && obj.__isPolymerInstance__);
  };
  Polymer.telemetry.instanceCount = 0;
})();
(function() {
  var modules = {};
  var lcModules = {};
  var findModule = function(id) {
    return modules[id] || lcModules[id.toLowerCase()];
  };
  var DomModule = function() {
    return document.createElement("dom-module");
  };
  DomModule.prototype = Object.create(HTMLElement.prototype);
  Polymer.Base.extend(DomModule.prototype, {constructor:DomModule, createdCallback:function() {
    this.register();
  }, register:function(id) {
    id = id || this.id || this.getAttribute("name") || this.getAttribute("is");
    if (id) {
      this.id = id;
      modules[id] = this;
      lcModules[id.toLowerCase()] = this;
    }
  }, import:function(id, selector) {
    if (id) {
      var m = findModule(id);
      if (!m) {
        forceDomModulesUpgrade();
        m = findModule(id);
      }
      if (m && selector) {
        m = m.querySelector(selector);
      }
      return m;
    }
  }});
  var cePolyfill = window.CustomElements && !CustomElements.useNative;
  document.registerElement("dom-module", DomModule);
  function forceDomModulesUpgrade() {
    if (cePolyfill) {
      var script = document._currentScript || document.currentScript;
      var doc = script && script.ownerDocument || document;
      var modules = doc.querySelectorAll("dom-module");
      for (var i = modules.length - 1, m; i >= 0 && (m = modules[i]); i--) {
        if (m.__upgraded__) {
          return;
        } else {
          CustomElements.upgrade(m);
        }
      }
    }
  }
})();
Polymer.Base._addFeature({_prepIs:function() {
  if (!this.is) {
    var module = (document._currentScript || document.currentScript).parentNode;
    if (module.localName === "dom-module") {
      var id = module.id || module.getAttribute("name") || module.getAttribute("is");
      this.is = id;
    }
  }
  if (this.is) {
    this.is = this.is.toLowerCase();
  }
}});
Polymer.Base._addFeature({behaviors:[], _desugarBehaviors:function() {
  if (this.behaviors.length) {
    this.behaviors = this._desugarSomeBehaviors(this.behaviors);
  }
}, _desugarSomeBehaviors:function(behaviors) {
  var behaviorSet = [];
  behaviors = this._flattenBehaviorsList(behaviors);
  for (var i = behaviors.length - 1; i >= 0; i--) {
    var b = behaviors[i];
    if (behaviorSet.indexOf(b) === -1) {
      this._mixinBehavior(b);
      behaviorSet.unshift(b);
    }
  }
  return behaviorSet;
}, _flattenBehaviorsList:function(behaviors) {
  var flat = [];
  for (var i = 0; i < behaviors.length; i++) {
    var b = behaviors[i];
    if (b instanceof Array) {
      flat = flat.concat(this._flattenBehaviorsList(b));
    } else {
      if (b) {
        flat.push(b);
      } else {
        this._warn(this._logf("_flattenBehaviorsList", "behavior is null, check for missing or 404 import"));
      }
    }
  }
  return flat;
}, _mixinBehavior:function(b) {
  var n$ = Object.getOwnPropertyNames(b);
  for (var i = 0, n; i < n$.length && (n = n$[i]); i++) {
    if (!Polymer.Base._behaviorProperties[n] && !this.hasOwnProperty(n)) {
      this.copyOwnProperty(n, b, this);
    }
  }
}, _prepBehaviors:function() {
  this._prepFlattenedBehaviors(this.behaviors);
}, _prepFlattenedBehaviors:function(behaviors) {
  for (var i = 0, l = behaviors.length; i < l; i++) {
    this._prepBehavior(behaviors[i]);
  }
  this._prepBehavior(this);
}, _doBehavior:function(name, args) {
  for (var i = 0; i < this.behaviors.length; i++) {
    this._invokeBehavior(this.behaviors[i], name, args);
  }
  this._invokeBehavior(this, name, args);
}, _invokeBehavior:function(b, name, args) {
  var fn = b[name];
  if (fn) {
    fn.apply(this, args || Polymer.nar);
  }
}, _marshalBehaviors:function() {
  for (var i = 0; i < this.behaviors.length; i++) {
    this._marshalBehavior(this.behaviors[i]);
  }
  this._marshalBehavior(this);
}});
Polymer.Base._behaviorProperties = {hostAttributes:true, beforeRegister:true, registered:true, properties:true, observers:true, listeners:true, created:true, attached:true, detached:true, attributeChanged:true, ready:true};
Polymer.Base._addFeature({_getExtendedPrototype:function(tag) {
  return this._getExtendedNativePrototype(tag);
}, _nativePrototypes:{}, _getExtendedNativePrototype:function(tag) {
  var p = this._nativePrototypes[tag];
  if (!p) {
    var np = this.getNativePrototype(tag);
    p = this.extend(Object.create(np), Polymer.Base);
    this._nativePrototypes[tag] = p;
  }
  return p;
}, getNativePrototype:function(tag) {
  return Object.getPrototypeOf(document.createElement(tag));
}});
Polymer.Base._addFeature({_prepConstructor:function() {
  this._factoryArgs = this.extends ? [this.extends, this.is] : [this.is];
  var ctor = function() {
    return this._factory(arguments);
  };
  if (this.hasOwnProperty("extends")) {
    ctor.extends = this.extends;
  }
  Object.defineProperty(this, "constructor", {value:ctor, writable:true, configurable:true});
  ctor.prototype = this;
}, _factory:function(args) {
  var elt = document.createElement.apply(document, this._factoryArgs);
  if (this.factoryImpl) {
    this.factoryImpl.apply(elt, args);
  }
  return elt;
}});
Polymer.nob = Object.create(null);
Polymer.Base._addFeature({properties:{}, getPropertyInfo:function(property) {
  var info = this._getPropertyInfo(property, this.properties);
  if (!info) {
    for (var i = 0; i < this.behaviors.length; i++) {
      info = this._getPropertyInfo(property, this.behaviors[i].properties);
      if (info) {
        return info;
      }
    }
  }
  return info || Polymer.nob;
}, _getPropertyInfo:function(property, properties) {
  var p = properties && properties[property];
  if (typeof p === "function") {
    p = properties[property] = {type:p};
  }
  if (p) {
    p.defined = true;
  }
  return p;
}, _prepPropertyInfo:function() {
  this._propertyInfo = {};
  for (var i = 0; i < this.behaviors.length; i++) {
    this._addPropertyInfo(this._propertyInfo, this.behaviors[i].properties);
  }
  this._addPropertyInfo(this._propertyInfo, this.properties);
  this._addPropertyInfo(this._propertyInfo, this._propertyEffects);
}, _addPropertyInfo:function(target, source) {
  if (source) {
    var t, s;
    for (var i in source) {
      t = target[i];
      s = source[i];
      if (i[0] === "_" && !s.readOnly) {
        continue;
      }
      if (!target[i]) {
        target[i] = {type:typeof s === "function" ? s : s.type, readOnly:s.readOnly, attribute:Polymer.CaseMap.camelToDashCase(i)};
      } else {
        if (!t.type) {
          t.type = s.type;
        }
        if (!t.readOnly) {
          t.readOnly = s.readOnly;
        }
      }
    }
  }
}});
Polymer.CaseMap = {_caseMap:{}, _rx:{dashToCamel:/-[a-z]/g, camelToDash:/([A-Z])/g}, dashToCamelCase:function(dash) {
  return this._caseMap[dash] || (this._caseMap[dash] = dash.indexOf("-") < 0 ? dash : dash.replace(this._rx.dashToCamel, function(m) {
    return m[1].toUpperCase();
  }));
}, camelToDashCase:function(camel) {
  return this._caseMap[camel] || (this._caseMap[camel] = camel.replace(this._rx.camelToDash, "-$1").toLowerCase());
}};
Polymer.Base._addFeature({_addHostAttributes:function(attributes) {
  if (!this._aggregatedAttributes) {
    this._aggregatedAttributes = {};
  }
  if (attributes) {
    this.mixin(this._aggregatedAttributes, attributes);
  }
}, _marshalHostAttributes:function() {
  if (this._aggregatedAttributes) {
    this._applyAttributes(this, this._aggregatedAttributes);
  }
}, _applyAttributes:function(node, attr$) {
  for (var n in attr$) {
    if (!this.hasAttribute(n) && n !== "class") {
      var v = attr$[n];
      this.serializeValueToAttribute(v, n, this);
    }
  }
}, _marshalAttributes:function() {
  this._takeAttributesToModel(this);
}, _takeAttributesToModel:function(model) {
  if (this.hasAttributes()) {
    for (var i in this._propertyInfo) {
      var info = this._propertyInfo[i];
      if (this.hasAttribute(info.attribute)) {
        this._setAttributeToProperty(model, info.attribute, i, info);
      }
    }
  }
}, _setAttributeToProperty:function(model, attribute, property, info) {
  if (!this._serializing) {
    property = property || Polymer.CaseMap.dashToCamelCase(attribute);
    info = info || this._propertyInfo && this._propertyInfo[property];
    if (info && !info.readOnly) {
      var v = this.getAttribute(attribute);
      model[property] = this.deserialize(v, info.type);
    }
  }
}, _serializing:false, reflectPropertyToAttribute:function(property, attribute, value) {
  this._serializing = true;
  value = value === undefined ? this[property] : value;
  this.serializeValueToAttribute(value, attribute || Polymer.CaseMap.camelToDashCase(property));
  this._serializing = false;
}, serializeValueToAttribute:function(value, attribute, node) {
  var str = this.serialize(value);
  node = node || this;
  if (str === undefined) {
    node.removeAttribute(attribute);
  } else {
    node.setAttribute(attribute, str);
  }
}, deserialize:function(value, type) {
  switch(type) {
    case Number:
      value = Number(value);
      break;
    case Boolean:
      value = value != null;
      break;
    case Object:
      try {
        value = JSON.parse(value);
      } catch (x) {
      }
      break;
    case Array:
      try {
        value = JSON.parse(value);
      } catch (x$0) {
        value = null;
        console.warn("Polymer::Attributes: couldn`t decode Array as JSON");
      }
      break;
    case Date:
      value = new Date(value);
      break;
    case String:
    default:
      break;
  }
  return value;
}, serialize:function(value) {
  switch(typeof value) {
    case "boolean":
      return value ? "" : undefined;
    case "object":
      if (value instanceof Date) {
        return value.toString();
      } else {
        if (value) {
          try {
            return JSON.stringify(value);
          } catch (x) {
            return "";
          }
        }
      }
    default:
      return value != null ? value : undefined;
  }
}});
Polymer.version = "1.4.0";
Polymer.Base._addFeature({_registerFeatures:function() {
  this._prepIs();
  this._prepBehaviors();
  this._prepConstructor();
  this._prepPropertyInfo();
}, _prepBehavior:function(b) {
  this._addHostAttributes(b.hostAttributes);
}, _marshalBehavior:function(b) {
}, _initFeatures:function() {
  this._marshalHostAttributes();
  this._marshalBehaviors();
}});
Polymer.Base._addFeature({_prepTemplate:function() {
  if (this._template === undefined) {
    this._template = Polymer.DomModule.import(this.is, "template");
  }
  if (this._template && this._template.hasAttribute("is")) {
    this._warn(this._logf("_prepTemplate", "top-level Polymer template " + "must not be a type-extension, found", this._template, "Move inside simple <template>."));
  }
  if (this._template && !this._template.content && window.HTMLTemplateElement && HTMLTemplateElement.decorate) {
    HTMLTemplateElement.decorate(this._template);
  }
}, _stampTemplate:function() {
  if (this._template) {
    this.root = this.instanceTemplate(this._template);
  }
}, instanceTemplate:function(template) {
  var dom = document.importNode(template._content || template.content, true);
  return dom;
}});
(function() {
  var baseAttachedCallback = Polymer.Base.attachedCallback;
  Polymer.Base._addFeature({_hostStack:[], ready:function() {
  }, _registerHost:function(host) {
    this.dataHost = host = host || Polymer.Base._hostStack[Polymer.Base._hostStack.length - 1];
    if (host && host._clients) {
      host._clients.push(this);
    }
    this._clients = null;
    this._clientsReadied = false;
  }, _beginHosting:function() {
    Polymer.Base._hostStack.push(this);
    if (!this._clients) {
      this._clients = [];
    }
  }, _endHosting:function() {
    Polymer.Base._hostStack.pop();
  }, _tryReady:function() {
    this._readied = false;
    if (this._canReady()) {
      this._ready();
    }
  }, _canReady:function() {
    return !this.dataHost || this.dataHost._clientsReadied;
  }, _ready:function() {
    this._beforeClientsReady();
    if (this._template) {
      this._setupRoot();
      this._readyClients();
    }
    this._clientsReadied = true;
    this._clients = null;
    this._afterClientsReady();
    this._readySelf();
  }, _readyClients:function() {
    this._beginDistribute();
    var c$ = this._clients;
    if (c$) {
      for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
        c._ready();
      }
    }
    this._finishDistribute();
  }, _readySelf:function() {
    this._doBehavior("ready");
    this._readied = true;
    if (this._attachedPending) {
      this._attachedPending = false;
      this.attachedCallback();
    }
  }, _beforeClientsReady:function() {
  }, _afterClientsReady:function() {
  }, _beforeAttached:function() {
  }, attachedCallback:function() {
    if (this._readied) {
      this._beforeAttached();
      baseAttachedCallback.call(this);
    } else {
      this._attachedPending = true;
    }
  }});
})();
Polymer.ArraySplice = function() {
  function newSplice(index, removed, addedCount) {
    return {index:index, removed:removed, addedCount:addedCount};
  }
  var EDIT_LEAVE = 0;
  var EDIT_UPDATE = 1;
  var EDIT_ADD = 2;
  var EDIT_DELETE = 3;
  function ArraySplice() {
  }
  ArraySplice.prototype = {calcEditDistances:function(current, currentStart, currentEnd, old, oldStart, oldEnd) {
    var rowCount = oldEnd - oldStart + 1;
    var columnCount = currentEnd - currentStart + 1;
    var distances = new Array(rowCount);
    for (var i = 0; i < rowCount; i++) {
      distances[i] = new Array(columnCount);
      distances[i][0] = i;
    }
    for (var j = 0; j < columnCount; j++) {
      distances[0][j] = j;
    }
    for (i = 1; i < rowCount; i++) {
      for (j = 1; j < columnCount; j++) {
        if (this.equals(current[currentStart + j - 1], old[oldStart + i - 1])) {
          distances[i][j] = distances[i - 1][j - 1];
        } else {
          var north = distances[i - 1][j] + 1;
          var west = distances[i][j - 1] + 1;
          distances[i][j] = north < west ? north : west;
        }
      }
    }
    return distances;
  }, spliceOperationsFromEditDistances:function(distances) {
    var i = distances.length - 1;
    var j = distances[0].length - 1;
    var current = distances[i][j];
    var edits = [];
    while (i > 0 || j > 0) {
      if (i == 0) {
        edits.push(EDIT_ADD);
        j--;
        continue;
      }
      if (j == 0) {
        edits.push(EDIT_DELETE);
        i--;
        continue;
      }
      var northWest = distances[i - 1][j - 1];
      var west = distances[i - 1][j];
      var north = distances[i][j - 1];
      var min;
      if (west < north) {
        min = west < northWest ? west : northWest;
      } else {
        min = north < northWest ? north : northWest;
      }
      if (min == northWest) {
        if (northWest == current) {
          edits.push(EDIT_LEAVE);
        } else {
          edits.push(EDIT_UPDATE);
          current = northWest;
        }
        i--;
        j--;
      } else {
        if (min == west) {
          edits.push(EDIT_DELETE);
          i--;
          current = west;
        } else {
          edits.push(EDIT_ADD);
          j--;
          current = north;
        }
      }
    }
    edits.reverse();
    return edits;
  }, calcSplices:function(current, currentStart, currentEnd, old, oldStart, oldEnd) {
    var prefixCount = 0;
    var suffixCount = 0;
    var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);
    if (currentStart == 0 && oldStart == 0) {
      prefixCount = this.sharedPrefix(current, old, minLength);
    }
    if (currentEnd == current.length && oldEnd == old.length) {
      suffixCount = this.sharedSuffix(current, old, minLength - prefixCount);
    }
    currentStart += prefixCount;
    oldStart += prefixCount;
    currentEnd -= suffixCount;
    oldEnd -= suffixCount;
    if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0) {
      return [];
    }
    if (currentStart == currentEnd) {
      var splice = newSplice(currentStart, [], 0);
      while (oldStart < oldEnd) {
        splice.removed.push(old[oldStart++]);
      }
      return [splice];
    } else {
      if (oldStart == oldEnd) {
        return [newSplice(currentStart, [], currentEnd - currentStart)];
      }
    }
    var ops = this.spliceOperationsFromEditDistances(this.calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));
    splice = undefined;
    var splices = [];
    var index = currentStart;
    var oldIndex = oldStart;
    for (var i = 0; i < ops.length; i++) {
      switch(ops[i]) {
        case EDIT_LEAVE:
          if (splice) {
            splices.push(splice);
            splice = undefined;
          }
          index++;
          oldIndex++;
          break;
        case EDIT_UPDATE:
          if (!splice) {
            splice = newSplice(index, [], 0);
          }
          splice.addedCount++;
          index++;
          splice.removed.push(old[oldIndex]);
          oldIndex++;
          break;
        case EDIT_ADD:
          if (!splice) {
            splice = newSplice(index, [], 0);
          }
          splice.addedCount++;
          index++;
          break;
        case EDIT_DELETE:
          if (!splice) {
            splice = newSplice(index, [], 0);
          }
          splice.removed.push(old[oldIndex]);
          oldIndex++;
          break;
      }
    }
    if (splice) {
      splices.push(splice);
    }
    return splices;
  }, sharedPrefix:function(current, old, searchLength) {
    for (var i = 0; i < searchLength; i++) {
      if (!this.equals(current[i], old[i])) {
        return i;
      }
    }
    return searchLength;
  }, sharedSuffix:function(current, old, searchLength) {
    var index1 = current.length;
    var index2 = old.length;
    var count = 0;
    while (count < searchLength && this.equals(current[--index1], old[--index2])) {
      count++;
    }
    return count;
  }, calculateSplices:function(current, previous) {
    return this.calcSplices(current, 0, current.length, previous, 0, previous.length);
  }, equals:function(currentValue, previousValue) {
    return currentValue === previousValue;
  }};
  return new ArraySplice;
}();
Polymer.domInnerHTML = function() {
  var escapeAttrRegExp = /[&\u00A0"]/g;
  var escapeDataRegExp = /[&\u00A0<>]/g;
  function escapeReplace(c) {
    switch(c) {
      case "&":
        return "&amp;";
      case "<":
        return "&lt;";
      case ">":
        return "&gt;";
      case '"':
        return "&quot;";
      case " ":
        return "&nbsp;";
    }
  }
  function escapeAttr(s) {
    return s.replace(escapeAttrRegExp, escapeReplace);
  }
  function escapeData(s) {
    return s.replace(escapeDataRegExp, escapeReplace);
  }
  function makeSet(arr) {
    var set = {};
    for (var i = 0; i < arr.length; i++) {
      set[arr[i]] = true;
    }
    return set;
  }
  var voidElements = makeSet(["area", "base", "br", "col", "command", "embed", "hr", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr"]);
  var plaintextParents = makeSet(["style", "script", "xmp", "iframe", "noembed", "noframes", "plaintext", "noscript"]);
  function getOuterHTML(node, parentNode, composed) {
    switch(node.nodeType) {
      case Node.ELEMENT_NODE:
        var tagName = node.localName;
        var s = "<" + tagName;
        var attrs = node.attributes;
        for (var i = 0, attr; attr = attrs[i]; i++) {
          s += " " + attr.name + '="' + escapeAttr(attr.value) + '"';
        }
        s += ">";
        if (voidElements[tagName]) {
          return s;
        }
        return s + getInnerHTML(node, composed) + "</" + tagName + ">";
      case Node.TEXT_NODE:
        var data = node.data;
        if (parentNode && plaintextParents[parentNode.localName]) {
          return data;
        }
        return escapeData(data);
      case Node.COMMENT_NODE:
        return "\x3c!--" + node.data + "--\x3e";
      default:
        console.error(node);
        throw new Error("not implemented");
    }
  }
  function getInnerHTML(node, composed) {
    if (node instanceof HTMLTemplateElement) {
      node = node.content;
    }
    var s = "";
    var c$ = Polymer.dom(node).childNodes;
    for (var i = 0, l = c$.length, child; i < l && (child = c$[i]); i++) {
      s += getOuterHTML(child, node, composed);
    }
    return s;
  }
  return {getInnerHTML:getInnerHTML};
}();
(function() {
  var nativeInsertBefore = Element.prototype.insertBefore;
  var nativeAppendChild = Element.prototype.appendChild;
  var nativeRemoveChild = Element.prototype.removeChild;
  Polymer.TreeApi = {arrayCopyChildNodes:function(parent) {
    var copy = [], i = 0;
    for (var n = parent.firstChild; n; n = n.nextSibling) {
      copy[i++] = n;
    }
    return copy;
  }, arrayCopyChildren:function(parent) {
    var copy = [], i = 0;
    for (var n = parent.firstElementChild; n; n = n.nextElementSibling) {
      copy[i++] = n;
    }
    return copy;
  }, arrayCopy:function(a$) {
    var l = a$.length;
    var copy = new Array(l);
    for (var i = 0; i < l; i++) {
      copy[i] = a$[i];
    }
    return copy;
  }};
  Polymer.TreeApi.Logical = {hasParentNode:function(node) {
    return Boolean(node.__dom && node.__dom.parentNode);
  }, hasChildNodes:function(node) {
    return Boolean(node.__dom && node.__dom.childNodes !== undefined);
  }, getChildNodes:function(node) {
    return this.hasChildNodes(node) ? this._getChildNodes(node) : node.childNodes;
  }, _getChildNodes:function(node) {
    if (!node.__dom.childNodes) {
      node.__dom.childNodes = [];
      for (var n = node.__dom.firstChild; n; n = n.__dom.nextSibling) {
        node.__dom.childNodes.push(n);
      }
    }
    return node.__dom.childNodes;
  }, getParentNode:function(node) {
    return node.__dom && node.__dom.parentNode !== undefined ? node.__dom.parentNode : node.parentNode;
  }, getFirstChild:function(node) {
    return node.__dom && node.__dom.firstChild !== undefined ? node.__dom.firstChild : node.firstChild;
  }, getLastChild:function(node) {
    return node.__dom && node.__dom.lastChild !== undefined ? node.__dom.lastChild : node.lastChild;
  }, getNextSibling:function(node) {
    return node.__dom && node.__dom.nextSibling !== undefined ? node.__dom.nextSibling : node.nextSibling;
  }, getPreviousSibling:function(node) {
    return node.__dom && node.__dom.previousSibling !== undefined ? node.__dom.previousSibling : node.previousSibling;
  }, getFirstElementChild:function(node) {
    return node.__dom && node.__dom.firstChild !== undefined ? this._getFirstElementChild(node) : node.firstElementChild;
  }, _getFirstElementChild:function(node) {
    var n = node.__dom.firstChild;
    while (n && n.nodeType !== Node.ELEMENT_NODE) {
      n = n.__dom.nextSibling;
    }
    return n;
  }, getLastElementChild:function(node) {
    return node.__dom && node.__dom.lastChild !== undefined ? this._getLastElementChild(node) : node.lastElementChild;
  }, _getLastElementChild:function(node) {
    var n = node.__dom.lastChild;
    while (n && n.nodeType !== Node.ELEMENT_NODE) {
      n = n.__dom.previousSibling;
    }
    return n;
  }, getNextElementSibling:function(node) {
    return node.__dom && node.__dom.nextSibling !== undefined ? this._getNextElementSibling(node) : node.nextElementSibling;
  }, _getNextElementSibling:function(node) {
    var n = node.__dom.nextSibling;
    while (n && n.nodeType !== Node.ELEMENT_NODE) {
      n = n.__dom.nextSibling;
    }
    return n;
  }, getPreviousElementSibling:function(node) {
    return node.__dom && node.__dom.previousSibling !== undefined ? this._getPreviousElementSibling(node) : node.previousElementSibling;
  }, _getPreviousElementSibling:function(node) {
    var n = node.__dom.previousSibling;
    while (n && n.nodeType !== Node.ELEMENT_NODE) {
      n = n.__dom.previousSibling;
    }
    return n;
  }, saveChildNodes:function(node) {
    if (!this.hasChildNodes(node)) {
      node.__dom = node.__dom || {};
      node.__dom.firstChild = node.firstChild;
      node.__dom.lastChild = node.lastChild;
      node.__dom.childNodes = [];
      for (var n = node.firstChild; n; n = n.nextSibling) {
        n.__dom = n.__dom || {};
        n.__dom.parentNode = node;
        node.__dom.childNodes.push(n);
        n.__dom.nextSibling = n.nextSibling;
        n.__dom.previousSibling = n.previousSibling;
      }
    }
  }, recordInsertBefore:function(node, container, ref_node) {
    container.__dom.childNodes = null;
    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
      for (var n = node.firstChild; n; n = n.nextSibling) {
        this._linkNode(n, container, ref_node);
      }
    } else {
      this._linkNode(node, container, ref_node);
    }
  }, _linkNode:function(node, container, ref_node) {
    node.__dom = node.__dom || {};
    container.__dom = container.__dom || {};
    if (ref_node) {
      ref_node.__dom = ref_node.__dom || {};
    }
    node.__dom.previousSibling = ref_node ? ref_node.__dom.previousSibling : container.__dom.lastChild;
    if (node.__dom.previousSibling) {
      node.__dom.previousSibling.__dom.nextSibling = node;
    }
    node.__dom.nextSibling = ref_node;
    if (node.__dom.nextSibling) {
      node.__dom.nextSibling.__dom.previousSibling = node;
    }
    node.__dom.parentNode = container;
    if (ref_node) {
      if (ref_node === container.__dom.firstChild) {
        container.__dom.firstChild = node;
      }
    } else {
      container.__dom.lastChild = node;
      if (!container.__dom.firstChild) {
        container.__dom.firstChild = node;
      }
    }
    container.__dom.childNodes = null;
  }, recordRemoveChild:function(node, container) {
    node.__dom = node.__dom || {};
    container.__dom = container.__dom || {};
    if (node === container.__dom.firstChild) {
      container.__dom.firstChild = node.__dom.nextSibling;
    }
    if (node === container.__dom.lastChild) {
      container.__dom.lastChild = node.__dom.previousSibling;
    }
    var p = node.__dom.previousSibling;
    var n = node.__dom.nextSibling;
    if (p) {
      p.__dom.nextSibling = n;
    }
    if (n) {
      n.__dom.previousSibling = p;
    }
    node.__dom.parentNode = node.__dom.previousSibling = node.__dom.nextSibling = undefined;
    container.__dom.childNodes = null;
  }};
  Polymer.TreeApi.Composed = {getChildNodes:function(node) {
    return Polymer.TreeApi.arrayCopyChildNodes(node);
  }, getParentNode:function(node) {
    return node.parentNode;
  }, clearChildNodes:function(node) {
    node.textContent = "";
  }, insertBefore:function(parentNode, newChild, refChild) {
    return nativeInsertBefore.call(parentNode, newChild, refChild || null);
  }, appendChild:function(parentNode, newChild) {
    return nativeAppendChild.call(parentNode, newChild);
  }, removeChild:function(parentNode, node) {
    return nativeRemoveChild.call(parentNode, node);
  }};
})();
Polymer.DomApi = function() {
  var Settings = Polymer.Settings;
  var TreeApi = Polymer.TreeApi;
  var DomApi = function(node) {
    this.node = needsToWrap ? DomApi.wrap(node) : node;
  };
  var needsToWrap = Settings.hasShadow && !Settings.nativeShadow;
  DomApi.wrap = window.wrap ? window.wrap : function(node) {
    return node;
  };
  DomApi.prototype = {flush:function() {
    Polymer.dom.flush();
  }, deepContains:function(node) {
    if (this.node.contains(node)) {
      return true;
    }
    var n = node;
    var doc = node.ownerDocument;
    while (n && n !== doc && n !== this.node) {
      n = Polymer.dom(n).parentNode || n.host;
    }
    return n === this.node;
  }, queryDistributedElements:function(selector) {
    var c$ = this.getEffectiveChildNodes();
    var list = [];
    for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
      if (c.nodeType === Node.ELEMENT_NODE && DomApi.matchesSelector.call(c, selector)) {
        list.push(c);
      }
    }
    return list;
  }, getEffectiveChildNodes:function() {
    var list = [];
    var c$ = this.childNodes;
    for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
      if (c.localName === CONTENT) {
        var d$ = dom(c).getDistributedNodes();
        for (var j = 0; j < d$.length; j++) {
          list.push(d$[j]);
        }
      } else {
        list.push(c);
      }
    }
    return list;
  }, observeNodes:function(callback) {
    if (callback) {
      if (!this.observer) {
        this.observer = this.node.localName === CONTENT ? new DomApi.DistributedNodesObserver(this) : new DomApi.EffectiveNodesObserver(this);
      }
      return this.observer.addListener(callback);
    }
  }, unobserveNodes:function(handle) {
    if (this.observer) {
      this.observer.removeListener(handle);
    }
  }, notifyObserver:function() {
    if (this.observer) {
      this.observer.notify();
    }
  }, _query:function(matcher, node, halter) {
    node = node || this.node;
    var list = [];
    this._queryElements(TreeApi.Logical.getChildNodes(node), matcher, halter, list);
    return list;
  }, _queryElements:function(elements, matcher, halter, list) {
    for (var i = 0, l = elements.length, c; i < l && (c = elements[i]); i++) {
      if (c.nodeType === Node.ELEMENT_NODE) {
        if (this._queryElement(c, matcher, halter, list)) {
          return true;
        }
      }
    }
  }, _queryElement:function(node, matcher, halter, list) {
    var result = matcher(node);
    if (result) {
      list.push(node);
    }
    if (halter && halter(result)) {
      return result;
    }
    this._queryElements(TreeApi.Logical.getChildNodes(node), matcher, halter, list);
  }};
  var CONTENT = DomApi.CONTENT = "content";
  var dom = DomApi.factory = function(node) {
    node = node || document;
    if (!node.__domApi) {
      node.__domApi = new DomApi.ctor(node);
    }
    return node.__domApi;
  };
  DomApi.hasApi = function(node) {
    return Boolean(node.__domApi);
  };
  DomApi.ctor = DomApi;
  Polymer.dom = function(obj, patch) {
    if (obj instanceof Event) {
      return Polymer.EventApi.factory(obj);
    } else {
      return DomApi.factory(obj, patch);
    }
  };
  var p = Element.prototype;
  DomApi.matchesSelector = p.matches || p.matchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;
  return DomApi;
}();
(function() {
  var Settings = Polymer.Settings;
  var DomApi = Polymer.DomApi;
  var dom = DomApi.factory;
  var TreeApi = Polymer.TreeApi;
  var getInnerHTML = Polymer.domInnerHTML.getInnerHTML;
  var CONTENT = DomApi.CONTENT;
  if (Settings.useShadow) {
    return;
  }
  var nativeCloneNode = Element.prototype.cloneNode;
  var nativeImportNode = Document.prototype.importNode;
  Polymer.Base.extend(DomApi.prototype, {_lazyDistribute:function(host) {
    if (host.shadyRoot && host.shadyRoot._distributionClean) {
      host.shadyRoot._distributionClean = false;
      Polymer.dom.addDebouncer(host.debounce("_distribute", host._distributeContent));
    }
  }, appendChild:function(node) {
    return this.insertBefore(node);
  }, insertBefore:function(node, ref_node) {
    if (ref_node && TreeApi.Logical.getParentNode(ref_node) !== this.node) {
      throw Error("The ref_node to be inserted before is not a child " + "of this node");
    }
    if (node.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {
      var parent = TreeApi.Logical.getParentNode(node);
      if (parent) {
        if (DomApi.hasApi(parent)) {
          dom(parent).notifyObserver();
        }
        this._removeNode(node);
      } else {
        this._removeOwnerShadyRoot(node);
      }
    }
    if (!this._addNode(node, ref_node)) {
      if (ref_node) {
        ref_node = ref_node.localName === CONTENT ? this._firstComposedNode(ref_node) : ref_node;
      }
      var container = this.node._isShadyRoot ? this.node.host : this.node;
      if (ref_node) {
        TreeApi.Composed.insertBefore(container, node, ref_node);
      } else {
        TreeApi.Composed.appendChild(container, node);
      }
    }
    this.notifyObserver();
    return node;
  }, _addNode:function(node, ref_node) {
    var root = this.getOwnerRoot();
    if (root) {
      var ipAdded = this._maybeAddInsertionPoint(node, this.node);
      if (!root._invalidInsertionPoints) {
        root._invalidInsertionPoints = ipAdded;
      }
      this._addNodeToHost(root.host, node);
    }
    if (TreeApi.Logical.hasChildNodes(this.node)) {
      TreeApi.Logical.recordInsertBefore(node, this.node, ref_node);
    }
    var handled = this._maybeDistribute(node) || this.node.shadyRoot;
    if (handled) {
      if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
        while (node.firstChild) {
          TreeApi.Composed.removeChild(node, node.firstChild);
        }
      } else {
        var parent = TreeApi.Composed.getParentNode(node);
        if (parent) {
          TreeApi.Composed.removeChild(parent, node);
        }
      }
    }
    return handled;
  }, removeChild:function(node) {
    if (TreeApi.Logical.getParentNode(node) !== this.node) {
      throw Error("The node to be removed is not a child of this node: " + node);
    }
    if (!this._removeNode(node)) {
      var container = this.node._isShadyRoot ? this.node.host : this.node;
      var parent = TreeApi.Composed.getParentNode(node);
      if (container === parent) {
        TreeApi.Composed.removeChild(container, node);
      }
    }
    this.notifyObserver();
    return node;
  }, _removeNode:function(node) {
    var logicalParent = TreeApi.Logical.hasParentNode(node) && TreeApi.Logical.getParentNode(node);
    var distributed;
    var root = this._ownerShadyRootForNode(node);
    if (logicalParent) {
      distributed = dom(node)._maybeDistributeParent();
      TreeApi.Logical.recordRemoveChild(node, logicalParent);
      if (root && this._removeDistributedChildren(root, node)) {
        root._invalidInsertionPoints = true;
        this._lazyDistribute(root.host);
      }
    }
    this._removeOwnerShadyRoot(node);
    if (root) {
      this._removeNodeFromHost(root.host, node);
    }
    return distributed;
  }, replaceChild:function(node, ref_node) {
    this.insertBefore(node, ref_node);
    this.removeChild(ref_node);
    return node;
  }, _hasCachedOwnerRoot:function(node) {
    return Boolean(node._ownerShadyRoot !== undefined);
  }, getOwnerRoot:function() {
    return this._ownerShadyRootForNode(this.node);
  }, _ownerShadyRootForNode:function(node) {
    if (!node) {
      return;
    }
    var root = node._ownerShadyRoot;
    if (root === undefined) {
      if (node._isShadyRoot) {
        root = node;
      } else {
        var parent = TreeApi.Logical.getParentNode(node);
        if (parent) {
          root = parent._isShadyRoot ? parent : this._ownerShadyRootForNode(parent);
        } else {
          root = null;
        }
      }
      if (root || document.documentElement.contains(node)) {
        node._ownerShadyRoot = root;
      }
    }
    return root;
  }, _maybeDistribute:function(node) {
    var fragContent = node.nodeType === Node.DOCUMENT_FRAGMENT_NODE && !node.__noContent && dom(node).querySelector(CONTENT);
    var wrappedContent = fragContent && TreeApi.Logical.getParentNode(fragContent).nodeType !== Node.DOCUMENT_FRAGMENT_NODE;
    var hasContent = fragContent || node.localName === CONTENT;
    if (hasContent) {
      var root = this.getOwnerRoot();
      if (root) {
        this._lazyDistribute(root.host);
      }
    }
    var needsDist = this._nodeNeedsDistribution(this.node);
    if (needsDist) {
      this._lazyDistribute(this.node);
    }
    return needsDist || hasContent && !wrappedContent;
  }, _maybeAddInsertionPoint:function(node, parent) {
    var added;
    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE && !node.__noContent) {
      var c$ = dom(node).querySelectorAll(CONTENT);
      for (var i = 0, n, np, na; i < c$.length && (n = c$[i]); i++) {
        np = TreeApi.Logical.getParentNode(n);
        if (np === node) {
          np = parent;
        }
        na = this._maybeAddInsertionPoint(n, np);
        added = added || na;
      }
    } else {
      if (node.localName === CONTENT) {
        TreeApi.Logical.saveChildNodes(parent);
        TreeApi.Logical.saveChildNodes(node);
        added = true;
      }
    }
    return added;
  }, _updateInsertionPoints:function(host) {
    var i$ = host.shadyRoot._insertionPoints = dom(host.shadyRoot).querySelectorAll(CONTENT);
    for (var i = 0, c; i < i$.length; i++) {
      c = i$[i];
      TreeApi.Logical.saveChildNodes(c);
      TreeApi.Logical.saveChildNodes(TreeApi.Logical.getParentNode(c));
    }
  }, _nodeNeedsDistribution:function(node) {
    return node && node.shadyRoot && DomApi.hasInsertionPoint(node.shadyRoot);
  }, _addNodeToHost:function(host, node) {
    if (host._elementAdd) {
      host._elementAdd(node);
    }
  }, _removeNodeFromHost:function(host, node) {
    if (host._elementRemove) {
      host._elementRemove(node);
    }
  }, _removeDistributedChildren:function(root, container) {
    var hostNeedsDist;
    var ip$ = root._insertionPoints;
    for (var i = 0; i < ip$.length; i++) {
      var content = ip$[i];
      if (this._contains(container, content)) {
        var dc$ = dom(content).getDistributedNodes();
        for (var j = 0; j < dc$.length; j++) {
          hostNeedsDist = true;
          var node = dc$[j];
          var parent = TreeApi.Composed.getParentNode(node);
          if (parent) {
            TreeApi.Composed.removeChild(parent, node);
          }
        }
      }
    }
    return hostNeedsDist;
  }, _contains:function(container, node) {
    while (node) {
      if (node == container) {
        return true;
      }
      node = TreeApi.Logical.getParentNode(node);
    }
  }, _removeOwnerShadyRoot:function(node) {
    if (this._hasCachedOwnerRoot(node)) {
      var c$ = TreeApi.Logical.getChildNodes(node);
      for (var i = 0, l = c$.length, n; i < l && (n = c$[i]); i++) {
        this._removeOwnerShadyRoot(n);
      }
    }
    node._ownerShadyRoot = undefined;
  }, _firstComposedNode:function(content) {
    var n$ = dom(content).getDistributedNodes();
    for (var i = 0, l = n$.length, n, p$; i < l && (n = n$[i]); i++) {
      p$ = dom(n).getDestinationInsertionPoints();
      if (p$[p$.length - 1] === content) {
        return n;
      }
    }
  }, querySelector:function(selector) {
    var result = this._query(function(n) {
      return DomApi.matchesSelector.call(n, selector);
    }, this.node, function(n) {
      return Boolean(n);
    })[0];
    return result || null;
  }, querySelectorAll:function(selector) {
    return this._query(function(n) {
      return DomApi.matchesSelector.call(n, selector);
    }, this.node);
  }, getDestinationInsertionPoints:function() {
    return this.node._destinationInsertionPoints || [];
  }, getDistributedNodes:function() {
    return this.node._distributedNodes || [];
  }, _clear:function() {
    while (this.childNodes.length) {
      this.removeChild(this.childNodes[0]);
    }
  }, setAttribute:function(name, value) {
    this.node.setAttribute(name, value);
    this._maybeDistributeParent();
  }, removeAttribute:function(name) {
    this.node.removeAttribute(name);
    this._maybeDistributeParent();
  }, _maybeDistributeParent:function() {
    if (this._nodeNeedsDistribution(this.parentNode)) {
      this._lazyDistribute(this.parentNode);
      return true;
    }
  }, cloneNode:function(deep) {
    var n = nativeCloneNode.call(this.node, false);
    if (deep) {
      var c$ = this.childNodes;
      var d = dom(n);
      for (var i = 0, nc; i < c$.length; i++) {
        nc = dom(c$[i]).cloneNode(true);
        d.appendChild(nc);
      }
    }
    return n;
  }, importNode:function(externalNode, deep) {
    var doc = this.node instanceof Document ? this.node : this.node.ownerDocument;
    var n = nativeImportNode.call(doc, externalNode, false);
    if (deep) {
      var c$ = TreeApi.Logical.getChildNodes(externalNode);
      var d = dom(n);
      for (var i = 0, nc; i < c$.length; i++) {
        nc = dom(doc).importNode(c$[i], true);
        d.appendChild(nc);
      }
    }
    return n;
  }, _getComposedInnerHTML:function() {
    return getInnerHTML(this.node, true);
  }});
  Object.defineProperties(DomApi.prototype, {activeElement:{get:function() {
    var active = document.activeElement;
    if (!active) {
      return null;
    }
    var isShadyRoot = !!this.node._isShadyRoot;
    if (this.node !== document) {
      if (!isShadyRoot) {
        return null;
      }
      if (this.node.host === active || !this.node.host.contains(active)) {
        return null;
      }
    }
    var activeRoot = dom(active).getOwnerRoot();
    while (activeRoot && activeRoot !== this.node) {
      active = activeRoot.host;
      activeRoot = dom(active).getOwnerRoot();
    }
    if (this.node === document) {
      return activeRoot ? null : active;
    } else {
      return activeRoot === this.node ? active : null;
    }
  }, configurable:true}, childNodes:{get:function() {
    var c$ = TreeApi.Logical.getChildNodes(this.node);
    return Array.isArray(c$) ? c$ : TreeApi.arrayCopyChildNodes(this.node);
  }, configurable:true}, children:{get:function() {
    if (TreeApi.Logical.hasChildNodes(this.node)) {
      return Array.prototype.filter.call(this.childNodes, function(n) {
        return n.nodeType === Node.ELEMENT_NODE;
      });
    } else {
      return TreeApi.arrayCopyChildren(this.node);
    }
  }, configurable:true}, parentNode:{get:function() {
    return TreeApi.Logical.getParentNode(this.node);
  }, configurable:true}, firstChild:{get:function() {
    return TreeApi.Logical.getFirstChild(this.node);
  }, configurable:true}, lastChild:{get:function() {
    return TreeApi.Logical.getLastChild(this.node);
  }, configurable:true}, nextSibling:{get:function() {
    return TreeApi.Logical.getNextSibling(this.node);
  }, configurable:true}, previousSibling:{get:function() {
    return TreeApi.Logical.getPreviousSibling(this.node);
  }, configurable:true}, firstElementChild:{get:function() {
    return TreeApi.Logical.getFirstElementChild(this.node);
  }, configurable:true}, lastElementChild:{get:function() {
    return TreeApi.Logical.getLastElementChild(this.node);
  }, configurable:true}, nextElementSibling:{get:function() {
    return TreeApi.Logical.getNextElementSibling(this.node);
  }, configurable:true}, previousElementSibling:{get:function() {
    return TreeApi.Logical.getPreviousElementSibling(this.node);
  }, configurable:true}, textContent:{get:function() {
    var nt = this.node.nodeType;
    if (nt === Node.TEXT_NODE || nt === Node.COMMENT_NODE) {
      return this.node.textContent;
    } else {
      var tc = [];
      for (var i = 0, cn = this.childNodes, c; c = cn[i]; i++) {
        if (c.nodeType !== Node.COMMENT_NODE) {
          tc.push(c.textContent);
        }
      }
      return tc.join("");
    }
  }, set:function(text) {
    var nt = this.node.nodeType;
    if (nt === Node.TEXT_NODE || nt === Node.COMMENT_NODE) {
      this.node.textContent = text;
    } else {
      this._clear();
      if (text) {
        this.appendChild(document.createTextNode(text));
      }
    }
  }, configurable:true}, innerHTML:{get:function() {
    var nt = this.node.nodeType;
    if (nt === Node.TEXT_NODE || nt === Node.COMMENT_NODE) {
      return null;
    } else {
      return getInnerHTML(this.node);
    }
  }, set:function(text) {
    var nt = this.node.nodeType;
    if (nt !== Node.TEXT_NODE || nt !== Node.COMMENT_NODE) {
      this._clear();
      var d = document.createElement("div");
      d.innerHTML = text;
      var c$ = TreeApi.arrayCopyChildNodes(d);
      for (var i = 0; i < c$.length; i++) {
        this.appendChild(c$[i]);
      }
    }
  }, configurable:true}});
  DomApi.hasInsertionPoint = function(root) {
    return Boolean(root && root._insertionPoints.length);
  };
})();
(function() {
  var Settings = Polymer.Settings;
  var TreeApi = Polymer.TreeApi;
  var DomApi = Polymer.DomApi;
  if (!Settings.useShadow) {
    return;
  }
  Polymer.Base.extend(DomApi.prototype, {querySelectorAll:function(selector) {
    return TreeApi.arrayCopy(this.node.querySelectorAll(selector));
  }, getOwnerRoot:function() {
    var n = this.node;
    while (n) {
      if (n.nodeType === Node.DOCUMENT_FRAGMENT_NODE && n.host) {
        return n;
      }
      n = n.parentNode;
    }
  }, importNode:function(externalNode, deep) {
    var doc = this.node instanceof Document ? this.node : this.node.ownerDocument;
    return doc.importNode(externalNode, deep);
  }, getDestinationInsertionPoints:function() {
    var n$ = this.node.getDestinationInsertionPoints && this.node.getDestinationInsertionPoints();
    return n$ ? TreeApi.arrayCopy(n$) : [];
  }, getDistributedNodes:function() {
    var n$ = this.node.getDistributedNodes && this.node.getDistributedNodes();
    return n$ ? TreeApi.arrayCopy(n$) : [];
  }});
  Object.defineProperties(DomApi.prototype, {activeElement:{get:function() {
    var node = DomApi.wrap(this.node);
    var activeElement = node.activeElement;
    return node.contains(activeElement) ? activeElement : null;
  }, configurable:true}, childNodes:{get:function() {
    return TreeApi.arrayCopyChildNodes(this.node);
  }, configurable:true}, children:{get:function() {
    return TreeApi.arrayCopyChildren(this.node);
  }, configurable:true}, textContent:{get:function() {
    return this.node.textContent;
  }, set:function(value) {
    return this.node.textContent = value;
  }, configurable:true}, innerHTML:{get:function() {
    return this.node.innerHTML;
  }, set:function(value) {
    return this.node.innerHTML = value;
  }, configurable:true}});
  var forwardMethods = function(m$) {
    for (var i = 0; i < m$.length; i++) {
      forwardMethod(m$[i]);
    }
  };
  var forwardMethod = function(method) {
    DomApi.prototype[method] = function() {
      return this.node[method].apply(this.node, arguments);
    };
  };
  forwardMethods(["cloneNode", "appendChild", "insertBefore", "removeChild", "replaceChild", "setAttribute", "removeAttribute", "querySelector"]);
  var forwardProperties = function(f$) {
    for (var i = 0; i < f$.length; i++) {
      forwardProperty(f$[i]);
    }
  };
  var forwardProperty = function(name) {
    Object.defineProperty(DomApi.prototype, name, {get:function() {
      return this.node[name];
    }, configurable:true});
  };
  forwardProperties(["parentNode", "firstChild", "lastChild", "nextSibling", "previousSibling", "firstElementChild", "lastElementChild", "nextElementSibling", "previousElementSibling"]);
})();
Polymer.Base.extend(Polymer.dom, {_flushGuard:0, _FLUSH_MAX:100, _needsTakeRecords:!Polymer.Settings.useNativeCustomElements, _debouncers:[], _staticFlushList:[], _finishDebouncer:null, flush:function() {
  this._flushGuard = 0;
  this._prepareFlush();
  while (this._debouncers.length && this._flushGuard < this._FLUSH_MAX) {
    while (this._debouncers.length) {
      this._debouncers.shift().complete();
    }
    if (this._finishDebouncer) {
      this._finishDebouncer.complete();
    }
    this._prepareFlush();
    this._flushGuard++;
  }
  if (this._flushGuard >= this._FLUSH_MAX) {
    console.warn("Polymer.dom.flush aborted. Flush may not be complete.");
  }
}, _prepareFlush:function() {
  if (this._needsTakeRecords) {
    CustomElements.takeRecords();
  }
  for (var i = 0; i < this._staticFlushList.length; i++) {
    this._staticFlushList[i]();
  }
}, addStaticFlush:function(fn) {
  this._staticFlushList.push(fn);
}, removeStaticFlush:function(fn) {
  var i = this._staticFlushList.indexOf(fn);
  if (i >= 0) {
    this._staticFlushList.splice(i, 1);
  }
}, addDebouncer:function(debouncer) {
  this._debouncers.push(debouncer);
  this._finishDebouncer = Polymer.Debounce(this._finishDebouncer, this._finishFlush);
}, _finishFlush:function() {
  Polymer.dom._debouncers = [];
}});
Polymer.EventApi = function() {
  var DomApi = Polymer.DomApi.ctor;
  var Settings = Polymer.Settings;
  DomApi.Event = function(event) {
    this.event = event;
  };
  if (Settings.useShadow) {
    DomApi.Event.prototype = {get rootTarget() {
      return this.event.path[0];
    }, get localTarget() {
      return this.event.target;
    }, get path() {
      var path = this.event.path;
      if (!Array.isArray(path)) {
        path = Array.prototype.slice.call(path);
      }
      return path;
    }};
  } else {
    DomApi.Event.prototype = {get rootTarget() {
      return this.event.target;
    }, get localTarget() {
      var current = this.event.currentTarget;
      var currentRoot = current && Polymer.dom(current).getOwnerRoot();
      var p$ = this.path;
      for (var i = 0; i < p$.length; i++) {
        if (Polymer.dom(p$[i]).getOwnerRoot() === currentRoot) {
          return p$[i];
        }
      }
    }, get path() {
      if (!this.event._path) {
        var path = [];
        var current = this.rootTarget;
        while (current) {
          path.push(current);
          var insertionPoints = Polymer.dom(current).getDestinationInsertionPoints();
          if (insertionPoints.length) {
            for (var i = 0; i < insertionPoints.length - 1; i++) {
              path.push(insertionPoints[i]);
            }
            current = insertionPoints[insertionPoints.length - 1];
          } else {
            current = Polymer.dom(current).parentNode || current.host;
          }
        }
        path.push(window);
        this.event._path = path;
      }
      return this.event._path;
    }};
  }
  var factory = function(event) {
    if (!event.__eventApi) {
      event.__eventApi = new DomApi.Event(event);
    }
    return event.__eventApi;
  };
  return {factory:factory};
}();
(function() {
  var DomApi = Polymer.DomApi.ctor;
  var useShadow = Polymer.Settings.useShadow;
  Object.defineProperty(DomApi.prototype, "classList", {get:function() {
    if (!this._classList) {
      this._classList = new DomApi.ClassList(this);
    }
    return this._classList;
  }, configurable:true});
  DomApi.ClassList = function(host) {
    this.domApi = host;
    this.node = host.node;
  };
  DomApi.ClassList.prototype = {add:function() {
    this.node.classList.add.apply(this.node.classList, arguments);
    this._distributeParent();
  }, remove:function() {
    this.node.classList.remove.apply(this.node.classList, arguments);
    this._distributeParent();
  }, toggle:function() {
    this.node.classList.toggle.apply(this.node.classList, arguments);
    this._distributeParent();
  }, _distributeParent:function() {
    if (!useShadow) {
      this.domApi._maybeDistributeParent();
    }
  }, contains:function() {
    return this.node.classList.contains.apply(this.node.classList, arguments);
  }};
})();
(function() {
  var DomApi = Polymer.DomApi.ctor;
  var Settings = Polymer.Settings;
  DomApi.EffectiveNodesObserver = function(domApi) {
    this.domApi = domApi;
    this.node = this.domApi.node;
    this._listeners = [];
  };
  DomApi.EffectiveNodesObserver.prototype = {addListener:function(callback) {
    if (!this._isSetup) {
      this._setup();
      this._isSetup = true;
    }
    var listener = {fn:callback, _nodes:[]};
    this._listeners.push(listener);
    this._scheduleNotify();
    return listener;
  }, removeListener:function(handle) {
    var i = this._listeners.indexOf(handle);
    if (i >= 0) {
      this._listeners.splice(i, 1);
      handle._nodes = [];
    }
    if (!this._hasListeners()) {
      this._cleanup();
      this._isSetup = false;
    }
  }, _setup:function() {
    this._observeContentElements(this.domApi.childNodes);
  }, _cleanup:function() {
    this._unobserveContentElements(this.domApi.childNodes);
  }, _hasListeners:function() {
    return Boolean(this._listeners.length);
  }, _scheduleNotify:function() {
    if (this._debouncer) {
      this._debouncer.stop();
    }
    this._debouncer = Polymer.Debounce(this._debouncer, this._notify);
    this._debouncer.context = this;
    Polymer.dom.addDebouncer(this._debouncer);
  }, notify:function() {
    if (this._hasListeners()) {
      this._scheduleNotify();
    }
  }, _notify:function() {
    this._beforeCallListeners();
    this._callListeners();
  }, _beforeCallListeners:function() {
    this._updateContentElements();
  }, _updateContentElements:function() {
    this._observeContentElements(this.domApi.childNodes);
  }, _observeContentElements:function(elements) {
    for (var i = 0, n; i < elements.length && (n = elements[i]); i++) {
      if (this._isContent(n)) {
        n.__observeNodesMap = n.__observeNodesMap || new WeakMap;
        if (!n.__observeNodesMap.has(this)) {
          n.__observeNodesMap.set(this, this._observeContent(n));
        }
      }
    }
  }, _observeContent:function(content) {
    var self = this;
    var h = Polymer.dom(content).observeNodes(function() {
      self._scheduleNotify();
    });
    h._avoidChangeCalculation = true;
    return h;
  }, _unobserveContentElements:function(elements) {
    for (var i = 0, n, h; i < elements.length && (n = elements[i]); i++) {
      if (this._isContent(n)) {
        h = n.__observeNodesMap.get(this);
        if (h) {
          Polymer.dom(n).unobserveNodes(h);
          n.__observeNodesMap.delete(this);
        }
      }
    }
  }, _isContent:function(node) {
    return node.localName === "content";
  }, _callListeners:function() {
    var o$ = this._listeners;
    var nodes = this._getEffectiveNodes();
    for (var i = 0, o; i < o$.length && (o = o$[i]); i++) {
      var info = this._generateListenerInfo(o, nodes);
      if (info || o._alwaysNotify) {
        this._callListener(o, info);
      }
    }
  }, _getEffectiveNodes:function() {
    return this.domApi.getEffectiveChildNodes();
  }, _generateListenerInfo:function(listener, newNodes) {
    if (listener._avoidChangeCalculation) {
      return true;
    }
    var oldNodes = listener._nodes;
    var info = {target:this.node, addedNodes:[], removedNodes:[]};
    var splices = Polymer.ArraySplice.calculateSplices(newNodes, oldNodes);
    for (var i = 0, s; i < splices.length && (s = splices[i]); i++) {
      for (var j = 0, n; j < s.removed.length && (n = s.removed[j]); j++) {
        info.removedNodes.push(n);
      }
    }
    for (i = 0, s; i < splices.length && (s = splices[i]); i++) {
      for (j = s.index; j < s.index + s.addedCount; j++) {
        info.addedNodes.push(newNodes[j]);
      }
    }
    listener._nodes = newNodes;
    if (info.addedNodes.length || info.removedNodes.length) {
      return info;
    }
  }, _callListener:function(listener, info) {
    return listener.fn.call(this.node, info);
  }, enableShadowAttributeTracking:function() {
  }};
  if (Settings.useShadow) {
    var baseSetup = DomApi.EffectiveNodesObserver.prototype._setup;
    var baseCleanup = DomApi.EffectiveNodesObserver.prototype._cleanup;
    Polymer.Base.extend(DomApi.EffectiveNodesObserver.prototype, {_setup:function() {
      if (!this._observer) {
        var self = this;
        this._mutationHandler = function(mxns) {
          if (mxns && mxns.length) {
            self._scheduleNotify();
          }
        };
        this._observer = new MutationObserver(this._mutationHandler);
        this._boundFlush = function() {
          self._flush();
        };
        Polymer.dom.addStaticFlush(this._boundFlush);
        this._observer.observe(this.node, {childList:true});
      }
      baseSetup.call(this);
    }, _cleanup:function() {
      this._observer.disconnect();
      this._observer = null;
      this._mutationHandler = null;
      Polymer.dom.removeStaticFlush(this._boundFlush);
      baseCleanup.call(this);
    }, _flush:function() {
      if (this._observer) {
        this._mutationHandler(this._observer.takeRecords());
      }
    }, enableShadowAttributeTracking:function() {
      if (this._observer) {
        this._makeContentListenersAlwaysNotify();
        this._observer.disconnect();
        this._observer.observe(this.node, {childList:true, attributes:true, subtree:true});
        var root = this.domApi.getOwnerRoot();
        var host = root && root.host;
        if (host && Polymer.dom(host).observer) {
          Polymer.dom(host).observer.enableShadowAttributeTracking();
        }
      }
    }, _makeContentListenersAlwaysNotify:function() {
      for (var i = 0, h; i < this._listeners.length; i++) {
        h = this._listeners[i];
        h._alwaysNotify = h._isContentListener;
      }
    }});
  }
})();
(function() {
  var DomApi = Polymer.DomApi.ctor;
  var Settings = Polymer.Settings;
  DomApi.DistributedNodesObserver = function(domApi) {
    DomApi.EffectiveNodesObserver.call(this, domApi);
  };
  DomApi.DistributedNodesObserver.prototype = Object.create(DomApi.EffectiveNodesObserver.prototype);
  Polymer.Base.extend(DomApi.DistributedNodesObserver.prototype, {_setup:function() {
  }, _cleanup:function() {
  }, _beforeCallListeners:function() {
  }, _getEffectiveNodes:function() {
    return this.domApi.getDistributedNodes();
  }});
  if (Settings.useShadow) {
    Polymer.Base.extend(DomApi.DistributedNodesObserver.prototype, {_setup:function() {
      if (!this._observer) {
        var root = this.domApi.getOwnerRoot();
        var host = root && root.host;
        if (host) {
          var self = this;
          this._observer = Polymer.dom(host).observeNodes(function() {
            self._scheduleNotify();
          });
          this._observer._isContentListener = true;
          if (this._hasAttrSelect()) {
            Polymer.dom(host).observer.enableShadowAttributeTracking();
          }
        }
      }
    }, _hasAttrSelect:function() {
      var select = this.node.getAttribute("select");
      return select && select.match(/[[.]+/);
    }, _cleanup:function() {
      var root = this.domApi.getOwnerRoot();
      var host = root && root.host;
      if (host) {
        Polymer.dom(host).unobserveNodes(this._observer);
      }
      this._observer = null;
    }});
  }
})();
(function() {
  var DomApi = Polymer.DomApi;
  var TreeApi = Polymer.TreeApi;
  Polymer.Base._addFeature({_prepShady:function() {
    this._useContent = this._useContent || Boolean(this._template);
  }, _setupShady:function() {
    this.shadyRoot = null;
    if (!this.__domApi) {
      this.__domApi = null;
    }
    if (!this.__dom) {
      this.__dom = null;
    }
    if (!this._ownerShadyRoot) {
      this._ownerShadyRoot = undefined;
    }
  }, _poolContent:function() {
    if (this._useContent) {
      TreeApi.Logical.saveChildNodes(this);
    }
  }, _setupRoot:function() {
    if (this._useContent) {
      this._createLocalRoot();
      if (!this.dataHost) {
        upgradeLogicalChildren(TreeApi.Logical.getChildNodes(this));
      }
    }
  }, _createLocalRoot:function() {
    this.shadyRoot = this.root;
    this.shadyRoot._distributionClean = false;
    this.shadyRoot._hasDistributed = false;
    this.shadyRoot._isShadyRoot = true;
    this.shadyRoot._dirtyRoots = [];
    var i$ = this.shadyRoot._insertionPoints = !this._notes || this._notes._hasContent ? this.shadyRoot.querySelectorAll("content") : [];
    TreeApi.Logical.saveChildNodes(this.shadyRoot);
    for (var i = 0, c; i < i$.length; i++) {
      c = i$[i];
      TreeApi.Logical.saveChildNodes(c);
      TreeApi.Logical.saveChildNodes(c.parentNode);
    }
    this.shadyRoot.host = this;
  }, get domHost() {
    var root = Polymer.dom(this).getOwnerRoot();
    return root && root.host;
  }, distributeContent:function(updateInsertionPoints) {
    if (this.shadyRoot) {
      this.shadyRoot._invalidInsertionPoints = this.shadyRoot._invalidInsertionPoints || updateInsertionPoints;
      var host = getTopDistributingHost(this);
      Polymer.dom(this)._lazyDistribute(host);
    }
  }, _distributeContent:function() {
    if (this._useContent && !this.shadyRoot._distributionClean) {
      if (this.shadyRoot._invalidInsertionPoints) {
        Polymer.dom(this)._updateInsertionPoints(this);
        this.shadyRoot._invalidInsertionPoints = false;
      }
      this._beginDistribute();
      this._distributeDirtyRoots();
      this._finishDistribute();
    }
  }, _beginDistribute:function() {
    if (this._useContent && DomApi.hasInsertionPoint(this.shadyRoot)) {
      this._resetDistribution();
      this._distributePool(this.shadyRoot, this._collectPool());
    }
  }, _distributeDirtyRoots:function() {
    var c$ = this.shadyRoot._dirtyRoots;
    for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
      c._distributeContent();
    }
    this.shadyRoot._dirtyRoots = [];
  }, _finishDistribute:function() {
    if (this._useContent) {
      this.shadyRoot._distributionClean = true;
      if (DomApi.hasInsertionPoint(this.shadyRoot)) {
        this._composeTree();
        notifyContentObservers(this.shadyRoot);
      } else {
        if (!this.shadyRoot._hasDistributed) {
          TreeApi.Composed.clearChildNodes(this);
          this.appendChild(this.shadyRoot);
        } else {
          var children = this._composeNode(this);
          this._updateChildNodes(this, children);
        }
      }
      if (!this.shadyRoot._hasDistributed) {
        notifyInitialDistribution(this);
      }
      this.shadyRoot._hasDistributed = true;
    }
  }, elementMatches:function(selector, node) {
    node = node || this;
    return DomApi.matchesSelector.call(node, selector);
  }, _resetDistribution:function() {
    var children = TreeApi.Logical.getChildNodes(this);
    for (var i = 0; i < children.length; i++) {
      var child = children[i];
      if (child._destinationInsertionPoints) {
        child._destinationInsertionPoints = undefined;
      }
      if (isInsertionPoint(child)) {
        clearDistributedDestinationInsertionPoints(child);
      }
    }
    var root = this.shadyRoot;
    var p$ = root._insertionPoints;
    for (var j = 0; j < p$.length; j++) {
      p$[j]._distributedNodes = [];
    }
  }, _collectPool:function() {
    var pool = [];
    var children = TreeApi.Logical.getChildNodes(this);
    for (var i = 0; i < children.length; i++) {
      var child = children[i];
      if (isInsertionPoint(child)) {
        pool.push.apply(pool, child._distributedNodes);
      } else {
        pool.push(child);
      }
    }
    return pool;
  }, _distributePool:function(node, pool) {
    var p$ = node._insertionPoints;
    for (var i = 0, l = p$.length, p; i < l && (p = p$[i]); i++) {
      this._distributeInsertionPoint(p, pool);
      maybeRedistributeParent(p, this);
    }
  }, _distributeInsertionPoint:function(content, pool) {
    var anyDistributed = false;
    for (var i = 0, l = pool.length, node; i < l; i++) {
      node = pool[i];
      if (!node) {
        continue;
      }
      if (this._matchesContentSelect(node, content)) {
        distributeNodeInto(node, content);
        pool[i] = undefined;
        anyDistributed = true;
      }
    }
    if (!anyDistributed) {
      var children = TreeApi.Logical.getChildNodes(content);
      for (var j = 0; j < children.length; j++) {
        distributeNodeInto(children[j], content);
      }
    }
  }, _composeTree:function() {
    this._updateChildNodes(this, this._composeNode(this));
    var p$ = this.shadyRoot._insertionPoints;
    for (var i = 0, l = p$.length, p, parent; i < l && (p = p$[i]); i++) {
      parent = TreeApi.Logical.getParentNode(p);
      if (!parent._useContent && parent !== this && parent !== this.shadyRoot) {
        this._updateChildNodes(parent, this._composeNode(parent));
      }
    }
  }, _composeNode:function(node) {
    var children = [];
    var c$ = TreeApi.Logical.getChildNodes(node.shadyRoot || node);
    for (var i = 0; i < c$.length; i++) {
      var child = c$[i];
      if (isInsertionPoint(child)) {
        var distributedNodes = child._distributedNodes;
        for (var j = 0; j < distributedNodes.length; j++) {
          var distributedNode = distributedNodes[j];
          if (isFinalDestination(child, distributedNode)) {
            children.push(distributedNode);
          }
        }
      } else {
        children.push(child);
      }
    }
    return children;
  }, _updateChildNodes:function(container, children) {
    var composed = TreeApi.Composed.getChildNodes(container);
    var splices = Polymer.ArraySplice.calculateSplices(children, composed);
    for (var i = 0, d = 0, s; i < splices.length && (s = splices[i]); i++) {
      for (var j = 0, n; j < s.removed.length && (n = s.removed[j]); j++) {
        if (TreeApi.Composed.getParentNode(n) === container) {
          TreeApi.Composed.removeChild(container, n);
        }
        composed.splice(s.index + d, 1);
      }
      d -= s.addedCount;
    }
    for (var i = 0, s, next; i < splices.length && (s = splices[i]); i++) {
      next = composed[s.index];
      for (j = s.index, n; j < s.index + s.addedCount; j++) {
        n = children[j];
        TreeApi.Composed.insertBefore(container, n, next);
        composed.splice(j, 0, n);
      }
    }
  }, _matchesContentSelect:function(node, contentElement) {
    var select = contentElement.getAttribute("select");
    if (!select) {
      return true;
    }
    select = select.trim();
    if (!select) {
      return true;
    }
    if (!(node instanceof Element)) {
      return false;
    }
    var validSelectors = /^(:not\()?[*.#[a-zA-Z_|]/;
    if (!validSelectors.test(select)) {
      return false;
    }
    return this.elementMatches(select, node);
  }, _elementAdd:function() {
  }, _elementRemove:function() {
  }});
  function distributeNodeInto(child, insertionPoint) {
    insertionPoint._distributedNodes.push(child);
    var points = child._destinationInsertionPoints;
    if (!points) {
      child._destinationInsertionPoints = [insertionPoint];
    } else {
      points.push(insertionPoint);
    }
  }
  function clearDistributedDestinationInsertionPoints(content) {
    var e$ = content._distributedNodes;
    if (e$) {
      for (var i = 0; i < e$.length; i++) {
        var d = e$[i]._destinationInsertionPoints;
        if (d) {
          d.splice(d.indexOf(content) + 1, d.length);
        }
      }
    }
  }
  function maybeRedistributeParent(content, host) {
    var parent = TreeApi.Logical.getParentNode(content);
    if (parent && parent.shadyRoot && DomApi.hasInsertionPoint(parent.shadyRoot) && parent.shadyRoot._distributionClean) {
      parent.shadyRoot._distributionClean = false;
      host.shadyRoot._dirtyRoots.push(parent);
    }
  }
  function isFinalDestination(insertionPoint, node) {
    var points = node._destinationInsertionPoints;
    return points && points[points.length - 1] === insertionPoint;
  }
  function isInsertionPoint(node) {
    return node.localName == "content";
  }
  function getTopDistributingHost(host) {
    while (host && hostNeedsRedistribution(host)) {
      host = host.domHost;
    }
    return host;
  }
  function hostNeedsRedistribution(host) {
    var c$ = TreeApi.Logical.getChildNodes(host);
    for (var i = 0, c; i < c$.length; i++) {
      c = c$[i];
      if (c.localName && c.localName === "content") {
        return host.domHost;
      }
    }
  }
  function notifyContentObservers(root) {
    for (var i = 0, c; i < root._insertionPoints.length; i++) {
      c = root._insertionPoints[i];
      if (DomApi.hasApi(c)) {
        Polymer.dom(c).notifyObserver();
      }
    }
  }
  function notifyInitialDistribution(host) {
    if (DomApi.hasApi(host)) {
      Polymer.dom(host).notifyObserver();
    }
  }
  var needsUpgrade = window.CustomElements && !CustomElements.useNative;
  function upgradeLogicalChildren(children) {
    if (needsUpgrade && children) {
      for (var i = 0; i < children.length; i++) {
        CustomElements.upgrade(children[i]);
      }
    }
  }
})();
if (Polymer.Settings.useShadow) {
  Polymer.Base._addFeature({_poolContent:function() {
  }, _beginDistribute:function() {
  }, distributeContent:function() {
  }, _distributeContent:function() {
  }, _finishDistribute:function() {
  }, _createLocalRoot:function() {
    this.createShadowRoot();
    this.shadowRoot.appendChild(this.root);
    this.root = this.shadowRoot;
  }});
}
Polymer.Async = {_currVal:0, _lastVal:0, _callbacks:[], _twiddleContent:0, _twiddle:document.createTextNode(""), run:function(callback, waitTime) {
  if (waitTime > 0) {
    return ~setTimeout(callback, waitTime);
  } else {
    this._twiddle.textContent = this._twiddleContent++;
    this._callbacks.push(callback);
    return this._currVal++;
  }
}, cancel:function(handle) {
  if (handle < 0) {
    clearTimeout(~handle);
  } else {
    var idx = handle - this._lastVal;
    if (idx >= 0) {
      if (!this._callbacks[idx]) {
        throw "invalid async handle: " + handle;
      }
      this._callbacks[idx] = null;
    }
  }
}, _atEndOfMicrotask:function() {
  var len = this._callbacks.length;
  for (var i = 0; i < len; i++) {
    var cb = this._callbacks[i];
    if (cb) {
      try {
        cb();
      } catch (e) {
        i++;
        this._callbacks.splice(0, i);
        this._lastVal += i;
        this._twiddle.textContent = this._twiddleContent++;
        throw e;
      }
    }
  }
  this._callbacks.splice(0, len);
  this._lastVal += len;
}};
(new window.MutationObserver(function() {
  Polymer.Async._atEndOfMicrotask();
})).observe(Polymer.Async._twiddle, {characterData:true});
Polymer.Debounce = function() {
  var Async = Polymer.Async;
  var Debouncer = function(context) {
    this.context = context;
    var self = this;
    this.boundComplete = function() {
      self.complete();
    };
  };
  Debouncer.prototype = {go:function(callback, wait) {
    var h;
    this.finish = function() {
      Async.cancel(h);
    };
    h = Async.run(this.boundComplete, wait);
    this.callback = callback;
  }, stop:function() {
    if (this.finish) {
      this.finish();
      this.finish = null;
    }
  }, complete:function() {
    if (this.finish) {
      this.stop();
      this.callback.call(this.context);
    }
  }};
  function debounce(debouncer, callback, wait) {
    if (debouncer) {
      debouncer.stop();
    } else {
      debouncer = new Debouncer(this);
    }
    debouncer.go(callback, wait);
    return debouncer;
  }
  return debounce;
}();
Polymer.Base._addFeature({_setupDebouncers:function() {
  this._debouncers = {};
}, debounce:function(jobName, callback, wait) {
  return this._debouncers[jobName] = Polymer.Debounce.call(this, this._debouncers[jobName], callback, wait);
}, isDebouncerActive:function(jobName) {
  var debouncer = this._debouncers[jobName];
  return !!(debouncer && debouncer.finish);
}, flushDebouncer:function(jobName) {
  var debouncer = this._debouncers[jobName];
  if (debouncer) {
    debouncer.complete();
  }
}, cancelDebouncer:function(jobName) {
  var debouncer = this._debouncers[jobName];
  if (debouncer) {
    debouncer.stop();
  }
}});
Polymer.DomModule = document.createElement("dom-module");
Polymer.Base._addFeature({_registerFeatures:function() {
  this._prepIs();
  this._prepBehaviors();
  this._prepConstructor();
  this._prepTemplate();
  this._prepShady();
  this._prepPropertyInfo();
}, _prepBehavior:function(b) {
  this._addHostAttributes(b.hostAttributes);
}, _initFeatures:function() {
  this._registerHost();
  if (this._template) {
    this._poolContent();
    this._beginHosting();
    this._stampTemplate();
    this._endHosting();
  }
  this._marshalHostAttributes();
  this._setupDebouncers();
  this._marshalBehaviors();
  this._tryReady();
}, _marshalBehavior:function(b) {
}});
Polymer.nar = [];
Polymer.Annotations = {parseAnnotations:function(template) {
  var list = [];
  var content = template._content || template.content;
  this._parseNodeAnnotations(content, list, template.hasAttribute("strip-whitespace"));
  return list;
}, _parseNodeAnnotations:function(node, list, stripWhiteSpace) {
  return node.nodeType === Node.TEXT_NODE ? this._parseTextNodeAnnotation(node, list) : this._parseElementAnnotations(node, list, stripWhiteSpace);
}, _bindingRegex:function() {
  var IDENT = "(?:" + "[a-zA-Z_$][\\w.:$\\-*]*" + ")";
  var NUMBER = "(?:" + "[-+]?[0-9]*\\.?[0-9]+(?:[eE][-+]?[0-9]+)?" + ")";
  var SQUOTE_STRING = "(?:" + "'(?:[^'\\\\]|\\\\.)*'" + ")";
  var DQUOTE_STRING = "(?:" + '"(?:[^"\\\\]|\\\\.)*"' + ")";
  var STRING = "(?:" + SQUOTE_STRING + "|" + DQUOTE_STRING + ")";
  var ARGUMENT = "(?:" + IDENT + "|" + NUMBER + "|" + STRING + "\\s*" + ")";
  var ARGUMENTS = "(?:" + ARGUMENT + "(?:,\\s*" + ARGUMENT + ")*" + ")";
  var ARGUMENT_LIST = "(?:" + "\\(\\s*" + "(?:" + ARGUMENTS + "?" + ")" + "\\)\\s*" + ")";
  var BINDING = "(" + IDENT + "\\s*" + ARGUMENT_LIST + "?" + ")";
  var OPEN_BRACKET = "(\\[\\[|{{)" + "\\s*";
  var CLOSE_BRACKET = "(?:]]|}})";
  var NEGATE = "(?:(!)\\s*)?";
  var EXPRESSION = OPEN_BRACKET + NEGATE + BINDING + CLOSE_BRACKET;
  return new RegExp(EXPRESSION, "g");
}(), _parseBindings:function(text) {
  var re = this._bindingRegex;
  var parts = [];
  var lastIndex = 0;
  var m;
  while ((m = re.exec(text)) !== null) {
    if (m.index > lastIndex) {
      parts.push({literal:text.slice(lastIndex, m.index)});
    }
    var mode = m[1][0];
    var negate = Boolean(m[2]);
    var value = m[3].trim();
    var customEvent, notifyEvent, colon;
    if (mode == "{" && (colon = value.indexOf("::")) > 0) {
      notifyEvent = value.substring(colon + 2);
      value = value.substring(0, colon);
      customEvent = true;
    }
    parts.push({compoundIndex:parts.length, value:value, mode:mode, negate:negate, event:notifyEvent, customEvent:customEvent});
    lastIndex = re.lastIndex;
  }
  if (lastIndex && lastIndex < text.length) {
    var literal = text.substring(lastIndex);
    if (literal) {
      parts.push({literal:literal});
    }
  }
  if (parts.length) {
    return parts;
  }
}, _literalFromParts:function(parts) {
  var s = "";
  for (var i = 0; i < parts.length; i++) {
    var literal = parts[i].literal;
    s += literal || "";
  }
  return s;
}, _parseTextNodeAnnotation:function(node, list) {
  var parts = this._parseBindings(node.textContent);
  if (parts) {
    node.textContent = this._literalFromParts(parts) || " ";
    var annote = {bindings:[{kind:"text", name:"textContent", parts:parts, isCompound:parts.length !== 1}]};
    list.push(annote);
    return annote;
  }
}, _parseElementAnnotations:function(element, list, stripWhiteSpace) {
  var annote = {bindings:[], events:[]};
  if (element.localName === "content") {
    list._hasContent = true;
  }
  this._parseChildNodesAnnotations(element, annote, list, stripWhiteSpace);
  if (element.attributes) {
    this._parseNodeAttributeAnnotations(element, annote, list);
    if (this.prepElement) {
      this.prepElement(element);
    }
  }
  if (annote.bindings.length || annote.events.length || annote.id) {
    list.push(annote);
  }
  return annote;
}, _parseChildNodesAnnotations:function(root, annote, list, stripWhiteSpace) {
  if (root.firstChild) {
    var node = root.firstChild;
    var i = 0;
    while (node) {
      var next = node.nextSibling;
      if (node.localName === "template" && !node.hasAttribute("preserve-content")) {
        this._parseTemplate(node, i, list, annote);
      }
      if (node.nodeType === Node.TEXT_NODE) {
        var n = next;
        while (n && n.nodeType === Node.TEXT_NODE) {
          node.textContent += n.textContent;
          next = n.nextSibling;
          root.removeChild(n);
          n = next;
        }
        if (stripWhiteSpace && !node.textContent.trim()) {
          root.removeChild(node);
          i--;
        }
      }
      if (node.parentNode) {
        var childAnnotation = this._parseNodeAnnotations(node, list, stripWhiteSpace);
        if (childAnnotation) {
          childAnnotation.parent = annote;
          childAnnotation.index = i;
        }
      }
      node = next;
      i++;
    }
  }
}, _parseTemplate:function(node, index, list, parent) {
  var content = document.createDocumentFragment();
  content._notes = this.parseAnnotations(node);
  content.appendChild(node.content);
  list.push({bindings:Polymer.nar, events:Polymer.nar, templateContent:content, parent:parent, index:index});
}, _parseNodeAttributeAnnotations:function(node, annotation) {
  var attrs = Array.prototype.slice.call(node.attributes);
  for (var i = attrs.length - 1, a; a = attrs[i]; i--) {
    var n = a.name;
    var v = a.value;
    var b;
    if (n.slice(0, 3) === "on-") {
      node.removeAttribute(n);
      annotation.events.push({name:n.slice(3), value:v});
    } else {
      if (b = this._parseNodeAttributeAnnotation(node, n, v)) {
        annotation.bindings.push(b);
      } else {
        if (n === "id") {
          annotation.id = v;
        }
      }
    }
  }
}, _parseNodeAttributeAnnotation:function(node, name, value) {
  var parts = this._parseBindings(value);
  if (parts) {
    var origName = name;
    var kind = "property";
    if (name[name.length - 1] == "$") {
      name = name.slice(0, -1);
      kind = "attribute";
    }
    var literal = this._literalFromParts(parts);
    if (literal && kind == "attribute") {
      node.setAttribute(name, literal);
    }
    if (node.localName === "input" && origName === "value") {
      node.setAttribute(origName, "");
    }
    node.removeAttribute(origName);
    var propertyName = Polymer.CaseMap.dashToCamelCase(name);
    if (kind === "property") {
      name = propertyName;
    }
    return {kind:kind, name:name, propertyName:propertyName, parts:parts, literal:literal, isCompound:parts.length !== 1};
  }
}, findAnnotatedNode:function(root, annote) {
  var parent = annote.parent && Polymer.Annotations.findAnnotatedNode(root, annote.parent);
  if (parent) {
    for (var n = parent.firstChild, i = 0; n; n = n.nextSibling) {
      if (annote.index === i++) {
        return n;
      }
    }
  } else {
    return root;
  }
}};
(function() {
  function resolveCss(cssText, ownerDocument) {
    return cssText.replace(CSS_URL_RX, function(m, pre, url, post) {
      return pre + "'" + resolve(url.replace(/["']/g, ""), ownerDocument) + "'" + post;
    });
  }
  function resolveAttrs(element, ownerDocument) {
    for (var name in URL_ATTRS) {
      var a$ = URL_ATTRS[name];
      for (var i = 0, l = a$.length, a, at, v; i < l && (a = a$[i]); i++) {
        if (name === "*" || element.localName === name) {
          at = element.attributes[a];
          v = at && at.value;
          if (v && v.search(BINDING_RX) < 0) {
            at.value = a === "style" ? resolveCss(v, ownerDocument) : resolve(v, ownerDocument);
          }
        }
      }
    }
  }
  function resolve(url, ownerDocument) {
    if (url && url[0] === "#") {
      return url;
    }
    var resolver = getUrlResolver(ownerDocument);
    resolver.href = url;
    return resolver.href || url;
  }
  var tempDoc;
  var tempDocBase;
  function resolveUrl(url, baseUri) {
    if (!tempDoc) {
      tempDoc = document.implementation.createHTMLDocument("temp");
      tempDocBase = tempDoc.createElement("base");
      tempDoc.head.appendChild(tempDocBase);
    }
    tempDocBase.href = baseUri;
    return resolve(url, tempDoc);
  }
  function getUrlResolver(ownerDocument) {
    return ownerDocument.__urlResolver || (ownerDocument.__urlResolver = ownerDocument.createElement("a"));
  }
  var CSS_URL_RX = /(url\()([^)]*)(\))/g;
  var URL_ATTRS = {"*":["href", "src", "style", "url"], form:["action"]};
  var BINDING_RX = /\{\{|\[\[/;
  Polymer.ResolveUrl = {resolveCss:resolveCss, resolveAttrs:resolveAttrs, resolveUrl:resolveUrl};
})();
Polymer.Base._addFeature({_prepAnnotations:function() {
  if (!this._template) {
    this._notes = [];
  } else {
    var self = this;
    Polymer.Annotations.prepElement = function(element) {
      self._prepElement(element);
    };
    if (this._template._content && this._template._content._notes) {
      this._notes = this._template._content._notes;
    } else {
      this._notes = Polymer.Annotations.parseAnnotations(this._template);
      this._processAnnotations(this._notes);
    }
    Polymer.Annotations.prepElement = null;
  }
}, _processAnnotations:function(notes) {
  for (var i = 0; i < notes.length; i++) {
    var note = notes[i];
    for (var j = 0; j < note.bindings.length; j++) {
      var b = note.bindings[j];
      for (var k = 0; k < b.parts.length; k++) {
        var p = b.parts[k];
        if (!p.literal) {
          var signature = this._parseMethod(p.value);
          if (signature) {
            p.signature = signature;
          } else {
            p.model = this._modelForPath(p.value);
          }
        }
      }
    }
    if (note.templateContent) {
      this._processAnnotations(note.templateContent._notes);
      var pp = note.templateContent._parentProps = this._discoverTemplateParentProps(note.templateContent._notes);
      var bindings = [];
      for (var prop in pp) {
        bindings.push({index:note.index, kind:"property", name:"_parent_" + prop, parts:[{mode:"{", model:prop, value:prop}]});
      }
      note.bindings = note.bindings.concat(bindings);
    }
  }
}, _discoverTemplateParentProps:function(notes) {
  var pp = {};
  for (var i = 0, n; i < notes.length && (n = notes[i]); i++) {
    for (var j = 0, b$ = n.bindings, b; j < b$.length && (b = b$[j]); j++) {
      for (var k = 0, p$ = b.parts, p; k < p$.length && (p = p$[k]); k++) {
        if (p.signature) {
          var args = p.signature.args;
          for (var kk = 0; kk < args.length; kk++) {
            var model = args[kk].model;
            if (model) {
              pp[model] = true;
            }
          }
        } else {
          if (p.model) {
            pp[p.model] = true;
          }
        }
      }
    }
    if (n.templateContent) {
      var tpp = n.templateContent._parentProps;
      Polymer.Base.mixin(pp, tpp);
    }
  }
  return pp;
}, _prepElement:function(element) {
  Polymer.ResolveUrl.resolveAttrs(element, this._template.ownerDocument);
}, _findAnnotatedNode:Polymer.Annotations.findAnnotatedNode, _marshalAnnotationReferences:function() {
  if (this._template) {
    this._marshalIdNodes();
    this._marshalAnnotatedNodes();
    this._marshalAnnotatedListeners();
  }
}, _configureAnnotationReferences:function() {
  var notes = this._notes;
  var nodes = this._nodes;
  for (var i = 0; i < notes.length; i++) {
    var note = notes[i];
    var node = nodes[i];
    this._configureTemplateContent(note, node);
    this._configureCompoundBindings(note, node);
  }
}, _configureTemplateContent:function(note, node) {
  if (note.templateContent) {
    node._content = note.templateContent;
  }
}, _configureCompoundBindings:function(note, node) {
  var bindings = note.bindings;
  for (var i = 0; i < bindings.length; i++) {
    var binding = bindings[i];
    if (binding.isCompound) {
      var storage = node.__compoundStorage__ || (node.__compoundStorage__ = {});
      var parts = binding.parts;
      var literals = new Array(parts.length);
      for (var j = 0; j < parts.length; j++) {
        literals[j] = parts[j].literal;
      }
      var name = binding.name;
      storage[name] = literals;
      if (binding.literal && binding.kind == "property") {
        if (node._configValue) {
          node._configValue(name, binding.literal);
        } else {
          node[name] = binding.literal;
        }
      }
    }
  }
}, _marshalIdNodes:function() {
  this.$ = {};
  for (var i = 0, l = this._notes.length, a; i < l && (a = this._notes[i]); i++) {
    if (a.id) {
      this.$[a.id] = this._findAnnotatedNode(this.root, a);
    }
  }
}, _marshalAnnotatedNodes:function() {
  if (this._notes && this._notes.length) {
    var r = new Array(this._notes.length);
    for (var i = 0; i < this._notes.length; i++) {
      r[i] = this._findAnnotatedNode(this.root, this._notes[i]);
    }
    this._nodes = r;
  }
}, _marshalAnnotatedListeners:function() {
  for (var i = 0, l = this._notes.length, a; i < l && (a = this._notes[i]); i++) {
    if (a.events && a.events.length) {
      var node = this._findAnnotatedNode(this.root, a);
      for (var j = 0, e$ = a.events, e; j < e$.length && (e = e$[j]); j++) {
        this.listen(node, e.name, e.value);
      }
    }
  }
}});
Polymer.Base._addFeature({listeners:{}, _listenListeners:function(listeners) {
  var node, name, eventName;
  for (eventName in listeners) {
    if (eventName.indexOf(".") < 0) {
      node = this;
      name = eventName;
    } else {
      name = eventName.split(".");
      node = this.$[name[0]];
      name = name[1];
    }
    this.listen(node, name, listeners[eventName]);
  }
}, listen:function(node, eventName, methodName) {
  var handler = this._recallEventHandler(this, eventName, node, methodName);
  if (!handler) {
    handler = this._createEventHandler(node, eventName, methodName);
  }
  if (handler._listening) {
    return;
  }
  this._listen(node, eventName, handler);
  handler._listening = true;
}, _boundListenerKey:function(eventName, methodName) {
  return eventName + ":" + methodName;
}, _recordEventHandler:function(host, eventName, target, methodName, handler) {
  var hbl = host.__boundListeners;
  if (!hbl) {
    hbl = host.__boundListeners = new WeakMap;
  }
  var bl = hbl.get(target);
  if (!bl) {
    bl = {};
    hbl.set(target, bl);
  }
  var key = this._boundListenerKey(eventName, methodName);
  bl[key] = handler;
}, _recallEventHandler:function(host, eventName, target, methodName) {
  var hbl = host.__boundListeners;
  if (!hbl) {
    return;
  }
  var bl = hbl.get(target);
  if (!bl) {
    return;
  }
  var key = this._boundListenerKey(eventName, methodName);
  return bl[key];
}, _createEventHandler:function(node, eventName, methodName) {
  var host = this;
  var handler = function(e) {
    if (host[methodName]) {
      host[methodName](e, e.detail);
    } else {
      host._warn(host._logf("_createEventHandler", "listener method `" + methodName + "` not defined"));
    }
  };
  handler._listening = false;
  this._recordEventHandler(host, eventName, node, methodName, handler);
  return handler;
}, unlisten:function(node, eventName, methodName) {
  var handler = this._recallEventHandler(this, eventName, node, methodName);
  if (handler) {
    this._unlisten(node, eventName, handler);
    handler._listening = false;
  }
}, _listen:function(node, eventName, handler) {
  node.addEventListener(eventName, handler);
}, _unlisten:function(node, eventName, handler) {
  node.removeEventListener(eventName, handler);
}});
(function() {
  var wrap = Polymer.DomApi.wrap;
  var HAS_NATIVE_TA = typeof document.head.style.touchAction === "string";
  var GESTURE_KEY = "__polymerGestures";
  var HANDLED_OBJ = "__polymerGesturesHandled";
  var TOUCH_ACTION = "__polymerGesturesTouchAction";
  var TAP_DISTANCE = 25;
  var TRACK_DISTANCE = 5;
  var TRACK_LENGTH = 2;
  var MOUSE_TIMEOUT = 2500;
  var MOUSE_EVENTS = ["mousedown", "mousemove", "mouseup", "click"];
  var MOUSE_WHICH_TO_BUTTONS = [0, 1, 4, 2];
  var MOUSE_HAS_BUTTONS = function() {
    try {
      return (new MouseEvent("test", {buttons:1})).buttons === 1;
    } catch (e) {
      return false;
    }
  }();
  var IS_TOUCH_ONLY = navigator.userAgent.match(/iP(?:[oa]d|hone)|Android/);
  var mouseCanceller = function(mouseEvent) {
    mouseEvent[HANDLED_OBJ] = {skip:true};
    if (mouseEvent.type === "click") {
      var path = Polymer.dom(mouseEvent).path;
      for (var i = 0; i < path.length; i++) {
        if (path[i] === POINTERSTATE.mouse.target) {
          return;
        }
      }
      mouseEvent.preventDefault();
      mouseEvent.stopPropagation();
    }
  };
  function setupTeardownMouseCanceller(setup) {
    for (var i = 0, en; i < MOUSE_EVENTS.length; i++) {
      en = MOUSE_EVENTS[i];
      if (setup) {
        document.addEventListener(en, mouseCanceller, true);
      } else {
        document.removeEventListener(en, mouseCanceller, true);
      }
    }
  }
  function ignoreMouse() {
    if (IS_TOUCH_ONLY) {
      return;
    }
    if (!POINTERSTATE.mouse.mouseIgnoreJob) {
      setupTeardownMouseCanceller(true);
    }
    var unset = function() {
      setupTeardownMouseCanceller();
      POINTERSTATE.mouse.target = null;
      POINTERSTATE.mouse.mouseIgnoreJob = null;
    };
    POINTERSTATE.mouse.mouseIgnoreJob = Polymer.Debounce(POINTERSTATE.mouse.mouseIgnoreJob, unset, MOUSE_TIMEOUT);
  }
  function hasLeftMouseButton(ev) {
    var type = ev.type;
    if (MOUSE_EVENTS.indexOf(type) === -1) {
      return false;
    }
    if (type === "mousemove") {
      var buttons = ev.buttons === undefined ? 1 : ev.buttons;
      if (ev instanceof window.MouseEvent && !MOUSE_HAS_BUTTONS) {
        buttons = MOUSE_WHICH_TO_BUTTONS[ev.which] || 0;
      }
      return Boolean(buttons & 1);
    } else {
      var button = ev.button === undefined ? 0 : ev.button;
      return button === 0;
    }
  }
  function isSyntheticClick(ev) {
    if (ev.type === "click") {
      if (ev.detail === 0) {
        return true;
      }
      var t = Gestures.findOriginalTarget(ev);
      var bcr = t.getBoundingClientRect();
      var x = ev.pageX, y = ev.pageY;
      return !(x >= bcr.left && x <= bcr.right && (y >= bcr.top && y <= bcr.bottom));
    }
    return false;
  }
  var POINTERSTATE = {mouse:{target:null, mouseIgnoreJob:null}, touch:{x:0, y:0, id:-1, scrollDecided:false}};
  function firstTouchAction(ev) {
    var path = Polymer.dom(ev).path;
    var ta = "auto";
    for (var i = 0, n; i < path.length; i++) {
      n = path[i];
      if (n[TOUCH_ACTION]) {
        ta = n[TOUCH_ACTION];
        break;
      }
    }
    return ta;
  }
  function trackDocument(stateObj, movefn, upfn) {
    stateObj.movefn = movefn;
    stateObj.upfn = upfn;
    document.addEventListener("mousemove", movefn);
    document.addEventListener("mouseup", upfn);
  }
  function untrackDocument(stateObj) {
    document.removeEventListener("mousemove", stateObj.movefn);
    document.removeEventListener("mouseup", stateObj.upfn);
    stateObj.movefn = null;
    stateObj.upfn = null;
  }
  var Gestures = {gestures:{}, recognizers:[], deepTargetFind:function(x, y) {
    var node = document.elementFromPoint(x, y);
    var next = node;
    while (next && next.shadowRoot) {
      next = next.shadowRoot.elementFromPoint(x, y);
      if (next) {
        node = next;
      }
    }
    return node;
  }, findOriginalTarget:function(ev) {
    if (ev.path) {
      return ev.path[0];
    }
    return ev.target;
  }, handleNative:function(ev) {
    var handled;
    var type = ev.type;
    var node = wrap(ev.currentTarget);
    var gobj = node[GESTURE_KEY];
    if (!gobj) {
      return;
    }
    var gs = gobj[type];
    if (!gs) {
      return;
    }
    if (!ev[HANDLED_OBJ]) {
      ev[HANDLED_OBJ] = {};
      if (type.slice(0, 5) === "touch") {
        var t = ev.changedTouches[0];
        if (type === "touchstart") {
          if (ev.touches.length === 1) {
            POINTERSTATE.touch.id = t.identifier;
          }
        }
        if (POINTERSTATE.touch.id !== t.identifier) {
          return;
        }
        if (!HAS_NATIVE_TA) {
          if (type === "touchstart" || type === "touchmove") {
            Gestures.handleTouchAction(ev);
          }
        }
        if (type === "touchend" && !ev.__polymerSimulatedTouch) {
          POINTERSTATE.mouse.target = Polymer.dom(ev).rootTarget;
          ignoreMouse(true);
        }
      }
    }
    handled = ev[HANDLED_OBJ];
    if (handled.skip) {
      return;
    }
    var recognizers = Gestures.recognizers;
    for (var i = 0, r; i < recognizers.length; i++) {
      r = recognizers[i];
      if (gs[r.name] && !handled[r.name]) {
        if (r.flow && r.flow.start.indexOf(ev.type) > -1 && r.reset) {
          r.reset();
        }
      }
    }
    for (i = 0, r; i < recognizers.length; i++) {
      r = recognizers[i];
      if (gs[r.name] && !handled[r.name]) {
        handled[r.name] = true;
        r[type](ev);
      }
    }
  }, handleTouchAction:function(ev) {
    var t = ev.changedTouches[0];
    var type = ev.type;
    if (type === "touchstart") {
      POINTERSTATE.touch.x = t.clientX;
      POINTERSTATE.touch.y = t.clientY;
      POINTERSTATE.touch.scrollDecided = false;
    } else {
      if (type === "touchmove") {
        if (POINTERSTATE.touch.scrollDecided) {
          return;
        }
        POINTERSTATE.touch.scrollDecided = true;
        var ta = firstTouchAction(ev);
        var prevent = false;
        var dx = Math.abs(POINTERSTATE.touch.x - t.clientX);
        var dy = Math.abs(POINTERSTATE.touch.y - t.clientY);
        if (!ev.cancelable) {
        } else {
          if (ta === "none") {
            prevent = true;
          } else {
            if (ta === "pan-x") {
              prevent = dy > dx;
            } else {
              if (ta === "pan-y") {
                prevent = dx > dy;
              }
            }
          }
        }
        if (prevent) {
          ev.preventDefault();
        } else {
          Gestures.prevent("track");
        }
      }
    }
  }, add:function(node, evType, handler) {
    node = wrap(node);
    var recognizer = this.gestures[evType];
    var deps = recognizer.deps;
    var name = recognizer.name;
    var gobj = node[GESTURE_KEY];
    if (!gobj) {
      node[GESTURE_KEY] = gobj = {};
    }
    for (var i = 0, dep, gd; i < deps.length; i++) {
      dep = deps[i];
      if (IS_TOUCH_ONLY && MOUSE_EVENTS.indexOf(dep) > -1) {
        continue;
      }
      gd = gobj[dep];
      if (!gd) {
        gobj[dep] = gd = {_count:0};
      }
      if (gd._count === 0) {
        node.addEventListener(dep, this.handleNative);
      }
      gd[name] = (gd[name] || 0) + 1;
      gd._count = (gd._count || 0) + 1;
    }
    node.addEventListener(evType, handler);
    if (recognizer.touchAction) {
      this.setTouchAction(node, recognizer.touchAction);
    }
  }, remove:function(node, evType, handler) {
    node = wrap(node);
    var recognizer = this.gestures[evType];
    var deps = recognizer.deps;
    var name = recognizer.name;
    var gobj = node[GESTURE_KEY];
    if (gobj) {
      for (var i = 0, dep, gd; i < deps.length; i++) {
        dep = deps[i];
        gd = gobj[dep];
        if (gd && gd[name]) {
          gd[name] = (gd[name] || 1) - 1;
          gd._count = (gd._count || 1) - 1;
          if (gd._count === 0) {
            node.removeEventListener(dep, this.handleNative);
          }
        }
      }
    }
    node.removeEventListener(evType, handler);
  }, register:function(recog) {
    this.recognizers.push(recog);
    for (var i = 0; i < recog.emits.length; i++) {
      this.gestures[recog.emits[i]] = recog;
    }
  }, findRecognizerByEvent:function(evName) {
    for (var i = 0, r; i < this.recognizers.length; i++) {
      r = this.recognizers[i];
      for (var j = 0, n; j < r.emits.length; j++) {
        n = r.emits[j];
        if (n === evName) {
          return r;
        }
      }
    }
    return null;
  }, setTouchAction:function(node, value) {
    if (HAS_NATIVE_TA) {
      node.style.touchAction = value;
    }
    node[TOUCH_ACTION] = value;
  }, fire:function(target, type, detail) {
    var ev = Polymer.Base.fire(type, detail, {node:target, bubbles:true, cancelable:true});
    if (ev.defaultPrevented) {
      var se = detail.sourceEvent;
      if (se && se.preventDefault) {
        se.preventDefault();
      }
    }
  }, prevent:function(evName) {
    var recognizer = this.findRecognizerByEvent(evName);
    if (recognizer.info) {
      recognizer.info.prevent = true;
    }
  }};
  Gestures.register({name:"downup", deps:["mousedown", "touchstart", "touchend"], flow:{start:["mousedown", "touchstart"], end:["mouseup", "touchend"]}, emits:["down", "up"], info:{movefn:null, upfn:null}, reset:function() {
    untrackDocument(this.info);
  }, mousedown:function(e) {
    if (!hasLeftMouseButton(e)) {
      return;
    }
    var t = Gestures.findOriginalTarget(e);
    var self = this;
    var movefn = function movefn(e) {
      if (!hasLeftMouseButton(e)) {
        self.fire("up", t, e);
        untrackDocument(self.info);
      }
    };
    var upfn = function upfn(e) {
      if (hasLeftMouseButton(e)) {
        self.fire("up", t, e);
      }
      untrackDocument(self.info);
    };
    trackDocument(this.info, movefn, upfn);
    this.fire("down", t, e);
  }, touchstart:function(e) {
    this.fire("down", Gestures.findOriginalTarget(e), e.changedTouches[0]);
  }, touchend:function(e) {
    this.fire("up", Gestures.findOriginalTarget(e), e.changedTouches[0]);
  }, fire:function(type, target, event) {
    Gestures.fire(target, type, {x:event.clientX, y:event.clientY, sourceEvent:event, prevent:function(e) {
      return Gestures.prevent(e);
    }});
  }});
  Gestures.register({name:"track", touchAction:"none", deps:["mousedown", "touchstart", "touchmove", "touchend"], flow:{start:["mousedown", "touchstart"], end:["mouseup", "touchend"]}, emits:["track"], info:{x:0, y:0, state:"start", started:false, moves:[], addMove:function(move) {
    if (this.moves.length > TRACK_LENGTH) {
      this.moves.shift();
    }
    this.moves.push(move);
  }, movefn:null, upfn:null, prevent:false}, reset:function() {
    this.info.state = "start";
    this.info.started = false;
    this.info.moves = [];
    this.info.x = 0;
    this.info.y = 0;
    this.info.prevent = false;
    untrackDocument(this.info);
  }, hasMovedEnough:function(x, y) {
    if (this.info.prevent) {
      return false;
    }
    if (this.info.started) {
      return true;
    }
    var dx = Math.abs(this.info.x - x);
    var dy = Math.abs(this.info.y - y);
    return dx >= TRACK_DISTANCE || dy >= TRACK_DISTANCE;
  }, mousedown:function(e) {
    if (!hasLeftMouseButton(e)) {
      return;
    }
    var t = Gestures.findOriginalTarget(e);
    var self = this;
    var movefn = function movefn(e) {
      var x = e.clientX, y = e.clientY;
      if (self.hasMovedEnough(x, y)) {
        self.info.state = self.info.started ? e.type === "mouseup" ? "end" : "track" : "start";
        if (self.info.state === "start") {
          Gestures.prevent("tap");
        }
        self.info.addMove({x:x, y:y});
        if (!hasLeftMouseButton(e)) {
          self.info.state = "end";
          untrackDocument(self.info);
        }
        self.fire(t, e);
        self.info.started = true;
      }
    };
    var upfn = function upfn(e) {
      if (self.info.started) {
        movefn(e);
      }
      untrackDocument(self.info);
    };
    trackDocument(this.info, movefn, upfn);
    this.info.x = e.clientX;
    this.info.y = e.clientY;
  }, touchstart:function(e) {
    var ct = e.changedTouches[0];
    this.info.x = ct.clientX;
    this.info.y = ct.clientY;
  }, touchmove:function(e) {
    var t = Gestures.findOriginalTarget(e);
    var ct = e.changedTouches[0];
    var x = ct.clientX, y = ct.clientY;
    if (this.hasMovedEnough(x, y)) {
      if (this.info.state === "start") {
        Gestures.prevent("tap");
      }
      this.info.addMove({x:x, y:y});
      this.fire(t, ct);
      this.info.state = "track";
      this.info.started = true;
    }
  }, touchend:function(e) {
    var t = Gestures.findOriginalTarget(e);
    var ct = e.changedTouches[0];
    if (this.info.started) {
      this.info.state = "end";
      this.info.addMove({x:ct.clientX, y:ct.clientY});
      this.fire(t, ct);
    }
  }, fire:function(target, touch) {
    var secondlast = this.info.moves[this.info.moves.length - 2];
    var lastmove = this.info.moves[this.info.moves.length - 1];
    var dx = lastmove.x - this.info.x;
    var dy = lastmove.y - this.info.y;
    var ddx, ddy = 0;
    if (secondlast) {
      ddx = lastmove.x - secondlast.x;
      ddy = lastmove.y - secondlast.y;
    }
    return Gestures.fire(target, "track", {state:this.info.state, x:touch.clientX, y:touch.clientY, dx:dx, dy:dy, ddx:ddx, ddy:ddy, sourceEvent:touch, hover:function() {
      return Gestures.deepTargetFind(touch.clientX, touch.clientY);
    }});
  }});
  Gestures.register({name:"tap", deps:["mousedown", "click", "touchstart", "touchend"], flow:{start:["mousedown", "touchstart"], end:["click", "touchend"]}, emits:["tap"], info:{x:NaN, y:NaN, prevent:false}, reset:function() {
    this.info.x = NaN;
    this.info.y = NaN;
    this.info.prevent = false;
  }, save:function(e) {
    this.info.x = e.clientX;
    this.info.y = e.clientY;
  }, mousedown:function(e) {
    if (hasLeftMouseButton(e)) {
      this.save(e);
    }
  }, click:function(e) {
    if (hasLeftMouseButton(e)) {
      this.forward(e);
    }
  }, touchstart:function(e) {
    this.save(e.changedTouches[0]);
  }, touchend:function(e) {
    this.forward(e.changedTouches[0]);
  }, forward:function(e) {
    var dx = Math.abs(e.clientX - this.info.x);
    var dy = Math.abs(e.clientY - this.info.y);
    var t = Gestures.findOriginalTarget(e);
    if (isNaN(dx) || isNaN(dy) || dx <= TAP_DISTANCE && dy <= TAP_DISTANCE || isSyntheticClick(e)) {
      if (!this.info.prevent) {
        Gestures.fire(t, "tap", {x:e.clientX, y:e.clientY, sourceEvent:e});
      }
    }
  }});
  var DIRECTION_MAP = {x:"pan-x", y:"pan-y", none:"none", all:"auto"};
  Polymer.Base._addFeature({_setupGestures:function() {
    this.__polymerGestures = null;
  }, _listen:function(node, eventName, handler) {
    if (Gestures.gestures[eventName]) {
      Gestures.add(node, eventName, handler);
    } else {
      node.addEventListener(eventName, handler);
    }
  }, _unlisten:function(node, eventName, handler) {
    if (Gestures.gestures[eventName]) {
      Gestures.remove(node, eventName, handler);
    } else {
      node.removeEventListener(eventName, handler);
    }
  }, setScrollDirection:function(direction, node) {
    node = node || this;
    Gestures.setTouchAction(node, DIRECTION_MAP[direction] || "auto");
  }});
  Polymer.Gestures = Gestures;
})();
Polymer.Base._addFeature({$$:function(slctr) {
  return Polymer.dom(this.root).querySelector(slctr);
}, toggleClass:function(name, bool, node) {
  node = node || this;
  if (arguments.length == 1) {
    bool = !node.classList.contains(name);
  }
  if (bool) {
    Polymer.dom(node).classList.add(name);
  } else {
    Polymer.dom(node).classList.remove(name);
  }
}, toggleAttribute:function(name, bool, node) {
  node = node || this;
  if (arguments.length == 1) {
    bool = !node.hasAttribute(name);
  }
  if (bool) {
    Polymer.dom(node).setAttribute(name, "");
  } else {
    Polymer.dom(node).removeAttribute(name);
  }
}, classFollows:function(name, toElement, fromElement) {
  if (fromElement) {
    Polymer.dom(fromElement).classList.remove(name);
  }
  if (toElement) {
    Polymer.dom(toElement).classList.add(name);
  }
}, attributeFollows:function(name, toElement, fromElement) {
  if (fromElement) {
    Polymer.dom(fromElement).removeAttribute(name);
  }
  if (toElement) {
    Polymer.dom(toElement).setAttribute(name, "");
  }
}, getEffectiveChildNodes:function() {
  return Polymer.dom(this).getEffectiveChildNodes();
}, getEffectiveChildren:function() {
  var list = Polymer.dom(this).getEffectiveChildNodes();
  return list.filter(function(n) {
    return n.nodeType === Node.ELEMENT_NODE;
  });
}, getEffectiveTextContent:function() {
  var cn = this.getEffectiveChildNodes();
  var tc = [];
  for (var i = 0, c; c = cn[i]; i++) {
    if (c.nodeType !== Node.COMMENT_NODE) {
      tc.push(Polymer.dom(c).textContent);
    }
  }
  return tc.join("");
}, queryEffectiveChildren:function(slctr) {
  var e$ = Polymer.dom(this).queryDistributedElements(slctr);
  return e$ && e$[0];
}, queryAllEffectiveChildren:function(slctr) {
  return Polymer.dom(this).queryDistributedElements(slctr);
}, getContentChildNodes:function(slctr) {
  var content = Polymer.dom(this.root).querySelector(slctr || "content");
  return content ? Polymer.dom(content).getDistributedNodes() : [];
}, getContentChildren:function(slctr) {
  return this.getContentChildNodes(slctr).filter(function(n) {
    return n.nodeType === Node.ELEMENT_NODE;
  });
}, fire:function(type, detail, options) {
  options = options || Polymer.nob;
  var node = options.node || this;
  detail = detail === null || detail === undefined ? {} : detail;
  var bubbles = options.bubbles === undefined ? true : options.bubbles;
  var cancelable = Boolean(options.cancelable);
  var useCache = options._useCache;
  var event = this._getEvent(type, bubbles, cancelable, useCache);
  event.detail = detail;
  if (useCache) {
    this.__eventCache[type] = null;
  }
  node.dispatchEvent(event);
  if (useCache) {
    this.__eventCache[type] = event;
  }
  return event;
}, __eventCache:{}, _getEvent:function(type, bubbles, cancelable, useCache) {
  var event = useCache && this.__eventCache[type];
  if (!event || (event.bubbles != bubbles || event.cancelable != cancelable)) {
    event = new Event(type, {bubbles:Boolean(bubbles), cancelable:cancelable});
  }
  return event;
}, async:function(callback, waitTime) {
  var self = this;
  return Polymer.Async.run(function() {
    callback.call(self);
  }, waitTime);
}, cancelAsync:function(handle) {
  Polymer.Async.cancel(handle);
}, arrayDelete:function(path, item) {
  var index;
  if (Array.isArray(path)) {
    index = path.indexOf(item);
    if (index >= 0) {
      return path.splice(index, 1);
    }
  } else {
    var arr = this._get(path);
    index = arr.indexOf(item);
    if (index >= 0) {
      return this.splice(path, index, 1);
    }
  }
}, transform:function(transform, node) {
  node = node || this;
  node.style.webkitTransform = transform;
  node.style.transform = transform;
}, translate3d:function(x, y, z, node) {
  node = node || this;
  this.transform("translate3d(" + x + "," + y + "," + z + ")", node);
}, importHref:function(href, onload, onerror, optAsync) {
  var l = document.createElement("link");
  l.rel = "import";
  l.href = href;
  optAsync = Boolean(optAsync);
  if (optAsync) {
    l.setAttribute("async", "");
  }
  var self = this;
  if (onload) {
    l.onload = function(e) {
      return onload.call(self, e);
    };
  }
  if (onerror) {
    l.onerror = function(e) {
      return onerror.call(self, e);
    };
  }
  document.head.appendChild(l);
  return l;
}, create:function(tag, props) {
  var elt = document.createElement(tag);
  if (props) {
    for (var n in props) {
      elt[n] = props[n];
    }
  }
  return elt;
}, isLightDescendant:function(node) {
  return this !== node && this.contains(node) && Polymer.dom(this).getOwnerRoot() === Polymer.dom(node).getOwnerRoot();
}, isLocalDescendant:function(node) {
  return this.root === Polymer.dom(node).getOwnerRoot();
}});
Polymer.Bind = {_dataEventCache:{}, prepareModel:function(model) {
  Polymer.Base.mixin(model, this._modelApi);
}, _modelApi:{_notifyChange:function(source, event, value) {
  value = value === undefined ? this[source] : value;
  event = event || Polymer.CaseMap.camelToDashCase(source) + "-changed";
  this.fire(event, {value:value}, {bubbles:false, cancelable:false, _useCache:true});
}, _propertySetter:function(property, value, effects, fromAbove) {
  var old = this.__data__[property];
  if (old !== value && (old === old || value === value)) {
    this.__data__[property] = value;
    if (typeof value == "object") {
      this._clearPath(property);
    }
    if (this._propertyChanged) {
      this._propertyChanged(property, value, old);
    }
    if (effects) {
      this._effectEffects(property, value, effects, old, fromAbove);
    }
  }
  return old;
}, __setProperty:function(property, value, quiet, node) {
  node = node || this;
  var effects = node._propertyEffects && node._propertyEffects[property];
  if (effects) {
    node._propertySetter(property, value, effects, quiet);
  } else {
    node[property] = value;
  }
}, _effectEffects:function(property, value, effects, old, fromAbove) {
  for (var i = 0, l = effects.length, fx; i < l && (fx = effects[i]); i++) {
    fx.fn.call(this, property, value, fx.effect, old, fromAbove);
  }
}, _clearPath:function(path) {
  for (var prop in this.__data__) {
    if (prop.indexOf(path + ".") === 0) {
      this.__data__[prop] = undefined;
    }
  }
}}, ensurePropertyEffects:function(model, property) {
  if (!model._propertyEffects) {
    model._propertyEffects = {};
  }
  var fx = model._propertyEffects[property];
  if (!fx) {
    fx = model._propertyEffects[property] = [];
  }
  return fx;
}, addPropertyEffect:function(model, property, kind, effect) {
  var fx = this.ensurePropertyEffects(model, property);
  var propEffect = {kind:kind, effect:effect, fn:Polymer.Bind["_" + kind + "Effect"]};
  fx.push(propEffect);
  return propEffect;
}, createBindings:function(model) {
  var fx$ = model._propertyEffects;
  if (fx$) {
    for (var n in fx$) {
      var fx = fx$[n];
      fx.sort(this._sortPropertyEffects);
      this._createAccessors(model, n, fx);
    }
  }
}, _sortPropertyEffects:function() {
  var EFFECT_ORDER = {"compute":0, "annotation":1, "annotatedComputation":2, "reflect":3, "notify":4, "observer":5, "complexObserver":6, "function":7};
  return function(a, b) {
    return EFFECT_ORDER[a.kind] - EFFECT_ORDER[b.kind];
  };
}(), _createAccessors:function(model, property, effects) {
  var defun = {get:function() {
    return this.__data__[property];
  }};
  var setter = function(value) {
    this._propertySetter(property, value, effects);
  };
  var info = model.getPropertyInfo && model.getPropertyInfo(property);
  if (info && info.readOnly) {
    if (!info.computed) {
      model["_set" + this.upper(property)] = setter;
    }
  } else {
    defun.set = setter;
  }
  Object.defineProperty(model, property, defun);
}, upper:function(name) {
  return name[0].toUpperCase() + name.substring(1);
}, _addAnnotatedListener:function(model, index, property, path, event, negated) {
  if (!model._bindListeners) {
    model._bindListeners = [];
  }
  var fn = this._notedListenerFactory(property, path, this._isStructured(path), negated);
  var eventName = event || Polymer.CaseMap.camelToDashCase(property) + "-changed";
  model._bindListeners.push({index:index, property:property, path:path, changedFn:fn, event:eventName});
}, _isStructured:function(path) {
  return path.indexOf(".") > 0;
}, _isEventBogus:function(e, target) {
  return e.path && e.path[0] !== target;
}, _notedListenerFactory:function(property, path, isStructured, negated) {
  return function(target, value, targetPath) {
    if (targetPath) {
      this._notifyPath(this._fixPath(path, property, targetPath), value);
    } else {
      value = target[property];
      if (negated) {
        value = !value;
      }
      if (!isStructured) {
        this[path] = value;
      } else {
        if (this.__data__[path] != value) {
          this.set(path, value);
        }
      }
    }
  };
}, prepareInstance:function(inst) {
  inst.__data__ = Object.create(null);
}, setupBindListeners:function(inst) {
  var b$ = inst._bindListeners;
  for (var i = 0, l = b$.length, info; i < l && (info = b$[i]); i++) {
    var node = inst._nodes[info.index];
    this._addNotifyListener(node, inst, info.event, info.changedFn);
  }
}, _addNotifyListener:function(element, context, event, changedFn) {
  element.addEventListener(event, function(e) {
    return context._notifyListener(changedFn, e);
  });
}};
Polymer.Base.extend(Polymer.Bind, {_shouldAddListener:function(effect) {
  return effect.name && effect.kind != "attribute" && effect.kind != "text" && !effect.isCompound && effect.parts[0].mode === "{";
}, _annotationEffect:function(source, value, effect) {
  if (source != effect.value) {
    value = this._get(effect.value);
    this.__data__[effect.value] = value;
  }
  var calc = effect.negate ? !value : value;
  if (!effect.customEvent || this._nodes[effect.index][effect.name] !== calc) {
    return this._applyEffectValue(effect, calc);
  }
}, _reflectEffect:function(source, value, effect) {
  this.reflectPropertyToAttribute(source, effect.attribute, value);
}, _notifyEffect:function(source, value, effect, old, fromAbove) {
  if (!fromAbove) {
    this._notifyChange(source, effect.event, value);
  }
}, _functionEffect:function(source, value, fn, old, fromAbove) {
  fn.call(this, source, value, old, fromAbove);
}, _observerEffect:function(source, value, effect, old) {
  var fn = this[effect.method];
  if (fn) {
    fn.call(this, value, old);
  } else {
    this._warn(this._logf("_observerEffect", "observer method `" + effect.method + "` not defined"));
  }
}, _complexObserverEffect:function(source, value, effect) {
  var fn = this[effect.method];
  if (fn) {
    var args = Polymer.Bind._marshalArgs(this.__data__, effect, source, value);
    if (args) {
      fn.apply(this, args);
    }
  } else {
    if (effect.dynamicFn) {
    } else {
      this._warn(this._logf("_complexObserverEffect", "observer method `" + effect.method + "` not defined"));
    }
  }
}, _computeEffect:function(source, value, effect) {
  var fn = this[effect.method];
  if (fn) {
    var args = Polymer.Bind._marshalArgs(this.__data__, effect, source, value);
    if (args) {
      var computedvalue = fn.apply(this, args);
      this.__setProperty(effect.name, computedvalue);
    }
  } else {
    if (effect.dynamicFn) {
    } else {
      this._warn(this._logf("_computeEffect", "compute method `" + effect.method + "` not defined"));
    }
  }
}, _annotatedComputationEffect:function(source, value, effect) {
  var computedHost = this._rootDataHost || this;
  var fn = computedHost[effect.method];
  if (fn) {
    var args = Polymer.Bind._marshalArgs(this.__data__, effect, source, value);
    if (args) {
      var computedvalue = fn.apply(computedHost, args);
      if (effect.negate) {
        computedvalue = !computedvalue;
      }
      this._applyEffectValue(effect, computedvalue);
    }
  } else {
    if (effect.dynamicFn) {
    } else {
      computedHost._warn(computedHost._logf("_annotatedComputationEffect", "compute method `" + effect.method + "` not defined"));
    }
  }
}, _marshalArgs:function(model, effect, path, value) {
  var values = [];
  var args = effect.args;
  var bailoutEarly = args.length > 1 || effect.dynamicFn;
  for (var i = 0, l = args.length; i < l; i++) {
    var arg = args[i];
    var name = arg.name;
    var v;
    if (arg.literal) {
      v = arg.value;
    } else {
      if (arg.structured) {
        v = Polymer.Base._get(name, model);
      } else {
        v = model[name];
      }
    }
    if (bailoutEarly && v === undefined) {
      return;
    }
    if (arg.wildcard) {
      var baseChanged = name.indexOf(path + ".") === 0;
      var matches = effect.trigger.name.indexOf(name) === 0 && !baseChanged;
      values[i] = {path:matches ? path : name, value:matches ? value : v, base:v};
    } else {
      values[i] = v;
    }
  }
  return values;
}});
Polymer.Base._addFeature({_addPropertyEffect:function(property, kind, effect) {
  var prop = Polymer.Bind.addPropertyEffect(this, property, kind, effect);
  prop.pathFn = this["_" + prop.kind + "PathEffect"];
}, _prepEffects:function() {
  Polymer.Bind.prepareModel(this);
  this._addAnnotationEffects(this._notes);
}, _prepBindings:function() {
  Polymer.Bind.createBindings(this);
}, _addPropertyEffects:function(properties) {
  if (properties) {
    for (var p in properties) {
      var prop = properties[p];
      if (prop.observer) {
        this._addObserverEffect(p, prop.observer);
      }
      if (prop.computed) {
        prop.readOnly = true;
        this._addComputedEffect(p, prop.computed);
      }
      if (prop.notify) {
        this._addPropertyEffect(p, "notify", {event:Polymer.CaseMap.camelToDashCase(p) + "-changed"});
      }
      if (prop.reflectToAttribute) {
        var attr = Polymer.CaseMap.camelToDashCase(p);
        if (attr[0] === "-") {
          this._warn(this._logf("_addPropertyEffects", "Property " + p + " cannot be reflected to attribute " + attr + ' because "-" is not a valid starting attribute name. Use a lowercase first letter for the property instead.'));
        } else {
          this._addPropertyEffect(p, "reflect", {attribute:attr});
        }
      }
      if (prop.readOnly) {
        Polymer.Bind.ensurePropertyEffects(this, p);
      }
    }
  }
}, _addComputedEffect:function(name, expression) {
  var sig = this._parseMethod(expression);
  var dynamicFn = sig.dynamicFn;
  for (var i = 0, arg; i < sig.args.length && (arg = sig.args[i]); i++) {
    this._addPropertyEffect(arg.model, "compute", {method:sig.method, args:sig.args, trigger:arg, name:name, dynamicFn:dynamicFn});
  }
  if (dynamicFn) {
    this._addPropertyEffect(sig.method, "compute", {method:sig.method, args:sig.args, trigger:null, name:name, dynamicFn:dynamicFn});
  }
}, _addObserverEffect:function(property, observer) {
  this._addPropertyEffect(property, "observer", {method:observer, property:property});
}, _addComplexObserverEffects:function(observers) {
  if (observers) {
    for (var i = 0, o; i < observers.length && (o = observers[i]); i++) {
      this._addComplexObserverEffect(o);
    }
  }
}, _addComplexObserverEffect:function(observer) {
  var sig = this._parseMethod(observer);
  if (!sig) {
    throw new Error("Malformed observer expression '" + observer + "'");
  }
  var dynamicFn = sig.dynamicFn;
  for (var i = 0, arg; i < sig.args.length && (arg = sig.args[i]); i++) {
    this._addPropertyEffect(arg.model, "complexObserver", {method:sig.method, args:sig.args, trigger:arg, dynamicFn:dynamicFn});
  }
  if (dynamicFn) {
    this._addPropertyEffect(sig.method, "complexObserver", {method:sig.method, args:sig.args, trigger:null, dynamicFn:dynamicFn});
  }
}, _addAnnotationEffects:function(notes) {
  for (var i = 0, note; i < notes.length && (note = notes[i]); i++) {
    var b$ = note.bindings;
    for (var j = 0, binding; j < b$.length && (binding = b$[j]); j++) {
      this._addAnnotationEffect(binding, i);
    }
  }
}, _addAnnotationEffect:function(note, index) {
  if (Polymer.Bind._shouldAddListener(note)) {
    Polymer.Bind._addAnnotatedListener(this, index, note.name, note.parts[0].value, note.parts[0].event, note.parts[0].negate);
  }
  for (var i = 0; i < note.parts.length; i++) {
    var part = note.parts[i];
    if (part.signature) {
      this._addAnnotatedComputationEffect(note, part, index);
    } else {
      if (!part.literal) {
        if (note.kind === "attribute" && note.name[0] === "-") {
          this._warn(this._logf("_addAnnotationEffect", "Cannot set attribute " + note.name + ' because "-" is not a valid attribute starting character'));
        } else {
          this._addPropertyEffect(part.model, "annotation", {kind:note.kind, index:index, name:note.name, propertyName:note.propertyName, value:part.value, isCompound:note.isCompound, compoundIndex:part.compoundIndex, event:part.event, customEvent:part.customEvent, negate:part.negate});
        }
      }
    }
  }
}, _addAnnotatedComputationEffect:function(note, part, index) {
  var sig = part.signature;
  if (sig.static) {
    this.__addAnnotatedComputationEffect("__static__", index, note, part, null);
  } else {
    for (var i = 0, arg; i < sig.args.length && (arg = sig.args[i]); i++) {
      if (!arg.literal) {
        this.__addAnnotatedComputationEffect(arg.model, index, note, part, arg);
      }
    }
    if (sig.dynamicFn) {
      this.__addAnnotatedComputationEffect(sig.method, index, note, part, null);
    }
  }
}, __addAnnotatedComputationEffect:function(property, index, note, part, trigger) {
  this._addPropertyEffect(property, "annotatedComputation", {index:index, isCompound:note.isCompound, compoundIndex:part.compoundIndex, kind:note.kind, name:note.name, negate:part.negate, method:part.signature.method, args:part.signature.args, trigger:trigger, dynamicFn:part.signature.dynamicFn});
}, _parseMethod:function(expression) {
  var m = expression.match(/([^\s]+?)\(([\s\S]*)\)/);
  if (m) {
    var sig = {method:m[1], static:true};
    if (this.getPropertyInfo(sig.method) !== Polymer.nob) {
      sig.static = false;
      sig.dynamicFn = true;
    }
    if (m[2].trim()) {
      var args = m[2].replace(/\\,/g, "&comma;").split(",");
      return this._parseArgs(args, sig);
    } else {
      sig.args = Polymer.nar;
      return sig;
    }
  }
}, _parseArgs:function(argList, sig) {
  sig.args = argList.map(function(rawArg) {
    var arg = this._parseArg(rawArg);
    if (!arg.literal) {
      sig.static = false;
    }
    return arg;
  }, this);
  return sig;
}, _parseArg:function(rawArg) {
  var arg = rawArg.trim().replace(/&comma;/g, ",").replace(/\\(.)/g, "$1");
  var a = {name:arg};
  var fc = arg[0];
  if (fc === "-") {
    fc = arg[1];
  }
  if (fc >= "0" && fc <= "9") {
    fc = "#";
  }
  switch(fc) {
    case "'":
    case '"':
      a.value = arg.slice(1, -1);
      a.literal = true;
      break;
    case "#":
      a.value = Number(arg);
      a.literal = true;
      break;
  }
  if (!a.literal) {
    a.model = this._modelForPath(arg);
    a.structured = arg.indexOf(".") > 0;
    if (a.structured) {
      a.wildcard = arg.slice(-2) == ".*";
      if (a.wildcard) {
        a.name = arg.slice(0, -2);
      }
    }
  }
  return a;
}, _marshalInstanceEffects:function() {
  Polymer.Bind.prepareInstance(this);
  if (this._bindListeners) {
    Polymer.Bind.setupBindListeners(this);
  }
}, _applyEffectValue:function(info, value) {
  var node = this._nodes[info.index];
  var property = info.name;
  if (info.isCompound) {
    var storage = node.__compoundStorage__[property];
    storage[info.compoundIndex] = value;
    value = storage.join("");
  }
  if (info.kind == "attribute") {
    this.serializeValueToAttribute(value, property, node);
  } else {
    if (property === "className") {
      value = this._scopeElementClass(node, value);
    }
    if (property === "textContent" || node.localName == "input" && property == "value") {
      value = value == undefined ? "" : value;
    }
    var pinfo;
    if (!node._propertyInfo || !(pinfo = node._propertyInfo[property]) || !pinfo.readOnly) {
      this.__setProperty(property, value, false, node);
    }
  }
}, _executeStaticEffects:function() {
  if (this._propertyEffects && this._propertyEffects.__static__) {
    this._effectEffects("__static__", null, this._propertyEffects.__static__);
  }
}});
(function() {
  var usePolyfillProto = Polymer.Settings.usePolyfillProto;
  Polymer.Base._addFeature({_setupConfigure:function(initialConfig) {
    this._config = {};
    this._handlers = [];
    this._aboveConfig = null;
    if (initialConfig) {
      for (var i in initialConfig) {
        if (initialConfig[i] !== undefined) {
          this._config[i] = initialConfig[i];
        }
      }
    }
  }, _marshalAttributes:function() {
    this._takeAttributesToModel(this._config);
  }, _attributeChangedImpl:function(name) {
    var model = this._clientsReadied ? this : this._config;
    this._setAttributeToProperty(model, name);
  }, _configValue:function(name, value) {
    var info = this._propertyInfo[name];
    if (!info || !info.readOnly) {
      this._config[name] = value;
    }
  }, _beforeClientsReady:function() {
    this._configure();
  }, _configure:function() {
    this._configureAnnotationReferences();
    this._aboveConfig = this.mixin({}, this._config);
    var config = {};
    for (var i = 0; i < this.behaviors.length; i++) {
      this._configureProperties(this.behaviors[i].properties, config);
    }
    this._configureProperties(this.properties, config);
    this.mixin(config, this._aboveConfig);
    this._config = config;
    if (this._clients && this._clients.length) {
      this._distributeConfig(this._config);
    }
  }, _configureProperties:function(properties, config) {
    for (var i in properties) {
      var c = properties[i];
      if (!usePolyfillProto && this.hasOwnProperty(i) && this._propertyEffects && this._propertyEffects[i]) {
        config[i] = this[i];
        delete this[i];
      } else {
        if (c.value !== undefined) {
          var value = c.value;
          if (typeof value == "function") {
            value = value.call(this, this._config);
          }
          config[i] = value;
        }
      }
    }
  }, _distributeConfig:function(config) {
    var fx$ = this._propertyEffects;
    if (fx$) {
      for (var p in config) {
        var fx = fx$[p];
        if (fx) {
          for (var i = 0, l = fx.length, x; i < l && (x = fx[i]); i++) {
            if (x.kind === "annotation" && !x.isCompound) {
              var node = this._nodes[x.effect.index];
              var name = x.effect.propertyName;
              var isAttr = x.effect.kind == "attribute";
              var hasEffect = node._propertyEffects && node._propertyEffects[name];
              if (node._configValue && (hasEffect || !isAttr)) {
                var value = p === x.effect.value ? config[p] : this._get(x.effect.value, config);
                if (isAttr) {
                  value = node.deserialize(this.serialize(value), node._propertyInfo[name].type);
                }
                node._configValue(name, value);
              }
            }
          }
        }
      }
    }
  }, _afterClientsReady:function() {
    this._executeStaticEffects();
    this._applyConfig(this._config, this._aboveConfig);
    this._flushHandlers();
  }, _applyConfig:function(config, aboveConfig) {
    for (var n in config) {
      if (this[n] === undefined) {
        this.__setProperty(n, config[n], n in aboveConfig);
      }
    }
  }, _notifyListener:function(fn, e) {
    if (!Polymer.Bind._isEventBogus(e, e.target)) {
      var value, path;
      if (e.detail) {
        value = e.detail.value;
        path = e.detail.path;
      }
      if (!this._clientsReadied) {
        this._queueHandler([fn, e.target, value, path]);
      } else {
        return fn.call(this, e.target, value, path);
      }
    }
  }, _queueHandler:function(args) {
    this._handlers.push(args);
  }, _flushHandlers:function() {
    var h$ = this._handlers;
    for (var i = 0, l = h$.length, h; i < l && (h = h$[i]); i++) {
      h[0].call(this, h[1], h[2], h[3]);
    }
    this._handlers = [];
  }});
})();
(function() {
  Polymer.Base._addFeature({notifyPath:function(path, value, fromAbove) {
    var info = {};
    this._get(path, this, info);
    if (info.path) {
      this._notifyPath(info.path, value, fromAbove);
    }
  }, _notifyPath:function(path, value, fromAbove) {
    var old = this._propertySetter(path, value);
    if (old !== value && (old === old || value === value)) {
      this._pathEffector(path, value);
      if (!fromAbove) {
        this._notifyPathUp(path, value);
      }
      return true;
    }
  }, _getPathParts:function(path) {
    if (Array.isArray(path)) {
      var parts = [];
      for (var i = 0; i < path.length; i++) {
        var args = path[i].toString().split(".");
        for (var j = 0; j < args.length; j++) {
          parts.push(args[j]);
        }
      }
      return parts;
    } else {
      return path.toString().split(".");
    }
  }, set:function(path, value, root) {
    var prop = root || this;
    var parts = this._getPathParts(path);
    var array;
    var last = parts[parts.length - 1];
    if (parts.length > 1) {
      for (var i = 0; i < parts.length - 1; i++) {
        var part = parts[i];
        if (array && part[0] == "#") {
          prop = Polymer.Collection.get(array).getItem(part);
        } else {
          prop = prop[part];
          if (array && parseInt(part, 10) == part) {
            parts[i] = Polymer.Collection.get(array).getKey(prop);
          }
        }
        if (!prop) {
          return;
        }
        array = Array.isArray(prop) ? prop : null;
      }
      if (array) {
        var coll = Polymer.Collection.get(array);
        var old, key;
        if (last[0] == "#") {
          key = last;
          old = coll.getItem(key);
          last = array.indexOf(old);
          coll.setItem(key, value);
        } else {
          if (parseInt(last, 10) == last) {
            old = prop[last];
            key = coll.getKey(old);
            parts[i] = key;
            coll.setItem(key, value);
          }
        }
      }
      prop[last] = value;
      if (!root) {
        this._notifyPath(parts.join("."), value);
      }
    } else {
      prop[path] = value;
    }
  }, get:function(path, root) {
    return this._get(path, root);
  }, _get:function(path, root, info) {
    var prop = root || this;
    var parts = this._getPathParts(path);
    var array;
    for (var i = 0; i < parts.length; i++) {
      if (!prop) {
        return;
      }
      var part = parts[i];
      if (array && part[0] == "#") {
        prop = Polymer.Collection.get(array).getItem(part);
      } else {
        prop = prop[part];
        if (info && array && parseInt(part, 10) == part) {
          parts[i] = Polymer.Collection.get(array).getKey(prop);
        }
      }
      array = Array.isArray(prop) ? prop : null;
    }
    if (info) {
      info.path = parts.join(".");
    }
    return prop;
  }, _pathEffector:function(path, value) {
    var model = this._modelForPath(path);
    var fx$ = this._propertyEffects && this._propertyEffects[model];
    if (fx$) {
      for (var i = 0, fx; i < fx$.length && (fx = fx$[i]); i++) {
        var fxFn = fx.pathFn;
        if (fxFn) {
          fxFn.call(this, path, value, fx.effect);
        }
      }
    }
    if (this._boundPaths) {
      this._notifyBoundPaths(path, value);
    }
  }, _annotationPathEffect:function(path, value, effect) {
    if (effect.value === path || effect.value.indexOf(path + ".") === 0) {
      Polymer.Bind._annotationEffect.call(this, path, value, effect);
    } else {
      if (path.indexOf(effect.value + ".") === 0 && !effect.negate) {
        var node = this._nodes[effect.index];
        if (node && node._notifyPath) {
          var p = this._fixPath(effect.name, effect.value, path);
          node._notifyPath(p, value, true);
        }
      }
    }
  }, _complexObserverPathEffect:function(path, value, effect) {
    if (this._pathMatchesEffect(path, effect)) {
      Polymer.Bind._complexObserverEffect.call(this, path, value, effect);
    }
  }, _computePathEffect:function(path, value, effect) {
    if (this._pathMatchesEffect(path, effect)) {
      Polymer.Bind._computeEffect.call(this, path, value, effect);
    }
  }, _annotatedComputationPathEffect:function(path, value, effect) {
    if (this._pathMatchesEffect(path, effect)) {
      Polymer.Bind._annotatedComputationEffect.call(this, path, value, effect);
    }
  }, _pathMatchesEffect:function(path, effect) {
    var effectArg = effect.trigger.name;
    return effectArg == path || effectArg.indexOf(path + ".") === 0 || effect.trigger.wildcard && path.indexOf(effectArg) === 0;
  }, linkPaths:function(to, from) {
    this._boundPaths = this._boundPaths || {};
    if (from) {
      this._boundPaths[to] = from;
    } else {
      this.unlinkPaths(to);
    }
  }, unlinkPaths:function(path) {
    if (this._boundPaths) {
      delete this._boundPaths[path];
    }
  }, _notifyBoundPaths:function(path, value) {
    for (var a in this._boundPaths) {
      var b = this._boundPaths[a];
      if (path.indexOf(a + ".") == 0) {
        this._notifyPath(this._fixPath(b, a, path), value);
      } else {
        if (path.indexOf(b + ".") == 0) {
          this._notifyPath(this._fixPath(a, b, path), value);
        }
      }
    }
  }, _fixPath:function(property, root, path) {
    return property + path.slice(root.length);
  }, _notifyPathUp:function(path, value) {
    var rootName = this._modelForPath(path);
    var dashCaseName = Polymer.CaseMap.camelToDashCase(rootName);
    var eventName = dashCaseName + this._EVENT_CHANGED;
    this.fire(eventName, {path:path, value:value}, {bubbles:false, _useCache:true});
  }, _modelForPath:function(path) {
    var dot = path.indexOf(".");
    return dot < 0 ? path : path.slice(0, dot);
  }, _EVENT_CHANGED:"-changed", notifySplices:function(path, splices) {
    var info = {};
    var array = this._get(path, this, info);
    this._notifySplices(array, info.path, splices);
  }, _notifySplices:function(array, path, splices) {
    var change = {keySplices:Polymer.Collection.applySplices(array, splices), indexSplices:splices};
    if (!array.hasOwnProperty("splices")) {
      Object.defineProperty(array, "splices", {configurable:true, writable:true});
    }
    array.splices = change;
    this._notifyPath(path + ".splices", change);
    this._notifyPath(path + ".length", array.length);
    change.keySplices = null;
    change.indexSplices = null;
  }, _notifySplice:function(array, path, index, added, removed) {
    this._notifySplices(array, path, [{index:index, addedCount:added, removed:removed, object:array, type:"splice"}]);
  }, push:function(path) {
    var info = {};
    var array = this._get(path, this, info);
    var args = Array.prototype.slice.call(arguments, 1);
    var len = array.length;
    var ret = array.push.apply(array, args);
    if (args.length) {
      this._notifySplice(array, info.path, len, args.length, []);
    }
    return ret;
  }, pop:function(path) {
    var info = {};
    var array = this._get(path, this, info);
    var hadLength = Boolean(array.length);
    var args = Array.prototype.slice.call(arguments, 1);
    var ret = array.pop.apply(array, args);
    if (hadLength) {
      this._notifySplice(array, info.path, array.length, 0, [ret]);
    }
    return ret;
  }, splice:function(path, start) {
    var info = {};
    var array = this._get(path, this, info);
    if (start < 0) {
      start = array.length - Math.floor(-start);
    } else {
      start = Math.floor(start);
    }
    if (!start) {
      start = 0;
    }
    var args = Array.prototype.slice.call(arguments, 1);
    var ret = array.splice.apply(array, args);
    var addedCount = Math.max(args.length - 2, 0);
    if (addedCount || ret.length) {
      this._notifySplice(array, info.path, start, addedCount, ret);
    }
    return ret;
  }, shift:function(path) {
    var info = {};
    var array = this._get(path, this, info);
    var hadLength = Boolean(array.length);
    var args = Array.prototype.slice.call(arguments, 1);
    var ret = array.shift.apply(array, args);
    if (hadLength) {
      this._notifySplice(array, info.path, 0, 0, [ret]);
    }
    return ret;
  }, unshift:function(path) {
    var info = {};
    var array = this._get(path, this, info);
    var args = Array.prototype.slice.call(arguments, 1);
    var ret = array.unshift.apply(array, args);
    if (args.length) {
      this._notifySplice(array, info.path, 0, args.length, []);
    }
    return ret;
  }, prepareModelNotifyPath:function(model) {
    this.mixin(model, {fire:Polymer.Base.fire, _getEvent:Polymer.Base._getEvent, __eventCache:Polymer.Base.__eventCache, notifyPath:Polymer.Base.notifyPath, _get:Polymer.Base._get, _EVENT_CHANGED:Polymer.Base._EVENT_CHANGED, _notifyPath:Polymer.Base._notifyPath, _notifyPathUp:Polymer.Base._notifyPathUp, _pathEffector:Polymer.Base._pathEffector, _annotationPathEffect:Polymer.Base._annotationPathEffect, _complexObserverPathEffect:Polymer.Base._complexObserverPathEffect, _annotatedComputationPathEffect:Polymer.Base._annotatedComputationPathEffect, 
    _computePathEffect:Polymer.Base._computePathEffect, _modelForPath:Polymer.Base._modelForPath, _pathMatchesEffect:Polymer.Base._pathMatchesEffect, _notifyBoundPaths:Polymer.Base._notifyBoundPaths, _getPathParts:Polymer.Base._getPathParts});
  }});
})();
Polymer.Base._addFeature({resolveUrl:function(url) {
  var module = Polymer.DomModule.import(this.is);
  var root = "";
  if (module) {
    var assetPath = module.getAttribute("assetpath") || "";
    root = Polymer.ResolveUrl.resolveUrl(assetPath, module.ownerDocument.baseURI);
  }
  return Polymer.ResolveUrl.resolveUrl(url, root);
}});
Polymer.CssParse = function() {
  return {parse:function(text) {
    text = this._clean(text);
    return this._parseCss(this._lex(text), text);
  }, _clean:function(cssText) {
    return cssText.replace(this._rx.comments, "").replace(this._rx.port, "");
  }, _lex:function(text) {
    var root = {start:0, end:text.length};
    var n = root;
    for (var i = 0, l = text.length; i < l; i++) {
      switch(text[i]) {
        case this.OPEN_BRACE:
          if (!n.rules) {
            n.rules = [];
          }
          var p = n;
          var previous = p.rules[p.rules.length - 1];
          n = {start:i + 1, parent:p, previous:previous};
          p.rules.push(n);
          break;
        case this.CLOSE_BRACE:
          n.end = i + 1;
          n = n.parent || root;
          break;
      }
    }
    return root;
  }, _parseCss:function(node, text) {
    var t = text.substring(node.start, node.end - 1);
    node.parsedCssText = node.cssText = t.trim();
    if (node.parent) {
      var ss = node.previous ? node.previous.end : node.parent.start;
      t = text.substring(ss, node.start - 1);
      t = this._expandUnicodeEscapes(t);
      t = t.replace(this._rx.multipleSpaces, " ");
      t = t.substring(t.lastIndexOf(";") + 1);
      var s = node.parsedSelector = node.selector = t.trim();
      node.atRule = s.indexOf(this.AT_START) === 0;
      if (node.atRule) {
        if (s.indexOf(this.MEDIA_START) === 0) {
          node.type = this.types.MEDIA_RULE;
        } else {
          if (s.match(this._rx.keyframesRule)) {
            node.type = this.types.KEYFRAMES_RULE;
            node.keyframesName = node.selector.split(this._rx.multipleSpaces).pop();
          }
        }
      } else {
        if (s.indexOf(this.VAR_START) === 0) {
          node.type = this.types.MIXIN_RULE;
        } else {
          node.type = this.types.STYLE_RULE;
        }
      }
    }
    var r$ = node.rules;
    if (r$) {
      for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
        this._parseCss(r, text);
      }
    }
    return node;
  }, _expandUnicodeEscapes:function(s) {
    return s.replace(/\\([0-9a-f]{1,6})\s/gi, function() {
      var code = arguments[1], repeat = 6 - code.length;
      while (repeat--) {
        code = "0" + code;
      }
      return "\\" + code;
    });
  }, stringify:function(node, preserveProperties, text) {
    text = text || "";
    var cssText = "";
    if (node.cssText || node.rules) {
      var r$ = node.rules;
      if (r$ && (preserveProperties || !this._hasMixinRules(r$))) {
        for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
          cssText = this.stringify(r, preserveProperties, cssText);
        }
      } else {
        cssText = preserveProperties ? node.cssText : this.removeCustomProps(node.cssText);
        cssText = cssText.trim();
        if (cssText) {
          cssText = "  " + cssText + "\n";
        }
      }
    }
    if (cssText) {
      if (node.selector) {
        text += node.selector + " " + this.OPEN_BRACE + "\n";
      }
      text += cssText;
      if (node.selector) {
        text += this.CLOSE_BRACE + "\n\n";
      }
    }
    return text;
  }, _hasMixinRules:function(rules) {
    return rules[0].selector.indexOf(this.VAR_START) === 0;
  }, removeCustomProps:function(cssText) {
    cssText = this.removeCustomPropAssignment(cssText);
    return this.removeCustomPropApply(cssText);
  }, removeCustomPropAssignment:function(cssText) {
    return cssText.replace(this._rx.customProp, "").replace(this._rx.mixinProp, "");
  }, removeCustomPropApply:function(cssText) {
    return cssText.replace(this._rx.mixinApply, "").replace(this._rx.varApply, "");
  }, types:{STYLE_RULE:1, KEYFRAMES_RULE:7, MEDIA_RULE:4, MIXIN_RULE:1000}, OPEN_BRACE:"{", CLOSE_BRACE:"}", _rx:{comments:/\/\*[^*]*\*+([^\/*][^*]*\*+)*\//gim, port:/@import[^;]*;/gim, customProp:/(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?(?:[;\n]|$)/gim, mixinProp:/(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?{[^}]*?}(?:[;\n]|$)?/gim, mixinApply:/@apply[\s]*\([^)]*?\)[\s]*(?:[;\n]|$)?/gim, varApply:/[^;:]*?:[^;]*?var\([^;]*\)(?:[;\n]|$)?/gim, keyframesRule:/^@[^\s]*keyframes/, multipleSpaces:/\s+/g}, VAR_START:"--", 
  MEDIA_START:"@media", AT_START:"@"};
}();
Polymer.StyleUtil = function() {
  return {MODULE_STYLES_SELECTOR:"style, link[rel=import][type~=css], template", INCLUDE_ATTR:"include", toCssText:function(rules, callback, preserveProperties) {
    if (typeof rules === "string") {
      rules = this.parser.parse(rules);
    }
    if (callback) {
      this.forEachRule(rules, callback);
    }
    return this.parser.stringify(rules, preserveProperties);
  }, forRulesInStyles:function(styles, styleRuleCallback, keyframesRuleCallback) {
    if (styles) {
      for (var i = 0, l = styles.length, s; i < l && (s = styles[i]); i++) {
        this.forEachRule(this.rulesForStyle(s), styleRuleCallback, keyframesRuleCallback);
      }
    }
  }, rulesForStyle:function(style) {
    if (!style.__cssRules && style.textContent) {
      style.__cssRules = this.parser.parse(style.textContent);
    }
    return style.__cssRules;
  }, isKeyframesSelector:function(rule) {
    return rule.parent && rule.parent.type === this.ruleTypes.KEYFRAMES_RULE;
  }, forEachRule:function(node, styleRuleCallback, keyframesRuleCallback) {
    if (!node) {
      return;
    }
    var skipRules = false;
    if (node.type === this.ruleTypes.STYLE_RULE) {
      styleRuleCallback(node);
    } else {
      if (keyframesRuleCallback && node.type === this.ruleTypes.KEYFRAMES_RULE) {
        keyframesRuleCallback(node);
      } else {
        if (node.type === this.ruleTypes.MIXIN_RULE) {
          skipRules = true;
        }
      }
    }
    var r$ = node.rules;
    if (r$ && !skipRules) {
      for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
        this.forEachRule(r, styleRuleCallback, keyframesRuleCallback);
      }
    }
  }, applyCss:function(cssText, moniker, target, contextNode) {
    var style = this.createScopeStyle(cssText, moniker);
    target = target || document.head;
    var after = contextNode && contextNode.nextSibling || target.firstChild;
    this.__lastHeadApplyNode = style;
    return target.insertBefore(style, after);
  }, createScopeStyle:function(cssText, moniker) {
    var style = document.createElement("style");
    if (moniker) {
      style.setAttribute("scope", moniker);
    }
    style.textContent = cssText;
    return style;
  }, __lastHeadApplyNode:null, applyStylePlaceHolder:function(moniker) {
    var placeHolder = document.createComment(" Shady DOM styles for " + moniker + " ");
    var after = this.__lastHeadApplyNode ? this.__lastHeadApplyNode.nextSibling : null;
    var scope = document.head;
    scope.insertBefore(placeHolder, after || scope.firstChild);
    this.__lastHeadApplyNode = placeHolder;
    return placeHolder;
  }, cssFromModules:function(moduleIds, warnIfNotFound) {
    var modules = moduleIds.trim().split(" ");
    var cssText = "";
    for (var i = 0; i < modules.length; i++) {
      cssText += this.cssFromModule(modules[i], warnIfNotFound);
    }
    return cssText;
  }, cssFromModule:function(moduleId, warnIfNotFound) {
    var m = Polymer.DomModule.import(moduleId);
    if (m && !m._cssText) {
      m._cssText = this.cssFromElement(m);
    }
    if (!m && warnIfNotFound) {
      console.warn("Could not find style data in module named", moduleId);
    }
    return m && m._cssText || "";
  }, cssFromElement:function(element) {
    var cssText = "";
    var content = element.content || element;
    var e$ = Polymer.TreeApi.arrayCopy(content.querySelectorAll(this.MODULE_STYLES_SELECTOR));
    for (var i = 0, e; i < e$.length; i++) {
      e = e$[i];
      if (e.localName === "template") {
        cssText += this.cssFromElement(e);
      } else {
        if (e.localName === "style") {
          var include = e.getAttribute(this.INCLUDE_ATTR);
          if (include) {
            cssText += this.cssFromModules(include, true);
          }
          e = e.__appliedElement || e;
          e.parentNode.removeChild(e);
          cssText += this.resolveCss(e.textContent, element.ownerDocument);
        } else {
          if (e.import && e.import.body) {
            cssText += this.resolveCss(e.import.body.textContent, e.import);
          }
        }
      }
    }
    return cssText;
  }, resolveCss:Polymer.ResolveUrl.resolveCss, parser:Polymer.CssParse, ruleTypes:Polymer.CssParse.types};
}();
Polymer.StyleTransformer = function() {
  var nativeShadow = Polymer.Settings.useNativeShadow;
  var styleUtil = Polymer.StyleUtil;
  var api = {dom:function(node, scope, useAttr, shouldRemoveScope) {
    this._transformDom(node, scope || "", useAttr, shouldRemoveScope);
  }, _transformDom:function(node, selector, useAttr, shouldRemoveScope) {
    if (node.setAttribute) {
      this.element(node, selector, useAttr, shouldRemoveScope);
    }
    var c$ = Polymer.dom(node).childNodes;
    for (var i = 0; i < c$.length; i++) {
      this._transformDom(c$[i], selector, useAttr, shouldRemoveScope);
    }
  }, element:function(element, scope, useAttr, shouldRemoveScope) {
    if (useAttr) {
      if (shouldRemoveScope) {
        element.removeAttribute(SCOPE_NAME);
      } else {
        element.setAttribute(SCOPE_NAME, scope);
      }
    } else {
      if (scope) {
        if (element.classList) {
          if (shouldRemoveScope) {
            element.classList.remove(SCOPE_NAME);
            element.classList.remove(scope);
          } else {
            element.classList.add(SCOPE_NAME);
            element.classList.add(scope);
          }
        } else {
          if (element.getAttribute) {
            var c = element.getAttribute(CLASS);
            if (shouldRemoveScope) {
              if (c) {
                element.setAttribute(CLASS, c.replace(SCOPE_NAME, "").replace(scope, ""));
              }
            } else {
              element.setAttribute(CLASS, (c ? c + " " : "") + SCOPE_NAME + " " + scope);
            }
          }
        }
      }
    }
  }, elementStyles:function(element, callback) {
    var styles = element._styles;
    var cssText = "";
    for (var i = 0, l = styles.length, s; i < l && (s = styles[i]); i++) {
      var rules = styleUtil.rulesForStyle(s);
      cssText += nativeShadow ? styleUtil.toCssText(rules, callback) : this.css(rules, element.is, element.extends, callback, element._scopeCssViaAttr) + "\n\n";
    }
    return cssText.trim();
  }, css:function(rules, scope, ext, callback, useAttr) {
    var hostScope = this._calcHostScope(scope, ext);
    scope = this._calcElementScope(scope, useAttr);
    var self = this;
    return styleUtil.toCssText(rules, function(rule) {
      if (!rule.isScoped) {
        self.rule(rule, scope, hostScope);
        rule.isScoped = true;
      }
      if (callback) {
        callback(rule, scope, hostScope);
      }
    });
  }, _calcElementScope:function(scope, useAttr) {
    if (scope) {
      return useAttr ? CSS_ATTR_PREFIX + scope + CSS_ATTR_SUFFIX : CSS_CLASS_PREFIX + scope;
    } else {
      return "";
    }
  }, _calcHostScope:function(scope, ext) {
    return ext ? "[is=" + scope + "]" : scope;
  }, rule:function(rule, scope, hostScope) {
    this._transformRule(rule, this._transformComplexSelector, scope, hostScope);
  }, _transformRule:function(rule, transformer, scope, hostScope) {
    var p$ = rule.selector.split(COMPLEX_SELECTOR_SEP);
    if (!styleUtil.isKeyframesSelector(rule)) {
      for (var i = 0, l = p$.length, p; i < l && (p = p$[i]); i++) {
        p$[i] = transformer.call(this, p, scope, hostScope);
      }
    }
    rule.selector = rule.transformedSelector = p$.join(COMPLEX_SELECTOR_SEP);
  }, _transformComplexSelector:function(selector, scope, hostScope) {
    var stop = false;
    var hostContext = false;
    var self = this;
    selector = selector.replace(CONTENT_START, HOST + " $1");
    selector = selector.replace(SIMPLE_SELECTOR_SEP, function(m, c, s) {
      if (!stop) {
        var info = self._transformCompoundSelector(s, c, scope, hostScope);
        stop = stop || info.stop;
        hostContext = hostContext || info.hostContext;
        c = info.combinator;
        s = info.value;
      } else {
        s = s.replace(SCOPE_JUMP, " ");
      }
      return c + s;
    });
    if (hostContext) {
      selector = selector.replace(HOST_CONTEXT_PAREN, function(m, pre, paren, post) {
        return pre + paren + " " + hostScope + post + COMPLEX_SELECTOR_SEP + " " + pre + hostScope + paren + post;
      });
    }
    return selector;
  }, _transformCompoundSelector:function(selector, combinator, scope, hostScope) {
    var jumpIndex = selector.search(SCOPE_JUMP);
    var hostContext = false;
    if (selector.indexOf(HOST_CONTEXT) >= 0) {
      hostContext = true;
    } else {
      if (selector.indexOf(HOST) >= 0) {
        selector = selector.replace(HOST_PAREN, function(m, host, paren) {
          return hostScope + paren;
        });
        selector = selector.replace(HOST, hostScope);
      } else {
        if (jumpIndex !== 0) {
          selector = scope ? this._transformSimpleSelector(selector, scope) : selector;
        }
      }
    }
    if (selector.indexOf(CONTENT) >= 0) {
      combinator = "";
    }
    var stop;
    if (jumpIndex >= 0) {
      selector = selector.replace(SCOPE_JUMP, " ");
      stop = true;
    }
    return {value:selector, combinator:combinator, stop:stop, hostContext:hostContext};
  }, _transformSimpleSelector:function(selector, scope) {
    var p$ = selector.split(PSEUDO_PREFIX);
    p$[0] += scope;
    return p$.join(PSEUDO_PREFIX);
  }, documentRule:function(rule) {
    rule.selector = rule.parsedSelector;
    this.normalizeRootSelector(rule);
    if (!nativeShadow) {
      this._transformRule(rule, this._transformDocumentSelector);
    }
  }, normalizeRootSelector:function(rule) {
    if (rule.selector === ROOT) {
      rule.selector = "body";
    }
  }, _transformDocumentSelector:function(selector) {
    return selector.match(SCOPE_JUMP) ? this._transformComplexSelector(selector, SCOPE_DOC_SELECTOR) : this._transformSimpleSelector(selector.trim(), SCOPE_DOC_SELECTOR);
  }, SCOPE_NAME:"style-scope"};
  var SCOPE_NAME = api.SCOPE_NAME;
  var SCOPE_DOC_SELECTOR = ":not([" + SCOPE_NAME + "])" + ":not(." + SCOPE_NAME + ")";
  var COMPLEX_SELECTOR_SEP = ",";
  var SIMPLE_SELECTOR_SEP = /(^|[\s>+~]+)((?:\[.+?\]|[^\s>+~=\[])+)/g;
  var HOST = ":host";
  var ROOT = ":root";
  var HOST_PAREN = /(:host)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))/g;
  var HOST_CONTEXT = ":host-context";
  var HOST_CONTEXT_PAREN = /(.*)(?::host-context)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))(.*)/;
  var CONTENT = "::content";
  var SCOPE_JUMP = /::content|::shadow|\/deep\//;
  var CSS_CLASS_PREFIX = ".";
  var CSS_ATTR_PREFIX = "[" + SCOPE_NAME + "~=";
  var CSS_ATTR_SUFFIX = "]";
  var PSEUDO_PREFIX = ":";
  var CLASS = "class";
  var CONTENT_START = new RegExp("^(" + CONTENT + ")");
  return api;
}();
Polymer.StyleExtends = function() {
  var styleUtil = Polymer.StyleUtil;
  return {hasExtends:function(cssText) {
    return Boolean(cssText.match(this.rx.EXTEND));
  }, transform:function(style) {
    var rules = styleUtil.rulesForStyle(style);
    var self = this;
    styleUtil.forEachRule(rules, function(rule) {
      self._mapRuleOntoParent(rule);
      if (rule.parent) {
        var m;
        while (m = self.rx.EXTEND.exec(rule.cssText)) {
          var extend = m[1];
          var extendor = self._findExtendor(extend, rule);
          if (extendor) {
            self._extendRule(rule, extendor);
          }
        }
      }
      rule.cssText = rule.cssText.replace(self.rx.EXTEND, "");
    });
    return styleUtil.toCssText(rules, function(rule) {
      if (rule.selector.match(self.rx.STRIP)) {
        rule.cssText = "";
      }
    }, true);
  }, _mapRuleOntoParent:function(rule) {
    if (rule.parent) {
      var map = rule.parent.map || (rule.parent.map = {});
      var parts = rule.selector.split(",");
      for (var i = 0, p; i < parts.length; i++) {
        p = parts[i];
        map[p.trim()] = rule;
      }
      return map;
    }
  }, _findExtendor:function(extend, rule) {
    return rule.parent && rule.parent.map && rule.parent.map[extend] || this._findExtendor(extend, rule.parent);
  }, _extendRule:function(target, source) {
    if (target.parent !== source.parent) {
      this._cloneAndAddRuleToParent(source, target.parent);
    }
    target.extends = target.extends || [];
    target.extends.push(source);
    source.selector = source.selector.replace(this.rx.STRIP, "");
    source.selector = (source.selector && source.selector + ",\n") + target.selector;
    if (source.extends) {
      source.extends.forEach(function(e) {
        this._extendRule(target, e);
      }, this);
    }
  }, _cloneAndAddRuleToParent:function(rule, parent) {
    rule = Object.create(rule);
    rule.parent = parent;
    if (rule.extends) {
      rule.extends = rule.extends.slice();
    }
    parent.rules.push(rule);
  }, rx:{EXTEND:/@extends\(([^)]*)\)\s*?;/gim, STRIP:/%[^,]*$/}};
}();
(function() {
  var prepElement = Polymer.Base._prepElement;
  var nativeShadow = Polymer.Settings.useNativeShadow;
  var styleUtil = Polymer.StyleUtil;
  var styleTransformer = Polymer.StyleTransformer;
  var styleExtends = Polymer.StyleExtends;
  Polymer.Base._addFeature({_prepElement:function(element) {
    if (this._encapsulateStyle) {
      styleTransformer.element(element, this.is, this._scopeCssViaAttr);
    }
    prepElement.call(this, element);
  }, _prepStyles:function() {
    if (!nativeShadow) {
      this._scopeStyle = styleUtil.applyStylePlaceHolder(this.is);
    }
  }, _prepShimStyles:function() {
    if (this._template) {
      if (this._encapsulateStyle === undefined) {
        this._encapsulateStyle = !nativeShadow;
      }
      this._styles = this._collectStyles();
      var cssText = styleTransformer.elementStyles(this);
      this._prepStyleProperties();
      if (!this._needsStyleProperties() && this._styles.length) {
        styleUtil.applyCss(cssText, this.is, nativeShadow ? this._template.content : null, this._scopeStyle);
      }
    } else {
      this._styles = [];
    }
  }, _collectStyles:function() {
    var styles = [];
    var cssText = "", m$ = this.styleModules;
    if (m$) {
      for (var i = 0, l = m$.length, m; i < l && (m = m$[i]); i++) {
        cssText += styleUtil.cssFromModule(m);
      }
    }
    cssText += styleUtil.cssFromModule(this.is);
    var p = this._template && this._template.parentNode;
    if (this._template && (!p || p.id.toLowerCase() !== this.is)) {
      cssText += styleUtil.cssFromElement(this._template);
    }
    if (cssText) {
      var style = document.createElement("style");
      style.textContent = cssText;
      if (styleExtends.hasExtends(style.textContent)) {
        cssText = styleExtends.transform(style);
      }
      styles.push(style);
    }
    return styles;
  }, _elementAdd:function(node) {
    if (this._encapsulateStyle) {
      if (node.__styleScoped) {
        node.__styleScoped = false;
      } else {
        styleTransformer.dom(node, this.is, this._scopeCssViaAttr);
      }
    }
  }, _elementRemove:function(node) {
    if (this._encapsulateStyle) {
      styleTransformer.dom(node, this.is, this._scopeCssViaAttr, true);
    }
  }, scopeSubtree:function(container, shouldObserve) {
    if (nativeShadow) {
      return;
    }
    var self = this;
    var scopify = function(node) {
      if (node.nodeType === Node.ELEMENT_NODE) {
        var className = node.getAttribute("class");
        node.setAttribute("class", self._scopeElementClass(node, className));
        var n$ = node.querySelectorAll("*");
        for (var i = 0, n; i < n$.length && (n = n$[i]); i++) {
          className = n.getAttribute("class");
          n.setAttribute("class", self._scopeElementClass(n, className));
        }
      }
    };
    scopify(container);
    if (shouldObserve) {
      var mo = new MutationObserver(function(mxns) {
        for (var i = 0, m; i < mxns.length && (m = mxns[i]); i++) {
          if (m.addedNodes) {
            for (var j = 0; j < m.addedNodes.length; j++) {
              scopify(m.addedNodes[j]);
            }
          }
        }
      });
      mo.observe(container, {childList:true, subtree:true});
      return mo;
    }
  }});
})();
Polymer.StyleProperties = function() {
  var nativeShadow = Polymer.Settings.useNativeShadow;
  var matchesSelector = Polymer.DomApi.matchesSelector;
  var styleUtil = Polymer.StyleUtil;
  var styleTransformer = Polymer.StyleTransformer;
  return {decorateStyles:function(styles) {
    var self = this, props = {}, keyframes = [];
    styleUtil.forRulesInStyles(styles, function(rule) {
      self.decorateRule(rule);
      self.collectPropertiesInCssText(rule.propertyInfo.cssText, props);
    }, function onKeyframesRule(rule) {
      keyframes.push(rule);
    });
    styles._keyframes = keyframes;
    var names = [];
    for (var i in props) {
      names.push(i);
    }
    return names;
  }, decorateRule:function(rule) {
    if (rule.propertyInfo) {
      return rule.propertyInfo;
    }
    var info = {}, properties = {};
    var hasProperties = this.collectProperties(rule, properties);
    if (hasProperties) {
      info.properties = properties;
      rule.rules = null;
    }
    info.cssText = this.collectCssText(rule);
    rule.propertyInfo = info;
    return info;
  }, collectProperties:function(rule, properties) {
    var info = rule.propertyInfo;
    if (info) {
      if (info.properties) {
        Polymer.Base.mixin(properties, info.properties);
        return true;
      }
    } else {
      var m, rx = this.rx.VAR_ASSIGN;
      var cssText = rule.parsedCssText;
      var any;
      while (m = rx.exec(cssText)) {
        properties[m[1]] = (m[2] || m[3]).trim();
        any = true;
      }
      return any;
    }
  }, collectCssText:function(rule) {
    return this.collectConsumingCssText(rule.parsedCssText);
  }, collectConsumingCssText:function(cssText) {
    return cssText.replace(this.rx.BRACKETED, "").replace(this.rx.VAR_ASSIGN, "");
  }, collectPropertiesInCssText:function(cssText, props) {
    var m;
    while (m = this.rx.VAR_CAPTURE.exec(cssText)) {
      props[m[1]] = true;
      var def = m[2];
      if (def && def.match(this.rx.IS_VAR)) {
        props[def] = true;
      }
    }
  }, reify:function(props) {
    var names = Object.getOwnPropertyNames(props);
    for (var i = 0, n; i < names.length; i++) {
      n = names[i];
      props[n] = this.valueForProperty(props[n], props);
    }
  }, valueForProperty:function(property, props) {
    if (property) {
      if (property.indexOf(";") >= 0) {
        property = this.valueForProperties(property, props);
      } else {
        var self = this;
        var fn = function(all, prefix, value, fallback) {
          var propertyValue = self.valueForProperty(props[value], props) || (props[fallback] ? self.valueForProperty(props[fallback], props) : fallback);
          return prefix + (propertyValue || "");
        };
        property = property.replace(this.rx.VAR_MATCH, fn);
      }
    }
    return property && property.trim() || "";
  }, valueForProperties:function(property, props) {
    var parts = property.split(";");
    for (var i = 0, p, m; i < parts.length; i++) {
      if (p = parts[i]) {
        m = p.match(this.rx.MIXIN_MATCH);
        if (m) {
          p = this.valueForProperty(props[m[1]], props);
        } else {
          var colon = p.indexOf(":");
          if (colon !== -1) {
            var pp = p.substring(colon);
            pp = pp.trim();
            pp = this.valueForProperty(pp, props) || pp;
            p = p.substring(0, colon) + pp;
          }
        }
        parts[i] = p && p.lastIndexOf(";") === p.length - 1 ? p.slice(0, -1) : p || "";
      }
    }
    return parts.join(";");
  }, applyProperties:function(rule, props) {
    var output = "";
    if (!rule.propertyInfo) {
      this.decorateRule(rule);
    }
    if (rule.propertyInfo.cssText) {
      output = this.valueForProperties(rule.propertyInfo.cssText, props);
    }
    rule.cssText = output;
  }, applyKeyframeTransforms:function(rule, keyframeTransforms) {
    var input = rule.cssText;
    var output = rule.cssText;
    if (rule.hasAnimations == null) {
      rule.hasAnimations = this.rx.ANIMATION_MATCH.test(input);
    }
    if (rule.hasAnimations) {
      var transform;
      if (rule.keyframeNamesToTransform == null) {
        rule.keyframeNamesToTransform = [];
        for (var keyframe in keyframeTransforms) {
          transform = keyframeTransforms[keyframe];
          output = transform(input);
          if (input !== output) {
            input = output;
            rule.keyframeNamesToTransform.push(keyframe);
          }
        }
      } else {
        for (var i = 0; i < rule.keyframeNamesToTransform.length; ++i) {
          transform = keyframeTransforms[rule.keyframeNamesToTransform[i]];
          input = transform(input);
        }
        output = input;
      }
    }
    rule.cssText = output;
  }, propertyDataFromStyles:function(styles, element) {
    var props = {}, self = this;
    var o = [], i = 0;
    styleUtil.forRulesInStyles(styles, function(rule) {
      if (!rule.propertyInfo) {
        self.decorateRule(rule);
      }
      if (element && rule.propertyInfo.properties && matchesSelector.call(element, rule.transformedSelector || rule.parsedSelector)) {
        self.collectProperties(rule, props);
        addToBitMask(i, o);
      }
      i++;
    });
    return {properties:props, key:o};
  }, scopePropertiesFromStyles:function(styles) {
    if (!styles._scopeStyleProperties) {
      styles._scopeStyleProperties = this.selectedPropertiesFromStyles(styles, this.SCOPE_SELECTORS);
    }
    return styles._scopeStyleProperties;
  }, hostPropertiesFromStyles:function(styles) {
    if (!styles._hostStyleProperties) {
      styles._hostStyleProperties = this.selectedPropertiesFromStyles(styles, this.HOST_SELECTORS);
    }
    return styles._hostStyleProperties;
  }, selectedPropertiesFromStyles:function(styles, selectors) {
    var props = {}, self = this;
    styleUtil.forRulesInStyles(styles, function(rule) {
      if (!rule.propertyInfo) {
        self.decorateRule(rule);
      }
      for (var i = 0; i < selectors.length; i++) {
        if (rule.parsedSelector === selectors[i]) {
          self.collectProperties(rule, props);
          return;
        }
      }
    });
    return props;
  }, transformStyles:function(element, properties, scopeSelector) {
    var self = this;
    var hostSelector = styleTransformer._calcHostScope(element.is, element.extends);
    var rxHostSelector = element.extends ? "\\" + hostSelector.slice(0, -1) + "\\]" : hostSelector;
    var hostRx = new RegExp(this.rx.HOST_PREFIX + rxHostSelector + this.rx.HOST_SUFFIX);
    var keyframeTransforms = this._elementKeyframeTransforms(element, scopeSelector);
    return styleTransformer.elementStyles(element, function(rule) {
      self.applyProperties(rule, properties);
      if (!nativeShadow && !Polymer.StyleUtil.isKeyframesSelector(rule) && rule.cssText) {
        self.applyKeyframeTransforms(rule, keyframeTransforms);
        self._scopeSelector(rule, hostRx, hostSelector, element._scopeCssViaAttr, scopeSelector);
      }
    });
  }, _elementKeyframeTransforms:function(element, scopeSelector) {
    var keyframesRules = element._styles._keyframes;
    var keyframeTransforms = {};
    if (!nativeShadow && keyframesRules) {
      for (var i = 0, keyframesRule = keyframesRules[i]; i < keyframesRules.length; keyframesRule = keyframesRules[++i]) {
        this._scopeKeyframes(keyframesRule, scopeSelector);
        keyframeTransforms[keyframesRule.keyframesName] = this._keyframesRuleTransformer(keyframesRule);
      }
    }
    return keyframeTransforms;
  }, _keyframesRuleTransformer:function(keyframesRule) {
    return function(cssText) {
      return cssText.replace(keyframesRule.keyframesNameRx, keyframesRule.transformedKeyframesName);
    };
  }, _scopeKeyframes:function(rule, scopeId) {
    rule.keyframesNameRx = new RegExp(rule.keyframesName, "g");
    rule.transformedKeyframesName = rule.keyframesName + "-" + scopeId;
    rule.transformedSelector = rule.transformedSelector || rule.selector;
    rule.selector = rule.transformedSelector.replace(rule.keyframesName, rule.transformedKeyframesName);
  }, _scopeSelector:function(rule, hostRx, hostSelector, viaAttr, scopeId) {
    rule.transformedSelector = rule.transformedSelector || rule.selector;
    var selector = rule.transformedSelector;
    var scope = viaAttr ? "[" + styleTransformer.SCOPE_NAME + "~=" + scopeId + "]" : "." + scopeId;
    var parts = selector.split(",");
    for (var i = 0, l = parts.length, p; i < l && (p = parts[i]); i++) {
      parts[i] = p.match(hostRx) ? p.replace(hostSelector, scope) : scope + " " + p;
    }
    rule.selector = parts.join(",");
  }, applyElementScopeSelector:function(element, selector, old, viaAttr) {
    var c = viaAttr ? element.getAttribute(styleTransformer.SCOPE_NAME) : element.getAttribute("class") || "";
    var v = old ? c.replace(old, selector) : (c ? c + " " : "") + this.XSCOPE_NAME + " " + selector;
    if (c !== v) {
      if (viaAttr) {
        element.setAttribute(styleTransformer.SCOPE_NAME, v);
      } else {
        element.setAttribute("class", v);
      }
    }
  }, applyElementStyle:function(element, properties, selector, style) {
    var cssText = style ? style.textContent || "" : this.transformStyles(element, properties, selector);
    var s = element._customStyle;
    if (s && !nativeShadow && s !== style) {
      s._useCount--;
      if (s._useCount <= 0 && s.parentNode) {
        s.parentNode.removeChild(s);
      }
    }
    if (nativeShadow || (!style || !style.parentNode)) {
      if (nativeShadow && element._customStyle) {
        element._customStyle.textContent = cssText;
        style = element._customStyle;
      } else {
        if (cssText) {
          style = styleUtil.applyCss(cssText, selector, nativeShadow ? element.root : null, element._scopeStyle);
        }
      }
    }
    if (style) {
      style._useCount = style._useCount || 0;
      if (element._customStyle != style) {
        style._useCount++;
      }
      element._customStyle = style;
    }
    return style;
  }, mixinCustomStyle:function(props, customStyle) {
    var v;
    for (var i in customStyle) {
      v = customStyle[i];
      if (v || v === 0) {
        props[i] = v;
      }
    }
  }, rx:{VAR_ASSIGN:/(?:^|[;\s{]\s*)(--[\w-]*?)\s*:\s*(?:([^;{]*)|{([^}]*)})(?:(?=[;\s}])|$)/gi, MIXIN_MATCH:/(?:^|\W+)@apply[\s]*\(([^)]*)\)/i, VAR_MATCH:/(^|\W+)var\([\s]*([^,)]*)[\s]*,?[\s]*((?:[^,()]*)|(?:[^;()]*\([^;)]*\)))[\s]*?\)/gi, VAR_CAPTURE:/\([\s]*(--[^,\s)]*)(?:,[\s]*(--[^,\s)]*))?(?:\)|,)/gi, ANIMATION_MATCH:/(animation\s*:)|(animation-name\s*:)/, IS_VAR:/^--/, BRACKETED:/\{[^}]*\}/g, HOST_PREFIX:"(?:^|[^.#[:])", HOST_SUFFIX:"($|[.:[\\s>+~])"}, HOST_SELECTORS:[":host"], SCOPE_SELECTORS:[":root"], 
  XSCOPE_NAME:"x-scope"};
  function addToBitMask(n, bits) {
    var o = parseInt(n / 32);
    var v = 1 << n % 32;
    bits[o] = (bits[o] || 0) | v;
  }
}();
(function() {
  Polymer.StyleCache = function() {
    this.cache = {};
  };
  Polymer.StyleCache.prototype = {MAX:100, store:function(is, data, keyValues, keyStyles) {
    data.keyValues = keyValues;
    data.styles = keyStyles;
    var s$ = this.cache[is] = this.cache[is] || [];
    s$.push(data);
    if (s$.length > this.MAX) {
      s$.shift();
    }
  }, retrieve:function(is, keyValues, keyStyles) {
    var cache = this.cache[is];
    if (cache) {
      for (var i = cache.length - 1, data; i >= 0; i--) {
        data = cache[i];
        if (keyStyles === data.styles && this._objectsEqual(keyValues, data.keyValues)) {
          return data;
        }
      }
    }
  }, clear:function() {
    this.cache = {};
  }, _objectsEqual:function(target, source) {
    var t, s;
    for (var i in target) {
      t = target[i], s = source[i];
      if (!(typeof t === "object" && t ? this._objectsStrictlyEqual(t, s) : t === s)) {
        return false;
      }
    }
    if (Array.isArray(target)) {
      return target.length === source.length;
    }
    return true;
  }, _objectsStrictlyEqual:function(target, source) {
    return this._objectsEqual(target, source) && this._objectsEqual(source, target);
  }};
})();
Polymer.StyleDefaults = function() {
  var styleProperties = Polymer.StyleProperties;
  var StyleCache = Polymer.StyleCache;
  var api = {_styles:[], _properties:null, customStyle:{}, _styleCache:new StyleCache, addStyle:function(style) {
    this._styles.push(style);
    this._properties = null;
  }, get _styleProperties() {
    if (!this._properties) {
      styleProperties.decorateStyles(this._styles);
      this._styles._scopeStyleProperties = null;
      this._properties = styleProperties.scopePropertiesFromStyles(this._styles);
      styleProperties.mixinCustomStyle(this._properties, this.customStyle);
      styleProperties.reify(this._properties);
    }
    return this._properties;
  }, _needsStyleProperties:function() {
  }, _computeStyleProperties:function() {
    return this._styleProperties;
  }, updateStyles:function(properties) {
    this._properties = null;
    if (properties) {
      Polymer.Base.mixin(this.customStyle, properties);
    }
    this._styleCache.clear();
    for (var i = 0, s; i < this._styles.length; i++) {
      s = this._styles[i];
      s = s.__importElement || s;
      s._apply();
    }
  }};
  return api;
}();
(function() {
  var serializeValueToAttribute = Polymer.Base.serializeValueToAttribute;
  var propertyUtils = Polymer.StyleProperties;
  var styleTransformer = Polymer.StyleTransformer;
  var styleDefaults = Polymer.StyleDefaults;
  var nativeShadow = Polymer.Settings.useNativeShadow;
  Polymer.Base._addFeature({_prepStyleProperties:function() {
    this._ownStylePropertyNames = this._styles && this._styles.length ? propertyUtils.decorateStyles(this._styles) : null;
  }, customStyle:null, getComputedStyleValue:function(property) {
    return this._styleProperties && this._styleProperties[property] || getComputedStyle(this).getPropertyValue(property);
  }, _setupStyleProperties:function() {
    this.customStyle = {};
    this._styleCache = null;
    this._styleProperties = null;
    this._scopeSelector = null;
    this._ownStyleProperties = null;
    this._customStyle = null;
  }, _needsStyleProperties:function() {
    return Boolean(this._ownStylePropertyNames && this._ownStylePropertyNames.length);
  }, _beforeAttached:function() {
    if (!this._scopeSelector && this._needsStyleProperties()) {
      this._updateStyleProperties();
    }
  }, _findStyleHost:function() {
    var e = this, root;
    while (root = Polymer.dom(e).getOwnerRoot()) {
      if (Polymer.isInstance(root.host)) {
        return root.host;
      }
      e = root.host;
    }
    return styleDefaults;
  }, _updateStyleProperties:function() {
    var info, scope = this._findStyleHost();
    if (!scope._styleCache) {
      scope._styleCache = new Polymer.StyleCache;
    }
    var scopeData = propertyUtils.propertyDataFromStyles(scope._styles, this);
    scopeData.key.customStyle = this.customStyle;
    info = scope._styleCache.retrieve(this.is, scopeData.key, this._styles);
    var scopeCached = Boolean(info);
    if (scopeCached) {
      this._styleProperties = info._styleProperties;
    } else {
      this._computeStyleProperties(scopeData.properties);
    }
    this._computeOwnStyleProperties();
    if (!scopeCached) {
      info = styleCache.retrieve(this.is, this._ownStyleProperties, this._styles);
    }
    var globalCached = Boolean(info) && !scopeCached;
    var style = this._applyStyleProperties(info);
    if (!scopeCached) {
      style = style && nativeShadow ? style.cloneNode(true) : style;
      info = {style:style, _scopeSelector:this._scopeSelector, _styleProperties:this._styleProperties};
      scopeData.key.customStyle = {};
      this.mixin(scopeData.key.customStyle, this.customStyle);
      scope._styleCache.store(this.is, info, scopeData.key, this._styles);
      if (!globalCached) {
        styleCache.store(this.is, Object.create(info), this._ownStyleProperties, this._styles);
      }
    }
  }, _computeStyleProperties:function(scopeProps) {
    var scope = this._findStyleHost();
    if (!scope._styleProperties) {
      scope._computeStyleProperties();
    }
    var props = Object.create(scope._styleProperties);
    this.mixin(props, propertyUtils.hostPropertiesFromStyles(this._styles));
    scopeProps = scopeProps || propertyUtils.propertyDataFromStyles(scope._styles, this).properties;
    this.mixin(props, scopeProps);
    this.mixin(props, propertyUtils.scopePropertiesFromStyles(this._styles));
    propertyUtils.mixinCustomStyle(props, this.customStyle);
    propertyUtils.reify(props);
    this._styleProperties = props;
  }, _computeOwnStyleProperties:function() {
    var props = {};
    for (var i = 0, n; i < this._ownStylePropertyNames.length; i++) {
      n = this._ownStylePropertyNames[i];
      props[n] = this._styleProperties[n];
    }
    this._ownStyleProperties = props;
  }, _scopeCount:0, _applyStyleProperties:function(info) {
    var oldScopeSelector = this._scopeSelector;
    this._scopeSelector = info ? info._scopeSelector : this.is + "-" + this.__proto__._scopeCount++;
    var style = propertyUtils.applyElementStyle(this, this._styleProperties, this._scopeSelector, info && info.style);
    if (!nativeShadow) {
      propertyUtils.applyElementScopeSelector(this, this._scopeSelector, oldScopeSelector, this._scopeCssViaAttr);
    }
    return style;
  }, serializeValueToAttribute:function(value, attribute, node) {
    node = node || this;
    if (attribute === "class" && !nativeShadow) {
      var host = node === this ? this.domHost || this.dataHost : this;
      if (host) {
        value = host._scopeElementClass(node, value);
      }
    }
    node = this.shadyRoot && this.shadyRoot._hasDistributed ? Polymer.dom(node) : node;
    serializeValueToAttribute.call(this, value, attribute, node);
  }, _scopeElementClass:function(element, selector) {
    if (!nativeShadow && !this._scopeCssViaAttr) {
      selector = (selector ? selector + " " : "") + SCOPE_NAME + " " + this.is + (element._scopeSelector ? " " + XSCOPE_NAME + " " + element._scopeSelector : "");
    }
    return selector;
  }, updateStyles:function(properties) {
    if (this.isAttached) {
      if (properties) {
        this.mixin(this.customStyle, properties);
      }
      if (this._needsStyleProperties()) {
        this._updateStyleProperties();
      } else {
        this._styleProperties = null;
      }
      if (this._styleCache) {
        this._styleCache.clear();
      }
      this._updateRootStyles();
    }
  }, _updateRootStyles:function(root) {
    root = root || this.root;
    var c$ = Polymer.dom(root)._query(function(e) {
      return e.shadyRoot || e.shadowRoot;
    });
    for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
      if (c.updateStyles) {
        c.updateStyles();
      }
    }
  }});
  Polymer.updateStyles = function(properties) {
    styleDefaults.updateStyles(properties);
    Polymer.Base._updateRootStyles(document);
  };
  var styleCache = new Polymer.StyleCache;
  Polymer.customStyleCache = styleCache;
  var SCOPE_NAME = styleTransformer.SCOPE_NAME;
  var XSCOPE_NAME = propertyUtils.XSCOPE_NAME;
})();
Polymer.Base._addFeature({_registerFeatures:function() {
  this._prepIs();
  this._prepConstructor();
  this._prepStyles();
}, _finishRegisterFeatures:function() {
  this._prepTemplate();
  this._prepShimStyles();
  this._prepAnnotations();
  this._prepEffects();
  this._prepBehaviors();
  this._prepPropertyInfo();
  this._prepBindings();
  this._prepShady();
}, _prepBehavior:function(b) {
  this._addPropertyEffects(b.properties);
  this._addComplexObserverEffects(b.observers);
  this._addHostAttributes(b.hostAttributes);
}, _initFeatures:function() {
  this._setupGestures();
  this._setupConfigure();
  this._setupStyleProperties();
  this._setupDebouncers();
  this._setupShady();
  this._registerHost();
  if (this._template) {
    this._poolContent();
    this._beginHosting();
    this._stampTemplate();
    this._endHosting();
    this._marshalAnnotationReferences();
  }
  this._marshalInstanceEffects();
  this._marshalBehaviors();
  this._marshalHostAttributes();
  this._marshalAttributes();
  this._tryReady();
}, _marshalBehavior:function(b) {
  if (b.listeners) {
    this._listenListeners(b.listeners);
  }
}});
(function() {
  var propertyUtils = Polymer.StyleProperties;
  var styleUtil = Polymer.StyleUtil;
  var cssParse = Polymer.CssParse;
  var styleDefaults = Polymer.StyleDefaults;
  var styleTransformer = Polymer.StyleTransformer;
  Polymer({is:"custom-style", extends:"style", _template:null, properties:{include:String}, ready:function() {
    this._tryApply();
  }, attached:function() {
    this._tryApply();
  }, _tryApply:function() {
    if (!this._appliesToDocument) {
      if (this.parentNode && this.parentNode.localName !== "dom-module") {
        this._appliesToDocument = true;
        var e = this.__appliedElement || this;
        styleDefaults.addStyle(e);
        if (e.textContent || this.include) {
          this._apply(true);
        } else {
          var self = this;
          var observer = new MutationObserver(function() {
            observer.disconnect();
            self._apply(true);
          });
          observer.observe(e, {childList:true});
        }
      }
    }
  }, _apply:function(deferProperties) {
    var e = this.__appliedElement || this;
    if (this.include) {
      e.textContent = styleUtil.cssFromModules(this.include, true) + e.textContent;
    }
    if (e.textContent) {
      styleUtil.forEachRule(styleUtil.rulesForStyle(e), function(rule) {
        styleTransformer.documentRule(rule);
      });
      var self = this;
      var fn = function fn() {
        self._applyCustomProperties(e);
      };
      if (this._pendingApplyProperties) {
        cancelAnimationFrame(this._pendingApplyProperties);
        this._pendingApplyProperties = null;
      }
      if (deferProperties) {
        this._pendingApplyProperties = requestAnimationFrame(fn);
      } else {
        fn();
      }
    }
  }, _applyCustomProperties:function(element) {
    this._computeStyleProperties();
    var props = this._styleProperties;
    var rules = styleUtil.rulesForStyle(element);
    element.textContent = styleUtil.toCssText(rules, function(rule) {
      var css = rule.cssText = rule.parsedCssText;
      if (rule.propertyInfo && rule.propertyInfo.cssText) {
        css = cssParse.removeCustomPropAssignment(css);
        rule.cssText = propertyUtils.valueForProperties(css, props);
      }
    });
  }});
})();
Polymer.Templatizer = {properties:{__hideTemplateChildren__:{observer:"_showHideChildren"}}, _instanceProps:Polymer.nob, _parentPropPrefix:"_parent_", templatize:function(template) {
  this._templatized = template;
  if (!template._content) {
    template._content = template.content;
  }
  if (template._content._ctor) {
    this.ctor = template._content._ctor;
    this._prepParentProperties(this.ctor.prototype, template);
    return;
  }
  var archetype = Object.create(Polymer.Base);
  this._customPrepAnnotations(archetype, template);
  this._prepParentProperties(archetype, template);
  archetype._prepEffects();
  this._customPrepEffects(archetype);
  archetype._prepBehaviors();
  archetype._prepPropertyInfo();
  archetype._prepBindings();
  archetype._notifyPathUp = this._notifyPathUpImpl;
  archetype._scopeElementClass = this._scopeElementClassImpl;
  archetype.listen = this._listenImpl;
  archetype._showHideChildren = this._showHideChildrenImpl;
  archetype.__setPropertyOrig = this.__setProperty;
  archetype.__setProperty = this.__setPropertyImpl;
  var _constructor = this._constructorImpl;
  var ctor = function TemplateInstance(model, host) {
    _constructor.call(this, model, host);
  };
  ctor.prototype = archetype;
  archetype.constructor = ctor;
  template._content._ctor = ctor;
  this.ctor = ctor;
}, _getRootDataHost:function() {
  return this.dataHost && this.dataHost._rootDataHost || this.dataHost;
}, _showHideChildrenImpl:function(hide) {
  var c = this._children;
  for (var i = 0; i < c.length; i++) {
    var n = c[i];
    if (Boolean(hide) != Boolean(n.__hideTemplateChildren__)) {
      if (n.nodeType === Node.TEXT_NODE) {
        if (hide) {
          n.__polymerTextContent__ = n.textContent;
          n.textContent = "";
        } else {
          n.textContent = n.__polymerTextContent__;
        }
      } else {
        if (n.style) {
          if (hide) {
            n.__polymerDisplay__ = n.style.display;
            n.style.display = "none";
          } else {
            n.style.display = n.__polymerDisplay__;
          }
        }
      }
    }
    n.__hideTemplateChildren__ = hide;
  }
}, __setPropertyImpl:function(property, value, fromAbove, node) {
  if (node && node.__hideTemplateChildren__ && property == "textContent") {
    property = "__polymerTextContent__";
  }
  this.__setPropertyOrig(property, value, fromAbove, node);
}, _debounceTemplate:function(fn) {
  Polymer.dom.addDebouncer(this.debounce("_debounceTemplate", fn));
}, _flushTemplates:function() {
  Polymer.dom.flush();
}, _customPrepEffects:function(archetype) {
  var parentProps = archetype._parentProps;
  for (var prop in parentProps) {
    archetype._addPropertyEffect(prop, "function", this._createHostPropEffector(prop));
  }
  for (prop in this._instanceProps) {
    archetype._addPropertyEffect(prop, "function", this._createInstancePropEffector(prop));
  }
}, _customPrepAnnotations:function(archetype, template) {
  archetype._template = template;
  var c = template._content;
  if (!c._notes) {
    var rootDataHost = archetype._rootDataHost;
    if (rootDataHost) {
      Polymer.Annotations.prepElement = function() {
        rootDataHost._prepElement();
      };
    }
    c._notes = Polymer.Annotations.parseAnnotations(template);
    Polymer.Annotations.prepElement = null;
    this._processAnnotations(c._notes);
  }
  archetype._notes = c._notes;
  archetype._parentProps = c._parentProps;
}, _prepParentProperties:function(archetype, template) {
  var parentProps = this._parentProps = archetype._parentProps;
  if (this._forwardParentProp && parentProps) {
    var proto = archetype._parentPropProto;
    var prop;
    if (!proto) {
      for (prop in this._instanceProps) {
        delete parentProps[prop];
      }
      proto = archetype._parentPropProto = Object.create(null);
      if (template != this) {
        Polymer.Bind.prepareModel(proto);
        Polymer.Base.prepareModelNotifyPath(proto);
      }
      for (prop in parentProps) {
        var parentProp = this._parentPropPrefix + prop;
        var effects = [{kind:"function", effect:this._createForwardPropEffector(prop), fn:Polymer.Bind._functionEffect}, {kind:"notify", fn:Polymer.Bind._notifyEffect, effect:{event:Polymer.CaseMap.camelToDashCase(parentProp) + "-changed"}}];
        Polymer.Bind._createAccessors(proto, parentProp, effects);
      }
    }
    var self = this;
    if (template != this) {
      Polymer.Bind.prepareInstance(template);
      template._forwardParentProp = function(source, value) {
        self._forwardParentProp(source, value);
      };
    }
    this._extendTemplate(template, proto);
    template._pathEffector = function(path, value, fromAbove) {
      return self._pathEffectorImpl(path, value, fromAbove);
    };
  }
}, _createForwardPropEffector:function(prop) {
  return function(source, value) {
    this._forwardParentProp(prop, value);
  };
}, _createHostPropEffector:function(prop) {
  var prefix = this._parentPropPrefix;
  return function(source, value) {
    this.dataHost._templatized[prefix + prop] = value;
  };
}, _createInstancePropEffector:function(prop) {
  return function(source, value, old, fromAbove) {
    if (!fromAbove) {
      this.dataHost._forwardInstanceProp(this, prop, value);
    }
  };
}, _extendTemplate:function(template, proto) {
  var n$ = Object.getOwnPropertyNames(proto);
  if (proto._propertySetter) {
    template._propertySetter = proto._propertySetter;
  }
  for (var i = 0, n; i < n$.length && (n = n$[i]); i++) {
    var val = template[n];
    var pd = Object.getOwnPropertyDescriptor(proto, n);
    Object.defineProperty(template, n, pd);
    if (val !== undefined) {
      template._propertySetter(n, val);
    }
  }
}, _showHideChildren:function(hidden) {
}, _forwardInstancePath:function(inst, path, value) {
}, _forwardInstanceProp:function(inst, prop, value) {
}, _notifyPathUpImpl:function(path, value) {
  var dataHost = this.dataHost;
  var dot = path.indexOf(".");
  var root = dot < 0 ? path : path.slice(0, dot);
  dataHost._forwardInstancePath.call(dataHost, this, path, value);
  if (root in dataHost._parentProps) {
    dataHost._templatized.notifyPath(dataHost._parentPropPrefix + path, value);
  }
}, _pathEffectorImpl:function(path, value, fromAbove) {
  if (this._forwardParentPath) {
    if (path.indexOf(this._parentPropPrefix) === 0) {
      var subPath = path.substring(this._parentPropPrefix.length);
      var model = this._modelForPath(subPath);
      if (model in this._parentProps) {
        this._forwardParentPath(subPath, value);
      }
    }
  }
  Polymer.Base._pathEffector.call(this._templatized, path, value, fromAbove);
}, _constructorImpl:function(model, host) {
  this._rootDataHost = host._getRootDataHost();
  this._setupConfigure(model);
  this._registerHost(host);
  this._beginHosting();
  this.root = this.instanceTemplate(this._template);
  this.root.__noContent = !this._notes._hasContent;
  this.root.__styleScoped = true;
  this._endHosting();
  this._marshalAnnotatedNodes();
  this._marshalInstanceEffects();
  this._marshalAnnotatedListeners();
  var children = [];
  for (var n = this.root.firstChild; n; n = n.nextSibling) {
    children.push(n);
    n._templateInstance = this;
  }
  this._children = children;
  if (host.__hideTemplateChildren__) {
    this._showHideChildren(true);
  }
  this._tryReady();
}, _listenImpl:function(node, eventName, methodName) {
  var model = this;
  var host = this._rootDataHost;
  var handler = host._createEventHandler(node, eventName, methodName);
  var decorated = function(e) {
    e.model = model;
    handler(e);
  };
  host._listen(node, eventName, decorated);
}, _scopeElementClassImpl:function(node, value) {
  var host = this._rootDataHost;
  if (host) {
    return host._scopeElementClass(node, value);
  }
}, stamp:function(model) {
  model = model || {};
  if (this._parentProps) {
    var templatized = this._templatized;
    for (var prop in this._parentProps) {
      if (model[prop] === undefined) {
        model[prop] = templatized[this._parentPropPrefix + prop];
      }
    }
  }
  return new this.ctor(model, this);
}, modelForElement:function(el) {
  var model;
  while (el) {
    if (model = el._templateInstance) {
      if (model.dataHost != this) {
        el = model.dataHost;
      } else {
        return model;
      }
    } else {
      el = el.parentNode;
    }
  }
}};
Polymer({is:"dom-template", extends:"template", _template:null, behaviors:[Polymer.Templatizer], ready:function() {
  this.templatize(this);
}});
Polymer._collections = new WeakMap;
Polymer.Collection = function(userArray) {
  Polymer._collections.set(userArray, this);
  this.userArray = userArray;
  this.store = userArray.slice();
  this.initMap();
};
Polymer.Collection.prototype = {constructor:Polymer.Collection, initMap:function() {
  var omap = this.omap = new WeakMap;
  var pmap = this.pmap = {};
  var s = this.store;
  for (var i = 0; i < s.length; i++) {
    var item = s[i];
    if (item && typeof item == "object") {
      omap.set(item, i);
    } else {
      pmap[item] = i;
    }
  }
}, add:function(item) {
  var key = this.store.push(item) - 1;
  if (item && typeof item == "object") {
    this.omap.set(item, key);
  } else {
    this.pmap[item] = key;
  }
  return "#" + key;
}, removeKey:function(key) {
  if (key = this._parseKey(key)) {
    this._removeFromMap(this.store[key]);
    delete this.store[key];
  }
}, _removeFromMap:function(item) {
  if (item && typeof item == "object") {
    this.omap.delete(item);
  } else {
    delete this.pmap[item];
  }
}, remove:function(item) {
  var key = this.getKey(item);
  this.removeKey(key);
  return key;
}, getKey:function(item) {
  var key;
  if (item && typeof item == "object") {
    key = this.omap.get(item);
  } else {
    key = this.pmap[item];
  }
  if (key != undefined) {
    return "#" + key;
  }
}, getKeys:function() {
  return Object.keys(this.store).map(function(key) {
    return "#" + key;
  });
}, _parseKey:function(key) {
  if (key && key[0] == "#") {
    return key.slice(1);
  }
}, setItem:function(key, item) {
  if (key = this._parseKey(key)) {
    var old = this.store[key];
    if (old) {
      this._removeFromMap(old);
    }
    if (item && typeof item == "object") {
      this.omap.set(item, key);
    } else {
      this.pmap[item] = key;
    }
    this.store[key] = item;
  }
}, getItem:function(key) {
  if (key = this._parseKey(key)) {
    return this.store[key];
  }
}, getItems:function() {
  var items = [], store = this.store;
  for (var key in store) {
    items.push(store[key]);
  }
  return items;
}, _applySplices:function(splices) {
  var keyMap = {}, key;
  for (var i = 0, s; i < splices.length && (s = splices[i]); i++) {
    s.addedKeys = [];
    for (var j = 0; j < s.removed.length; j++) {
      key = this.getKey(s.removed[j]);
      keyMap[key] = keyMap[key] ? null : -1;
    }
    for (j = 0; j < s.addedCount; j++) {
      var item = this.userArray[s.index + j];
      key = this.getKey(item);
      key = key === undefined ? this.add(item) : key;
      keyMap[key] = keyMap[key] ? null : 1;
      s.addedKeys.push(key);
    }
  }
  var removed = [];
  var added = [];
  for (key in keyMap) {
    if (keyMap[key] < 0) {
      this.removeKey(key);
      removed.push(key);
    }
    if (keyMap[key] > 0) {
      added.push(key);
    }
  }
  return [{removed:removed, added:added}];
}};
Polymer.Collection.get = function(userArray) {
  return Polymer._collections.get(userArray) || new Polymer.Collection(userArray);
};
Polymer.Collection.applySplices = function(userArray, splices) {
  var coll = Polymer._collections.get(userArray);
  return coll ? coll._applySplices(splices) : null;
};
Polymer({is:"dom-repeat", extends:"template", _template:null, properties:{items:{type:Array}, as:{type:String, value:"item"}, indexAs:{type:String, value:"index"}, sort:{type:Function, observer:"_sortChanged"}, filter:{type:Function, observer:"_filterChanged"}, observe:{type:String, observer:"_observeChanged"}, delay:Number, renderedItemCount:{type:Number, notify:true, readOnly:true}, initialCount:{type:Number, observer:"_initializeChunking"}, targetFramerate:{type:Number, value:20}, _targetFrameTime:{type:Number, 
computed:"_computeFrameTime(targetFramerate)"}}, behaviors:[Polymer.Templatizer], observers:["_itemsChanged(items.*)"], created:function() {
  this._instances = [];
  this._pool = [];
  this._limit = Infinity;
  var self = this;
  this._boundRenderChunk = function() {
    self._renderChunk();
  };
}, detached:function() {
  this.__isDetached = true;
  for (var i = 0; i < this._instances.length; i++) {
    this._detachInstance(i);
  }
}, attached:function() {
  if (this.__isDetached) {
    this.__isDetached = false;
    var parent = Polymer.dom(Polymer.dom(this).parentNode);
    for (var i = 0; i < this._instances.length; i++) {
      this._attachInstance(i, parent);
    }
  }
}, ready:function() {
  this._instanceProps = {__key__:true};
  this._instanceProps[this.as] = true;
  this._instanceProps[this.indexAs] = true;
  if (!this.ctor) {
    this.templatize(this);
  }
}, _sortChanged:function(sort) {
  var dataHost = this._getRootDataHost();
  this._sortFn = sort && (typeof sort == "function" ? sort : function() {
    return dataHost[sort].apply(dataHost, arguments);
  });
  this._needFullRefresh = true;
  if (this.items) {
    this._debounceTemplate(this._render);
  }
}, _filterChanged:function(filter) {
  var dataHost = this._getRootDataHost();
  this._filterFn = filter && (typeof filter == "function" ? filter : function() {
    return dataHost[filter].apply(dataHost, arguments);
  });
  this._needFullRefresh = true;
  if (this.items) {
    this._debounceTemplate(this._render);
  }
}, _computeFrameTime:function(rate) {
  return Math.ceil(1000 / rate);
}, _initializeChunking:function() {
  if (this.initialCount) {
    this._limit = this.initialCount;
    this._chunkCount = this.initialCount;
    this._lastChunkTime = performance.now();
  }
}, _tryRenderChunk:function() {
  if (this.items && this._limit < this.items.length) {
    this.debounce("renderChunk", this._requestRenderChunk);
  }
}, _requestRenderChunk:function() {
  requestAnimationFrame(this._boundRenderChunk);
}, _renderChunk:function() {
  var currChunkTime = performance.now();
  var ratio = this._targetFrameTime / (currChunkTime - this._lastChunkTime);
  this._chunkCount = Math.round(this._chunkCount * ratio) || 1;
  this._limit += this._chunkCount;
  this._lastChunkTime = currChunkTime;
  this._debounceTemplate(this._render);
}, _observeChanged:function() {
  this._observePaths = this.observe && this.observe.replace(".*", ".").split(" ");
}, _itemsChanged:function(change) {
  if (change.path == "items") {
    if (Array.isArray(this.items)) {
      this.collection = Polymer.Collection.get(this.items);
    } else {
      if (!this.items) {
        this.collection = null;
      } else {
        this._error(this._logf("dom-repeat", "expected array for `items`," + " found", this.items));
      }
    }
    this._keySplices = [];
    this._indexSplices = [];
    this._needFullRefresh = true;
    this._initializeChunking();
    this._debounceTemplate(this._render);
  } else {
    if (change.path == "items.splices") {
      this._keySplices = this._keySplices.concat(change.value.keySplices);
      this._indexSplices = this._indexSplices.concat(change.value.indexSplices);
      this._debounceTemplate(this._render);
    } else {
      var subpath = change.path.slice(6);
      this._forwardItemPath(subpath, change.value);
      this._checkObservedPaths(subpath);
    }
  }
}, _checkObservedPaths:function(path) {
  if (this._observePaths) {
    path = path.substring(path.indexOf(".") + 1);
    var paths = this._observePaths;
    for (var i = 0; i < paths.length; i++) {
      if (path.indexOf(paths[i]) === 0) {
        this._needFullRefresh = true;
        if (this.delay) {
          this.debounce("render", this._render, this.delay);
        } else {
          this._debounceTemplate(this._render);
        }
        return;
      }
    }
  }
}, render:function() {
  this._needFullRefresh = true;
  this._debounceTemplate(this._render);
  this._flushTemplates();
}, _render:function() {
  if (this._needFullRefresh) {
    this._applyFullRefresh();
    this._needFullRefresh = false;
  } else {
    if (this._keySplices.length) {
      if (this._sortFn) {
        this._applySplicesUserSort(this._keySplices);
      } else {
        if (this._filterFn) {
          this._applyFullRefresh();
        } else {
          this._applySplicesArrayOrder(this._indexSplices);
        }
      }
    } else {
    }
  }
  this._keySplices = [];
  this._indexSplices = [];
  var keyToIdx = this._keyToInstIdx = {};
  for (var i = this._instances.length - 1; i >= 0; i--) {
    var inst = this._instances[i];
    if (inst.isPlaceholder && i < this._limit) {
      inst = this._insertInstance(i, inst.__key__);
    } else {
      if (!inst.isPlaceholder && i >= this._limit) {
        inst = this._downgradeInstance(i, inst.__key__);
      }
    }
    keyToIdx[inst.__key__] = i;
    if (!inst.isPlaceholder) {
      inst.__setProperty(this.indexAs, i, true);
    }
  }
  this._pool.length = 0;
  this._setRenderedItemCount(this._instances.length);
  this.fire("dom-change");
  this._tryRenderChunk();
}, _applyFullRefresh:function() {
  var c = this.collection;
  var keys;
  if (this._sortFn) {
    keys = c ? c.getKeys() : [];
  } else {
    keys = [];
    var items = this.items;
    if (items) {
      for (var i = 0; i < items.length; i++) {
        keys.push(c.getKey(items[i]));
      }
    }
  }
  var self = this;
  if (this._filterFn) {
    keys = keys.filter(function(a) {
      return self._filterFn(c.getItem(a));
    });
  }
  if (this._sortFn) {
    keys.sort(function(a, b) {
      return self._sortFn(c.getItem(a), c.getItem(b));
    });
  }
  for (i = 0; i < keys.length; i++) {
    var key = keys[i];
    var inst = this._instances[i];
    if (inst) {
      inst.__key__ = key;
      if (!inst.isPlaceholder && i < this._limit) {
        inst.__setProperty(this.as, c.getItem(key), true);
      }
    } else {
      if (i < this._limit) {
        this._insertInstance(i, key);
      } else {
        this._insertPlaceholder(i, key);
      }
    }
  }
  for (var j = this._instances.length - 1; j >= i; j--) {
    this._detachAndRemoveInstance(j);
  }
}, _numericSort:function(a, b) {
  return a - b;
}, _applySplicesUserSort:function(splices) {
  var c = this.collection;
  var keyMap = {};
  var key;
  for (var i = 0, s; i < splices.length && (s = splices[i]); i++) {
    for (var j = 0; j < s.removed.length; j++) {
      key = s.removed[j];
      keyMap[key] = keyMap[key] ? null : -1;
    }
    for (j = 0; j < s.added.length; j++) {
      key = s.added[j];
      keyMap[key] = keyMap[key] ? null : 1;
    }
  }
  var removedIdxs = [];
  var addedKeys = [];
  for (key in keyMap) {
    if (keyMap[key] === -1) {
      removedIdxs.push(this._keyToInstIdx[key]);
    }
    if (keyMap[key] === 1) {
      addedKeys.push(key);
    }
  }
  if (removedIdxs.length) {
    removedIdxs.sort(this._numericSort);
    for (i = removedIdxs.length - 1; i >= 0; i--) {
      var idx = removedIdxs[i];
      if (idx !== undefined) {
        this._detachAndRemoveInstance(idx);
      }
    }
  }
  var self = this;
  if (addedKeys.length) {
    if (this._filterFn) {
      addedKeys = addedKeys.filter(function(a) {
        return self._filterFn(c.getItem(a));
      });
    }
    addedKeys.sort(function(a, b) {
      return self._sortFn(c.getItem(a), c.getItem(b));
    });
    var start = 0;
    for (i = 0; i < addedKeys.length; i++) {
      start = this._insertRowUserSort(start, addedKeys[i]);
    }
  }
}, _insertRowUserSort:function(start, key) {
  var c = this.collection;
  var item = c.getItem(key);
  var end = this._instances.length - 1;
  var idx = -1;
  while (start <= end) {
    var mid = start + end >> 1;
    var midKey = this._instances[mid].__key__;
    var cmp = this._sortFn(c.getItem(midKey), item);
    if (cmp < 0) {
      start = mid + 1;
    } else {
      if (cmp > 0) {
        end = mid - 1;
      } else {
        idx = mid;
        break;
      }
    }
  }
  if (idx < 0) {
    idx = end + 1;
  }
  this._insertPlaceholder(idx, key);
  return idx;
}, _applySplicesArrayOrder:function(splices) {
  for (var i = 0, s; i < splices.length && (s = splices[i]); i++) {
    for (var j = 0; j < s.removed.length; j++) {
      this._detachAndRemoveInstance(s.index);
    }
    for (j = 0; j < s.addedKeys.length; j++) {
      this._insertPlaceholder(s.index + j, s.addedKeys[j]);
    }
  }
}, _detachInstance:function(idx) {
  var inst = this._instances[idx];
  if (!inst.isPlaceholder) {
    for (var i = 0; i < inst._children.length; i++) {
      var el = inst._children[i];
      Polymer.dom(inst.root).appendChild(el);
    }
    return inst;
  }
}, _attachInstance:function(idx, parent) {
  var inst = this._instances[idx];
  if (!inst.isPlaceholder) {
    parent.insertBefore(inst.root, this);
  }
}, _detachAndRemoveInstance:function(idx) {
  var inst = this._detachInstance(idx);
  if (inst) {
    this._pool.push(inst);
  }
  this._instances.splice(idx, 1);
}, _insertPlaceholder:function(idx, key) {
  this._instances.splice(idx, 0, {isPlaceholder:true, __key__:key});
}, _stampInstance:function(idx, key) {
  var model = {__key__:key};
  model[this.as] = this.collection.getItem(key);
  model[this.indexAs] = idx;
  return this.stamp(model);
}, _insertInstance:function(idx, key) {
  var inst = this._pool.pop();
  if (inst) {
    inst.__setProperty(this.as, this.collection.getItem(key), true);
    inst.__setProperty("__key__", key, true);
  } else {
    inst = this._stampInstance(idx, key);
  }
  var beforeRow = this._instances[idx + 1];
  var beforeNode = beforeRow && !beforeRow.isPlaceholder ? beforeRow._children[0] : this;
  var parentNode = Polymer.dom(this).parentNode;
  Polymer.dom(parentNode).insertBefore(inst.root, beforeNode);
  this._instances[idx] = inst;
  return inst;
}, _downgradeInstance:function(idx, key) {
  var inst = this._detachInstance(idx);
  if (inst) {
    this._pool.push(inst);
  }
  inst = {isPlaceholder:true, __key__:key};
  this._instances[idx] = inst;
  return inst;
}, _showHideChildren:function(hidden) {
  for (var i = 0; i < this._instances.length; i++) {
    this._instances[i]._showHideChildren(hidden);
  }
}, _forwardInstanceProp:function(inst, prop, value) {
  if (prop == this.as) {
    var idx;
    if (this._sortFn || this._filterFn) {
      idx = this.items.indexOf(this.collection.getItem(inst.__key__));
    } else {
      idx = inst[this.indexAs];
    }
    this.set("items." + idx, value);
  }
}, _forwardInstancePath:function(inst, path, value) {
  if (path.indexOf(this.as + ".") === 0) {
    this._notifyPath("items." + inst.__key__ + "." + path.slice(this.as.length + 1), value);
  }
}, _forwardParentProp:function(prop, value) {
  var i$ = this._instances;
  for (var i = 0, inst; i < i$.length && (inst = i$[i]); i++) {
    if (!inst.isPlaceholder) {
      inst.__setProperty(prop, value, true);
    }
  }
}, _forwardParentPath:function(path, value) {
  var i$ = this._instances;
  for (var i = 0, inst; i < i$.length && (inst = i$[i]); i++) {
    if (!inst.isPlaceholder) {
      inst._notifyPath(path, value, true);
    }
  }
}, _forwardItemPath:function(path, value) {
  if (this._keyToInstIdx) {
    var dot = path.indexOf(".");
    var key = path.substring(0, dot < 0 ? path.length : dot);
    var idx = this._keyToInstIdx[key];
    var inst = this._instances[idx];
    if (inst && !inst.isPlaceholder) {
      if (dot >= 0) {
        path = this.as + "." + path.substring(dot + 1);
        inst._notifyPath(path, value, true);
      } else {
        inst.__setProperty(this.as, value, true);
      }
    }
  }
}, itemForElement:function(el) {
  var instance = this.modelForElement(el);
  return instance && instance[this.as];
}, keyForElement:function(el) {
  var instance = this.modelForElement(el);
  return instance && instance.__key__;
}, indexForElement:function(el) {
  var instance = this.modelForElement(el);
  return instance && instance[this.indexAs];
}});
Polymer({is:"array-selector", _template:null, properties:{items:{type:Array, observer:"clearSelection"}, multi:{type:Boolean, value:false, observer:"clearSelection"}, selected:{type:Object, notify:true}, selectedItem:{type:Object, notify:true}, toggle:{type:Boolean, value:false}}, clearSelection:function() {
  if (Array.isArray(this.selected)) {
    for (var i = 0; i < this.selected.length; i++) {
      this.unlinkPaths("selected." + i);
    }
  } else {
    this.unlinkPaths("selected");
    this.unlinkPaths("selectedItem");
  }
  if (this.multi) {
    if (!this.selected || this.selected.length) {
      this.selected = [];
      this._selectedColl = Polymer.Collection.get(this.selected);
    }
  } else {
    this.selected = null;
    this._selectedColl = null;
  }
  this.selectedItem = null;
}, isSelected:function(item) {
  if (this.multi) {
    return this._selectedColl.getKey(item) !== undefined;
  } else {
    return this.selected == item;
  }
}, deselect:function(item) {
  if (this.multi) {
    if (this.isSelected(item)) {
      var skey = this._selectedColl.getKey(item);
      this.arrayDelete("selected", item);
      this.unlinkPaths("selected." + skey);
    }
  } else {
    this.selected = null;
    this.selectedItem = null;
    this.unlinkPaths("selected");
    this.unlinkPaths("selectedItem");
  }
}, select:function(item) {
  var icol = Polymer.Collection.get(this.items);
  var key = icol.getKey(item);
  if (this.multi) {
    if (this.isSelected(item)) {
      if (this.toggle) {
        this.deselect(item);
      }
    } else {
      this.push("selected", item);
      var skey = this._selectedColl.getKey(item);
      this.linkPaths("selected." + skey, "items." + key);
    }
  } else {
    if (this.toggle && item == this.selected) {
      this.deselect();
    } else {
      this.selected = item;
      this.selectedItem = item;
      this.linkPaths("selected", "items." + key);
      this.linkPaths("selectedItem", "items." + key);
    }
  }
}});
Polymer({is:"dom-if", extends:"template", _template:null, properties:{"if":{type:Boolean, value:false, observer:"_queueRender"}, restamp:{type:Boolean, value:false, observer:"_queueRender"}}, behaviors:[Polymer.Templatizer], _queueRender:function() {
  this._debounceTemplate(this._render);
}, detached:function() {
  if (!this.parentNode || this.parentNode.nodeType == Node.DOCUMENT_FRAGMENT_NODE && (!Polymer.Settings.hasShadow || !(this.parentNode instanceof ShadowRoot))) {
    this._teardownInstance();
  }
}, attached:function() {
  if (this.if && this.ctor) {
    this.async(this._ensureInstance);
  }
}, render:function() {
  this._flushTemplates();
}, _render:function() {
  if (this.if) {
    if (!this.ctor) {
      this.templatize(this);
    }
    this._ensureInstance();
    this._showHideChildren();
  } else {
    if (this.restamp) {
      this._teardownInstance();
    }
  }
  if (!this.restamp && this._instance) {
    this._showHideChildren();
  }
  if (this.if != this._lastIf) {
    this.fire("dom-change");
    this._lastIf = this.if;
  }
}, _ensureInstance:function() {
  var parentNode = Polymer.dom(this).parentNode;
  if (parentNode) {
    var parent = Polymer.dom(parentNode);
    if (!this._instance) {
      this._instance = this.stamp();
      var root = this._instance.root;
      parent.insertBefore(root, this);
    } else {
      var c$ = this._instance._children;
      if (c$ && c$.length) {
        var lastChild = Polymer.dom(this).previousSibling;
        if (lastChild !== c$[c$.length - 1]) {
          for (var i = 0, n; i < c$.length && (n = c$[i]); i++) {
            parent.insertBefore(n, this);
          }
        }
      }
    }
  }
}, _teardownInstance:function() {
  if (this._instance) {
    var c$ = this._instance._children;
    if (c$ && c$.length) {
      var parent = Polymer.dom(Polymer.dom(c$[0]).parentNode);
      for (var i = 0, n; i < c$.length && (n = c$[i]); i++) {
        parent.removeChild(n);
      }
    }
    this._instance = null;
  }
}, _showHideChildren:function() {
  var hidden = this.__hideTemplateChildren__ || !this.if;
  if (this._instance) {
    this._instance._showHideChildren(hidden);
  }
}, _forwardParentProp:function(prop, value) {
  if (this._instance) {
    this._instance[prop] = value;
  }
}, _forwardParentPath:function(path, value) {
  if (this._instance) {
    this._instance._notifyPath(path, value, true);
  }
}});
Polymer({is:"dom-bind", extends:"template", _template:null, created:function() {
  var self = this;
  Polymer.RenderStatus.whenReady(function() {
    if (document.readyState == "loading") {
      document.addEventListener("DOMContentLoaded", function() {
        self._markImportsReady();
      });
    } else {
      self._markImportsReady();
    }
  });
}, _ensureReady:function() {
  if (!this._readied) {
    this._readySelf();
  }
}, _markImportsReady:function() {
  this._importsReady = true;
  this._ensureReady();
}, _registerFeatures:function() {
  this._prepConstructor();
}, _insertChildren:function() {
  var parentDom = Polymer.dom(Polymer.dom(this).parentNode);
  parentDom.insertBefore(this.root, this);
}, _removeChildren:function() {
  if (this._children) {
    for (var i = 0; i < this._children.length; i++) {
      this.root.appendChild(this._children[i]);
    }
  }
}, _initFeatures:function() {
}, _scopeElementClass:function(element, selector) {
  if (this.dataHost) {
    return this.dataHost._scopeElementClass(element, selector);
  } else {
    return selector;
  }
}, _prepConfigure:function() {
  var config = {};
  for (var prop in this._propertyEffects) {
    config[prop] = this[prop];
  }
  var setupConfigure = this._setupConfigure;
  this._setupConfigure = function() {
    setupConfigure.call(this, config);
  };
}, attached:function() {
  if (this._importsReady) {
    this.render();
  }
}, detached:function() {
  this._removeChildren();
}, render:function() {
  this._ensureReady();
  if (!this._children) {
    this._template = this;
    this._prepAnnotations();
    this._prepEffects();
    this._prepBehaviors();
    this._prepConfigure();
    this._prepBindings();
    this._prepPropertyInfo();
    Polymer.Base._initFeatures.call(this);
    this._children = Polymer.TreeApi.arrayCopyChildNodes(this.root);
  }
  this._insertChildren();
  this.fire("dom-change");
}});
(function() {
  var KEY_IDENTIFIER = {"U+0008":"backspace", "U+0009":"tab", "U+001B":"esc", "U+0020":"space", "U+007F":"del"};
  var KEY_CODE = {8:"backspace", 9:"tab", 13:"enter", 27:"esc", 33:"pageup", 34:"pagedown", 35:"end", 36:"home", 32:"space", 37:"left", 38:"up", 39:"right", 40:"down", 46:"del", 106:"*"};
  var MODIFIER_KEYS = {"shift":"shiftKey", "ctrl":"ctrlKey", "alt":"altKey", "meta":"metaKey"};
  var KEY_CHAR = /[a-z0-9*]/;
  var IDENT_CHAR = /U\+/;
  var ARROW_KEY = /^arrow/;
  var SPACE_KEY = /^space(bar)?/;
  var ESC_KEY = /^escape$/;
  function transformKey(key, noSpecialChars) {
    var validKey = "";
    if (key) {
      var lKey = key.toLowerCase();
      if (lKey === " " || SPACE_KEY.test(lKey)) {
        validKey = "space";
      } else {
        if (ESC_KEY.test(lKey)) {
          validKey = "esc";
        } else {
          if (lKey.length == 1) {
            if (!noSpecialChars || KEY_CHAR.test(lKey)) {
              validKey = lKey;
            }
          } else {
            if (ARROW_KEY.test(lKey)) {
              validKey = lKey.replace("arrow", "");
            } else {
              if (lKey == "multiply") {
                validKey = "*";
              } else {
                validKey = lKey;
              }
            }
          }
        }
      }
    }
    return validKey;
  }
  function transformKeyIdentifier(keyIdent) {
    var validKey = "";
    if (keyIdent) {
      if (keyIdent in KEY_IDENTIFIER) {
        validKey = KEY_IDENTIFIER[keyIdent];
      } else {
        if (IDENT_CHAR.test(keyIdent)) {
          keyIdent = parseInt(keyIdent.replace("U+", "0x"), 16);
          validKey = String.fromCharCode(keyIdent).toLowerCase();
        } else {
          validKey = keyIdent.toLowerCase();
        }
      }
    }
    return validKey;
  }
  function transformKeyCode(keyCode) {
    var validKey = "";
    if (Number(keyCode)) {
      if (keyCode >= 65 && keyCode <= 90) {
        validKey = String.fromCharCode(32 + keyCode);
      } else {
        if (keyCode >= 112 && keyCode <= 123) {
          validKey = "f" + (keyCode - 112);
        } else {
          if (keyCode >= 48 && keyCode <= 57) {
            validKey = String(keyCode - 48);
          } else {
            if (keyCode >= 96 && keyCode <= 105) {
              validKey = String(keyCode - 96);
            } else {
              validKey = KEY_CODE[keyCode];
            }
          }
        }
      }
    }
    return validKey;
  }
  function normalizedKeyForEvent(keyEvent, noSpecialChars) {
    return transformKey(keyEvent.key, noSpecialChars) || transformKeyIdentifier(keyEvent.keyIdentifier) || transformKeyCode(keyEvent.keyCode) || transformKey(keyEvent.detail.key, noSpecialChars) || "";
  }
  function keyComboMatchesEvent(keyCombo, event) {
    var keyEvent = normalizedKeyForEvent(event, keyCombo.hasModifiers);
    return keyEvent === keyCombo.key && (!keyCombo.hasModifiers || !!event.shiftKey === !!keyCombo.shiftKey && !!event.ctrlKey === !!keyCombo.ctrlKey && !!event.altKey === !!keyCombo.altKey && !!event.metaKey === !!keyCombo.metaKey);
  }
  function parseKeyComboString(keyComboString) {
    if (keyComboString.length === 1) {
      return {combo:keyComboString, key:keyComboString, event:"keydown"};
    }
    return keyComboString.split("+").reduce(function(parsedKeyCombo, keyComboPart) {
      var eventParts = keyComboPart.split(":");
      var keyName = eventParts[0];
      var event = eventParts[1];
      if (keyName in MODIFIER_KEYS) {
        parsedKeyCombo[MODIFIER_KEYS[keyName]] = true;
        parsedKeyCombo.hasModifiers = true;
      } else {
        parsedKeyCombo.key = keyName;
        parsedKeyCombo.event = event || "keydown";
      }
      return parsedKeyCombo;
    }, {combo:keyComboString.split(":").shift()});
  }
  function parseEventString(eventString) {
    return eventString.trim().split(" ").map(function(keyComboString) {
      return parseKeyComboString(keyComboString);
    });
  }
  Polymer.IronA11yKeysBehavior = {properties:{keyEventTarget:{type:Object, value:function() {
    return this;
  }}, stopKeyboardEventPropagation:{type:Boolean, value:false}, _boundKeyHandlers:{type:Array, value:function() {
    return [];
  }}, _imperativeKeyBindings:{type:Object, value:function() {
    return {};
  }}}, observers:["_resetKeyEventListeners(keyEventTarget, _boundKeyHandlers)"], keyBindings:{}, registered:function() {
    this._prepKeyBindings();
  }, attached:function() {
    this._listenKeyEventListeners();
  }, detached:function() {
    this._unlistenKeyEventListeners();
  }, addOwnKeyBinding:function(eventString, handlerName) {
    this._imperativeKeyBindings[eventString] = handlerName;
    this._prepKeyBindings();
    this._resetKeyEventListeners();
  }, removeOwnKeyBindings:function() {
    this._imperativeKeyBindings = {};
    this._prepKeyBindings();
    this._resetKeyEventListeners();
  }, keyboardEventMatchesKeys:function(event, eventString) {
    var keyCombos = parseEventString(eventString);
    for (var i = 0; i < keyCombos.length; ++i) {
      if (keyComboMatchesEvent(keyCombos[i], event)) {
        return true;
      }
    }
    return false;
  }, _collectKeyBindings:function() {
    var keyBindings = this.behaviors.map(function(behavior) {
      return behavior.keyBindings;
    });
    if (keyBindings.indexOf(this.keyBindings) === -1) {
      keyBindings.push(this.keyBindings);
    }
    return keyBindings;
  }, _prepKeyBindings:function() {
    this._keyBindings = {};
    this._collectKeyBindings().forEach(function(keyBindings) {
      for (var eventString in keyBindings) {
        this._addKeyBinding(eventString, keyBindings[eventString]);
      }
    }, this);
    for (var eventString in this._imperativeKeyBindings) {
      this._addKeyBinding(eventString, this._imperativeKeyBindings[eventString]);
    }
    for (var eventName in this._keyBindings) {
      this._keyBindings[eventName].sort(function(kb1, kb2) {
        var b1 = kb1[0].hasModifiers;
        var b2 = kb2[0].hasModifiers;
        return b1 === b2 ? 0 : b1 ? -1 : 1;
      });
    }
  }, _addKeyBinding:function(eventString, handlerName) {
    parseEventString(eventString).forEach(function(keyCombo) {
      this._keyBindings[keyCombo.event] = this._keyBindings[keyCombo.event] || [];
      this._keyBindings[keyCombo.event].push([keyCombo, handlerName]);
    }, this);
  }, _resetKeyEventListeners:function() {
    this._unlistenKeyEventListeners();
    if (this.isAttached) {
      this._listenKeyEventListeners();
    }
  }, _listenKeyEventListeners:function() {
    Object.keys(this._keyBindings).forEach(function(eventName) {
      var keyBindings = this._keyBindings[eventName];
      var boundKeyHandler = this._onKeyBindingEvent.bind(this, keyBindings);
      this._boundKeyHandlers.push([this.keyEventTarget, eventName, boundKeyHandler]);
      this.keyEventTarget.addEventListener(eventName, boundKeyHandler);
    }, this);
  }, _unlistenKeyEventListeners:function() {
    var keyHandlerTuple;
    var keyEventTarget;
    var eventName;
    var boundKeyHandler;
    while (this._boundKeyHandlers.length) {
      keyHandlerTuple = this._boundKeyHandlers.pop();
      keyEventTarget = keyHandlerTuple[0];
      eventName = keyHandlerTuple[1];
      boundKeyHandler = keyHandlerTuple[2];
      keyEventTarget.removeEventListener(eventName, boundKeyHandler);
    }
  }, _onKeyBindingEvent:function(keyBindings, event) {
    if (this.stopKeyboardEventPropagation) {
      event.stopPropagation();
    }
    if (event.defaultPrevented) {
      return;
    }
    for (var i = 0; i < keyBindings.length; i++) {
      var keyCombo = keyBindings[i][0];
      var handlerName = keyBindings[i][1];
      if (keyComboMatchesEvent(keyCombo, event)) {
        this._triggerKeyHandler(keyCombo, handlerName, event);
        if (event.defaultPrevented) {
          return;
        }
      }
    }
  }, _triggerKeyHandler:function(keyCombo, handlerName, keyboardEvent) {
    var detail = Object.create(keyCombo);
    detail.keyboardEvent = keyboardEvent;
    var event = new CustomEvent(keyCombo.event, {detail:detail, cancelable:true});
    this[handlerName].call(this, event);
    if (event.defaultPrevented) {
      keyboardEvent.preventDefault();
    }
  }};
})();
Polymer({is:"iron-a11y-keys", behaviors:[Polymer.IronA11yKeysBehavior], properties:{target:{type:Object, observer:"_targetChanged"}, keys:{type:String, reflectToAttribute:true, observer:"_keysChanged"}}, attached:function() {
  if (!this.target) {
    this.target = this.parentNode;
  }
}, _targetChanged:function(target) {
  this.keyEventTarget = target;
}, _keysChanged:function() {
  this.removeOwnKeyBindings();
  this.addOwnKeyBinding(this.keys, "_fireKeysPressed");
}, _fireKeysPressed:function(event) {
  this.fire("keys-pressed", event.detail, {});
}});
function MakePromise(asap) {
  function Promise(fn) {
    if (typeof this !== "object" || typeof fn !== "function") {
      throw new TypeError;
    }
    this._state = null;
    this._value = null;
    this._deferreds = [];
    doResolve(fn, resolve.bind(this), reject.bind(this));
  }
  function handle(deferred) {
    var me = this;
    if (this._state === null) {
      this._deferreds.push(deferred);
      return;
    }
    asap(function() {
      var cb = me._state ? deferred.onFulfilled : deferred.onRejected;
      if (typeof cb !== "function") {
        (me._state ? deferred.resolve : deferred.reject)(me._value);
        return;
      }
      var ret;
      try {
        ret = cb(me._value);
      } catch (e) {
        deferred.reject(e);
        return;
      }
      deferred.resolve(ret);
    });
  }
  function resolve(newValue) {
    try {
      if (newValue === this) {
        throw new TypeError;
      }
      if (newValue && (typeof newValue === "object" || typeof newValue === "function")) {
        var then = newValue.then;
        if (typeof then === "function") {
          doResolve(then.bind(newValue), resolve.bind(this), reject.bind(this));
          return;
        }
      }
      this._state = true;
      this._value = newValue;
      finale.call(this);
    } catch (e) {
      reject.call(this, e);
    }
  }
  function reject(newValue) {
    this._state = false;
    this._value = newValue;
    finale.call(this);
  }
  function finale() {
    for (var i = 0, len = this._deferreds.length; i < len; i++) {
      handle.call(this, this._deferreds[i]);
    }
    this._deferreds = null;
  }
  function doResolve(fn, onFulfilled, onRejected) {
    var done = false;
    try {
      fn(function(value) {
        if (done) {
          return;
        }
        done = true;
        onFulfilled(value);
      }, function(reason) {
        if (done) {
          return;
        }
        done = true;
        onRejected(reason);
      });
    } catch (ex) {
      if (done) {
        return;
      }
      done = true;
      onRejected(ex);
    }
  }
  Promise.prototype["catch"] = function(onRejected) {
    return this.then(null, onRejected);
  };
  Promise.prototype.then = function(onFulfilled, onRejected) {
    var me = this;
    return new Promise(function(resolve, reject) {
      handle.call(me, {onFulfilled:onFulfilled, onRejected:onRejected, resolve:resolve, reject:reject});
    });
  };
  Promise.resolve = function(value) {
    if (value && typeof value === "object" && value.constructor === Promise) {
      return value;
    }
    return new Promise(function(resolve) {
      resolve(value);
    });
  };
  Promise.reject = function(value) {
    return new Promise(function(resolve, reject) {
      reject(value);
    });
  };
  return Promise;
}
if (typeof module !== "undefined") {
  module.exports = MakePromise;
}
if (!window.Promise) {
  window.Promise = MakePromise(Polymer.Base.async);
}
"use strict";
Polymer({is:"iron-request", hostAttributes:{hidden:true}, properties:{xhr:{type:Object, notify:true, readOnly:true, value:function() {
  return new XMLHttpRequest;
}}, response:{type:Object, notify:true, readOnly:true, value:function() {
  return null;
}}, status:{type:Number, notify:true, readOnly:true, value:0}, statusText:{type:String, notify:true, readOnly:true, value:""}, completes:{type:Object, readOnly:true, notify:true, value:function() {
  return new Promise(function(resolve, reject) {
    this.resolveCompletes = resolve;
    this.rejectCompletes = reject;
  }.bind(this));
}}, progress:{type:Object, notify:true, readOnly:true, value:function() {
  return {};
}}, aborted:{type:Boolean, notify:true, readOnly:true, value:false}, errored:{type:Boolean, notify:true, readOnly:true, value:false}, timedOut:{type:Boolean, notify:true, readOnly:true, value:false}}, get succeeded() {
  if (this.errored || this.aborted || this.timedOut) {
    return false;
  }
  var status = this.xhr.status || 0;
  return status === 0 || status >= 200 && status < 300;
}, send:function(options) {
  var xhr = this.xhr;
  if (xhr.readyState > 0) {
    return null;
  }
  xhr.addEventListener("progress", function(progress) {
    this._setProgress({lengthComputable:progress.lengthComputable, loaded:progress.loaded, total:progress.total});
  }.bind(this));
  xhr.addEventListener("error", function(error) {
    this._setErrored(true);
    this._updateStatus();
    this.rejectCompletes(error);
  }.bind(this));
  xhr.addEventListener("timeout", function(error) {
    this._setTimedOut(true);
    this._updateStatus();
    this.rejectCompletes(error);
  }.bind(this));
  xhr.addEventListener("abort", function() {
    this._updateStatus();
    this.rejectCompletes(new Error("Request aborted."));
  }.bind(this));
  xhr.addEventListener("loadend", function() {
    this._updateStatus();
    if (!this.succeeded) {
      this.rejectCompletes(new Error("The request failed with status code: " + this.xhr.status));
      return;
    }
    this._setResponse(this.parseResponse());
    this.resolveCompletes(this);
  }.bind(this));
  this.url = options.url;
  xhr.open(options.method || "GET", options.url, options.async !== false);
  var acceptType = {"json":"application/json", "text":"text/plain", "html":"text/html", "xml":"application/xml", "arraybuffer":"application/octet-stream"}[options.handleAs];
  var headers = options.headers || Object.create(null);
  var newHeaders = Object.create(null);
  for (var key in headers) {
    newHeaders[key.toLowerCase()] = headers[key];
  }
  headers = newHeaders;
  if (acceptType && !headers["accept"]) {
    headers["accept"] = acceptType;
  }
  Object.keys(headers).forEach(function(requestHeader) {
    if (/[A-Z]/.test(requestHeader)) {
      console.error("Headers must be lower case, got", requestHeader);
    }
    xhr.setRequestHeader(requestHeader, headers[requestHeader]);
  }, this);
  if (options.async !== false) {
    var handleAs = options.handleAs;
    if (!!options.jsonPrefix || !handleAs) {
      handleAs = "text";
    }
    xhr.responseType = xhr._responseType = handleAs;
    if (!!options.jsonPrefix) {
      xhr._jsonPrefix = options.jsonPrefix;
    }
  }
  xhr.withCredentials = !!options.withCredentials;
  xhr.timeout = options.timeout;
  var body = this._encodeBodyObject(options.body, headers["content-type"]);
  xhr.send(body);
  return this.completes;
}, parseResponse:function() {
  var xhr = this.xhr;
  var responseType = xhr.responseType || xhr._responseType;
  var preferResponseText = !this.xhr.responseType;
  var prefixLen = xhr._jsonPrefix && xhr._jsonPrefix.length || 0;
  try {
    switch(responseType) {
      case "json":
        if (preferResponseText || xhr.response === undefined) {
          try {
            return JSON.parse(xhr.responseText);
          } catch (_$1) {
            return null;
          }
        }
        return xhr.response;
      case "xml":
        return xhr.responseXML;
      case "blob":
      case "document":
      case "arraybuffer":
        return xhr.response;
      case "text":
      default:
        {
          if (prefixLen) {
            try {
              return JSON.parse(xhr.responseText.substring(prefixLen));
            } catch (_$2) {
              return null;
            }
          }
          return xhr.responseText;
        }
    }
  } catch (e) {
    this.rejectCompletes(new Error("Could not parse response. " + e.message));
  }
}, abort:function() {
  this._setAborted(true);
  this.xhr.abort();
}, _encodeBodyObject:function(body, contentType) {
  if (typeof body == "string") {
    return body;
  }
  var bodyObj = body;
  switch(contentType) {
    case "application/json":
      return JSON.stringify(bodyObj);
    case "application/x-www-form-urlencoded":
      return this._wwwFormUrlEncode(bodyObj);
  }
  return body;
}, _wwwFormUrlEncode:function(object) {
  if (!object) {
    return "";
  }
  var pieces = [];
  Object.keys(object).forEach(function(key) {
    pieces.push(this._wwwFormUrlEncodePiece(key) + "=" + this._wwwFormUrlEncodePiece(object[key]));
  }, this);
  return pieces.join("&");
}, _wwwFormUrlEncodePiece:function(str) {
  return encodeURIComponent(str.toString().replace(/\r?\n/g, "\r\n")).replace(/%20/g, "+");
}, _updateStatus:function() {
  this._setStatus(this.xhr.status);
  this._setStatusText(this.xhr.statusText === undefined ? "" : this.xhr.statusText);
}});
"use strict";
Polymer({is:"iron-ajax", hostAttributes:{hidden:true}, properties:{url:{type:String}, params:{type:Object, value:function() {
  return {};
}}, method:{type:String, value:"GET"}, headers:{type:Object, value:function() {
  return {};
}}, contentType:{type:String, value:null}, body:{type:Object, value:null}, sync:{type:Boolean, value:false}, handleAs:{type:String, value:"json"}, withCredentials:{type:Boolean, value:false}, timeout:{type:Number, value:0}, auto:{type:Boolean, value:false}, verbose:{type:Boolean, value:false}, lastRequest:{type:Object, notify:true, readOnly:true}, loading:{type:Boolean, notify:true, readOnly:true}, lastResponse:{type:Object, notify:true, readOnly:true}, lastError:{type:Object, notify:true, readOnly:true}, 
activeRequests:{type:Array, notify:true, readOnly:true, value:function() {
  return [];
}}, debounceDuration:{type:Number, value:0, notify:true}, jsonPrefix:{type:String, value:""}, bubbles:{type:Boolean, value:false}, _boundHandleResponse:{type:Function, value:function() {
  return this._handleResponse.bind(this);
}}}, observers:["_requestOptionsChanged(url, method, params.*, headers, contentType, " + "body, sync, handleAs, jsonPrefix, withCredentials, timeout, auto)"], get queryString() {
  var queryParts = [];
  var param;
  var value;
  for (param in this.params) {
    value = this.params[param];
    param = window.encodeURIComponent(param);
    if (Array.isArray(value)) {
      for (var i = 0; i < value.length; i++) {
        queryParts.push(param + "=" + window.encodeURIComponent(value[i]));
      }
    } else {
      if (value !== null) {
        queryParts.push(param + "=" + window.encodeURIComponent(value));
      } else {
        queryParts.push(param);
      }
    }
  }
  return queryParts.join("&");
}, get requestUrl() {
  var queryString = this.queryString;
  if (queryString) {
    var bindingChar = this.url.indexOf("?") >= 0 ? "&" : "?";
    return this.url + bindingChar + queryString;
  }
  return this.url;
}, get requestHeaders() {
  var headers = {};
  var contentType = this.contentType;
  if (contentType == null && typeof this.body === "string") {
    contentType = "application/x-www-form-urlencoded";
  }
  if (contentType) {
    headers["content-type"] = contentType;
  }
  var header;
  if (this.headers instanceof Object) {
    for (header in this.headers) {
      headers[header] = this.headers[header].toString();
    }
  }
  return headers;
}, toRequestOptions:function() {
  return {url:this.requestUrl || "", method:this.method, headers:this.requestHeaders, body:this.body, async:!this.sync, handleAs:this.handleAs, jsonPrefix:this.jsonPrefix, withCredentials:this.withCredentials, timeout:this.timeout};
}, generateRequest:function() {
  var request = document.createElement("iron-request");
  var requestOptions = this.toRequestOptions();
  this.activeRequests.push(request);
  request.completes.then(this._boundHandleResponse).catch(this._handleError.bind(this, request)).then(this._discardRequest.bind(this, request));
  request.send(requestOptions);
  this._setLastRequest(request);
  this._setLoading(true);
  this.fire("request", {request:request, options:requestOptions}, {bubbles:this.bubbles});
  return request;
}, _handleResponse:function(request) {
  if (request === this.lastRequest) {
    this._setLastResponse(request.response);
    this._setLastError(null);
    this._setLoading(false);
  }
  this.fire("response", request, {bubbles:this.bubbles});
}, _handleError:function(request, error) {
  if (this.verbose) {
    console.error(error);
  }
  if (request === this.lastRequest) {
    this._setLastError({request:request, error:error});
    this._setLastResponse(null);
    this._setLoading(false);
  }
  this.fire("error", {request:request, error:error}, {bubbles:this.bubbles});
}, _discardRequest:function(request) {
  var requestIndex = this.activeRequests.indexOf(request);
  if (requestIndex > -1) {
    this.activeRequests.splice(requestIndex, 1);
  }
}, _requestOptionsChanged:function() {
  this.debounce("generate-request", function() {
    if (this.url == null) {
      return;
    }
    if (this.auto) {
      this.generateRequest();
    }
  }, this.debounceDuration);
}});
Polymer.IronControlState = {properties:{focused:{type:Boolean, value:false, notify:true, readOnly:true, reflectToAttribute:true}, disabled:{type:Boolean, value:false, notify:true, observer:"_disabledChanged", reflectToAttribute:true}, _oldTabIndex:{type:Number}, _boundFocusBlurHandler:{type:Function, value:function() {
  return this._focusBlurHandler.bind(this);
}}}, observers:["_changedControlState(focused, disabled)"], ready:function() {
  this.addEventListener("focus", this._boundFocusBlurHandler, true);
  this.addEventListener("blur", this._boundFocusBlurHandler, true);
}, _focusBlurHandler:function(event) {
  if (event.target === this) {
    this._setFocused(event.type === "focus");
  } else {
    if (!this.shadowRoot) {
      var target = Polymer.dom(event).localTarget;
      if (!this.isLightDescendant(target)) {
        this.fire(event.type, {sourceEvent:event}, {node:this, bubbles:event.bubbles, cancelable:event.cancelable});
      }
    }
  }
}, _disabledChanged:function(disabled, old) {
  this.setAttribute("aria-disabled", disabled ? "true" : "false");
  this.style.pointerEvents = disabled ? "none" : "";
  if (disabled) {
    this._oldTabIndex = this.tabIndex;
    this._setFocused(false);
    this.tabIndex = -1;
    this.blur();
  } else {
    if (this._oldTabIndex !== undefined) {
      this.tabIndex = this._oldTabIndex;
    }
  }
}, _changedControlState:function() {
  if (this._controlStateChanged) {
    this._controlStateChanged();
  }
}};
(function() {
  var metaDatas = {};
  var metaArrays = {};
  var singleton = null;
  Polymer.IronMeta = Polymer({is:"iron-meta", properties:{type:{type:String, value:"default", observer:"_typeChanged"}, key:{type:String, observer:"_keyChanged"}, value:{type:Object, notify:true, observer:"_valueChanged"}, self:{type:Boolean, observer:"_selfChanged"}, list:{type:Array, notify:true}}, hostAttributes:{hidden:true}, factoryImpl:function(config) {
    if (config) {
      for (var n in config) {
        switch(n) {
          case "type":
          case "key":
          case "value":
            this[n] = config[n];
            break;
        }
      }
    }
  }, created:function() {
    this._metaDatas = metaDatas;
    this._metaArrays = metaArrays;
  }, _keyChanged:function(key, old) {
    this._resetRegistration(old);
  }, _valueChanged:function(value) {
    this._resetRegistration(this.key);
  }, _selfChanged:function(self) {
    if (self) {
      this.value = this;
    }
  }, _typeChanged:function(type) {
    this._unregisterKey(this.key);
    if (!metaDatas[type]) {
      metaDatas[type] = {};
    }
    this._metaData = metaDatas[type];
    if (!metaArrays[type]) {
      metaArrays[type] = [];
    }
    this.list = metaArrays[type];
    this._registerKeyValue(this.key, this.value);
  }, byKey:function(key) {
    return this._metaData && this._metaData[key];
  }, _resetRegistration:function(oldKey) {
    this._unregisterKey(oldKey);
    this._registerKeyValue(this.key, this.value);
  }, _unregisterKey:function(key) {
    this._unregister(key, this._metaData, this.list);
  }, _registerKeyValue:function(key, value) {
    this._register(key, value, this._metaData, this.list);
  }, _register:function(key, value, data, list) {
    if (key && data && value !== undefined) {
      data[key] = value;
      list.push(value);
    }
  }, _unregister:function(key, data, list) {
    if (key && data) {
      if (key in data) {
        var value = data[key];
        delete data[key];
        this.arrayDelete(list, value);
      }
    }
  }});
  Polymer.IronMeta.getIronMeta = function getIronMeta() {
    if (singleton === null) {
      singleton = new Polymer.IronMeta;
    }
    return singleton;
  };
  Polymer.IronMetaQuery = Polymer({is:"iron-meta-query", properties:{type:{type:String, value:"default", observer:"_typeChanged"}, key:{type:String, observer:"_keyChanged"}, value:{type:Object, notify:true, readOnly:true}, list:{type:Array, notify:true}}, factoryImpl:function(config) {
    if (config) {
      for (var n in config) {
        switch(n) {
          case "type":
          case "key":
            this[n] = config[n];
            break;
        }
      }
    }
  }, created:function() {
    this._metaDatas = metaDatas;
    this._metaArrays = metaArrays;
  }, _keyChanged:function(key) {
    this._setValue(this._metaData && this._metaData[key]);
  }, _typeChanged:function(type) {
    this._metaData = metaDatas[type];
    this.list = metaArrays[type];
    if (this.key) {
      this._keyChanged(this.key);
    }
  }, byKey:function(key) {
    return this._metaData && this._metaData[key];
  }});
})();
Polymer.IronValidatableBehaviorMeta = null;
Polymer.IronValidatableBehavior = {properties:{validator:{type:String}, invalid:{notify:true, reflectToAttribute:true, type:Boolean, value:false}, _validatorMeta:{type:Object}, validatorType:{type:String, value:"validator"}, _validator:{type:Object, computed:"__computeValidator(validator)"}}, observers:["_invalidChanged(invalid)"], registered:function() {
  Polymer.IronValidatableBehaviorMeta = new Polymer.IronMeta({type:"validator"});
}, _invalidChanged:function() {
  if (this.invalid) {
    this.setAttribute("aria-invalid", "true");
  } else {
    this.removeAttribute("aria-invalid");
  }
}, hasValidator:function() {
  return this._validator != null;
}, validate:function(value) {
  this.invalid = !this._getValidity(value);
  return !this.invalid;
}, _getValidity:function(value) {
  if (this.hasValidator()) {
    return this._validator.validate(value);
  }
  return true;
}, __computeValidator:function() {
  return Polymer.IronValidatableBehaviorMeta && Polymer.IronValidatableBehaviorMeta.byKey(this.validator);
}};
Polymer.IronFormElementBehavior = {properties:{name:{type:String}, value:{notify:true, type:String}, required:{type:Boolean, value:false}, _parentForm:{type:Object}}, attached:function() {
  this.fire("iron-form-element-register");
}, detached:function() {
  if (this._parentForm) {
    this._parentForm.fire("iron-form-element-unregister", {target:this});
  }
}};
Polymer({is:"iron-autogrow-textarea", behaviors:[Polymer.IronFormElementBehavior, Polymer.IronValidatableBehavior, Polymer.IronControlState], properties:{bindValue:{observer:"_bindValueChanged", type:String}, rows:{type:Number, value:1, observer:"_updateCached"}, maxRows:{type:Number, value:0, observer:"_updateCached"}, autocomplete:{type:String, value:"off"}, autofocus:{type:Boolean, value:false}, inputmode:{type:String}, placeholder:{type:String}, readonly:{type:String}, required:{type:Boolean}, 
maxlength:{type:Number}}, listeners:{"input":"_onInput"}, observers:["_onValueChanged(value)"], get textarea() {
  return this.$.textarea;
}, get selectionStart() {
  return this.$.textarea.selectionStart;
}, get selectionEnd() {
  return this.$.textarea.selectionEnd;
}, set selectionStart(value) {
  this.$.textarea.selectionStart = value;
}, set selectionEnd(value) {
  this.$.textarea.selectionEnd = value;
}, validate:function() {
  if (!this.required && this.value == "") {
    this.invalid = false;
    return true;
  }
  var valid;
  if (this.hasValidator()) {
    valid = Polymer.IronValidatableBehavior.validate.call(this, this.value);
  } else {
    valid = this.$.textarea.validity.valid;
    this.invalid = !valid;
  }
  this.fire("iron-input-validate");
  return valid;
}, _bindValueChanged:function() {
  var textarea = this.textarea;
  if (!textarea) {
    return;
  }
  if (textarea.value !== this.bindValue) {
    textarea.value = !(this.bindValue || this.bindValue === 0) ? "" : this.bindValue;
  }
  this.value = this.bindValue;
  this.$.mirror.innerHTML = this._valueForMirror();
  this.fire("bind-value-changed", {value:this.bindValue});
}, _onInput:function(event) {
  this.bindValue = event.path ? event.path[0].value : event.target.value;
}, _constrain:function(tokens) {
  var _tokens;
  tokens = tokens || [""];
  if (this.maxRows > 0 && tokens.length > this.maxRows) {
    _tokens = tokens.slice(0, this.maxRows);
  } else {
    _tokens = tokens.slice(0);
  }
  while (this.rows > 0 && _tokens.length < this.rows) {
    _tokens.push("");
  }
  return _tokens.join("<br/>") + "&#160;";
}, _valueForMirror:function() {
  var input = this.textarea;
  if (!input) {
    return;
  }
  this.tokens = input && input.value ? input.value.replace(/&/gm, "&amp;").replace(/"/gm, "&quot;").replace(/'/gm, "&#39;").replace(/</gm, "&lt;").replace(/>/gm, "&gt;").split("\n") : [""];
  return this._constrain(this.tokens);
}, _updateCached:function() {
  this.$.mirror.innerHTML = this._constrain(this.tokens);
}, _onValueChanged:function() {
  this.bindValue = this.value;
}});
Polymer.IronButtonStateImpl = {properties:{pressed:{type:Boolean, readOnly:true, value:false, reflectToAttribute:true, observer:"_pressedChanged"}, toggles:{type:Boolean, value:false, reflectToAttribute:true}, active:{type:Boolean, value:false, notify:true, reflectToAttribute:true}, pointerDown:{type:Boolean, readOnly:true, value:false}, receivedFocusFromKeyboard:{type:Boolean, readOnly:true}, ariaActiveAttribute:{type:String, value:"aria-pressed", observer:"_ariaActiveAttributeChanged"}}, listeners:{down:"_downHandler", 
up:"_upHandler", tap:"_tapHandler"}, observers:["_detectKeyboardFocus(focused)", "_activeChanged(active, ariaActiveAttribute)"], keyBindings:{"enter:keydown":"_asyncClick", "space:keydown":"_spaceKeyDownHandler", "space:keyup":"_spaceKeyUpHandler"}, _mouseEventRe:/^mouse/, _tapHandler:function() {
  if (this.toggles) {
    this._userActivate(!this.active);
  } else {
    this.active = false;
  }
}, _detectKeyboardFocus:function(focused) {
  this._setReceivedFocusFromKeyboard(!this.pointerDown && focused);
}, _userActivate:function(active) {
  if (this.active !== active) {
    this.active = active;
    this.fire("change");
  }
}, _downHandler:function(event) {
  this._setPointerDown(true);
  this._setPressed(true);
  this._setReceivedFocusFromKeyboard(false);
}, _upHandler:function() {
  this._setPointerDown(false);
  this._setPressed(false);
}, _spaceKeyDownHandler:function(event) {
  var keyboardEvent = event.detail.keyboardEvent;
  var target = Polymer.dom(keyboardEvent).localTarget;
  if (this.isLightDescendant(target)) {
    return;
  }
  keyboardEvent.preventDefault();
  keyboardEvent.stopImmediatePropagation();
  this._setPressed(true);
}, _spaceKeyUpHandler:function(event) {
  var keyboardEvent = event.detail.keyboardEvent;
  var target = Polymer.dom(keyboardEvent).localTarget;
  if (this.isLightDescendant(target)) {
    return;
  }
  if (this.pressed) {
    this._asyncClick();
  }
  this._setPressed(false);
}, _asyncClick:function() {
  this.async(function() {
    this.click();
  }, 1);
}, _pressedChanged:function(pressed) {
  this._changedButtonState();
}, _ariaActiveAttributeChanged:function(value, oldValue) {
  if (oldValue && oldValue != value && this.hasAttribute(oldValue)) {
    this.removeAttribute(oldValue);
  }
}, _activeChanged:function(active, ariaActiveAttribute) {
  if (this.toggles) {
    this.setAttribute(this.ariaActiveAttribute, active ? "true" : "false");
  } else {
    this.removeAttribute(this.ariaActiveAttribute);
  }
  this._changedButtonState();
}, _controlStateChanged:function() {
  if (this.disabled) {
    this._setPressed(false);
  } else {
    this._changedButtonState();
  }
}, _changedButtonState:function() {
  if (this._buttonStateChanged) {
    this._buttonStateChanged();
  }
}};
Polymer.IronButtonState = [Polymer.IronA11yKeysBehavior, Polymer.IronButtonStateImpl];
Polymer.IronResizableBehavior = {properties:{_parentResizable:{type:Object, observer:"_parentResizableChanged"}, _notifyingDescendant:{type:Boolean, value:false}}, listeners:{"iron-request-resize-notifications":"_onIronRequestResizeNotifications"}, created:function() {
  this._interestedResizables = [];
  this._boundNotifyResize = this.notifyResize.bind(this);
}, attached:function() {
  this.fire("iron-request-resize-notifications", null, {node:this, bubbles:true, cancelable:true});
  if (!this._parentResizable) {
    window.addEventListener("resize", this._boundNotifyResize);
    this.notifyResize();
  }
}, detached:function() {
  if (this._parentResizable) {
    this._parentResizable.stopResizeNotificationsFor(this);
  } else {
    window.removeEventListener("resize", this._boundNotifyResize);
  }
  this._parentResizable = null;
}, notifyResize:function() {
  if (!this.isAttached) {
    return;
  }
  this._interestedResizables.forEach(function(resizable) {
    if (this.resizerShouldNotify(resizable)) {
      this._notifyDescendant(resizable);
    }
  }, this);
  this._fireResize();
}, assignParentResizable:function(parentResizable) {
  this._parentResizable = parentResizable;
}, stopResizeNotificationsFor:function(target) {
  var index = this._interestedResizables.indexOf(target);
  if (index > -1) {
    this._interestedResizables.splice(index, 1);
    this.unlisten(target, "iron-resize", "_onDescendantIronResize");
  }
}, resizerShouldNotify:function(element) {
  return true;
}, _onDescendantIronResize:function(event) {
  if (this._notifyingDescendant) {
    event.stopPropagation();
    return;
  }
  if (!Polymer.Settings.useShadow) {
    this._fireResize();
  }
}, _fireResize:function() {
  this.fire("iron-resize", null, {node:this, bubbles:false});
}, _onIronRequestResizeNotifications:function(event) {
  var target = event.path ? event.path[0] : event.target;
  if (target === this) {
    return;
  }
  if (this._interestedResizables.indexOf(target) === -1) {
    this._interestedResizables.push(target);
    this.listen(target, "iron-resize", "_onDescendantIronResize");
  }
  target.assignParentResizable(this);
  this._notifyDescendant(target);
  event.stopPropagation();
}, _parentResizableChanged:function(parentResizable) {
  if (parentResizable) {
    window.removeEventListener("resize", this._boundNotifyResize);
  }
}, _notifyDescendant:function(descendant) {
  if (!this.isAttached) {
    return;
  }
  this._notifyingDescendant = true;
  descendant.notifyResize();
  this._notifyingDescendant = false;
}};
Polymer({is:"iron-collapse", behaviors:[Polymer.IronResizableBehavior], properties:{horizontal:{type:Boolean, value:false, observer:"_horizontalChanged"}, opened:{type:Boolean, value:false, notify:true, observer:"_openedChanged"}, noAnimation:{type:Boolean}}, get dimension() {
  return this.horizontal ? "width" : "height";
}, hostAttributes:{role:"group", "aria-hidden":"true", "aria-expanded":"false"}, listeners:{transitionend:"_transitionEnd"}, attached:function() {
  this._transitionEnd();
}, toggle:function() {
  this.opened = !this.opened;
}, show:function() {
  this.opened = true;
}, hide:function() {
  this.opened = false;
}, updateSize:function(size, animated) {
  if (this.style[this.dimension] === size) {
    return;
  }
  this._updateTransition(false);
  if (animated && !this.noAnimation && this._isDisplayed) {
    var startSize = this._calcSize();
    if (size === "auto") {
      this.style[this.dimension] = size;
      size = this._calcSize();
    }
    this.style[this.dimension] = startSize;
    this.offsetHeight = this.offsetHeight;
    this._updateTransition(true);
  }
  this.style[this.dimension] = size;
}, enableTransition:function(enabled) {
  console.warn("`enableTransition()` is deprecated, use `noAnimation` instead.");
  this.noAnimation = !enabled;
}, _updateTransition:function(enabled) {
  this.style.transitionDuration = enabled && !this.noAnimation ? "" : "0s";
}, _horizontalChanged:function() {
  this.style.transitionProperty = this.dimension;
  var otherDimension = this.dimension === "width" ? "height" : "width";
  this.style[otherDimension] = "";
  this.updateSize(this.opened ? "auto" : "0px", false);
}, _openedChanged:function() {
  this.setAttribute("aria-expanded", this.opened);
  this.setAttribute("aria-hidden", !this.opened);
  this.toggleClass("iron-collapse-closed", false);
  this.toggleClass("iron-collapse-opened", false);
  this.updateSize(this.opened ? "auto" : "0px", true);
  if (this.opened) {
    this.focus();
  }
  if (this.noAnimation) {
    this._transitionEnd();
  }
}, _transitionEnd:function() {
  if (this.opened) {
    this.style[this.dimension] = "auto";
  }
  this.toggleClass("iron-collapse-closed", !this.opened);
  this.toggleClass("iron-collapse-opened", this.opened);
  this._updateTransition(false);
  this.notifyResize();
}, get _isDisplayed() {
  var rect = this.getBoundingClientRect();
  for (var prop in rect) {
    if (rect[prop] !== 0) {
      return true;
    }
  }
  return false;
}, _calcSize:function() {
  return this.getBoundingClientRect()[this.dimension] + "px";
}});
Polymer({is:"iron-icon", properties:{icon:{type:String, observer:"_iconChanged"}, theme:{type:String, observer:"_updateIcon"}, src:{type:String, observer:"_srcChanged"}, _meta:{value:Polymer.Base.create("iron-meta", {type:"iconset"}), observer:"_updateIcon"}}, _DEFAULT_ICONSET:"icons", _iconChanged:function(icon) {
  var parts = (icon || "").split(":");
  this._iconName = parts.pop();
  this._iconsetName = parts.pop() || this._DEFAULT_ICONSET;
  this._updateIcon();
}, _srcChanged:function(src) {
  this._updateIcon();
}, _usesIconset:function() {
  return this.icon || !this.src;
}, _updateIcon:function() {
  if (this._usesIconset()) {
    if (this._img && this._img.parentNode) {
      Polymer.dom(this.root).removeChild(this._img);
    }
    if (this._iconName === "") {
      if (this._iconset) {
        this._iconset.removeIcon(this);
      }
    } else {
      if (this._iconsetName && this._meta) {
        this._iconset = this._meta.byKey(this._iconsetName);
        if (this._iconset) {
          this._iconset.applyIcon(this, this._iconName, this.theme);
          this.unlisten(window, "iron-iconset-added", "_updateIcon");
        } else {
          this.listen(window, "iron-iconset-added", "_updateIcon");
        }
      }
    }
  } else {
    if (this._iconset) {
      this._iconset.removeIcon(this);
    }
    if (!this._img) {
      this._img = document.createElement("img");
      this._img.style.width = "100%";
      this._img.style.height = "100%";
      this._img.draggable = false;
    }
    this._img.src = this.src;
    Polymer.dom(this.root).appendChild(this._img);
  }
}});
Polymer({is:"iron-iconset-svg", properties:{name:{type:String, observer:"_nameChanged"}, size:{type:Number, value:24}}, attached:function() {
  this.style.display = "none";
}, getIconNames:function() {
  this._icons = this._createIconMap();
  return Object.keys(this._icons).map(function(n) {
    return this.name + ":" + n;
  }, this);
}, applyIcon:function(element, iconName) {
  element = element.root || element;
  this.removeIcon(element);
  var svg = this._cloneIcon(iconName);
  if (svg) {
    var pde = Polymer.dom(element);
    pde.insertBefore(svg, pde.childNodes[0]);
    return element._svgIcon = svg;
  }
  return null;
}, removeIcon:function(element) {
  if (element._svgIcon) {
    Polymer.dom(element).removeChild(element._svgIcon);
    element._svgIcon = null;
  }
}, _nameChanged:function() {
  new Polymer.IronMeta({type:"iconset", key:this.name, value:this});
  this.async(function() {
    this.fire("iron-iconset-added", this, {node:window});
  });
}, _createIconMap:function() {
  var icons = Object.create(null);
  Polymer.dom(this).querySelectorAll("[id]").forEach(function(icon) {
    icons[icon.id] = icon;
  });
  return icons;
}, _cloneIcon:function(id) {
  this._icons = this._icons || this._createIconMap();
  return this._prepareSvgClone(this._icons[id], this.size);
}, _prepareSvgClone:function(sourceSvg, size) {
  if (sourceSvg) {
    var content = sourceSvg.cloneNode(true), svg = document.createElementNS("http://www.w3.org/2000/svg", "svg"), viewBox = content.getAttribute("viewBox") || "0 0 " + size + " " + size;
    svg.setAttribute("viewBox", viewBox);
    svg.setAttribute("preserveAspectRatio", "xMidYMid meet");
    svg.style.cssText = "pointer-events: none; display: block; width: 100%; height: 100%;";
    svg.appendChild(content).removeAttribute("id");
    return svg;
  }
  return null;
}});
Polymer({is:"iron-iconset", properties:{src:{type:String, observer:"_srcChanged"}, name:{type:String, observer:"_nameChanged"}, width:{type:Number, value:0}, icons:{type:String}, size:{type:Number, value:24}, _offsetX:{type:Number, value:0}, _offsetY:{type:Number, value:0}, iconNames:{type:Array, notify:true}}, hostAttributes:{style:"display: none;"}, ready:function() {
  this._themes = this._mapThemes();
}, applyIcon:function(element, icon, theme, scale) {
  this._validateIconMap();
  var offset = this._getThemedOffset(icon, theme);
  if (element && offset) {
    this._addIconStyles(element, this._srcUrl, offset, scale || 1, this.size, this.width);
  }
}, removeIcon:function(element) {
  this._removeIconStyles(element.style);
}, _mapThemes:function() {
  var themes = Object.create(null);
  Polymer.dom(this).querySelectorAll("property[theme]").forEach(function(property) {
    var offsetX = window.parseInt(property.getAttribute("offset-x"), 10) || 0;
    var offsetY = window.parseInt(property.getAttribute("offset-y"), 10) || 0;
    themes[property.getAttribute("theme")] = {offsetX:offsetX, offsetY:offsetY};
  });
  return themes;
}, _srcChanged:function(src) {
  this._srcUrl = this.ownerDocument !== document ? this.resolveUrl(src) : src;
  this._prepareIconset();
}, _nameChanged:function(name) {
  this._prepareIconset();
}, _prepareIconset:function() {
  new Polymer.IronMeta({type:"iconset", key:this.name, value:this});
  this.async(function() {
    this.fire("iron-iconset-added", this, {node:window});
  });
}, _invalidateIconMap:function() {
  this._iconMapValid = false;
}, _validateIconMap:function() {
  if (!this._iconMapValid) {
    this._recomputeIconMap();
    this._iconMapValid = true;
  }
}, _recomputeIconMap:function() {
  this.iconNames = this._computeIconNames(this.icons);
  this.iconMap = this._computeIconMap(this._offsetX, this._offsetY, this.size, this.width, this.iconNames);
}, _computeIconNames:function(icons) {
  return icons.split(/\s+/g);
}, _computeIconMap:function(offsetX, offsetY, size, width, iconNames) {
  var iconMap = {};
  if (offsetX !== undefined && offsetY !== undefined) {
    var x0 = offsetX;
    iconNames.forEach(function(iconName) {
      iconMap[iconName] = {offsetX:offsetX, offsetY:offsetY};
      if (offsetX + size < width) {
        offsetX += size;
      } else {
        offsetX = x0;
        offsetY += size;
      }
    }, this);
  }
  return iconMap;
}, _getThemedOffset:function(identifier, theme) {
  var iconOffset = this._getIconOffset(identifier);
  var themeOffset = this._themes[theme];
  if (iconOffset && themeOffset) {
    return {offsetX:iconOffset.offsetX + themeOffset.offsetX, offsetY:iconOffset.offsetY + themeOffset.offsetY};
  }
  return iconOffset;
}, _getIconOffset:function(identifier) {
  return this.iconMap[identifier] || this.iconMap[this.iconNames[Number(identifier)]];
}, _addIconStyles:function(element, url, offset, scale, size, width) {
  var style = element.style;
  style.backgroundImage = "url(" + url + ")";
  style.backgroundPosition = -offset.offsetX * scale + "px" + " " + (-offset.offsetY * scale + "px");
  style.backgroundSize = scale === 1 ? "auto" : width * scale + "px";
  style.width = size + "px";
  style.height = size + "px";
  element.setAttribute("role", "img");
}, _removeIconStyles:function(style) {
  style.background = "";
}});
Polymer({is:"iron-image", properties:{src:{observer:"_srcChanged", type:String, value:""}, alt:{type:String, value:null}, preventLoad:{type:Boolean, value:false, observer:"_preventLoadChanged"}, sizing:{type:String, value:null, reflectToAttribute:true}, position:{type:String, value:"center"}, preload:{type:Boolean, value:false}, placeholder:{type:String, value:null, observer:"_placeholderChanged"}, fade:{type:Boolean, value:false}, loaded:{notify:true, readOnly:true, type:Boolean, value:false}, loading:{notify:true, 
readOnly:true, type:Boolean, value:false}, error:{notify:true, readOnly:true, type:Boolean, value:false}, width:{observer:"_widthChanged", type:Number, value:null}, height:{observer:"_heightChanged", type:Number, value:null}}, observers:["_transformChanged(sizing, position)"], ready:function() {
  var img = this.$.img;
  img.onload = function() {
    if (this.$.img.src !== this._resolveSrc(this.src)) {
      return;
    }
    this._setLoading(false);
    this._setLoaded(true);
    this._setError(false);
  }.bind(this);
  img.onerror = function() {
    if (this.$.img.src !== this._resolveSrc(this.src)) {
      return;
    }
    this._reset();
    this._setLoading(false);
    this._setLoaded(false);
    this._setError(true);
  }.bind(this);
  this._resolvedSrc = "";
}, _load:function(src) {
  if (src) {
    this.$.img.src = src;
  } else {
    this.$.img.removeAttribute("src");
  }
  this.$.sizedImgDiv.style.backgroundImage = src ? 'url("' + src + '")' : "";
  this._setLoading(!!src);
  this._setLoaded(false);
  this._setError(false);
}, _reset:function() {
  this.$.img.removeAttribute("src");
  this.$.sizedImgDiv.style.backgroundImage = "";
  this._setLoading(false);
  this._setLoaded(false);
  this._setError(false);
}, _computePlaceholderHidden:function() {
  return !this.preload || !this.fade && !this.loading && this.loaded;
}, _computePlaceholderClassName:function() {
  return this.preload && this.fade && !this.loading && this.loaded ? "faded-out" : "";
}, _computeImgDivHidden:function() {
  return !this.sizing;
}, _computeImgDivARIAHidden:function() {
  return this.alt === "" ? "true" : undefined;
}, _computeImgDivARIALabel:function() {
  if (this.alt !== null) {
    return this.alt;
  }
  if (this.src === "") {
    return "";
  }
  var pathComponents = (new URL(this._resolveSrc(this.src))).pathname.split("/");
  return pathComponents[pathComponents.length - 1];
}, _computeImgHidden:function() {
  return !!this.sizing;
}, _widthChanged:function() {
  this.style.width = isNaN(this.width) ? this.width : this.width + "px";
}, _heightChanged:function() {
  this.style.height = isNaN(this.height) ? this.height : this.height + "px";
}, _preventLoadChanged:function() {
  if (this.preventLoad || this.loaded) {
    return;
  }
  this._reset();
  this._load(this.src);
}, _srcChanged:function(newSrc, oldSrc) {
  var newResolvedSrc = this._resolveSrc(newSrc);
  if (newResolvedSrc === this._resolvedSrc) {
    return;
  }
  this._resolvedSrc = newResolvedSrc;
  this._reset();
  if (!this.preventLoad) {
    this._load(newSrc);
  }
}, _placeholderChanged:function() {
  this.$.placeholder.style.backgroundImage = this.placeholder ? 'url("' + this.placeholder + '")' : "";
}, _transformChanged:function() {
  var sizedImgDivStyle = this.$.sizedImgDiv.style;
  var placeholderStyle = this.$.placeholder.style;
  sizedImgDivStyle.backgroundSize = placeholderStyle.backgroundSize = this.sizing;
  sizedImgDivStyle.backgroundPosition = placeholderStyle.backgroundPosition = this.sizing ? this.position : "";
  sizedImgDivStyle.backgroundRepeat = placeholderStyle.backgroundRepeat = this.sizing ? "no-repeat" : "";
}, _resolveSrc:function(testSrc) {
  return Polymer.ResolveUrl.resolveUrl(testSrc, this.ownerDocument.baseURI);
}});
(function() {
  var block = {newline:/^\n+/, code:/^( {4}[^\n]+\n*)+/, fences:noop, hr:/^( *[-*_]){3,} *(?:\n+|$)/, heading:/^ *(#{1,6}) *([^\n]+?) *#* *(?:\n+|$)/, nptable:noop, lheading:/^([^\n]+)\n *(=|-){2,} *(?:\n+|$)/, blockquote:/^( *>[^\n]+(\n(?!def)[^\n]+)*\n*)+/, list:/^( *)(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/, html:/^ *(?:comment *(?:\n|\s*$)|closed *(?:\n{2,}|\s*$)|closing *(?:\n{2,}|\s*$))/, def:/^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +["(]([^\n]+)[")])? *(?:\n+|$)/, table:noop, paragraph:/^((?:[^\n]+\n?(?!hr|heading|lheading|blockquote|tag|def))+)\n*/, 
  text:/^[^\n]+/};
  block.bullet = /(?:[*+-]|\d+\.)/;
  block.item = /^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/;
  block.item = replace(block.item, "gm")(/bull/g, block.bullet)();
  block.list = replace(block.list)(/bull/g, block.bullet)("hr", "\\n+(?=\\1?(?:[-*_] *){3,}(?:\\n+|$))")("def", "\\n+(?=" + block.def.source + ")")();
  block.blockquote = replace(block.blockquote)("def", block.def)();
  block._tag = "(?!(?:" + "a|em|strong|small|s|cite|q|dfn|abbr|data|time|code" + "|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo" + "|span|br|wbr|ins|del|img)\\b)\\w+(?!:/|[^\\w\\s@]*@)\\b";
  block.html = replace(block.html)("comment", /\x3c!--[\s\S]*?--\x3e/)("closed", /<(tag)[\s\S]+?<\/\1>/)("closing", /<tag(?:"[^"]*"|'[^']*'|[^'">])*?>/)(/tag/g, block._tag)();
  block.paragraph = replace(block.paragraph)("hr", block.hr)("heading", block.heading)("lheading", block.lheading)("blockquote", block.blockquote)("tag", "<" + block._tag)("def", block.def)();
  block.normal = merge({}, block);
  block.gfm = merge({}, block.normal, {fences:/^ *(`{3,}|~{3,})[ \.]*(\S+)? *\n([\s\S]*?)\s*\1 *(?:\n+|$)/, paragraph:/^/, heading:/^ *(#{1,6}) +([^\n]+?) *#* *(?:\n+|$)/});
  block.gfm.paragraph = replace(block.paragraph)("(?!", "(?!" + block.gfm.fences.source.replace("\\1", "\\2") + "|" + block.list.source.replace("\\1", "\\3") + "|")();
  block.tables = merge({}, block.gfm, {nptable:/^ *(\S.*\|.*)\n *([-:]+ *\|[-| :]*)\n((?:.*\|.*(?:\n|$))*)\n*/, table:/^ *\|(.+)\n *\|( *[-:]+[-| :]*)\n((?: *\|.*(?:\n|$))*)\n*/});
  function Lexer(options) {
    this.tokens = [];
    this.tokens.links = {};
    this.options = options || marked.defaults;
    this.rules = block.normal;
    if (this.options.gfm) {
      if (this.options.tables) {
        this.rules = block.tables;
      } else {
        this.rules = block.gfm;
      }
    }
  }
  Lexer.rules = block;
  Lexer.lex = function(src, options) {
    var lexer = new Lexer(options);
    return lexer.lex(src);
  };
  Lexer.prototype.lex = function(src) {
    src = src.replace(/\r\n|\r/g, "\n").replace(/\t/g, "    ").replace(/\u00a0/g, " ").replace(/\u2424/g, "\n");
    return this.token(src, true);
  };
  Lexer.prototype.token = function(src, top, bq) {
    var src = src.replace(/^ +$/gm, ""), next, loose, cap, bull, b, item, space, i, l;
    while (src) {
      if (cap = this.rules.newline.exec(src)) {
        src = src.substring(cap[0].length);
        if (cap[0].length > 1) {
          this.tokens.push({type:"space"});
        }
      }
      if (cap = this.rules.code.exec(src)) {
        src = src.substring(cap[0].length);
        cap = cap[0].replace(/^ {4}/gm, "");
        this.tokens.push({type:"code", text:!this.options.pedantic ? cap.replace(/\n+$/, "") : cap});
        continue;
      }
      if (cap = this.rules.fences.exec(src)) {
        src = src.substring(cap[0].length);
        this.tokens.push({type:"code", lang:cap[2], text:cap[3] || ""});
        continue;
      }
      if (cap = this.rules.heading.exec(src)) {
        src = src.substring(cap[0].length);
        this.tokens.push({type:"heading", depth:cap[1].length, text:cap[2]});
        continue;
      }
      if (top && (cap = this.rules.nptable.exec(src))) {
        src = src.substring(cap[0].length);
        item = {type:"table", header:cap[1].replace(/^ *| *\| *$/g, "").split(/ *\| */), align:cap[2].replace(/^ *|\| *$/g, "").split(/ *\| */), cells:cap[3].replace(/\n$/, "").split("\n")};
        for (i = 0; i < item.align.length; i++) {
          if (/^ *-+: *$/.test(item.align[i])) {
            item.align[i] = "right";
          } else {
            if (/^ *:-+: *$/.test(item.align[i])) {
              item.align[i] = "center";
            } else {
              if (/^ *:-+ *$/.test(item.align[i])) {
                item.align[i] = "left";
              } else {
                item.align[i] = null;
              }
            }
          }
        }
        for (i = 0; i < item.cells.length; i++) {
          item.cells[i] = item.cells[i].split(/ *\| */);
        }
        this.tokens.push(item);
        continue;
      }
      if (cap = this.rules.lheading.exec(src)) {
        src = src.substring(cap[0].length);
        this.tokens.push({type:"heading", depth:cap[2] === "=" ? 1 : 2, text:cap[1]});
        continue;
      }
      if (cap = this.rules.hr.exec(src)) {
        src = src.substring(cap[0].length);
        this.tokens.push({type:"hr"});
        continue;
      }
      if (cap = this.rules.blockquote.exec(src)) {
        src = src.substring(cap[0].length);
        this.tokens.push({type:"blockquote_start"});
        cap = cap[0].replace(/^ *> ?/gm, "");
        this.token(cap, top, true);
        this.tokens.push({type:"blockquote_end"});
        continue;
      }
      if (cap = this.rules.list.exec(src)) {
        src = src.substring(cap[0].length);
        bull = cap[2];
        this.tokens.push({type:"list_start", ordered:bull.length > 1});
        cap = cap[0].match(this.rules.item);
        next = false;
        l = cap.length;
        i = 0;
        for (; i < l; i++) {
          item = cap[i];
          space = item.length;
          item = item.replace(/^ *([*+-]|\d+\.) +/, "");
          if (~item.indexOf("\n ")) {
            space -= item.length;
            item = !this.options.pedantic ? item.replace(new RegExp("^ {1," + space + "}", "gm"), "") : item.replace(/^ {1,4}/gm, "");
          }
          if (this.options.smartLists && i !== l - 1) {
            b = block.bullet.exec(cap[i + 1])[0];
            if (bull !== b && !(bull.length > 1 && b.length > 1)) {
              src = cap.slice(i + 1).join("\n") + src;
              i = l - 1;
            }
          }
          loose = next || /\n\n(?!\s*$)/.test(item);
          if (i !== l - 1) {
            next = item.charAt(item.length - 1) === "\n";
            if (!loose) {
              loose = next;
            }
          }
          this.tokens.push({type:loose ? "loose_item_start" : "list_item_start"});
          this.token(item, false, bq);
          this.tokens.push({type:"list_item_end"});
        }
        this.tokens.push({type:"list_end"});
        continue;
      }
      if (cap = this.rules.html.exec(src)) {
        src = src.substring(cap[0].length);
        this.tokens.push({type:this.options.sanitize ? "paragraph" : "html", pre:!this.options.sanitizer && (cap[1] === "pre" || cap[1] === "script" || cap[1] === "style"), text:cap[0]});
        continue;
      }
      if (!bq && top && (cap = this.rules.def.exec(src))) {
        src = src.substring(cap[0].length);
        this.tokens.links[cap[1].toLowerCase()] = {href:cap[2], title:cap[3]};
        continue;
      }
      if (top && (cap = this.rules.table.exec(src))) {
        src = src.substring(cap[0].length);
        item = {type:"table", header:cap[1].replace(/^ *| *\| *$/g, "").split(/ *\| */), align:cap[2].replace(/^ *|\| *$/g, "").split(/ *\| */), cells:cap[3].replace(/(?: *\| *)?\n$/, "").split("\n")};
        for (i = 0; i < item.align.length; i++) {
          if (/^ *-+: *$/.test(item.align[i])) {
            item.align[i] = "right";
          } else {
            if (/^ *:-+: *$/.test(item.align[i])) {
              item.align[i] = "center";
            } else {
              if (/^ *:-+ *$/.test(item.align[i])) {
                item.align[i] = "left";
              } else {
                item.align[i] = null;
              }
            }
          }
        }
        for (i = 0; i < item.cells.length; i++) {
          item.cells[i] = item.cells[i].replace(/^ *\| *| *\| *$/g, "").split(/ *\| */);
        }
        this.tokens.push(item);
        continue;
      }
      if (top && (cap = this.rules.paragraph.exec(src))) {
        src = src.substring(cap[0].length);
        this.tokens.push({type:"paragraph", text:cap[1].charAt(cap[1].length - 1) === "\n" ? cap[1].slice(0, -1) : cap[1]});
        continue;
      }
      if (cap = this.rules.text.exec(src)) {
        src = src.substring(cap[0].length);
        this.tokens.push({type:"text", text:cap[0]});
        continue;
      }
      if (src) {
        throw new Error("Infinite loop on byte: " + src.charCodeAt(0));
      }
    }
    return this.tokens;
  };
  var inline = {escape:/^\\([\\`*{}\[\]()#+\-.!_>])/, autolink:/^<([^ >]+(@|:\/)[^ >]+)>/, url:noop, tag:/^\x3c!--[\s\S]*?--\x3e|^<\/?\w+(?:"[^"]*"|'[^']*'|[^'">])*?>/, link:/^!?\[(inside)\]\(href\)/, reflink:/^!?\[(inside)\]\s*\[([^\]]*)\]/, nolink:/^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/, strong:/^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/, em:/^\b_((?:[^_]|__)+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/, code:/^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/, br:/^ {2,}\n(?!\s*$)/, del:noop, text:/^[\s\S]+?(?=[\\<!\[_*`]| {2,}\n|$)/};
  inline._inside = /(?:\[[^\]]*\]|[^\[\]]|\](?=[^\[]*\]))*/;
  inline._href = /\s*<?([\s\S]*?)>?(?:\s+['"]([\s\S]*?)['"])?\s*/;
  inline.link = replace(inline.link)("inside", inline._inside)("href", inline._href)();
  inline.reflink = replace(inline.reflink)("inside", inline._inside)();
  inline.normal = merge({}, inline);
  inline.pedantic = merge({}, inline.normal, {strong:/^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/, em:/^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/});
  inline.gfm = merge({}, inline.normal, {escape:replace(inline.escape)("])", "~|])")(), url:/^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/, del:/^~~(?=\S)([\s\S]*?\S)~~/, text:replace(inline.text)("]|", "~]|")("|", "|https?://|")()});
  inline.breaks = merge({}, inline.gfm, {br:replace(inline.br)("{2,}", "*")(), text:replace(inline.gfm.text)("{2,}", "*")()});
  function InlineLexer(links, options) {
    this.options = options || marked.defaults;
    this.links = links;
    this.rules = inline.normal;
    this.renderer = this.options.renderer || new Renderer;
    this.renderer.options = this.options;
    if (!this.links) {
      throw new Error("Tokens array requires a `links` property.");
    }
    if (this.options.gfm) {
      if (this.options.breaks) {
        this.rules = inline.breaks;
      } else {
        this.rules = inline.gfm;
      }
    } else {
      if (this.options.pedantic) {
        this.rules = inline.pedantic;
      }
    }
  }
  InlineLexer.rules = inline;
  InlineLexer.output = function(src, links, options) {
    var inline = new InlineLexer(links, options);
    return inline.output(src);
  };
  InlineLexer.prototype.output = function(src) {
    var out = "", link, text, href, cap;
    while (src) {
      if (cap = this.rules.escape.exec(src)) {
        src = src.substring(cap[0].length);
        out += cap[1];
        continue;
      }
      if (cap = this.rules.autolink.exec(src)) {
        src = src.substring(cap[0].length);
        if (cap[2] === "@") {
          text = cap[1].charAt(6) === ":" ? this.mangle(cap[1].substring(7)) : this.mangle(cap[1]);
          href = this.mangle("mailto:") + text;
        } else {
          text = escape(cap[1]);
          href = text;
        }
        out += this.renderer.link(href, null, text);
        continue;
      }
      if (!this.inLink && (cap = this.rules.url.exec(src))) {
        src = src.substring(cap[0].length);
        text = escape(cap[1]);
        href = text;
        out += this.renderer.link(href, null, text);
        continue;
      }
      if (cap = this.rules.tag.exec(src)) {
        if (!this.inLink && /^<a /i.test(cap[0])) {
          this.inLink = true;
        } else {
          if (this.inLink && /^<\/a>/i.test(cap[0])) {
            this.inLink = false;
          }
        }
        src = src.substring(cap[0].length);
        out += this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0];
        continue;
      }
      if (cap = this.rules.link.exec(src)) {
        src = src.substring(cap[0].length);
        this.inLink = true;
        out += this.outputLink(cap, {href:cap[2], title:cap[3]});
        this.inLink = false;
        continue;
      }
      if ((cap = this.rules.reflink.exec(src)) || (cap = this.rules.nolink.exec(src))) {
        src = src.substring(cap[0].length);
        link = (cap[2] || cap[1]).replace(/\s+/g, " ");
        link = this.links[link.toLowerCase()];
        if (!link || !link.href) {
          out += cap[0].charAt(0);
          src = cap[0].substring(1) + src;
          continue;
        }
        this.inLink = true;
        out += this.outputLink(cap, link);
        this.inLink = false;
        continue;
      }
      if (cap = this.rules.strong.exec(src)) {
        src = src.substring(cap[0].length);
        out += this.renderer.strong(this.output(cap[2] || cap[1]));
        continue;
      }
      if (cap = this.rules.em.exec(src)) {
        src = src.substring(cap[0].length);
        out += this.renderer.em(this.output(cap[2] || cap[1]));
        continue;
      }
      if (cap = this.rules.code.exec(src)) {
        src = src.substring(cap[0].length);
        out += this.renderer.codespan(escape(cap[2], true));
        continue;
      }
      if (cap = this.rules.br.exec(src)) {
        src = src.substring(cap[0].length);
        out += this.renderer.br();
        continue;
      }
      if (cap = this.rules.del.exec(src)) {
        src = src.substring(cap[0].length);
        out += this.renderer.del(this.output(cap[1]));
        continue;
      }
      if (cap = this.rules.text.exec(src)) {
        src = src.substring(cap[0].length);
        out += this.renderer.text(escape(this.smartypants(cap[0])));
        continue;
      }
      if (src) {
        throw new Error("Infinite loop on byte: " + src.charCodeAt(0));
      }
    }
    return out;
  };
  InlineLexer.prototype.outputLink = function(cap, link) {
    var href = escape(link.href), title = link.title ? escape(link.title) : null;
    return cap[0].charAt(0) !== "!" ? this.renderer.link(href, title, this.output(cap[1])) : this.renderer.image(href, title, escape(cap[1]));
  };
  InlineLexer.prototype.smartypants = function(text) {
    if (!this.options.smartypants) {
      return text;
    }
    return text.replace(/---/g, "—").replace(/--/g, "–").replace(/(^|[-\u2014/(\[{"\s])'/g, "$1‘").replace(/'/g, "’").replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1“").replace(/"/g, "”").replace(/\.{3}/g, "…");
  };
  InlineLexer.prototype.mangle = function(text) {
    if (!this.options.mangle) {
      return text;
    }
    var out = "", l = text.length, i = 0, ch;
    for (; i < l; i++) {
      ch = text.charCodeAt(i);
      if (Math.random() > 0.5) {
        ch = "x" + ch.toString(16);
      }
      out += "&#" + ch + ";";
    }
    return out;
  };
  function Renderer(options) {
    this.options = options || {};
  }
  Renderer.prototype.code = function(code, lang, escaped) {
    if (this.options.highlight) {
      var out = this.options.highlight(code, lang);
      if (out != null && out !== code) {
        escaped = true;
        code = out;
      }
    }
    if (!lang) {
      return "<pre><code>" + (escaped ? code : escape(code, true)) + "\n</code></pre>";
    }
    return '<pre><code class="' + this.options.langPrefix + escape(lang, true) + '">' + (escaped ? code : escape(code, true)) + "\n</code></pre>\n";
  };
  Renderer.prototype.blockquote = function(quote) {
    return "<blockquote>\n" + quote + "</blockquote>\n";
  };
  Renderer.prototype.html = function(html) {
    return html;
  };
  Renderer.prototype.heading = function(text, level, raw) {
    return "<h" + level + ' id="' + this.options.headerPrefix + raw.toLowerCase().replace(/[^\w]+/g, "-") + '">' + text + "</h" + level + ">\n";
  };
  Renderer.prototype.hr = function() {
    return this.options.xhtml ? "<hr/>\n" : "<hr>\n";
  };
  Renderer.prototype.list = function(body, ordered) {
    var type = ordered ? "ol" : "ul";
    return "<" + type + ">\n" + body + "</" + type + ">\n";
  };
  Renderer.prototype.listitem = function(text) {
    return "<li>" + text + "</li>\n";
  };
  Renderer.prototype.paragraph = function(text) {
    return "<p>" + text + "</p>\n";
  };
  Renderer.prototype.table = function(header, body) {
    return "<table>\n" + "<thead>\n" + header + "</thead>\n" + "<tbody>\n" + body + "</tbody>\n" + "</table>\n";
  };
  Renderer.prototype.tablerow = function(content) {
    return "<tr>\n" + content + "</tr>\n";
  };
  Renderer.prototype.tablecell = function(content, flags) {
    var type = flags.header ? "th" : "td";
    var tag = flags.align ? "<" + type + ' style="text-align:' + flags.align + '">' : "<" + type + ">";
    return tag + content + "</" + type + ">\n";
  };
  Renderer.prototype.strong = function(text) {
    return "<strong>" + text + "</strong>";
  };
  Renderer.prototype.em = function(text) {
    return "<em>" + text + "</em>";
  };
  Renderer.prototype.codespan = function(text) {
    return "<code>" + text + "</code>";
  };
  Renderer.prototype.br = function() {
    return this.options.xhtml ? "<br/>" : "<br>";
  };
  Renderer.prototype.del = function(text) {
    return "<del>" + text + "</del>";
  };
  Renderer.prototype.link = function(href, title, text) {
    if (this.options.sanitize) {
      try {
        var prot = decodeURIComponent(unescape(href)).replace(/[^\w:]/g, "").toLowerCase();
      } catch (e) {
        return "";
      }
      if (prot.indexOf("javascript:") === 0 || prot.indexOf("vbscript:") === 0) {
        return "";
      }
    }
    var out = '<a href="' + href + '"';
    if (title) {
      out += ' title="' + title + '"';
    }
    out += ">" + text + "</a>";
    return out;
  };
  Renderer.prototype.image = function(href, title, text) {
    var out = '<img src="' + href + '" alt="' + text + '"';
    if (title) {
      out += ' title="' + title + '"';
    }
    out += this.options.xhtml ? "/>" : ">";
    return out;
  };
  Renderer.prototype.text = function(text) {
    return text;
  };
  function Parser(options) {
    this.tokens = [];
    this.token = null;
    this.options = options || marked.defaults;
    this.options.renderer = this.options.renderer || new Renderer;
    this.renderer = this.options.renderer;
    this.renderer.options = this.options;
  }
  Parser.parse = function(src, options, renderer) {
    var parser = new Parser(options, renderer);
    return parser.parse(src);
  };
  Parser.prototype.parse = function(src) {
    this.inline = new InlineLexer(src.links, this.options, this.renderer);
    this.tokens = src.reverse();
    var out = "";
    while (this.next()) {
      out += this.tok();
    }
    return out;
  };
  Parser.prototype.next = function() {
    return this.token = this.tokens.pop();
  };
  Parser.prototype.peek = function() {
    return this.tokens[this.tokens.length - 1] || 0;
  };
  Parser.prototype.parseText = function() {
    var body = this.token.text;
    while (this.peek().type === "text") {
      body += "\n" + this.next().text;
    }
    return this.inline.output(body);
  };
  Parser.prototype.tok = function() {
    switch(this.token.type) {
      case "space":
        {
          return "";
        }
      case "hr":
        {
          return this.renderer.hr();
        }
      case "heading":
        {
          return this.renderer.heading(this.inline.output(this.token.text), this.token.depth, this.token.text);
        }
      case "code":
        {
          return this.renderer.code(this.token.text, this.token.lang, this.token.escaped);
        }
      case "table":
        {
          var header = "", body = "", i, row, cell, flags, j;
          cell = "";
          for (i = 0; i < this.token.header.length; i++) {
            flags = {header:true, align:this.token.align[i]};
            cell += this.renderer.tablecell(this.inline.output(this.token.header[i]), {header:true, align:this.token.align[i]});
          }
          header += this.renderer.tablerow(cell);
          for (i = 0; i < this.token.cells.length; i++) {
            row = this.token.cells[i];
            cell = "";
            for (j = 0; j < row.length; j++) {
              cell += this.renderer.tablecell(this.inline.output(row[j]), {header:false, align:this.token.align[j]});
            }
            body += this.renderer.tablerow(cell);
          }
          return this.renderer.table(header, body);
        }
      case "blockquote_start":
        {
          var body = "";
          while (this.next().type !== "blockquote_end") {
            body += this.tok();
          }
          return this.renderer.blockquote(body);
        }
      case "list_start":
        {
          var body = "", ordered = this.token.ordered;
          while (this.next().type !== "list_end") {
            body += this.tok();
          }
          return this.renderer.list(body, ordered);
        }
      case "list_item_start":
        {
          var body = "";
          while (this.next().type !== "list_item_end") {
            body += this.token.type === "text" ? this.parseText() : this.tok();
          }
          return this.renderer.listitem(body);
        }
      case "loose_item_start":
        {
          var body = "";
          while (this.next().type !== "list_item_end") {
            body += this.tok();
          }
          return this.renderer.listitem(body);
        }
      case "html":
        {
          var html = !this.token.pre && !this.options.pedantic ? this.inline.output(this.token.text) : this.token.text;
          return this.renderer.html(html);
        }
      case "paragraph":
        {
          return this.renderer.paragraph(this.inline.output(this.token.text));
        }
      case "text":
        {
          return this.renderer.paragraph(this.parseText());
        }
    }
  };
  function escape(html, encode) {
    return html.replace(!encode ? /&(?!#?\w+;)/g : /&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
  }
  function unescape(html) {
    return html.replace(/&([#\w]+);/g, function(_, n) {
      n = n.toLowerCase();
      if (n === "colon") {
        return ":";
      }
      if (n.charAt(0) === "#") {
        return n.charAt(1) === "x" ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));
      }
      return "";
    });
  }
  function replace(regex, opt) {
    regex = regex.source;
    opt = opt || "";
    return function self(name, val) {
      if (!name) {
        return new RegExp(regex, opt);
      }
      val = val.source || val;
      val = val.replace(/(^|[^\[])\^/g, "$1");
      regex = regex.replace(name, val);
      return self;
    };
  }
  function noop() {
  }
  noop.exec = noop;
  function merge(obj) {
    var i = 1, target, key;
    for (; i < arguments.length; i++) {
      target = arguments[i];
      for (key in target) {
        if (Object.prototype.hasOwnProperty.call(target, key)) {
          obj[key] = target[key];
        }
      }
    }
    return obj;
  }
  function marked(src, opt, callback) {
    if (callback || typeof opt === "function") {
      if (!callback) {
        callback = opt;
        opt = null;
      }
      opt = merge({}, marked.defaults, opt || {});
      var highlight = opt.highlight, tokens, pending, i = 0;
      try {
        tokens = Lexer.lex(src, opt);
      } catch (e) {
        return callback(e);
      }
      pending = tokens.length;
      var done = function(err) {
        if (err) {
          opt.highlight = highlight;
          return callback(err);
        }
        var out;
        try {
          out = Parser.parse(tokens, opt);
        } catch (e$3) {
          err = e$3;
        }
        opt.highlight = highlight;
        return err ? callback(err) : callback(null, out);
      };
      if (!highlight || highlight.length < 3) {
        return done();
      }
      delete opt.highlight;
      if (!pending) {
        return done();
      }
      for (; i < tokens.length; i++) {
        (function(token) {
          if (token.type !== "code") {
            return --pending || done();
          }
          return highlight(token.text, token.lang, function(err, code) {
            if (err) {
              return done(err);
            }
            if (code == null || code === token.text) {
              return --pending || done();
            }
            token.text = code;
            token.escaped = true;
            --pending || done();
          });
        })(tokens[i]);
      }
      return;
    }
    try {
      if (opt) {
        opt = merge({}, marked.defaults, opt);
      }
      return Parser.parse(Lexer.lex(src, opt), opt);
    } catch (e$4) {
      e$4.message += "\nPlease report this to https://github.com/chjj/marked.";
      if ((opt || marked.defaults).silent) {
        return "<p>An error occured:</p><pre>" + escape(e$4.message + "", true) + "</pre>";
      }
      throw e$4;
    }
  }
  marked.options = marked.setOptions = function(opt) {
    merge(marked.defaults, opt);
    return marked;
  };
  marked.defaults = {gfm:true, tables:true, breaks:false, pedantic:false, sanitize:false, sanitizer:null, mangle:true, smartLists:false, silent:false, highlight:null, langPrefix:"lang-", smartypants:false, headerPrefix:"", renderer:new Renderer, xhtml:false};
  marked.Parser = Parser;
  marked.parser = Parser.parse;
  marked.Renderer = Renderer;
  marked.Lexer = Lexer;
  marked.lexer = Lexer.lex;
  marked.InlineLexer = InlineLexer;
  marked.inlineLexer = InlineLexer.output;
  marked.parse = marked;
  if (typeof module !== "undefined" && typeof exports === "object") {
    module.exports = marked;
  } else {
    if (typeof define === "function" && define.amd) {
      define(function() {
        return marked;
      });
    } else {
      this.marked = marked;
    }
  }
}).call(function() {
  return this || (typeof window !== "undefined" ? window : global);
}());
"use strict";
Polymer({is:"marked-element", properties:{markdown:{observer:"render", type:String, value:null}, pedantic:{observer:"render", type:Boolean, value:false}, sanitize:{observer:"render", type:Boolean, value:false}, smartypants:{observer:"render", type:Boolean, value:false}}, ready:function() {
  if (!this.markdown) {
    var markdownElement = Polymer.dom(this).querySelector('[type^="text/markdown"]');
    if (markdownElement != null) {
      this.markdown = this._unindent(markdownElement.textContent);
    }
  }
}, attached:function() {
  this._attached = true;
  this._outputElement = this.outputElement;
  this.render();
}, detached:function() {
  this._attached = false;
}, unindent:function(text) {
  return this._unindent(text);
}, get outputElement() {
  var child = Polymer.dom(this).queryDistributedElements(".markdown-html")[0];
  if (child) {
    return child;
  }
  this.toggleClass("hidden", false, this.$.content);
  return this.$.content;
}, render:function() {
  if (!this._attached) {
    return;
  }
  if (!this.markdown) {
    Polymer.dom(this._outputElement).innerHTML = "";
    return;
  }
  var opts = {highlight:this._highlight.bind(this), sanitize:this.sanitize, pedantic:this.pedantic, smartypants:this.smartypants};
  Polymer.dom(this._outputElement).innerHTML = marked(this.markdown, opts);
  this.fire("marked-render-complete");
}, _highlight:function(code, lang) {
  var event = this.fire("syntax-highlight", {code:code, lang:lang});
  return event.detail.code || code;
}, _unindent:function(text) {
  if (!text) {
    return text;
  }
  var lines = text.replace(/\t/g, "  ").split("\n");
  var indent = lines.reduce(function(prev, line) {
    if (/^\s*$/.test(line)) {
      return prev;
    }
    var lineIndent = line.match(/^(\s*)/)[0].length;
    if (prev === null) {
      return lineIndent;
    }
    return lineIndent < prev ? lineIndent : prev;
  }, null);
  return lines.map(function(l) {
    return l.substr(indent);
  }).join("\n");
}});
(function() {
  var Utility = {distance:function(x1, y1, x2, y2) {
    var xDelta = x1 - x2;
    var yDelta = y1 - y2;
    return Math.sqrt(xDelta * xDelta + yDelta * yDelta);
  }, now:window.performance && window.performance.now ? window.performance.now.bind(window.performance) : Date.now};
  function ElementMetrics(element) {
    this.element = element;
    this.width = this.boundingRect.width;
    this.height = this.boundingRect.height;
    this.size = Math.max(this.width, this.height);
  }
  ElementMetrics.prototype = {get boundingRect() {
    return this.element.getBoundingClientRect();
  }, furthestCornerDistanceFrom:function(x, y) {
    var topLeft = Utility.distance(x, y, 0, 0);
    var topRight = Utility.distance(x, y, this.width, 0);
    var bottomLeft = Utility.distance(x, y, 0, this.height);
    var bottomRight = Utility.distance(x, y, this.width, this.height);
    return Math.max(topLeft, topRight, bottomLeft, bottomRight);
  }};
  function Ripple(element) {
    this.element = element;
    this.color = window.getComputedStyle(element).color;
    this.wave = document.createElement("div");
    this.waveContainer = document.createElement("div");
    this.wave.style.backgroundColor = this.color;
    this.wave.classList.add("wave");
    this.waveContainer.classList.add("wave-container");
    Polymer.dom(this.waveContainer).appendChild(this.wave);
    this.resetInteractionState();
  }
  Ripple.MAX_RADIUS = 300;
  Ripple.prototype = {get recenters() {
    return this.element.recenters;
  }, get center() {
    return this.element.center;
  }, get mouseDownElapsed() {
    var elapsed;
    if (!this.mouseDownStart) {
      return 0;
    }
    elapsed = Utility.now() - this.mouseDownStart;
    if (this.mouseUpStart) {
      elapsed -= this.mouseUpElapsed;
    }
    return elapsed;
  }, get mouseUpElapsed() {
    return this.mouseUpStart ? Utility.now() - this.mouseUpStart : 0;
  }, get mouseDownElapsedSeconds() {
    return this.mouseDownElapsed / 1000;
  }, get mouseUpElapsedSeconds() {
    return this.mouseUpElapsed / 1000;
  }, get mouseInteractionSeconds() {
    return this.mouseDownElapsedSeconds + this.mouseUpElapsedSeconds;
  }, get initialOpacity() {
    return this.element.initialOpacity;
  }, get opacityDecayVelocity() {
    return this.element.opacityDecayVelocity;
  }, get radius() {
    var width2 = this.containerMetrics.width * this.containerMetrics.width;
    var height2 = this.containerMetrics.height * this.containerMetrics.height;
    var waveRadius = Math.min(Math.sqrt(width2 + height2), Ripple.MAX_RADIUS) * 1.1 + 5;
    var duration = 1.1 - 0.2 * (waveRadius / Ripple.MAX_RADIUS);
    var timeNow = this.mouseInteractionSeconds / duration;
    var size = waveRadius * (1 - Math.pow(80, -timeNow));
    return Math.abs(size);
  }, get opacity() {
    if (!this.mouseUpStart) {
      return this.initialOpacity;
    }
    return Math.max(0, this.initialOpacity - this.mouseUpElapsedSeconds * this.opacityDecayVelocity);
  }, get outerOpacity() {
    var outerOpacity = this.mouseUpElapsedSeconds * 0.3;
    var waveOpacity = this.opacity;
    return Math.max(0, Math.min(outerOpacity, waveOpacity));
  }, get isOpacityFullyDecayed() {
    return this.opacity < 0.01 && this.radius >= Math.min(this.maxRadius, Ripple.MAX_RADIUS);
  }, get isRestingAtMaxRadius() {
    return this.opacity >= this.initialOpacity && this.radius >= Math.min(this.maxRadius, Ripple.MAX_RADIUS);
  }, get isAnimationComplete() {
    return this.mouseUpStart ? this.isOpacityFullyDecayed : this.isRestingAtMaxRadius;
  }, get translationFraction() {
    return Math.min(1, this.radius / this.containerMetrics.size * 2 / Math.sqrt(2));
  }, get xNow() {
    if (this.xEnd) {
      return this.xStart + this.translationFraction * (this.xEnd - this.xStart);
    }
    return this.xStart;
  }, get yNow() {
    if (this.yEnd) {
      return this.yStart + this.translationFraction * (this.yEnd - this.yStart);
    }
    return this.yStart;
  }, get isMouseDown() {
    return this.mouseDownStart && !this.mouseUpStart;
  }, resetInteractionState:function() {
    this.maxRadius = 0;
    this.mouseDownStart = 0;
    this.mouseUpStart = 0;
    this.xStart = 0;
    this.yStart = 0;
    this.xEnd = 0;
    this.yEnd = 0;
    this.slideDistance = 0;
    this.containerMetrics = new ElementMetrics(this.element);
  }, draw:function() {
    var scale;
    var translateString;
    var dx;
    var dy;
    this.wave.style.opacity = this.opacity;
    scale = this.radius / (this.containerMetrics.size / 2);
    dx = this.xNow - this.containerMetrics.width / 2;
    dy = this.yNow - this.containerMetrics.height / 2;
    this.waveContainer.style.webkitTransform = "translate(" + dx + "px, " + dy + "px)";
    this.waveContainer.style.transform = "translate3d(" + dx + "px, " + dy + "px, 0)";
    this.wave.style.webkitTransform = "scale(" + scale + "," + scale + ")";
    this.wave.style.transform = "scale3d(" + scale + "," + scale + ",1)";
  }, downAction:function(event) {
    var xCenter = this.containerMetrics.width / 2;
    var yCenter = this.containerMetrics.height / 2;
    this.resetInteractionState();
    this.mouseDownStart = Utility.now();
    if (this.center) {
      this.xStart = xCenter;
      this.yStart = yCenter;
      this.slideDistance = Utility.distance(this.xStart, this.yStart, this.xEnd, this.yEnd);
    } else {
      this.xStart = event ? event.detail.x - this.containerMetrics.boundingRect.left : this.containerMetrics.width / 2;
      this.yStart = event ? event.detail.y - this.containerMetrics.boundingRect.top : this.containerMetrics.height / 2;
    }
    if (this.recenters) {
      this.xEnd = xCenter;
      this.yEnd = yCenter;
      this.slideDistance = Utility.distance(this.xStart, this.yStart, this.xEnd, this.yEnd);
    }
    this.maxRadius = this.containerMetrics.furthestCornerDistanceFrom(this.xStart, this.yStart);
    this.waveContainer.style.top = (this.containerMetrics.height - this.containerMetrics.size) / 2 + "px";
    this.waveContainer.style.left = (this.containerMetrics.width - this.containerMetrics.size) / 2 + "px";
    this.waveContainer.style.width = this.containerMetrics.size + "px";
    this.waveContainer.style.height = this.containerMetrics.size + "px";
  }, upAction:function(event) {
    if (!this.isMouseDown) {
      return;
    }
    this.mouseUpStart = Utility.now();
  }, remove:function() {
    Polymer.dom(this.waveContainer.parentNode).removeChild(this.waveContainer);
  }};
  Polymer({is:"paper-ripple", behaviors:[Polymer.IronA11yKeysBehavior], properties:{initialOpacity:{type:Number, value:0.25}, opacityDecayVelocity:{type:Number, value:0.8}, recenters:{type:Boolean, value:false}, center:{type:Boolean, value:false}, ripples:{type:Array, value:function() {
    return [];
  }}, animating:{type:Boolean, readOnly:true, reflectToAttribute:true, value:false}, holdDown:{type:Boolean, value:false, observer:"_holdDownChanged"}, noink:{type:Boolean, value:false}, _animating:{type:Boolean}, _boundAnimate:{type:Function, value:function() {
    return this.animate.bind(this);
  }}}, get target() {
    var ownerRoot = Polymer.dom(this).getOwnerRoot();
    var target;
    if (this.parentNode.nodeType == 11) {
      target = ownerRoot.host;
    } else {
      target = this.parentNode;
    }
    return target;
  }, keyBindings:{"enter:keydown":"_onEnterKeydown", "space:keydown":"_onSpaceKeydown", "space:keyup":"_onSpaceKeyup"}, attached:function() {
    this.keyEventTarget = this.target;
    this.listen(this.target, "up", "uiUpAction");
    this.listen(this.target, "down", "uiDownAction");
  }, detached:function() {
    this.unlisten(this.target, "up", "uiUpAction");
    this.unlisten(this.target, "down", "uiDownAction");
  }, get shouldKeepAnimating() {
    for (var index = 0; index < this.ripples.length; ++index) {
      if (!this.ripples[index].isAnimationComplete) {
        return true;
      }
    }
    return false;
  }, simulatedRipple:function() {
    this.downAction(null);
    this.async(function() {
      this.upAction();
    }, 1);
  }, uiDownAction:function(event) {
    if (!this.noink) {
      this.downAction(event);
    }
  }, downAction:function(event) {
    if (this.holdDown && this.ripples.length > 0) {
      return;
    }
    var ripple = this.addRipple();
    ripple.downAction(event);
    if (!this._animating) {
      this.animate();
    }
  }, uiUpAction:function(event) {
    if (!this.noink) {
      this.upAction(event);
    }
  }, upAction:function(event) {
    if (this.holdDown) {
      return;
    }
    this.ripples.forEach(function(ripple) {
      ripple.upAction(event);
    });
    this.animate();
  }, onAnimationComplete:function() {
    this._animating = false;
    this.$.background.style.backgroundColor = null;
    this.fire("transitionend");
  }, addRipple:function() {
    var ripple = new Ripple(this);
    Polymer.dom(this.$.waves).appendChild(ripple.waveContainer);
    this.$.background.style.backgroundColor = ripple.color;
    this.ripples.push(ripple);
    this._setAnimating(true);
    return ripple;
  }, removeRipple:function(ripple) {
    var rippleIndex = this.ripples.indexOf(ripple);
    if (rippleIndex < 0) {
      return;
    }
    this.ripples.splice(rippleIndex, 1);
    ripple.remove();
    if (!this.ripples.length) {
      this._setAnimating(false);
    }
  }, animate:function() {
    var index;
    var ripple;
    this._animating = true;
    for (index = 0; index < this.ripples.length; ++index) {
      ripple = this.ripples[index];
      ripple.draw();
      this.$.background.style.opacity = ripple.outerOpacity;
      if (ripple.isOpacityFullyDecayed && !ripple.isRestingAtMaxRadius) {
        this.removeRipple(ripple);
      }
    }
    if (!this.shouldKeepAnimating && this.ripples.length === 0) {
      this.onAnimationComplete();
    } else {
      window.requestAnimationFrame(this._boundAnimate);
    }
  }, _onEnterKeydown:function() {
    this.uiDownAction();
    this.async(this.uiUpAction, 1);
  }, _onSpaceKeydown:function() {
    this.uiDownAction();
  }, _onSpaceKeyup:function() {
    this.uiUpAction();
  }, _holdDownChanged:function(newVal, oldVal) {
    if (oldVal === undefined) {
      return;
    }
    if (newVal) {
      this.downAction();
    } else {
      this.upAction();
    }
  }});
})();
Polymer.PaperRippleBehavior = {properties:{noink:{type:Boolean, observer:"_noinkChanged"}, _rippleContainer:{type:Object}}, _buttonStateChanged:function() {
  if (this.focused) {
    this.ensureRipple();
  }
}, _downHandler:function(event) {
  Polymer.IronButtonStateImpl._downHandler.call(this, event);
  if (this.pressed) {
    this.ensureRipple(event);
  }
}, ensureRipple:function(optTriggeringEvent) {
  if (!this.hasRipple()) {
    this._ripple = this._createRipple();
    this._ripple.noink = this.noink;
    var rippleContainer = this._rippleContainer || this.root;
    if (rippleContainer) {
      Polymer.dom(rippleContainer).appendChild(this._ripple);
    }
    if (optTriggeringEvent) {
      var domContainer = Polymer.dom(this._rippleContainer || this);
      var target = Polymer.dom(optTriggeringEvent).rootTarget;
      if (domContainer.deepContains(target)) {
        this._ripple.uiDownAction(optTriggeringEvent);
      }
    }
  }
}, getRipple:function() {
  this.ensureRipple();
  return this._ripple;
}, hasRipple:function() {
  return Boolean(this._ripple);
}, _createRipple:function() {
  return document.createElement("paper-ripple");
}, _noinkChanged:function(noink) {
  if (this.hasRipple()) {
    this._ripple.noink = noink;
  }
}};
Polymer.PaperButtonBehaviorImpl = {properties:{elevation:{type:Number, reflectToAttribute:true, readOnly:true}}, observers:["_calculateElevation(focused, disabled, active, pressed, receivedFocusFromKeyboard)", "_computeKeyboardClass(receivedFocusFromKeyboard)"], hostAttributes:{role:"button", tabindex:"0", animated:true}, _calculateElevation:function() {
  var e = 1;
  if (this.disabled) {
    e = 0;
  } else {
    if (this.active || this.pressed) {
      e = 4;
    } else {
      if (this.receivedFocusFromKeyboard) {
        e = 3;
      }
    }
  }
  this._setElevation(e);
}, _computeKeyboardClass:function(receivedFocusFromKeyboard) {
  this.toggleClass("keyboard-focus", receivedFocusFromKeyboard);
}, _spaceKeyDownHandler:function(event) {
  Polymer.IronButtonStateImpl._spaceKeyDownHandler.call(this, event);
  if (this.hasRipple() && this.getRipple().ripples.length < 1) {
    this._ripple.uiDownAction();
  }
}, _spaceKeyUpHandler:function(event) {
  Polymer.IronButtonStateImpl._spaceKeyUpHandler.call(this, event);
  if (this.hasRipple()) {
    this._ripple.uiUpAction();
  }
}};
Polymer.PaperButtonBehavior = [Polymer.IronButtonState, Polymer.IronControlState, Polymer.PaperRippleBehavior, Polymer.PaperButtonBehaviorImpl];
Polymer({is:"paper-material", properties:{elevation:{type:Number, reflectToAttribute:true, value:1}, animated:{type:Boolean, reflectToAttribute:true, value:false}}});
Polymer({is:"paper-button", behaviors:[Polymer.PaperButtonBehavior], properties:{raised:{type:Boolean, reflectToAttribute:true, value:false, observer:"_calculateElevation"}}, _calculateElevation:function() {
  if (!this.raised) {
    this._setElevation(0);
  } else {
    Polymer.PaperButtonBehaviorImpl._calculateElevation.apply(this);
  }
}});
var _self = typeof window !== "undefined" ? window : typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope ? self : {};
var Prism = function() {
  var lang = /\blang(?:uage)?-(\w+)\b/i;
  var uniqueId = 0;
  var _ = _self.Prism = {util:{encode:function(tokens) {
    if (tokens instanceof Token) {
      return new Token(tokens.type, _.util.encode(tokens.content), tokens.alias);
    } else {
      if (_.util.type(tokens) === "Array") {
        return tokens.map(_.util.encode);
      } else {
        return tokens.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
      }
    }
  }, type:function(o) {
    return Object.prototype.toString.call(o).match(/\[object (\w+)\]/)[1];
  }, objId:function(obj) {
    if (!obj["__id"]) {
      Object.defineProperty(obj, "__id", {value:++uniqueId});
    }
    return obj["__id"];
  }, clone:function(o) {
    var type = _.util.type(o);
    switch(type) {
      case "Object":
        var clone = {};
        for (var key in o) {
          if (o.hasOwnProperty(key)) {
            clone[key] = _.util.clone(o[key]);
          }
        }
        return clone;
      case "Array":
        return o.map && o.map(function(v) {
          return _.util.clone(v);
        });
    }
    return o;
  }}, languages:{extend:function(id, redef) {
    var lang = _.util.clone(_.languages[id]);
    for (var key in redef) {
      lang[key] = redef[key];
    }
    return lang;
  }, insertBefore:function(inside, before, insert, root) {
    root = root || _.languages;
    var grammar = root[inside];
    if (arguments.length == 2) {
      insert = arguments[1];
      for (var newToken in insert) {
        if (insert.hasOwnProperty(newToken)) {
          grammar[newToken] = insert[newToken];
        }
      }
      return grammar;
    }
    var ret = {};
    for (var token in grammar) {
      if (grammar.hasOwnProperty(token)) {
        if (token == before) {
          for (var newToken in insert) {
            if (insert.hasOwnProperty(newToken)) {
              ret[newToken] = insert[newToken];
            }
          }
        }
        ret[token] = grammar[token];
      }
    }
    _.languages.DFS(_.languages, function(key, value) {
      if (value === root[inside] && key != inside) {
        this[key] = ret;
      }
    });
    return root[inside] = ret;
  }, DFS:function(o, callback, type, visited) {
    visited = visited || {};
    for (var i in o) {
      if (o.hasOwnProperty(i)) {
        callback.call(o, i, o[i], type || i);
        if (_.util.type(o[i]) === "Object" && !visited[_.util.objId(o[i])]) {
          visited[_.util.objId(o[i])] = true;
          _.languages.DFS(o[i], callback, null, visited);
        } else {
          if (_.util.type(o[i]) === "Array" && !visited[_.util.objId(o[i])]) {
            visited[_.util.objId(o[i])] = true;
            _.languages.DFS(o[i], callback, i, visited);
          }
        }
      }
    }
  }}, plugins:{}, highlightAll:function(async, callback) {
    var env = {callback:callback, selector:'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'};
    _.hooks.run("before-highlightall", env);
    var elements = env.elements || document.querySelectorAll(env.selector);
    for (var i = 0, element; element = elements[i++];) {
      _.highlightElement(element, async === true, env.callback);
    }
  }, highlightElement:function(element, async, callback) {
    var language, grammar, parent = element;
    while (parent && !lang.test(parent.className)) {
      parent = parent.parentNode;
    }
    if (parent) {
      language = (parent.className.match(lang) || [, ""])[1];
      grammar = _.languages[language];
    }
    element.className = element.className.replace(lang, "").replace(/\s+/g, " ") + " language-" + language;
    parent = element.parentNode;
    if (/pre/i.test(parent.nodeName)) {
      parent.className = parent.className.replace(lang, "").replace(/\s+/g, " ") + " language-" + language;
    }
    var code = element.textContent;
    var env = {element:element, language:language, grammar:grammar, code:code};
    _.hooks.run("before-sanity-check", env);
    if (!env.code || !env.grammar) {
      _.hooks.run("complete", env);
      return;
    }
    _.hooks.run("before-highlight", env);
    if (async && _self.Worker) {
      var worker = new Worker(_.filename);
      worker.onmessage = function(evt) {
        env.highlightedCode = evt.data;
        _.hooks.run("before-insert", env);
        env.element.innerHTML = env.highlightedCode;
        callback && callback.call(env.element);
        _.hooks.run("after-highlight", env);
        _.hooks.run("complete", env);
      };
      worker.postMessage(JSON.stringify({language:env.language, code:env.code, immediateClose:true}));
    } else {
      env.highlightedCode = _.highlight(env.code, env.grammar, env.language);
      _.hooks.run("before-insert", env);
      env.element.innerHTML = env.highlightedCode;
      callback && callback.call(element);
      _.hooks.run("after-highlight", env);
      _.hooks.run("complete", env);
    }
  }, highlight:function(text, grammar, language) {
    var tokens = _.tokenize(text, grammar);
    return Token.stringify(_.util.encode(tokens), language);
  }, tokenize:function(text, grammar, language) {
    var Token = _.Token;
    var strarr = [text];
    var rest = grammar.rest;
    if (rest) {
      for (var token in rest) {
        grammar[token] = rest[token];
      }
      delete grammar.rest;
    }
    tokenloop: for (var token in grammar) {
      if (!grammar.hasOwnProperty(token) || !grammar[token]) {
        continue;
      }
      var patterns = grammar[token];
      patterns = _.util.type(patterns) === "Array" ? patterns : [patterns];
      for (var j = 0; j < patterns.length; ++j) {
        var pattern = patterns[j], inside = pattern.inside, lookbehind = !!pattern.lookbehind, greedy = !!pattern.greedy, lookbehindLength = 0, alias = pattern.alias;
        pattern = pattern.pattern || pattern;
        for (var i = 0; i < strarr.length; i++) {
          var str = strarr[i];
          if (strarr.length > text.length) {
            break tokenloop;
          }
          if (str instanceof Token) {
            continue;
          }
          pattern.lastIndex = 0;
          var match = pattern.exec(str), delNum = 1;
          if (!match && greedy && i != strarr.length - 1) {
            var nextToken = strarr[i + 1].matchedStr || strarr[i + 1], combStr = str + nextToken;
            if (i < strarr.length - 2) {
              combStr += strarr[i + 2].matchedStr || strarr[i + 2];
            }
            pattern.lastIndex = 0;
            match = pattern.exec(combStr);
            if (!match) {
              continue;
            }
            var from = match.index + (lookbehind ? match[1].length : 0);
            if (from >= str.length) {
              continue;
            }
            var to = match.index + match[0].length, len = str.length + nextToken.length;
            delNum = 3;
            if (to <= len) {
              if (strarr[i + 1].greedy) {
                continue;
              }
              delNum = 2;
              combStr = combStr.slice(0, len);
            }
            str = combStr;
          }
          if (!match) {
            continue;
          }
          if (lookbehind) {
            lookbehindLength = match[1].length;
          }
          var from = match.index + lookbehindLength, match = match[0].slice(lookbehindLength), to = from + match.length, before = str.slice(0, from), after = str.slice(to);
          var args = [i, delNum];
          if (before) {
            args.push(before);
          }
          var wrapped = new Token(token, inside ? _.tokenize(match, inside) : match, alias, match, greedy);
          args.push(wrapped);
          if (after) {
            args.push(after);
          }
          Array.prototype.splice.apply(strarr, args);
        }
      }
    }
    return strarr;
  }, hooks:{all:{}, add:function(name, callback) {
    var hooks = _.hooks.all;
    hooks[name] = hooks[name] || [];
    hooks[name].push(callback);
  }, run:function(name, env) {
    var callbacks = _.hooks.all[name];
    if (!callbacks || !callbacks.length) {
      return;
    }
    for (var i = 0, callback; callback = callbacks[i++];) {
      callback(env);
    }
  }}};
  var Token = _.Token = function(type, content, alias, matchedStr, greedy) {
    this.type = type;
    this.content = content;
    this.alias = alias;
    this.matchedStr = matchedStr || null;
    this.greedy = !!greedy;
  };
  Token.stringify = function(o, language, parent) {
    if (typeof o == "string") {
      return o;
    }
    if (_.util.type(o) === "Array") {
      return o.map(function(element) {
        return Token.stringify(element, language, o);
      }).join("");
    }
    var env = {type:o.type, content:Token.stringify(o.content, language, parent), tag:"span", classes:["token", o.type], attributes:{}, language:language, parent:parent};
    if (env.type == "comment") {
      env.attributes["spellcheck"] = "true";
    }
    if (o.alias) {
      var aliases = _.util.type(o.alias) === "Array" ? o.alias : [o.alias];
      Array.prototype.push.apply(env.classes, aliases);
    }
    _.hooks.run("wrap", env);
    var attributes = "";
    for (var name in env.attributes) {
      attributes += (attributes ? " " : "") + name + '="' + (env.attributes[name] || "") + '"';
    }
    return "<" + env.tag + ' class="' + env.classes.join(" ") + '" ' + attributes + ">" + env.content + "</" + env.tag + ">";
  };
  if (!_self.document) {
    if (!_self.addEventListener) {
      return _self.Prism;
    }
    _self.addEventListener("message", function(evt) {
      var message = JSON.parse(evt.data), lang = message.language, code = message.code, immediateClose = message.immediateClose;
      _self.postMessage(_.highlight(code, _.languages[lang], lang));
      if (immediateClose) {
        _self.close();
      }
    }, false);
    return _self.Prism;
  }
  var script = document.currentScript || [].slice.call(document.getElementsByTagName("script")).pop();
  if (script) {
    _.filename = script.src;
    if (document.addEventListener && !script.hasAttribute("data-manual")) {
      document.addEventListener("DOMContentLoaded", _.highlightAll);
    }
  }
  return _self.Prism;
}();
if (typeof module !== "undefined" && module.exports) {
  module.exports = Prism;
}
if (typeof global !== "undefined") {
  global.Prism = Prism;
}
Prism.languages.markup = {"comment":/\x3c!--[\w\W]*?--\x3e/, "prolog":/<\?[\w\W]+?\?>/, "doctype":/<!DOCTYPE[\w\W]+?>/, "cdata":/<!\[CDATA\[[\w\W]*?]]\x3e/i, "tag":{pattern:/<\/?(?!\d)[^\s>\/=.$<]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\\1|\\?(?!\1)[\w\W])*\1|[^\s'">=]+))?)*\s*\/?>/i, inside:{"tag":{pattern:/^<\/?[^\s>\/]+/i, inside:{"punctuation":/^<\/?/, "namespace":/^[^\s>\/:]+:/}}, "attr-value":{pattern:/=(?:('|")[\w\W]*?(\1)|[^\s>]+)/i, inside:{"punctuation":/[=>"']/}}, "punctuation":/\/?>/, "attr-name":{pattern:/[^\s>\/]+/, 
inside:{"namespace":/^[^\s>\/:]+:/}}}}, "entity":/&#?[\da-z]{1,8};/i};
Prism.hooks.add("wrap", function(env) {
  if (env.type === "entity") {
    env.attributes["title"] = env.content.replace(/&amp;/, "&");
  }
});
Prism.languages.xml = Prism.languages.markup;
Prism.languages.html = Prism.languages.markup;
Prism.languages.mathml = Prism.languages.markup;
Prism.languages.svg = Prism.languages.markup;
Prism.languages.css = {"comment":/\/\*[\w\W]*?\*\//, "atrule":{pattern:/@[\w-]+?.*?(;|(?=\s*\{))/i, inside:{"rule":/@[\w-]+/}}, "url":/url\((?:(["'])(\\(?:\r\n|[\w\W])|(?!\1)[^\\\r\n])*\1|.*?)\)/i, "selector":/[^\{\}\s][^\{\};]*?(?=\s*\{)/, "string":/("|')(\\(?:\r\n|[\w\W])|(?!\1)[^\\\r\n])*\1/, "property":/(\b|\B)[\w-]+(?=\s*:)/i, "important":/\B!important\b/i, "function":/[-a-z0-9]+(?=\()/i, "punctuation":/[(){};:]/};
Prism.languages.css["atrule"].inside.rest = Prism.util.clone(Prism.languages.css);
if (Prism.languages.markup) {
  Prism.languages.insertBefore("markup", "tag", {"style":{pattern:/(<style[\w\W]*?>)[\w\W]*?(?=<\/style>)/i, lookbehind:true, inside:Prism.languages.css, alias:"language-css"}});
  Prism.languages.insertBefore("inside", "attr-value", {"style-attr":{pattern:/\s*style=("|').*?\1/i, inside:{"attr-name":{pattern:/^\s*style/i, inside:Prism.languages.markup.tag.inside}, "punctuation":/^\s*=\s*['"]|['"]\s*$/, "attr-value":{pattern:/.+/i, inside:Prism.languages.css}}, alias:"language-css"}}, Prism.languages.markup.tag);
}
Prism.languages.clike = {"comment":[{pattern:/(^|[^\\])\/\*[\w\W]*?\*\//, lookbehind:true}, {pattern:/(^|[^\\:])\/\/.*/, lookbehind:true}], "string":{pattern:/(["'])(\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, greedy:true}, "class-name":{pattern:/((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[a-z0-9_\.\\]+/i, lookbehind:true, inside:{punctuation:/(\.|\\)/}}, "keyword":/\b(if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/, 
"boolean":/\b(true|false)\b/, "function":/[a-z0-9_]+(?=\()/i, "number":/\b-?(?:0x[\da-f]+|\d*\.?\d+(?:e[+-]?\d+)?)\b/i, "operator":/--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/, "punctuation":/[{}[\];(),.:]/};
Prism.languages.javascript = Prism.languages.extend("clike", {"keyword":/\b(as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|var|void|while|with|yield)\b/, "number":/\b-?(0x[\dA-Fa-f]+|0b[01]+|0o[0-7]+|\d*\.?\d+([Ee][+-]?\d+)?|NaN|Infinity)\b/, "function":/[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*(?=\()/i});
Prism.languages.insertBefore("javascript", "keyword", {"regex":{pattern:/(^|[^/])\/(?!\/)(\[.+?]|\\.|[^/\\\r\n])+\/[gimyu]{0,5}(?=\s*($|[\r\n,.;})]))/, lookbehind:true, greedy:true}});
Prism.languages.insertBefore("javascript", "class-name", {"template-string":{pattern:/`(?:\\\\|\\?[^\\])*?`/, greedy:true, inside:{"interpolation":{pattern:/\$\{[^}]+\}/, inside:{"interpolation-punctuation":{pattern:/^\$\{|\}$/, alias:"punctuation"}, rest:Prism.languages.javascript}}, "string":/[\s\S]+/}}});
if (Prism.languages.markup) {
  Prism.languages.insertBefore("markup", "tag", {"script":{pattern:/(<script[\w\W]*?>)[\w\W]*?(?=<\/script>)/i, lookbehind:true, inside:Prism.languages.javascript, alias:"language-javascript"}});
}
Prism.languages.js = Prism.languages.javascript;
(function() {
  if (typeof self === "undefined" || !self.Prism || !self.document || !document.querySelector) {
    return;
  }
  self.Prism.fileHighlight = function() {
    var Extensions = {"js":"javascript", "py":"python", "rb":"ruby", "ps1":"powershell", "psm1":"powershell", "sh":"bash", "bat":"batch", "h":"c", "tex":"latex"};
    if (Array.prototype.forEach) {
      Array.prototype.slice.call(document.querySelectorAll("pre[data-src]")).forEach(function(pre) {
        var src = pre.getAttribute("data-src");
        var language, parent = pre;
        var lang = /\blang(?:uage)?-(?!\*)(\w+)\b/i;
        while (parent && !lang.test(parent.className)) {
          parent = parent.parentNode;
        }
        if (parent) {
          language = (pre.className.match(lang) || [, ""])[1];
        }
        if (!language) {
          var extension = (src.match(/\.(\w+)$/) || [, ""])[1];
          language = Extensions[extension] || extension;
        }
        var code = document.createElement("code");
        code.className = "language-" + language;
        pre.textContent = "";
        code.textContent = "Loading…";
        pre.appendChild(code);
        var xhr = new XMLHttpRequest;
        xhr.open("GET", src, true);
        xhr.onreadystatechange = function() {
          if (xhr.readyState == 4) {
            if (xhr.status < 400 && xhr.responseText) {
              code.textContent = xhr.responseText;
              Prism.highlightElement(code);
            } else {
              if (xhr.status >= 400) {
                code.textContent = "✖ Error " + xhr.status + " while fetching file: " + xhr.statusText;
              } else {
                code.textContent = "✖ Error: File does not exist or is empty";
              }
            }
          }
        };
        xhr.send(null);
      });
    }
  };
  document.addEventListener("DOMContentLoaded", self.Prism.fileHighlight);
})();
(function() {
  var HIGHLIGHT_EVENT = "syntax-highlight";
  Polymer({is:"prism-highlighter", ready:function() {
    this._handler = this._highlight.bind(this);
  }, attached:function() {
    (this.parentElement || this.parentNode.host).addEventListener(HIGHLIGHT_EVENT, this._handler);
  }, detached:function() {
    (this.parentElement || this.parentNode.host).removeEventListener(HIGHLIGHT_EVENT, this._handler);
  }, _highlight:function(event) {
    if (!event.detail || !event.detail.code) {
      console.warn("Malformed", HIGHLIGHT_EVENT, "event:", event.detail);
      return;
    }
    var detail = event.detail;
    detail.code = Prism.highlight(detail.code, this._detectLang(detail.code, detail.lang));
  }, _detectLang:function(code, lang) {
    if (!lang) {
      return code.match(/^\s*</) ? Prism.languages.markup : Prism.languages.javascript;
    }
    if (Prism.languages[lang]) {
      return Prism.languages[lang];
    }
    switch(lang.substr(0, 2)) {
      case "js":
      case "es":
        return Prism.languages.javascript;
      case "c":
        return Prism.languages.clike;
      default:
        return Prism.languages.markup;
    }
  }});
})();
(function() {
  Polymer({is:"iron-doc-property", properties:{descriptor:{type:Object, observer:"_descriptorChanged"}, collapsed:{type:Boolean, value:false, observer:"_collapsedChanged"}, anchorId:{type:String, reflectToAttribute:true}, _paramText:String}, listeners:{"transitionEnd":"_onTransitionEnd", "webkitTransitionEnd":"_onTransitionEnd"}, ready:function() {
    this._isReady = true;
  }, _onTransitionEnd:function(event) {
    if (event.path[0] !== this.$.transitionMask) {
      return;
    }
    this.$.transitionMask.style.height = "";
  }, _descriptorChanged:function() {
    this.toggleAttribute("private", this.descriptor.private);
    this.toggleAttribute("configuration", this.descriptor.configuration);
    this.toggleAttribute("function", this.descriptor.function);
    this._paramText = (this.descriptor.params || []).map(function(param) {
      return param.name;
    }).join(", ");
  }, _collapsedChanged:function() {
    if (!this._isReady) {
      this.toggleAttribute("_collapsed", this.collapsed);
      return;
    }
    var container = this.$.transitionMask;
    var collapsed = this.collapsed;
    container.style.height = "auto";
    var fullHeight = container.offsetHeight;
    if (this.collapsed) {
      container.style.height = fullHeight + "px";
    } else {
      container.style.height = "";
    }
    requestAnimationFrame(function() {
      this.toggleAttribute("_collapsed", collapsed);
      if (this.collapsed) {
        container.style.height = "";
      } else {
        container.style.height = fullHeight + "px";
      }
    }.bind(this));
  }, _computeHideMeta:function(descriptor) {
    return descriptor.type === undefined && descriptor.default === undefined;
  }, _computeHideParams:function(descriptor, ret) {
    return (!descriptor.params || descriptor.params.length === 0) && !ret;
  }, _computeHideDefault:function(def) {
    return def === undefined;
  }, _computeDefaultDisplay:function(def) {
    if (def === "") {
      return "''";
    }
    return def;
  }, _getAnnotation:function(descriptor) {
    var annotations = [];
    if (descriptor["default"] !== undefined) {
      annotations.push("Default: " + descriptor["default"]);
    }
    if (descriptor.readOnly) {
      annotations.push("readOnly");
    }
    if (descriptor.notify) {
      annotations.push("notifies");
    }
    return annotations.join(" – ");
  }});
})();
(function() {
  Polymer({is:"iron-doc-viewer", properties:{descriptor:{type:Object, observer:"_descriptorChanged"}, prefix:{type:String, value:""}, _showPrivate:{type:Boolean, value:false, observer:"_showPrivateChanged"}, _privateToggleLabel:String}, ready:function() {
    var jsonDescriptor = this._loadJson();
    if (jsonDescriptor && this.descriptor) {
      console.error(this, "received both a bound descriptor:", this.descriptor, "and JSON descriptor:", this._jsonDescriptor, "Please provide only one");
      throw new Error("<iron-doc-viewer> accepts either a bound or JSON descriptor; not both");
    }
    if (jsonDescriptor) {
      this.descriptor = jsonDescriptor;
    }
  }, _loadJson:function() {
    var textContent = "";
    Array.prototype.forEach.call(Polymer.dom(this).childNodes, function(node) {
      textContent = textContent + node.textContent;
    });
    textContent = textContent.trim();
    if (textContent === "") {
      return null;
    }
    try {
      return JSON.parse(textContent);
    } catch (error) {
      console.error("Failure when parsing JSON:", textContent, error);
      throw error;
    }
  }, _descriptorChanged:function() {
    if (!this.descriptor) {
      return;
    }
    var properties = [];
    var methods = [];
    for (var i = 0, property; property = this.descriptor.properties[i]; i++) {
      (property.type === "Function" ? methods : properties).push(property);
    }
    this._properties = properties;
    this._methods = methods;
    this._events = this.descriptor.events || [];
    this._behaviors = this.descriptor.behaviors || [];
    this.toggleAttribute("abstract", this.descriptor.abstract);
  }, scrollToAnchor:function(hash) {
    if (hash && hash.length > 1) {
      Polymer.dom.flush();
      var anchorId = window.location.hash.slice(1);
      var elementToFocus = this.$$('[anchor-id="' + anchorId + '"]');
      if (elementToFocus) {
        elementToFocus.scrollIntoView();
      }
    }
  }, _collapsedChanged:function() {
    this._collapseToggleLabel = this._collapsed ? "expand" : "collapse";
    var properties = this.querySelectorAll("iron-doc-property");
    for (var i = 0, property; property = properties[i]; i++) {
      property.collapsed = this._collapsed;
    }
  }, _toggleCollapsed:function() {
    this._collapsed = !this._collapsed;
  }, _showPrivateChanged:function() {
    this._privateToggleLabel = (this._showPrivate ? "hide" : "show") + " private API";
    this.toggleClass("show-private", this._showPrivate);
  }, _togglePrivate:function() {
    this._showPrivate = !this._showPrivate;
  }, _noneToShow:function(showPrivate, items) {
    for (var i = 0; i < items.length; i++) {
      if (showPrivate || !items[i].private) {
        return false;
      }
    }
    return true;
  }, _formatAnchor:function(prefix, type, membername) {
    var suffix = membername ? "-" + membername : "";
    return prefix + type + suffix;
  }, _hideBehaviors:function(behaviors) {
    return behaviors === null || behaviors.length === 0;
  }, _broadcastBehavior:function(ev) {
    this.fire("iron-doc-viewer-component-selected", ev.target._templateInstance.item);
  }});
})();
(function() {
  Polymer.IronJsonpLibraryBehavior = {properties:{libraryLoaded:{type:Boolean, value:false, notify:true, readOnly:true}, libraryErrorMessage:{type:String, value:null, notify:true, readOnly:true}}, observers:["_libraryUrlChanged(libraryUrl)"], _libraryUrlChanged:function(libraryUrl) {
    if (this._isReady && this.libraryUrl) {
      this._loadLibrary();
    }
  }, _libraryLoadCallback:function(err, result) {
    if (err) {
      console.warn("Library load failed:", err.message);
      this._setLibraryErrorMessage(err.message);
    } else {
      this._setLibraryErrorMessage(null);
      this._setLibraryLoaded(true);
      if (this.notifyEvent) {
        this.fire(this.notifyEvent, result);
      }
    }
  }, _loadLibrary:function() {
    LoaderMap.require(this.libraryUrl, this._libraryLoadCallback.bind(this), this.callbackName);
  }, ready:function() {
    this._isReady = true;
    if (this.libraryUrl) {
      this._loadLibrary();
    }
  }};
  var LoaderMap = {apiMap:{}, require:function(url, notifyCallback, jsonpCallbackName) {
    var name = this.nameFromUrl(url);
    if (!this.apiMap[name]) {
      this.apiMap[name] = new Loader(name, url, jsonpCallbackName);
    }
    this.apiMap[name].requestNotify(notifyCallback);
  }, nameFromUrl:function(url) {
    return url.replace(/[\:\/\%\?\&\.\=\-\,]/g, "_") + "_api";
  }};
  var Loader = function(name, url, callbackName) {
    this.notifiers = [];
    if (!callbackName) {
      if (url.indexOf(this.callbackMacro) >= 0) {
        callbackName = name + "_loaded";
        url = url.replace(this.callbackMacro, callbackName);
      } else {
        this.error = new Error("IronJsonpLibraryBehavior a %%callback%% parameter is required in libraryUrl");
        return;
      }
    }
    this.callbackName = callbackName;
    window[this.callbackName] = this.success.bind(this);
    this.addScript(url);
  };
  Loader.prototype = {callbackMacro:"%%callback%%", loaded:false, addScript:function(src) {
    var script = document.createElement("script");
    script.src = src;
    script.onerror = this.handleError.bind(this);
    var s = document.querySelector("script") || document.body;
    s.parentNode.insertBefore(script, s);
    this.script = script;
  }, removeScript:function() {
    if (this.script.parentNode) {
      this.script.parentNode.removeChild(this.script);
    }
    this.script = null;
  }, handleError:function(ev) {
    this.error = new Error("Library failed to load");
    this.notifyAll();
    this.cleanup();
  }, success:function() {
    this.loaded = true;
    this.result = Array.prototype.slice.call(arguments);
    this.notifyAll();
    this.cleanup();
  }, cleanup:function() {
    delete window[this.callbackName];
  }, notifyAll:function() {
    this.notifiers.forEach(function(notifyCallback) {
      notifyCallback(this.error, this.result);
    }.bind(this));
    this.notifiers = [];
  }, requestNotify:function(notifyCallback) {
    if (this.loaded || this.error) {
      notifyCallback(this.error, this.result);
    } else {
      this.notifiers.push(notifyCallback);
    }
  }};
})();
Polymer({is:"iron-jsonp-library", behaviors:[Polymer.IronJsonpLibraryBehavior], properties:{libraryUrl:String, callbackName:String, notifyEvent:String}});
Polymer({is:"iron-localstorage", properties:{name:{type:String, value:""}, value:{type:Object, notify:true}, useRaw:{type:Boolean, value:false}, autoSaveDisabled:{type:Boolean, value:false}, errorMessage:{type:String, notify:true}, _loaded:{type:Boolean, value:false}}, observers:["_debounceReload(name,useRaw)", "_trySaveValue(autoSaveDisabled)", "_trySaveValue(value.*)"], ready:function() {
  this._boundHandleStorage = this._handleStorage.bind(this);
}, attached:function() {
  window.addEventListener("storage", this._boundHandleStorage);
}, detached:function() {
  window.removeEventListener("storage", this._boundHandleStorage);
}, _handleStorage:function(ev) {
  if (ev.key == this.name) {
    this._load(true);
  }
}, _trySaveValue:function() {
  if (this._doNotSave) {
    return;
  }
  if (this._loaded && !this.autoSaveDisabled) {
    this.debounce("save", this.save);
  }
}, _debounceReload:function() {
  this.debounce("reload", this.reload);
}, reload:function() {
  this._loaded = false;
  this._load();
}, _load:function(externalChange) {
  var v = window.localStorage.getItem(this.name);
  if (v === null) {
    this._loaded = true;
    this._doNotSave = true;
    this.value = null;
    this._doNotSave = false;
    this.fire("iron-localstorage-load-empty", {externalChange:externalChange});
  } else {
    if (!this.useRaw) {
      try {
        v = JSON.parse(v);
      } catch (x) {
        this.errorMessage = "Could not parse local storage value";
        console.error("could not parse local storage value", v);
        v = null;
      }
    }
    this._loaded = true;
    this._doNotSave = true;
    this.value = v;
    this._doNotSave = false;
    this.fire("iron-localstorage-load", {externalChange:externalChange});
  }
}, save:function() {
  var v = this.useRaw ? this.value : JSON.stringify(this.value);
  try {
    if (this.value === null || this.value === undefined) {
      window.localStorage.removeItem(this.name);
    } else {
      window.localStorage.setItem(this.name, v);
    }
  } catch (ex) {
    this.errorMessage = ex.message;
    console.error("localStorage could not be saved. Safari incoginito mode?", ex);
  }
}});
Polymer({is:"iron-media-query", properties:{queryMatches:{type:Boolean, value:false, readOnly:true, notify:true}, query:{type:String, observer:"queryChanged"}, full:{type:Boolean, value:false}, _boundMQHandler:{value:function() {
  return this.queryHandler.bind(this);
}}, _mq:{value:null}}, attached:function() {
  this.style.display = "none";
  this.queryChanged();
}, detached:function() {
  this._remove();
}, _add:function() {
  if (this._mq) {
    this._mq.addListener(this._boundMQHandler);
  }
}, _remove:function() {
  if (this._mq) {
    this._mq.removeListener(this._boundMQHandler);
  }
  this._mq = null;
}, queryChanged:function() {
  this._remove();
  var query = this.query;
  if (!query) {
    return;
  }
  if (!this.full && query[0] !== "(") {
    query = "(" + query + ")";
  }
  this._mq = window.matchMedia(query);
  this._add();
  this.queryHandler(this._mq);
}, queryHandler:function(mq) {
  this._setQueryMatches(mq.matches);
}});
(function() {
  Polymer({is:"iron-overlay-backdrop", properties:{opened:{reflectToAttribute:true, type:Boolean, value:false, observer:"_openedChanged"}}, listeners:{"transitionend":"_onTransitionend"}, created:function() {
    this.__openedRaf = null;
  }, attached:function() {
    this.opened && this._openedChanged(this.opened);
  }, prepare:function() {
    if (this.opened && !this.parentNode) {
      Polymer.dom(document.body).appendChild(this);
    }
  }, open:function() {
    this.opened = true;
  }, close:function() {
    this.opened = false;
  }, complete:function() {
    if (!this.opened && this.parentNode === document.body) {
      Polymer.dom(this.parentNode).removeChild(this);
    }
  }, _onTransitionend:function(event) {
    if (event && event.target === this) {
      this.complete();
    }
  }, _openedChanged:function(opened) {
    if (opened) {
      this.prepare();
    } else {
      var cs = window.getComputedStyle(this);
      if (cs.transitionDuration === "0s" || cs.opacity == 0) {
        this.complete();
      }
    }
    if (!this.isAttached) {
      return;
    }
    if (this.__openedRaf) {
      window.cancelAnimationFrame(this.__openedRaf);
      this.__openedRaf = null;
    }
    this.scrollTop = this.scrollTop;
    this.__openedRaf = window.requestAnimationFrame(function() {
      this.__openedRaf = null;
      this.toggleClass("opened", this.opened);
    }.bind(this));
  }});
})();
Polymer.IronFitBehavior = {properties:{sizingTarget:{type:Object, value:function() {
  return this;
}}, fitInto:{type:Object, value:window}, noOverlap:{type:Boolean}, positionTarget:{type:Element}, horizontalAlign:{type:String}, verticalAlign:{type:String}, dynamicAlign:{type:Boolean}, horizontalOffset:{type:Number, value:0, notify:true}, verticalOffset:{type:Number, value:0, notify:true}, autoFitOnAttach:{type:Boolean, value:false}, _fitInfo:{type:Object}}, get _fitWidth() {
  var fitWidth;
  if (this.fitInto === window) {
    fitWidth = this.fitInto.innerWidth;
  } else {
    fitWidth = this.fitInto.getBoundingClientRect().width;
  }
  return fitWidth;
}, get _fitHeight() {
  var fitHeight;
  if (this.fitInto === window) {
    fitHeight = this.fitInto.innerHeight;
  } else {
    fitHeight = this.fitInto.getBoundingClientRect().height;
  }
  return fitHeight;
}, get _fitLeft() {
  var fitLeft;
  if (this.fitInto === window) {
    fitLeft = 0;
  } else {
    fitLeft = this.fitInto.getBoundingClientRect().left;
  }
  return fitLeft;
}, get _fitTop() {
  var fitTop;
  if (this.fitInto === window) {
    fitTop = 0;
  } else {
    fitTop = this.fitInto.getBoundingClientRect().top;
  }
  return fitTop;
}, get _defaultPositionTarget() {
  var parent = Polymer.dom(this).parentNode;
  if (parent && parent.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
    parent = parent.host;
  }
  return parent;
}, get _localeHorizontalAlign() {
  if (this._isRTL) {
    if (this.horizontalAlign === "right") {
      return "left";
    }
    if (this.horizontalAlign === "left") {
      return "right";
    }
  }
  return this.horizontalAlign;
}, attached:function() {
  this._isRTL = window.getComputedStyle(this).direction == "rtl";
  this.positionTarget = this.positionTarget || this._defaultPositionTarget;
  if (this.autoFitOnAttach) {
    if (window.getComputedStyle(this).display === "none") {
      setTimeout(function() {
        this.fit();
      }.bind(this));
    } else {
      this.fit();
    }
  }
}, fit:function() {
  this._discoverInfo();
  this.position();
  this.constrain();
  this.center();
}, _discoverInfo:function() {
  if (this._fitInfo) {
    return;
  }
  var target = window.getComputedStyle(this);
  var sizer = window.getComputedStyle(this.sizingTarget);
  this._fitInfo = {inlineStyle:{top:this.style.top || "", left:this.style.left || "", position:this.style.position || ""}, sizerInlineStyle:{maxWidth:this.sizingTarget.style.maxWidth || "", maxHeight:this.sizingTarget.style.maxHeight || "", boxSizing:this.sizingTarget.style.boxSizing || ""}, positionedBy:{vertically:target.top !== "auto" ? "top" : target.bottom !== "auto" ? "bottom" : null, horizontally:target.left !== "auto" ? "left" : target.right !== "auto" ? "right" : null}, sizedBy:{height:sizer.maxHeight !== 
  "none", width:sizer.maxWidth !== "none", minWidth:parseInt(sizer.minWidth, 10) || 0, minHeight:parseInt(sizer.minHeight, 10) || 0}, margin:{top:parseInt(target.marginTop, 10) || 0, right:parseInt(target.marginRight, 10) || 0, bottom:parseInt(target.marginBottom, 10) || 0, left:parseInt(target.marginLeft, 10) || 0}};
  if (this.verticalOffset) {
    this._fitInfo.margin.top = this._fitInfo.margin.bottom = this.verticalOffset;
    this._fitInfo.inlineStyle.marginTop = this.style.marginTop || "";
    this._fitInfo.inlineStyle.marginBottom = this.style.marginBottom || "";
    this.style.marginTop = this.style.marginBottom = this.verticalOffset + "px";
  }
  if (this.horizontalOffset) {
    this._fitInfo.margin.left = this._fitInfo.margin.right = this.horizontalOffset;
    this._fitInfo.inlineStyle.marginLeft = this.style.marginLeft || "";
    this._fitInfo.inlineStyle.marginRight = this.style.marginRight || "";
    this.style.marginLeft = this.style.marginRight = this.horizontalOffset + "px";
  }
}, resetFit:function() {
  var info = this._fitInfo || {};
  for (var property in info.sizerInlineStyle) {
    this.sizingTarget.style[property] = info.sizerInlineStyle[property];
  }
  for (var property in info.inlineStyle) {
    this.style[property] = info.inlineStyle[property];
  }
  this._fitInfo = null;
}, refit:function() {
  var scrollLeft = this.sizingTarget.scrollLeft;
  var scrollTop = this.sizingTarget.scrollTop;
  this.resetFit();
  this.fit();
  this.sizingTarget.scrollLeft = scrollLeft;
  this.sizingTarget.scrollTop = scrollTop;
}, position:function() {
  if (!this.horizontalAlign && !this.verticalAlign) {
    return;
  }
  this.style.position = "fixed";
  this.sizingTarget.style.boxSizing = "border-box";
  this.style.left = "0px";
  this.style.top = "0px";
  var rect = this.getBoundingClientRect();
  var positionRect = this.__getNormalizedRect(this.positionTarget);
  var fitRect = this.__getNormalizedRect(this.fitInto);
  var margin = this._fitInfo.margin;
  var size = {width:rect.width + margin.left + margin.right, height:rect.height + margin.top + margin.bottom};
  var position = this.__getPosition(this._localeHorizontalAlign, this.verticalAlign, size, positionRect, fitRect);
  var left = position.left + margin.left;
  var top = position.top + margin.top;
  var right = Math.min(fitRect.right - margin.right, left + rect.width);
  var bottom = Math.min(fitRect.bottom - margin.bottom, top + rect.height);
  var minWidth = this._fitInfo.sizedBy.minWidth;
  var minHeight = this._fitInfo.sizedBy.minHeight;
  if (left < margin.left) {
    left = margin.left;
    if (right - left < minWidth) {
      left = right - minWidth;
    }
  }
  if (top < margin.top) {
    top = margin.top;
    if (bottom - top < minHeight) {
      top = bottom - minHeight;
    }
  }
  this.sizingTarget.style.maxWidth = right - left + "px";
  this.sizingTarget.style.maxHeight = bottom - top + "px";
  this.style.left = left - rect.left + "px";
  this.style.top = top - rect.top + "px";
}, constrain:function() {
  if (this.horizontalAlign || this.verticalAlign) {
    return;
  }
  var info = this._fitInfo;
  if (!info.positionedBy.vertically) {
    this.style.position = "fixed";
    this.style.top = "0px";
  }
  if (!info.positionedBy.horizontally) {
    this.style.position = "fixed";
    this.style.left = "0px";
  }
  this.sizingTarget.style.boxSizing = "border-box";
  var rect = this.getBoundingClientRect();
  if (!info.sizedBy.height) {
    this.__sizeDimension(rect, info.positionedBy.vertically, "top", "bottom", "Height");
  }
  if (!info.sizedBy.width) {
    this.__sizeDimension(rect, info.positionedBy.horizontally, "left", "right", "Width");
  }
}, _sizeDimension:function(rect, positionedBy, start, end, extent) {
  this.__sizeDimension(rect, positionedBy, start, end, extent);
}, __sizeDimension:function(rect, positionedBy, start, end, extent) {
  var info = this._fitInfo;
  var fitRect = this.__getNormalizedRect(this.fitInto);
  var max = extent === "Width" ? fitRect.width : fitRect.height;
  var flip = positionedBy === end;
  var offset = flip ? max - rect[end] : rect[start];
  var margin = info.margin[flip ? start : end];
  var offsetExtent = "offset" + extent;
  var sizingOffset = this[offsetExtent] - this.sizingTarget[offsetExtent];
  this.sizingTarget.style["max" + extent] = max - margin - offset - sizingOffset + "px";
}, center:function() {
  if (this.horizontalAlign || this.verticalAlign) {
    return;
  }
  var positionedBy = this._fitInfo.positionedBy;
  if (positionedBy.vertically && positionedBy.horizontally) {
    return;
  }
  this.style.position = "fixed";
  if (!positionedBy.vertically) {
    this.style.top = "0px";
  }
  if (!positionedBy.horizontally) {
    this.style.left = "0px";
  }
  var rect = this.getBoundingClientRect();
  var fitRect = this.__getNormalizedRect(this.fitInto);
  if (!positionedBy.vertically) {
    var top = fitRect.top - rect.top + (fitRect.height - rect.height) / 2;
    this.style.top = top + "px";
  }
  if (!positionedBy.horizontally) {
    var left = fitRect.left - rect.left + (fitRect.width - rect.width) / 2;
    this.style.left = left + "px";
  }
}, __getNormalizedRect:function(target) {
  if (target === document.documentElement || target === window) {
    return {top:0, left:0, width:window.innerWidth, height:window.innerHeight, right:window.innerWidth, bottom:window.innerHeight};
  }
  return target.getBoundingClientRect();
}, __getCroppedArea:function(position, size, fitRect) {
  var verticalCrop = Math.min(0, position.top) + Math.min(0, fitRect.bottom - (position.top + size.height));
  var horizontalCrop = Math.min(0, position.left) + Math.min(0, fitRect.right - (position.left + size.width));
  return Math.abs(verticalCrop) * size.width + Math.abs(horizontalCrop) * size.height;
}, __getPosition:function(hAlign, vAlign, size, positionRect, fitRect) {
  var positions = [{verticalAlign:"top", horizontalAlign:"left", top:positionRect.top, left:positionRect.left}, {verticalAlign:"top", horizontalAlign:"right", top:positionRect.top, left:positionRect.right - size.width}, {verticalAlign:"bottom", horizontalAlign:"left", top:positionRect.bottom - size.height, left:positionRect.left}, {verticalAlign:"bottom", horizontalAlign:"right", top:positionRect.bottom - size.height, left:positionRect.right - size.width}];
  if (this.noOverlap) {
    for (var i = 0, l = positions.length; i < l; i++) {
      var copy = {};
      for (var key in positions[i]) {
        copy[key] = positions[i][key];
      }
      positions.push(copy);
    }
    positions[0].top = positions[1].top += positionRect.height;
    positions[2].top = positions[3].top -= positionRect.height;
    positions[4].left = positions[6].left += positionRect.width;
    positions[5].left = positions[7].left -= positionRect.width;
  }
  vAlign = vAlign === "auto" ? null : vAlign;
  hAlign = hAlign === "auto" ? null : hAlign;
  var position;
  for (var i = 0; i < positions.length; i++) {
    var pos = positions[i];
    if (!this.dynamicAlign && !this.noOverlap && pos.verticalAlign === vAlign && pos.horizontalAlign === hAlign) {
      position = pos;
      break;
    }
    var alignOk = (!vAlign || pos.verticalAlign === vAlign) && (!hAlign || pos.horizontalAlign === hAlign);
    if (!this.dynamicAlign && !alignOk) {
      continue;
    }
    position = position || pos;
    pos.croppedArea = this.__getCroppedArea(pos, size, fitRect);
    var diff = pos.croppedArea - position.croppedArea;
    if (diff < 0 || diff === 0 && alignOk) {
      position = pos;
    }
    if (position.croppedArea === 0 && alignOk) {
      break;
    }
  }
  return position;
}};
Polymer.IronOverlayManagerClass = function() {
  this._overlays = [];
  this._minimumZ = 101;
  this._backdropElement = null;
  Polymer.Gestures.add(document, "tap", null);
  document.addEventListener("tap", this._onCaptureClick.bind(this), true);
  document.addEventListener("focus", this._onCaptureFocus.bind(this), true);
  document.addEventListener("keydown", this._onCaptureKeyDown.bind(this), true);
};
Polymer.IronOverlayManagerClass.prototype = {constructor:Polymer.IronOverlayManagerClass, get backdropElement() {
  if (!this._backdropElement) {
    this._backdropElement = document.createElement("iron-overlay-backdrop");
  }
  return this._backdropElement;
}, get deepActiveElement() {
  var active = document.activeElement || document.body;
  while (active.root && Polymer.dom(active.root).activeElement) {
    active = Polymer.dom(active.root).activeElement;
  }
  return active;
}, _bringOverlayAtIndexToFront:function(i) {
  var overlay = this._overlays[i];
  if (!overlay) {
    return;
  }
  var lastI = this._overlays.length - 1;
  var currentOverlay = this._overlays[lastI];
  if (currentOverlay && this._shouldBeBehindOverlay(overlay, currentOverlay)) {
    lastI--;
  }
  if (i >= lastI) {
    return;
  }
  var minimumZ = Math.max(this.currentOverlayZ(), this._minimumZ);
  if (this._getZ(overlay) <= minimumZ) {
    this._applyOverlayZ(overlay, minimumZ);
  }
  while (i < lastI) {
    this._overlays[i] = this._overlays[i + 1];
    i++;
  }
  this._overlays[lastI] = overlay;
}, addOrRemoveOverlay:function(overlay) {
  if (overlay.opened) {
    this.addOverlay(overlay);
  } else {
    this.removeOverlay(overlay);
  }
}, addOverlay:function(overlay) {
  var i = this._overlays.indexOf(overlay);
  if (i >= 0) {
    this._bringOverlayAtIndexToFront(i);
    this.trackBackdrop();
    return;
  }
  var insertionIndex = this._overlays.length;
  var currentOverlay = this._overlays[insertionIndex - 1];
  var minimumZ = Math.max(this._getZ(currentOverlay), this._minimumZ);
  var newZ = this._getZ(overlay);
  if (currentOverlay && this._shouldBeBehindOverlay(overlay, currentOverlay)) {
    this._applyOverlayZ(currentOverlay, minimumZ);
    insertionIndex--;
    var previousOverlay = this._overlays[insertionIndex - 1];
    minimumZ = Math.max(this._getZ(previousOverlay), this._minimumZ);
  }
  if (newZ <= minimumZ) {
    this._applyOverlayZ(overlay, minimumZ);
  }
  this._overlays.splice(insertionIndex, 0, overlay);
  var element = this.deepActiveElement;
  overlay.restoreFocusNode = this._overlayParent(element) ? null : element;
  this.trackBackdrop();
}, removeOverlay:function(overlay) {
  var i = this._overlays.indexOf(overlay);
  if (i === -1) {
    return;
  }
  this._overlays.splice(i, 1);
  var node = overlay.restoreFocusOnClose ? overlay.restoreFocusNode : null;
  overlay.restoreFocusNode = null;
  if (node && Polymer.dom(document.body).deepContains(node)) {
    node.focus();
  }
  this.trackBackdrop();
}, currentOverlay:function() {
  var i = this._overlays.length - 1;
  return this._overlays[i];
}, currentOverlayZ:function() {
  return this._getZ(this.currentOverlay());
}, ensureMinimumZ:function(minimumZ) {
  this._minimumZ = Math.max(this._minimumZ, minimumZ);
}, focusOverlay:function() {
  var current = this.currentOverlay();
  if (current && !current.transitioning) {
    current._applyFocus();
  }
}, trackBackdrop:function() {
  var overlay = this._overlayWithBackdrop();
  if (!overlay && !this._backdropElement) {
    return;
  }
  this.backdropElement.style.zIndex = this._getZ(overlay) - 1;
  this.backdropElement.opened = !!overlay;
}, getBackdrops:function() {
  var backdrops = [];
  for (var i = 0; i < this._overlays.length; i++) {
    if (this._overlays[i].withBackdrop) {
      backdrops.push(this._overlays[i]);
    }
  }
  return backdrops;
}, backdropZ:function() {
  return this._getZ(this._overlayWithBackdrop()) - 1;
}, _overlayWithBackdrop:function() {
  for (var i = 0; i < this._overlays.length; i++) {
    if (this._overlays[i].withBackdrop) {
      return this._overlays[i];
    }
  }
}, _getZ:function(overlay) {
  var z = this._minimumZ;
  if (overlay) {
    var z1 = Number(overlay.style.zIndex || window.getComputedStyle(overlay).zIndex);
    if (z1 === z1) {
      z = z1;
    }
  }
  return z;
}, _setZ:function(element, z) {
  element.style.zIndex = z;
}, _applyOverlayZ:function(overlay, aboveZ) {
  this._setZ(overlay, aboveZ + 2);
}, _overlayParent:function(node) {
  while (node && node !== document.body) {
    if (node._manager === this) {
      return node;
    }
    node = Polymer.dom(node).parentNode || node.host;
  }
}, _overlayInPath:function(path) {
  path = path || [];
  for (var i = 0; i < path.length; i++) {
    if (path[i]._manager === this) {
      return path[i];
    }
  }
}, _onCaptureClick:function(event) {
  var overlay = this.currentOverlay();
  if (overlay && this._overlayInPath(Polymer.dom(event).path) !== overlay) {
    overlay._onCaptureClick(event);
  }
}, _onCaptureFocus:function(event) {
  var overlay = this.currentOverlay();
  if (overlay) {
    overlay._onCaptureFocus(event);
  }
}, _onCaptureKeyDown:function(event) {
  var overlay = this.currentOverlay();
  if (overlay) {
    if (Polymer.IronA11yKeysBehavior.keyboardEventMatchesKeys(event, "esc")) {
      overlay._onCaptureEsc(event);
    } else {
      if (Polymer.IronA11yKeysBehavior.keyboardEventMatchesKeys(event, "tab")) {
        overlay._onCaptureTab(event);
      }
    }
  }
}, _shouldBeBehindOverlay:function(overlay1, overlay2) {
  var o1 = overlay1;
  var o2 = overlay2;
  return !o1.alwaysOnTop && o2.alwaysOnTop;
}};
Polymer.IronOverlayManager = new Polymer.IronOverlayManagerClass;
(function() {
  Polymer.IronOverlayBehaviorImpl = {properties:{opened:{observer:"_openedChanged", type:Boolean, value:false, notify:true}, canceled:{observer:"_canceledChanged", readOnly:true, type:Boolean, value:false}, withBackdrop:{observer:"_withBackdropChanged", type:Boolean}, noAutoFocus:{type:Boolean, value:false}, noCancelOnEscKey:{type:Boolean, value:false}, noCancelOnOutsideClick:{type:Boolean, value:false}, closingReason:{type:Object}, restoreFocusOnClose:{type:Boolean, value:false}, alwaysOnTop:{type:Boolean}, 
  _manager:{type:Object, value:function() {
    return Polymer.IronOverlayManager;
  }}, _focusedChild:{type:Object}}, listeners:{"iron-resize":"_onIronResize"}, get backdropElement() {
    return this._manager.backdropElement;
  }, get _focusNode() {
    return this._focusedChild || Polymer.dom(this).querySelector("[autofocus]") || this;
  }, get _focusableNodes() {
    var FOCUSABLE_WITH_DISABLED = ["a[href]", "area[href]", "iframe", "[tabindex]", "[contentEditable=true]"];
    var FOCUSABLE_WITHOUT_DISABLED = ["input", "select", "textarea", "button"];
    var selector = FOCUSABLE_WITH_DISABLED.join(':not([tabindex="-1"]),') + ':not([tabindex="-1"]),' + FOCUSABLE_WITHOUT_DISABLED.join(':not([disabled]):not([tabindex="-1"]),') + ':not([disabled]):not([tabindex="-1"])';
    var focusables = Polymer.dom(this).querySelectorAll(selector);
    if (this.tabIndex >= 0) {
      focusables.splice(0, 0, this);
    }
    return focusables.sort(function(a, b) {
      if (a.tabIndex === b.tabIndex) {
        return 0;
      }
      if (a.tabIndex === 0 || a.tabIndex > b.tabIndex) {
        return 1;
      }
      return -1;
    });
  }, ready:function() {
    this.__isAnimating = false;
    this.__shouldRemoveTabIndex = false;
    this.__firstFocusableNode = this.__lastFocusableNode = null;
    this.__openChangedAsync = null;
    this.__onIronResizeAsync = null;
    this._ensureSetup();
  }, attached:function() {
    if (this.opened) {
      this._openedChanged();
    }
    this._observer = Polymer.dom(this).observeNodes(this._onNodesChange);
  }, detached:function() {
    Polymer.dom(this).unobserveNodes(this._observer);
    this._observer = null;
    this.opened = false;
  }, toggle:function() {
    this._setCanceled(false);
    this.opened = !this.opened;
  }, open:function() {
    this._setCanceled(false);
    this.opened = true;
  }, close:function() {
    this._setCanceled(false);
    this.opened = false;
  }, cancel:function(event) {
    var cancelEvent = this.fire("iron-overlay-canceled", event, {cancelable:true});
    if (cancelEvent.defaultPrevented) {
      return;
    }
    this._setCanceled(true);
    this.opened = false;
  }, _ensureSetup:function() {
    if (this._overlaySetup) {
      return;
    }
    this._overlaySetup = true;
    this.style.outline = "none";
    this.style.display = "none";
  }, _openedChanged:function() {
    if (this.opened) {
      this.removeAttribute("aria-hidden");
    } else {
      this.setAttribute("aria-hidden", "true");
    }
    if (!this._overlaySetup) {
      return;
    }
    if (this.__openChangedAsync) {
      window.cancelAnimationFrame(this.__openChangedAsync);
    }
    if (!this.opened) {
      this._manager.removeOverlay(this);
    }
    if (!this.isAttached) {
      return;
    }
    this.__isAnimating = true;
    this.__openChangedAsync = window.requestAnimationFrame(function() {
      this.__openChangedAsync = null;
      if (this.opened) {
        this._manager.addOverlay(this);
        this._prepareRenderOpened();
        this._renderOpened();
      } else {
        this._renderClosed();
      }
    }.bind(this));
  }, _canceledChanged:function() {
    this.closingReason = this.closingReason || {};
    this.closingReason.canceled = this.canceled;
  }, _withBackdropChanged:function() {
    if (this.withBackdrop && !this.hasAttribute("tabindex")) {
      this.setAttribute("tabindex", "-1");
      this.__shouldRemoveTabIndex = true;
    } else {
      if (this.__shouldRemoveTabIndex) {
        this.removeAttribute("tabindex");
        this.__shouldRemoveTabIndex = false;
      }
    }
    if (this.opened && this.isAttached) {
      this._manager.trackBackdrop();
    }
  }, _prepareRenderOpened:function() {
    this._preparePositioning();
    this.refit();
    this._finishPositioning();
    if (this.noAutoFocus && document.activeElement === this._focusNode) {
      this._focusNode.blur();
    }
  }, _renderOpened:function() {
    this._finishRenderOpened();
  }, _renderClosed:function() {
    this._finishRenderClosed();
  }, _finishRenderOpened:function() {
    this._applyFocus();
    this.notifyResize();
    this.__isAnimating = false;
    var focusableNodes = this._focusableNodes;
    this.__firstFocusableNode = focusableNodes[0];
    this.__lastFocusableNode = focusableNodes[focusableNodes.length - 1];
    this.fire("iron-overlay-opened");
  }, _finishRenderClosed:function() {
    this.style.display = "none";
    this.style.zIndex = "";
    this._applyFocus();
    this.notifyResize();
    this.__isAnimating = false;
    this.fire("iron-overlay-closed", this.closingReason);
  }, _preparePositioning:function() {
    this.style.transition = this.style.webkitTransition = "none";
    this.style.transform = this.style.webkitTransform = "none";
    this.style.display = "";
  }, _finishPositioning:function() {
    this.style.display = "none";
    this.scrollTop = this.scrollTop;
    this.style.transition = this.style.webkitTransition = "";
    this.style.transform = this.style.webkitTransform = "";
    this.style.display = "";
    this.scrollTop = this.scrollTop;
  }, _applyFocus:function() {
    if (this.opened) {
      if (!this.noAutoFocus) {
        this._focusNode.focus();
      }
    } else {
      this._focusNode.blur();
      this._focusedChild = null;
      this._manager.focusOverlay();
    }
  }, _onCaptureClick:function(event) {
    if (!this.noCancelOnOutsideClick) {
      this.cancel(event);
    }
  }, _onCaptureFocus:function(event) {
    if (!this.withBackdrop) {
      return;
    }
    var path = Polymer.dom(event).path;
    if (path.indexOf(this) === -1) {
      event.stopPropagation();
      this._applyFocus();
    } else {
      this._focusedChild = path[0];
    }
  }, _onCaptureEsc:function(event) {
    if (!this.noCancelOnEscKey) {
      this.cancel(event);
    }
  }, _onCaptureTab:function(event) {
    if (!this.withBackdrop) {
      return;
    }
    var shift = event.shiftKey;
    var nodeToCheck = shift ? this.__firstFocusableNode : this.__lastFocusableNode;
    var nodeToSet = shift ? this.__lastFocusableNode : this.__firstFocusableNode;
    var shouldWrap = false;
    if (nodeToCheck === nodeToSet) {
      shouldWrap = true;
    } else {
      var focusedNode = this._manager.deepActiveElement;
      shouldWrap = focusedNode === nodeToCheck || focusedNode === this;
    }
    if (shouldWrap) {
      event.preventDefault();
      this._focusedChild = nodeToSet;
      this._applyFocus();
    }
  }, _onIronResize:function() {
    if (this.__onIronResizeAsync) {
      window.cancelAnimationFrame(this.__onIronResizeAsync);
      this.__onIronResizeAsync = null;
    }
    if (this.opened && !this.__isAnimating) {
      this.__onIronResizeAsync = window.requestAnimationFrame(function() {
        this.__onIronResizeAsync = null;
        this.refit();
      }.bind(this));
    }
  }, _onNodesChange:function() {
    if (this.opened && !this.__isAnimating) {
      this.notifyResize();
    }
  }};
  Polymer.IronOverlayBehavior = [Polymer.IronFitBehavior, Polymer.IronResizableBehavior, Polymer.IronOverlayBehaviorImpl];
})();
Polymer.IronSelection = function(selectCallback) {
  this.selection = [];
  this.selectCallback = selectCallback;
};
Polymer.IronSelection.prototype = {get:function() {
  return this.multi ? this.selection.slice() : this.selection[0];
}, clear:function(excludes) {
  this.selection.slice().forEach(function(item) {
    if (!excludes || excludes.indexOf(item) < 0) {
      this.setItemSelected(item, false);
    }
  }, this);
}, isSelected:function(item) {
  return this.selection.indexOf(item) >= 0;
}, setItemSelected:function(item, isSelected) {
  if (item != null) {
    if (isSelected !== this.isSelected(item)) {
      if (isSelected) {
        this.selection.push(item);
      } else {
        var i = this.selection.indexOf(item);
        if (i >= 0) {
          this.selection.splice(i, 1);
        }
      }
      if (this.selectCallback) {
        this.selectCallback(item, isSelected);
      }
    }
  }
}, select:function(item) {
  if (this.multi) {
    this.toggle(item);
  } else {
    if (this.get() !== item) {
      this.setItemSelected(this.get(), false);
      this.setItemSelected(item, true);
    }
  }
}, toggle:function(item) {
  this.setItemSelected(item, !this.isSelected(item));
}};
Polymer.IronSelectableBehavior = {properties:{attrForSelected:{type:String, value:null}, selected:{type:String, notify:true}, selectedItem:{type:Object, readOnly:true, notify:true}, activateEvent:{type:String, value:"tap", observer:"_activateEventChanged"}, selectable:String, selectedClass:{type:String, value:"iron-selected"}, selectedAttribute:{type:String, value:null}, fallbackSelection:{type:String, value:null}, items:{type:Array, readOnly:true, notify:true, value:function() {
  return [];
}}, _excludedLocalNames:{type:Object, value:function() {
  return {"template":1};
}}}, observers:["_updateAttrForSelected(attrForSelected)", "_updateSelected(selected)", "_checkFallback(fallbackSelection)"], created:function() {
  this._bindFilterItem = this._filterItem.bind(this);
  this._selection = new Polymer.IronSelection(this._applySelection.bind(this));
}, attached:function() {
  this._observer = this._observeItems(this);
  this._updateItems();
  if (!this._shouldUpdateSelection) {
    this._updateSelected();
  }
  this._addListener(this.activateEvent);
}, detached:function() {
  if (this._observer) {
    Polymer.dom(this).unobserveNodes(this._observer);
  }
  this._removeListener(this.activateEvent);
}, indexOf:function(item) {
  return this.items.indexOf(item);
}, select:function(value) {
  this.selected = value;
}, selectPrevious:function() {
  var length = this.items.length;
  var index = (Number(this._valueToIndex(this.selected)) - 1 + length) % length;
  this.selected = this._indexToValue(index);
}, selectNext:function() {
  var index = (Number(this._valueToIndex(this.selected)) + 1) % this.items.length;
  this.selected = this._indexToValue(index);
}, selectIndex:function(index) {
  this.select(this._indexToValue(index));
}, forceSynchronousItemUpdate:function() {
  this._updateItems();
}, get _shouldUpdateSelection() {
  return this.selected != null;
}, _checkFallback:function() {
  if (this._shouldUpdateSelection) {
    this._updateSelected();
  }
}, _addListener:function(eventName) {
  this.listen(this, eventName, "_activateHandler");
}, _removeListener:function(eventName) {
  this.unlisten(this, eventName, "_activateHandler");
}, _activateEventChanged:function(eventName, old) {
  this._removeListener(old);
  this._addListener(eventName);
}, _updateItems:function() {
  var nodes = Polymer.dom(this).queryDistributedElements(this.selectable || "*");
  nodes = Array.prototype.filter.call(nodes, this._bindFilterItem);
  this._setItems(nodes);
}, _updateAttrForSelected:function() {
  if (this._shouldUpdateSelection) {
    this.selected = this._indexToValue(this.indexOf(this.selectedItem));
  }
}, _updateSelected:function() {
  this._selectSelected(this.selected);
}, _selectSelected:function(selected) {
  this._selection.select(this._valueToItem(this.selected));
  if (this.fallbackSelection && this.items.length && this._selection.get() === undefined) {
    this.selected = this.fallbackSelection;
  }
}, _filterItem:function(node) {
  return !this._excludedLocalNames[node.localName];
}, _valueToItem:function(value) {
  return value == null ? null : this.items[this._valueToIndex(value)];
}, _valueToIndex:function(value) {
  if (this.attrForSelected) {
    for (var i = 0, item; item = this.items[i]; i++) {
      if (this._valueForItem(item) == value) {
        return i;
      }
    }
  } else {
    return Number(value);
  }
}, _indexToValue:function(index) {
  if (this.attrForSelected) {
    var item = this.items[index];
    if (item) {
      return this._valueForItem(item);
    }
  } else {
    return index;
  }
}, _valueForItem:function(item) {
  var propValue = item[Polymer.CaseMap.dashToCamelCase(this.attrForSelected)];
  return propValue != undefined ? propValue : item.getAttribute(this.attrForSelected);
}, _applySelection:function(item, isSelected) {
  if (this.selectedClass) {
    this.toggleClass(this.selectedClass, isSelected, item);
  }
  if (this.selectedAttribute) {
    this.toggleAttribute(this.selectedAttribute, isSelected, item);
  }
  this._selectionChange();
  this.fire("iron-" + (isSelected ? "select" : "deselect"), {item:item});
}, _selectionChange:function() {
  this._setSelectedItem(this._selection.get());
}, _observeItems:function(node) {
  return Polymer.dom(node).observeNodes(function(mutation) {
    this._updateItems();
    if (this._shouldUpdateSelection) {
      this._updateSelected();
    }
    this.fire("iron-items-changed", mutation, {bubbles:false, cancelable:false});
  });
}, _activateHandler:function(e) {
  var t = e.target;
  var items = this.items;
  while (t && t != this) {
    var i = items.indexOf(t);
    if (i >= 0) {
      var value = this._indexToValue(i);
      this._itemActivate(value, t);
      return;
    }
    t = t.parentNode;
  }
}, _itemActivate:function(value, item) {
  if (!this.fire("iron-activate", {selected:value, item:item}, {cancelable:true}).defaultPrevented) {
    this.select(value);
  }
}};
Polymer({is:"iron-pages", behaviors:[Polymer.IronResizableBehavior, Polymer.IronSelectableBehavior], properties:{activateEvent:{type:String, value:null}}, observers:["_selectedPageChanged(selected)"], _selectedPageChanged:function(selected, old) {
  this.async(this.notifyResize);
}});
Polymer.IronMultiSelectableBehaviorImpl = {properties:{multi:{type:Boolean, value:false, observer:"multiChanged"}, selectedValues:{type:Array, notify:true}, selectedItems:{type:Array, readOnly:true, notify:true}}, observers:["_updateSelected(selectedValues.splices)"], select:function(value) {
  if (this.multi) {
    if (this.selectedValues) {
      this._toggleSelected(value);
    } else {
      this.selectedValues = [value];
    }
  } else {
    this.selected = value;
  }
}, multiChanged:function(multi) {
  this._selection.multi = multi;
}, get _shouldUpdateSelection() {
  return this.selected != null || this.selectedValues != null && this.selectedValues.length;
}, _updateAttrForSelected:function() {
  if (!this.multi) {
    Polymer.IronSelectableBehavior._updateAttrForSelected.apply(this);
  } else {
    if (this._shouldUpdateSelection) {
      this.selectedValues = this.selectedItems.map(function(selectedItem) {
        return this._indexToValue(this.indexOf(selectedItem));
      }, this).filter(function(unfilteredValue) {
        return unfilteredValue != null;
      }, this);
    }
  }
}, _updateSelected:function() {
  if (this.multi) {
    this._selectMulti(this.selectedValues);
  } else {
    this._selectSelected(this.selected);
  }
}, _selectMulti:function(values) {
  if (values) {
    var selectedItems = this._valuesToItems(values);
    this._selection.clear(selectedItems);
    for (var i = 0; i < selectedItems.length; i++) {
      this._selection.setItemSelected(selectedItems[i], true);
    }
    if (this.fallbackSelection && this.items.length && !this._selection.get().length) {
      var fallback = this._valueToItem(this.fallbackSelection);
      if (fallback) {
        this.selectedValues = [this.fallbackSelection];
      }
    }
  } else {
    this._selection.clear();
  }
}, _selectionChange:function() {
  var s = this._selection.get();
  if (this.multi) {
    this._setSelectedItems(s);
  } else {
    this._setSelectedItems([s]);
    this._setSelectedItem(s);
  }
}, _toggleSelected:function(value) {
  var i = this.selectedValues.indexOf(value);
  var unselected = i < 0;
  if (unselected) {
    this.push("selectedValues", value);
  } else {
    this.splice("selectedValues", i, 1);
  }
}, _valuesToItems:function(values) {
  return values == null ? null : values.map(function(value) {
    return this._valueToItem(value);
  }, this);
}};
Polymer.IronMultiSelectableBehavior = [Polymer.IronSelectableBehavior, Polymer.IronMultiSelectableBehaviorImpl];
Polymer({is:"iron-selector", behaviors:[Polymer.IronMultiSelectableBehavior]});
(function() {
  Polymer({is:"iron-signals", attached:function() {
    signals.push(this);
  }, detached:function() {
    var i = signals.indexOf(this);
    if (i >= 0) {
      signals.splice(i, 1);
    }
  }});
  var signals = [];
  function notify(name, data) {
    var signal = new CustomEvent("iron-signal-" + name, {bubbles:false, detail:data});
    signals.forEach(function(s) {
      s.dispatchEvent(signal);
    });
  }
  document.addEventListener("iron-signal", function(e) {
    notify(e.detail.name, e.detail.data);
  });
})();
(function() {
  Polymer.IronA11yAnnouncer = Polymer({is:"iron-a11y-announcer", properties:{mode:{type:String, value:"polite"}, _text:{type:String, value:""}}, created:function() {
    if (!Polymer.IronA11yAnnouncer.instance) {
      Polymer.IronA11yAnnouncer.instance = this;
    }
    document.body.addEventListener("iron-announce", this._onIronAnnounce.bind(this));
  }, announce:function(text) {
    this._text = "";
    this.async(function() {
      this._text = text;
    }, 100);
  }, _onIronAnnounce:function(event) {
    if (event.detail && event.detail.text) {
      this.announce(event.detail.text);
    }
  }});
  Polymer.IronA11yAnnouncer.instance = null;
  Polymer.IronA11yAnnouncer.requestAvailability = function() {
    if (!Polymer.IronA11yAnnouncer.instance) {
      Polymer.IronA11yAnnouncer.instance = document.createElement("iron-a11y-announcer");
    }
    document.body.appendChild(Polymer.IronA11yAnnouncer.instance);
  };
})();
Polymer({is:"iron-input", extends:"input", behaviors:[Polymer.IronValidatableBehavior], properties:{bindValue:{observer:"_bindValueChanged", type:String}, preventInvalidInput:{type:Boolean}, allowedPattern:{type:String, observer:"_allowedPatternChanged"}, _previousValidInput:{type:String, value:""}, _patternAlreadyChecked:{type:Boolean, value:false}}, listeners:{"input":"_onInput", "keypress":"_onKeypress"}, registered:function() {
  if (!this._canDispatchEventOnDisabled()) {
    this._origDispatchEvent = this.dispatchEvent;
    this.dispatchEvent = this._dispatchEventFirefoxIE;
  }
}, created:function() {
  Polymer.IronA11yAnnouncer.requestAvailability();
}, _canDispatchEventOnDisabled:function() {
  var input = document.createElement("input");
  var canDispatch = false;
  input.disabled = true;
  input.addEventListener("feature-check-dispatch-event", function() {
    canDispatch = true;
  });
  try {
    input.dispatchEvent(new Event("feature-check-dispatch-event"));
  } catch (e) {
  }
  return canDispatch;
}, _dispatchEventFirefoxIE:function() {
  var disabled = this.disabled;
  this.disabled = false;
  this._origDispatchEvent.apply(this, arguments);
  this.disabled = disabled;
}, get _patternRegExp() {
  var pattern;
  if (this.allowedPattern) {
    pattern = new RegExp(this.allowedPattern);
  } else {
    switch(this.type) {
      case "number":
        pattern = /[0-9.,e-]/;
        break;
    }
  }
  return pattern;
}, ready:function() {
  this.bindValue = this.value;
}, _bindValueChanged:function() {
  if (this.value !== this.bindValue) {
    this.value = !(this.bindValue || this.bindValue === 0 || this.bindValue === false) ? "" : this.bindValue;
  }
  this.fire("bind-value-changed", {value:this.bindValue});
}, _allowedPatternChanged:function() {
  this.preventInvalidInput = this.allowedPattern ? true : false;
}, _onInput:function() {
  if (this.preventInvalidInput && !this._patternAlreadyChecked) {
    var valid = this._checkPatternValidity();
    if (!valid) {
      this._announceInvalidCharacter("Invalid string of characters not entered.");
      this.value = this._previousValidInput;
    }
  }
  this.bindValue = this.value;
  this._previousValidInput = this.value;
  this._patternAlreadyChecked = false;
}, _isPrintable:function(event) {
  var anyNonPrintable = event.keyCode == 8 || event.keyCode == 9 || event.keyCode == 13 || event.keyCode == 27;
  var mozNonPrintable = event.keyCode == 19 || event.keyCode == 20 || event.keyCode == 45 || event.keyCode == 46 || event.keyCode == 144 || event.keyCode == 145 || event.keyCode > 32 && event.keyCode < 41 || event.keyCode > 111 && event.keyCode < 124;
  return !anyNonPrintable && !(event.charCode == 0 && mozNonPrintable);
}, _onKeypress:function(event) {
  if (!this.preventInvalidInput && this.type !== "number") {
    return;
  }
  var regexp = this._patternRegExp;
  if (!regexp) {
    return;
  }
  if (event.metaKey || event.ctrlKey || event.altKey) {
    return;
  }
  this._patternAlreadyChecked = true;
  var thisChar = String.fromCharCode(event.charCode);
  if (this._isPrintable(event) && !regexp.test(thisChar)) {
    event.preventDefault();
    this._announceInvalidCharacter("Invalid character " + thisChar + " not entered.");
  }
}, _checkPatternValidity:function() {
  var regexp = this._patternRegExp;
  if (!regexp) {
    return true;
  }
  for (var i = 0; i < this.value.length; i++) {
    if (!regexp.test(this.value[i])) {
      return false;
    }
  }
  return true;
}, validate:function() {
  var valid = this.checkValidity();
  if (valid) {
    if (this.required && this.value === "") {
      valid = false;
    } else {
      if (this.hasValidator()) {
        valid = Polymer.IronValidatableBehavior.validate.call(this, this.value);
      }
    }
  }
  this.invalid = !valid;
  this.fire("iron-input-validate");
  return valid;
}, _announceInvalidCharacter:function(message) {
  this.fire("iron-announce", {text:message});
}});
Polymer.NeonAnimationBehavior = {properties:{animationTiming:{type:Object, value:function() {
  return {duration:500, easing:"cubic-bezier(0.4, 0, 0.2, 1)", fill:"both"};
}}}, isNeonAnimation:true, timingFromConfig:function(config) {
  if (config.timing) {
    for (var property in config.timing) {
      this.animationTiming[property] = config.timing[property];
    }
  }
  return this.animationTiming;
}, setPrefixedProperty:function(node, property, value) {
  var map = {"transform":["webkitTransform"], "transformOrigin":["mozTransformOrigin", "webkitTransformOrigin"]};
  var prefixes = map[property];
  for (var prefix, index = 0; prefix = prefixes[index]; index++) {
    node.style[prefix] = value;
  }
  node.style[property] = value;
}, complete:function() {
}};
!function(a, b) {
  var c = {}, d = {}, e = {}, f = null;
  !function(a, b) {
    function c(a) {
      if ("number" == typeof a) {
        return a;
      }
      var b = {};
      for (var c in a) {
        b[c] = a[c];
      }
      return b;
    }
    function d() {
      this._delay = 0, this._endDelay = 0, this._fill = "none", this._iterationStart = 0, this._iterations = 1, this._duration = 0, this._playbackRate = 1, this._direction = "normal", this._easing = "linear", this._easingFunction = w;
    }
    function e() {
      return a.isDeprecated("Invalid timing inputs", "2016-03-02", "TypeError exceptions will be thrown instead.", !0);
    }
    function f(b, c, e) {
      var f = new d;
      return c && (f.fill = "both", f.duration = "auto"), "number" != typeof b || isNaN(b) ? void 0 !== b && Object.getOwnPropertyNames(b).forEach(function(c) {
        if ("auto" != b[c]) {
          if (("number" == typeof f[c] || "duration" == c) && ("number" != typeof b[c] || isNaN(b[c]))) {
            return;
          }
          if ("fill" == c && -1 == u.indexOf(b[c])) {
            return;
          }
          if ("direction" == c && -1 == v.indexOf(b[c])) {
            return;
          }
          if ("playbackRate" == c && 1 !== b[c] && a.isDeprecated("AnimationEffectTiming.playbackRate", "2014-11-28", "Use Animation.playbackRate instead.")) {
            return;
          }
          f[c] = b[c];
        }
      }) : f.duration = b, f;
    }
    function g(a) {
      return "number" == typeof a && (a = isNaN(a) ? {duration:0} : {duration:a}), a;
    }
    function h(b, c) {
      return b = a.numericTimingToObject(b), f(b, c);
    }
    function i(a, b, c, d) {
      return 0 > a || a > 1 || 0 > c || c > 1 ? w : function(e) {
        function f(a, b, c) {
          return 3 * a * (1 - c) * (1 - c) * c + 3 * b * (1 - c) * c * c + c * c * c;
        }
        if (0 == e || 1 == e) {
          return e;
        }
        for (var g = 0, h = 1;;) {
          var i = (g + h) / 2, j = f(a, c, i);
          if (Math.abs(e - j) < 1e-4) {
            return f(b, d, i);
          }
          e > j ? g = i : h = i;
        }
      };
    }
    function j(a, b) {
      return function(c) {
        if (c >= 1) {
          return 1;
        }
        var d = 1 / a;
        return c += b * d, c - c % d;
      };
    }
    function k(a) {
      B || (B = document.createElement("div").style), B.animationTimingFunction = "", B.animationTimingFunction = a;
      var b = B.animationTimingFunction;
      if ("" == b && e()) {
        throw new TypeError(a + " is not a valid value for easing");
      }
      var c = D.exec(b);
      if (c) {
        return i.apply(this, c.slice(1).map(Number));
      }
      var d = E.exec(b);
      if (d) {
        return j(Number(d[1]), {start:x, middle:y, end:z}[d[2]]);
      }
      var f = A[b];
      return f ? f : w;
    }
    function l(a) {
      return Math.abs(m(a) / a.playbackRate);
    }
    function m(a) {
      return a.duration * a.iterations;
    }
    function n(a, b, c) {
      return null == b ? F : b < c.delay ? G : b >= c.delay + a ? H : I;
    }
    function o(a, b, c, d, e) {
      switch(d) {
        case G:
          return "backwards" == b || "both" == b ? 0 : null;
        case I:
          return c - e;
        case H:
          return "forwards" == b || "both" == b ? a : null;
        case F:
          return null;
      }
    }
    function p(a, b, c, d) {
      return (d.playbackRate < 0 ? b - a : b) * d.playbackRate + c;
    }
    function q(a, b, c, d, e) {
      return c === 1 / 0 || c === -(1 / 0) || c - d == b && e.iterations && (e.iterations + e.iterationStart) % 1 == 0 ? a : c % a;
    }
    function r(a, b, c, d) {
      return 0 === c ? 0 : b == a ? d.iterationStart + d.iterations - 1 : Math.floor(c / a);
    }
    function s(a, b, c, d) {
      var e = a % 2 >= 1, f = "normal" == d.direction || d.direction == (e ? "alternate-reverse" : "alternate"), g = f ? c : b - c, h = g / b;
      return b * d._easingFunction(h);
    }
    function t(a, b, c) {
      var d = n(a, b, c), e = o(a, c.fill, b, d, c.delay);
      if (null === e) {
        return null;
      }
      if (0 === a) {
        return d === G ? 0 : 1;
      }
      var f = c.iterationStart * c.duration, g = p(a, e, f, c), h = q(c.duration, m(c), g, f, c), i = r(c.duration, h, g, c);
      return s(i, c.duration, h, c) / c.duration;
    }
    var u = "backwards|forwards|both|none".split("|"), v = "reverse|alternate|alternate-reverse".split("|"), w = function(a) {
      return a;
    };
    d.prototype = {_setMember:function(b, c) {
      this["_" + b] = c, this._effect && (this._effect._timingInput[b] = c, this._effect._timing = a.normalizeTimingInput(this._effect._timingInput), this._effect.activeDuration = a.calculateActiveDuration(this._effect._timing), this._effect._animation && this._effect._animation._rebuildUnderlyingAnimation());
    }, get playbackRate() {
      return this._playbackRate;
    }, set delay(a) {
      this._setMember("delay", a);
    }, get delay() {
      return this._delay;
    }, set endDelay(a) {
      this._setMember("endDelay", a);
    }, get endDelay() {
      return this._endDelay;
    }, set fill(a) {
      this._setMember("fill", a);
    }, get fill() {
      return this._fill;
    }, set iterationStart(a) {
      if ((isNaN(a) || 0 > a) && e()) {
        throw new TypeError("iterationStart must be a non-negative number, received: " + timing.iterationStart);
      }
      this._setMember("iterationStart", a);
    }, get iterationStart() {
      return this._iterationStart;
    }, set duration(a) {
      if ("auto" != a && (isNaN(a) || 0 > a) && e()) {
        throw new TypeError("duration must be non-negative or auto, received: " + a);
      }
      this._setMember("duration", a);
    }, get duration() {
      return this._duration;
    }, set direction(a) {
      this._setMember("direction", a);
    }, get direction() {
      return this._direction;
    }, set easing(a) {
      this._easingFunction = k(a), this._setMember("easing", a);
    }, get easing() {
      return this._easing;
    }, set iterations(a) {
      if ((isNaN(a) || 0 > a) && e()) {
        throw new TypeError("iterations must be non-negative, received: " + a);
      }
      this._setMember("iterations", a);
    }, get iterations() {
      return this._iterations;
    }};
    var x = 1, y = .5, z = 0, A = {ease:i(.25, .1, .25, 1), "ease-in":i(.42, 0, 1, 1), "ease-out":i(0, 0, .58, 1), "ease-in-out":i(.42, 0, .58, 1), "step-start":j(1, x), "step-middle":j(1, y), "step-end":j(1, z)}, B = null, C = "\\s*(-?\\d+\\.?\\d*|-?\\.\\d+)\\s*", D = new RegExp("cubic-bezier\\(" + C + "," + C + "," + C + "," + C + "\\)"), E = /steps\(\s*(\d+)\s*,\s*(start|middle|end)\s*\)/, F = 0, G = 1, H = 2, I = 3;
    a.cloneTimingInput = c, a.makeTiming = f, a.numericTimingToObject = g, a.normalizeTimingInput = h, a.calculateActiveDuration = l, a.calculateTimeFraction = t, a.calculatePhase = n, a.toTimingFunction = k;
  }(c, f), function(a, b) {
    function c(a, b) {
      return a in j ? j[a][b] || b : b;
    }
    function d(a, b, d) {
      var e = g[a];
      if (e) {
        h.style[a] = b;
        for (var f in e) {
          var i = e[f], j = h.style[i];
          d[i] = c(i, j);
        }
      } else {
        d[a] = c(a, b);
      }
    }
    function e(a) {
      var b = [];
      for (var c in a) {
        if (!(c in ["easing", "offset", "composite"])) {
          var d = a[c];
          Array.isArray(d) || (d = [d]);
          for (var e, f = d.length, g = 0; f > g; g++) {
            e = {}, "offset" in a ? e.offset = a.offset : 1 == f ? e.offset = 1 : e.offset = g / (f - 1), "easing" in a && (e.easing = a.easing), "composite" in a && (e.composite = a.composite), e[c] = d[g], b.push(e);
          }
        }
      }
      return b.sort(function(a, b) {
        return a.offset - b.offset;
      }), b;
    }
    function f(a) {
      function b() {
        var a = c.length;
        null == c[a - 1].offset && (c[a - 1].offset = 1), a > 1 && null == c[0].offset && (c[0].offset = 0);
        for (var b = 0, d = c[0].offset, e = 1; a > e; e++) {
          var f = c[e].offset;
          if (null != f) {
            for (var g = 1; e - b > g; g++) {
              c[b + g].offset = d + (f - d) * g / (e - b);
            }
            b = e, d = f;
          }
        }
      }
      if (null == a) {
        return [];
      }
      window.Symbol && Symbol.iterator && Array.prototype.from && a[Symbol.iterator] && (a = Array.from(a)), Array.isArray(a) || (a = e(a));
      for (var c = a.map(function(a) {
        var b = {};
        for (var c in a) {
          var e = a[c];
          if ("offset" == c) {
            if (null != e && (e = Number(e), !isFinite(e))) {
              throw new TypeError("keyframe offsets must be numbers.");
            }
          } else {
            if ("composite" == c) {
              throw {type:DOMException.NOT_SUPPORTED_ERR, name:"NotSupportedError", message:"add compositing is not supported"};
            }
            e = "" + e;
          }
          d(c, e, b);
        }
        return void 0 == b.offset && (b.offset = null), b;
      }), f = !0, g = -(1 / 0), h = 0; h < c.length; h++) {
        var i = c[h].offset;
        if (null != i) {
          if (g > i) {
            throw {code:DOMException.INVALID_MODIFICATION_ERR, name:"InvalidModificationError", message:"Keyframes are not loosely sorted by offset. Sort or specify offsets."};
          }
          g = i;
        } else {
          f = !1;
        }
      }
      return c = c.filter(function(a) {
        return a.offset >= 0 && a.offset <= 1;
      }), f || b(), c;
    }
    var g = {background:["backgroundImage", "backgroundPosition", "backgroundSize", "backgroundRepeat", "backgroundAttachment", "backgroundOrigin", "backgroundClip", "backgroundColor"], border:["borderTopColor", "borderTopStyle", "borderTopWidth", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderLeftColor", "borderLeftStyle", "borderLeftWidth"], borderBottom:["borderBottomWidth", "borderBottomStyle", "borderBottomColor"], 
    borderColor:["borderTopColor", "borderRightColor", "borderBottomColor", "borderLeftColor"], borderLeft:["borderLeftWidth", "borderLeftStyle", "borderLeftColor"], borderRadius:["borderTopLeftRadius", "borderTopRightRadius", "borderBottomRightRadius", "borderBottomLeftRadius"], borderRight:["borderRightWidth", "borderRightStyle", "borderRightColor"], borderTop:["borderTopWidth", "borderTopStyle", "borderTopColor"], borderWidth:["borderTopWidth", "borderRightWidth", "borderBottomWidth", "borderLeftWidth"], 
    flex:["flexGrow", "flexShrink", "flexBasis"], font:["fontFamily", "fontSize", "fontStyle", "fontVariant", "fontWeight", "lineHeight"], margin:["marginTop", "marginRight", "marginBottom", "marginLeft"], outline:["outlineColor", "outlineStyle", "outlineWidth"], padding:["paddingTop", "paddingRight", "paddingBottom", "paddingLeft"]}, h = document.createElementNS("http://www.w3.org/1999/xhtml", "div"), i = {thin:"1px", medium:"3px", thick:"5px"}, j = {borderBottomWidth:i, borderLeftWidth:i, borderRightWidth:i, 
    borderTopWidth:i, fontSize:{"xx-small":"60%", "x-small":"75%", small:"89%", medium:"100%", large:"120%", "x-large":"150%", "xx-large":"200%"}, fontWeight:{normal:"400", bold:"700"}, outlineWidth:i, textShadow:{none:"0px 0px 0px transparent"}, boxShadow:{none:"0px 0px 0px 0px transparent"}};
    a.convertToArrayForm = e, a.normalizeKeyframes = f;
  }(c, f), function(a) {
    var b = {};
    a.isDeprecated = function(a, c, d, e) {
      var f = e ? "are" : "is", g = new Date, h = new Date(c);
      return h.setMonth(h.getMonth() + 3), h > g ? (a in b || console.warn("Web Animations: " + a + " " + f + " deprecated and will stop working on " + h.toDateString() + ". " + d), b[a] = !0, !1) : !0;
    }, a.deprecated = function(b, c, d, e) {
      var f = e ? "are" : "is";
      if (a.isDeprecated(b, c, d, e)) {
        throw new Error(b + " " + f + " no longer supported. " + d);
      }
    };
  }(c), function() {
    if (document.documentElement.animate) {
      var a = document.documentElement.animate([], 0), b = !0;
      if (a && (b = !1, "play|currentTime|pause|reverse|playbackRate|cancel|finish|startTime|playState".split("|").forEach(function(c) {
        void 0 === a[c] && (b = !0);
      })), !b) {
        return;
      }
    }
    !function(a, b, c) {
      function d(a) {
        for (var b = {}, c = 0; c < a.length; c++) {
          for (var d in a[c]) {
            if ("offset" != d && "easing" != d && "composite" != d) {
              var e = {offset:a[c].offset, easing:a[c].easing, value:a[c][d]};
              b[d] = b[d] || [], b[d].push(e);
            }
          }
        }
        for (var f in b) {
          var g = b[f];
          if (0 != g[0].offset || 1 != g[g.length - 1].offset) {
            throw {type:DOMException.NOT_SUPPORTED_ERR, name:"NotSupportedError", message:"Partial keyframes are not supported"};
          }
        }
        return b;
      }
      function e(c) {
        var d = [];
        for (var e in c) {
          for (var f = c[e], g = 0; g < f.length - 1; g++) {
            var h = f[g].offset, i = f[g + 1].offset, j = f[g].value, k = f[g + 1].value, l = f[g].easing;
            h == i && (1 == i ? j = k : k = j), d.push({startTime:h, endTime:i, easing:a.toTimingFunction(l ? l : "linear"), property:e, interpolation:b.propertyInterpolation(e, j, k)});
          }
        }
        return d.sort(function(a, b) {
          return a.startTime - b.startTime;
        }), d;
      }
      b.convertEffectInput = function(c) {
        var f = a.normalizeKeyframes(c), g = d(f), h = e(g);
        return function(a, c) {
          if (null != c) {
            h.filter(function(a) {
              return 0 >= c && 0 == a.startTime || c >= 1 && 1 == a.endTime || c >= a.startTime && c <= a.endTime;
            }).forEach(function(d) {
              var e = c - d.startTime, f = d.endTime - d.startTime, g = 0 == f ? 0 : d.easing(e / f);
              b.apply(a, d.property, d.interpolation(g));
            });
          } else {
            for (var d in g) {
              "offset" != d && "easing" != d && "composite" != d && b.clear(a, d);
            }
          }
        };
      };
    }(c, d, f), function(a, b, c) {
      function d(a) {
        return a.replace(/-(.)/g, function(a, b) {
          return b.toUpperCase();
        });
      }
      function e(a, b, c) {
        h[c] = h[c] || [], h[c].push([a, b]);
      }
      function f(a, b, c) {
        for (var f = 0; f < c.length; f++) {
          var g = c[f];
          e(a, b, d(g));
        }
      }
      function g(c, e, f) {
        var g = c;
        /-/.test(c) && !a.isDeprecated("Hyphenated property names", "2016-03-22", "Use camelCase instead.", !0) && (g = d(c)), "initial" != e && "initial" != f || ("initial" == e && (e = i[g]), "initial" == f && (f = i[g]));
        for (var j = e == f ? [] : h[g], k = 0; j && k < j.length; k++) {
          var l = j[k][0](e), m = j[k][0](f);
          if (void 0 !== l && void 0 !== m) {
            var n = j[k][1](l, m);
            if (n) {
              var o = b.Interpolation.apply(null, n);
              return function(a) {
                return 0 == a ? e : 1 == a ? f : o(a);
              };
            }
          }
        }
        return b.Interpolation(!1, !0, function(a) {
          return a ? f : e;
        });
      }
      var h = {};
      b.addPropertiesHandler = f;
      var i = {backgroundColor:"transparent", backgroundPosition:"0% 0%", borderBottomColor:"currentColor", borderBottomLeftRadius:"0px", borderBottomRightRadius:"0px", borderBottomWidth:"3px", borderLeftColor:"currentColor", borderLeftWidth:"3px", borderRightColor:"currentColor", borderRightWidth:"3px", borderSpacing:"2px", borderTopColor:"currentColor", borderTopLeftRadius:"0px", borderTopRightRadius:"0px", borderTopWidth:"3px", bottom:"auto", clip:"rect(0px, 0px, 0px, 0px)", color:"black", fontSize:"100%", 
      fontWeight:"400", height:"auto", left:"auto", letterSpacing:"normal", lineHeight:"120%", marginBottom:"0px", marginLeft:"0px", marginRight:"0px", marginTop:"0px", maxHeight:"none", maxWidth:"none", minHeight:"0px", minWidth:"0px", opacity:"1.0", outlineColor:"invert", outlineOffset:"0px", outlineWidth:"3px", paddingBottom:"0px", paddingLeft:"0px", paddingRight:"0px", paddingTop:"0px", right:"auto", textIndent:"0px", textShadow:"0px 0px 0px transparent", top:"auto", transform:"", verticalAlign:"0px", 
      visibility:"visible", width:"auto", wordSpacing:"normal", zIndex:"auto"};
      b.propertyInterpolation = g;
    }(c, d, f), function(a, b, c) {
      function d(b) {
        var c = a.calculateActiveDuration(b), d = function(d) {
          return a.calculateTimeFraction(c, d, b);
        };
        return d._totalDuration = b.delay + c + b.endDelay, d._isCurrent = function(d) {
          var e = a.calculatePhase(c, d, b);
          return e === PhaseActive || e === PhaseBefore;
        }, d;
      }
      b.KeyframeEffect = function(c, e, f, g) {
        var h, i = d(a.normalizeTimingInput(f)), j = b.convertEffectInput(e), k = function() {
          j(c, h);
        };
        return k._update = function(a) {
          return h = i(a), null !== h;
        }, k._clear = function() {
          j(c, null);
        }, k._hasSameTarget = function(a) {
          return c === a;
        }, k._isCurrent = i._isCurrent, k._totalDuration = i._totalDuration, k._id = g, k;
      }, b.NullEffect = function(a) {
        var b = function() {
          a && (a(), a = null);
        };
        return b._update = function() {
          return null;
        }, b._totalDuration = 0, b._isCurrent = function() {
          return !1;
        }, b._hasSameTarget = function() {
          return !1;
        }, b;
      };
    }(c, d, f), function(a, b) {
      a.apply = function(b, c, d) {
        b.style[a.propertyName(c)] = d;
      }, a.clear = function(b, c) {
        b.style[a.propertyName(c)] = "";
      };
    }(d, f), function(a) {
      window.Element.prototype.animate = function(b, c) {
        var d = "";
        return c && c.id && (d = c.id), a.timeline._play(a.KeyframeEffect(this, b, c, d));
      };
    }(d), function(a, b) {
      function c(a, b, d) {
        if ("number" == typeof a && "number" == typeof b) {
          return a * (1 - d) + b * d;
        }
        if ("boolean" == typeof a && "boolean" == typeof b) {
          return .5 > d ? a : b;
        }
        if (a.length == b.length) {
          for (var e = [], f = 0; f < a.length; f++) {
            e.push(c(a[f], b[f], d));
          }
          return e;
        }
        throw "Mismatched interpolation arguments " + a + ":" + b;
      }
      a.Interpolation = function(a, b, d) {
        return function(e) {
          return d(c(a, b, e));
        };
      };
    }(d, f), function(a, b, c) {
      a.sequenceNumber = 0;
      var d = function(a, b, c) {
        this.target = a, this.currentTime = b, this.timelineTime = c, this.type = "finish", this.bubbles = !1, this.cancelable = !1, this.currentTarget = a, this.defaultPrevented = !1, this.eventPhase = Event.AT_TARGET, this.timeStamp = Date.now();
      };
      b.Animation = function(b) {
        this.id = "", b && b._id && (this.id = b._id), this._sequenceNumber = a.sequenceNumber++, this._currentTime = 0, this._startTime = null, this._paused = !1, this._playbackRate = 1, this._inTimeline = !0, this._finishedFlag = !0, this.onfinish = null, this._finishHandlers = [], this._effect = b, this._inEffect = this._effect._update(0), this._idle = !0, this._currentTimePending = !1;
      }, b.Animation.prototype = {_ensureAlive:function() {
        this.playbackRate < 0 && 0 === this.currentTime ? this._inEffect = this._effect._update(-1) : this._inEffect = this._effect._update(this.currentTime), this._inTimeline || !this._inEffect && this._finishedFlag || (this._inTimeline = !0, b.timeline._animations.push(this));
      }, _tickCurrentTime:function(a, b) {
        a != this._currentTime && (this._currentTime = a, this._isFinished && !b && (this._currentTime = this._playbackRate > 0 ? this._totalDuration : 0), this._ensureAlive());
      }, get currentTime() {
        return this._idle || this._currentTimePending ? null : this._currentTime;
      }, set currentTime(a) {
        a = +a, isNaN(a) || (b.restart(), this._paused || null == this._startTime || (this._startTime = this._timeline.currentTime - a / this._playbackRate), this._currentTimePending = !1, this._currentTime != a && (this._tickCurrentTime(a, !0), b.invalidateEffects()));
      }, get startTime() {
        return this._startTime;
      }, set startTime(a) {
        a = +a, isNaN(a) || this._paused || this._idle || (this._startTime = a, this._tickCurrentTime((this._timeline.currentTime - this._startTime) * this.playbackRate), b.invalidateEffects());
      }, get playbackRate() {
        return this._playbackRate;
      }, set playbackRate(a) {
        if (a != this._playbackRate) {
          var b = this.currentTime;
          this._playbackRate = a, this._startTime = null, "paused" != this.playState && "idle" != this.playState && this.play(), null != b && (this.currentTime = b);
        }
      }, get _isFinished() {
        return !this._idle && (this._playbackRate > 0 && this._currentTime >= this._totalDuration || this._playbackRate < 0 && this._currentTime <= 0);
      }, get _totalDuration() {
        return this._effect._totalDuration;
      }, get playState() {
        return this._idle ? "idle" : null == this._startTime && !this._paused && 0 != this.playbackRate || this._currentTimePending ? "pending" : this._paused ? "paused" : this._isFinished ? "finished" : "running";
      }, play:function() {
        this._paused = !1, (this._isFinished || this._idle) && (this._currentTime = this._playbackRate > 0 ? 0 : this._totalDuration, this._startTime = null), this._finishedFlag = !1, this._idle = !1, this._ensureAlive(), b.invalidateEffects();
      }, pause:function() {
        this._isFinished || this._paused || this._idle || (this._currentTimePending = !0), this._startTime = null, this._paused = !0;
      }, finish:function() {
        this._idle || (this.currentTime = this._playbackRate > 0 ? this._totalDuration : 0, this._startTime = this._totalDuration - this.currentTime, this._currentTimePending = !1, b.invalidateEffects());
      }, cancel:function() {
        this._inEffect && (this._inEffect = !1, this._idle = !0, this._finishedFlag = !0, this.currentTime = 0, this._startTime = null, this._effect._update(null), b.invalidateEffects());
      }, reverse:function() {
        this.playbackRate *= -1, this.play();
      }, addEventListener:function(a, b) {
        "function" == typeof b && "finish" == a && this._finishHandlers.push(b);
      }, removeEventListener:function(a, b) {
        if ("finish" == a) {
          var c = this._finishHandlers.indexOf(b);
          c >= 0 && this._finishHandlers.splice(c, 1);
        }
      }, _fireEvents:function(a) {
        if (this._isFinished) {
          if (!this._finishedFlag) {
            var b = new d(this, this._currentTime, a), c = this._finishHandlers.concat(this.onfinish ? [this.onfinish] : []);
            setTimeout(function() {
              c.forEach(function(a) {
                a.call(b.target, b);
              });
            }, 0), this._finishedFlag = !0;
          }
        } else {
          this._finishedFlag = !1;
        }
      }, _tick:function(a, b) {
        this._idle || this._paused || (null == this._startTime ? b && (this.startTime = a - this._currentTime / this.playbackRate) : this._isFinished || this._tickCurrentTime((a - this._startTime) * this.playbackRate)), b && (this._currentTimePending = !1, this._fireEvents(a));
      }, get _needsTick() {
        return this.playState in {pending:1, running:1} || !this._finishedFlag;
      }};
    }(c, d, f), function(a, b, c) {
      function d(a) {
        var b = j;
        j = [], a < p.currentTime && (a = p.currentTime), h(a, !0), b.forEach(function(b) {
          b[1](a);
        }), g(), l = void 0;
      }
      function e(a, b) {
        return a._sequenceNumber - b._sequenceNumber;
      }
      function f() {
        this._animations = [], this.currentTime = window.performance && performance.now ? performance.now() : 0;
      }
      function g() {
        o.forEach(function(a) {
          a();
        }), o.length = 0;
      }
      function h(a, c) {
        n = !1;
        var d = b.timeline;
        d.currentTime = a, d._animations.sort(e), m = !1;
        var f = d._animations;
        d._animations = [];
        var g = [], h = [];
        f = f.filter(function(b) {
          b._tick(a, c), b._inEffect ? h.push(b._effect) : g.push(b._effect), b._needsTick && (m = !0);
          var d = b._inEffect || b._needsTick;
          return b._inTimeline = d, d;
        }), o.push.apply(o, g), o.push.apply(o, h), d._animations.push.apply(d._animations, f), m && requestAnimationFrame(function() {
        });
      }
      var i = window.requestAnimationFrame, j = [], k = 0;
      window.requestAnimationFrame = function(a) {
        var b = k++;
        return 0 == j.length && i(d), j.push([b, a]), b;
      }, window.cancelAnimationFrame = function(a) {
        j.forEach(function(b) {
          b[0] == a && (b[1] = function() {
          });
        });
      }, f.prototype = {_play:function(c) {
        c._timing = a.normalizeTimingInput(c.timing);
        var d = new b.Animation(c);
        return d._idle = !1, d._timeline = this, this._animations.push(d), b.restart(), b.invalidateEffects(), d;
      }};
      var l = void 0, m = !1, n = !1;
      b.restart = function() {
        return m || (m = !0, requestAnimationFrame(function() {
        }), n = !0), n;
      }, b.invalidateEffects = function() {
        h(b.timeline.currentTime, !1), g();
      };
      var o = [], p = new f;
      b.timeline = p;
    }(c, d, f), function(a) {
      function b(a, b) {
        var c = a.exec(b);
        return c ? (c = a.ignoreCase ? c[0].toLowerCase() : c[0], [c, b.substr(c.length)]) : void 0;
      }
      function c(a, b) {
        b = b.replace(/^\s*/, "");
        var c = a(b);
        return c ? [c[0], c[1].replace(/^\s*/, "")] : void 0;
      }
      function d(a, d, e) {
        a = c.bind(null, a);
        for (var f = [];;) {
          var g = a(e);
          if (!g) {
            return [f, e];
          }
          if (f.push(g[0]), e = g[1], g = b(d, e), !g || "" == g[1]) {
            return [f, e];
          }
          e = g[1];
        }
      }
      function e(a, b) {
        for (var c = 0, d = 0; d < b.length && (!/\s|,/.test(b[d]) || 0 != c); d++) {
          if ("(" == b[d]) {
            c++;
          } else {
            if (")" == b[d] && (c--, 0 == c && d++, 0 >= c)) {
              break;
            }
          }
        }
        var e = a(b.substr(0, d));
        return void 0 == e ? void 0 : [e, b.substr(d)];
      }
      function f(a, b) {
        for (var c = a, d = b; c && d;) {
          c > d ? c %= d : d %= c;
        }
        return c = a * b / (c + d);
      }
      function g(a) {
        return function(b) {
          var c = a(b);
          return c && (c[0] = void 0), c;
        };
      }
      function h(a, b) {
        return function(c) {
          var d = a(c);
          return d ? d : [b, c];
        };
      }
      function i(b, c) {
        for (var d = [], e = 0; e < b.length; e++) {
          var f = a.consumeTrimmed(b[e], c);
          if (!f || "" == f[0]) {
            return;
          }
          void 0 !== f[0] && d.push(f[0]), c = f[1];
        }
        return "" == c ? d : void 0;
      }
      function j(a, b, c, d, e) {
        for (var g = [], h = [], i = [], j = f(d.length, e.length), k = 0; j > k; k++) {
          var l = b(d[k % d.length], e[k % e.length]);
          if (!l) {
            return;
          }
          g.push(l[0]), h.push(l[1]), i.push(l[2]);
        }
        return [g, h, function(b) {
          var d = b.map(function(a, b) {
            return i[b](a);
          }).join(c);
          return a ? a(d) : d;
        }];
      }
      function k(a, b, c) {
        for (var d = [], e = [], f = [], g = 0, h = 0; h < c.length; h++) {
          if ("function" == typeof c[h]) {
            var i = c[h](a[g], b[g++]);
            d.push(i[0]), e.push(i[1]), f.push(i[2]);
          } else {
            !function(a) {
              d.push(!1), e.push(!1), f.push(function() {
                return c[a];
              });
            }(h);
          }
        }
        return [d, e, function(a) {
          for (var b = "", c = 0; c < a.length; c++) {
            b += f[c](a[c]);
          }
          return b;
        }];
      }
      a.consumeToken = b, a.consumeTrimmed = c, a.consumeRepeated = d, a.consumeParenthesised = e, a.ignore = g, a.optional = h, a.consumeList = i, a.mergeNestedRepeated = j.bind(null, null), a.mergeWrappedNestedRepeated = j, a.mergeList = k;
    }(d), function(a) {
      function b(b) {
        function c(b) {
          var c = a.consumeToken(/^inset/i, b);
          if (c) {
            return d.inset = !0, c;
          }
          var c = a.consumeLengthOrPercent(b);
          if (c) {
            return d.lengths.push(c[0]), c;
          }
          var c = a.consumeColor(b);
          return c ? (d.color = c[0], c) : void 0;
        }
        var d = {inset:!1, lengths:[], color:null}, e = a.consumeRepeated(c, /^/, b);
        return e && e[0].length ? [d, e[1]] : void 0;
      }
      function c(c) {
        var d = a.consumeRepeated(b, /^,/, c);
        return d && "" == d[1] ? d[0] : void 0;
      }
      function d(b, c) {
        for (; b.lengths.length < Math.max(b.lengths.length, c.lengths.length);) {
          b.lengths.push({px:0});
        }
        for (; c.lengths.length < Math.max(b.lengths.length, c.lengths.length);) {
          c.lengths.push({px:0});
        }
        if (b.inset == c.inset && !!b.color == !!c.color) {
          for (var d, e = [], f = [[], 0], g = [[], 0], h = 0; h < b.lengths.length; h++) {
            var i = a.mergeDimensions(b.lengths[h], c.lengths[h], 2 == h);
            f[0].push(i[0]), g[0].push(i[1]), e.push(i[2]);
          }
          if (b.color && c.color) {
            var j = a.mergeColors(b.color, c.color);
            f[1] = j[0], g[1] = j[1], d = j[2];
          }
          return [f, g, function(a) {
            for (var c = b.inset ? "inset " : " ", f = 0; f < e.length; f++) {
              c += e[f](a[0][f]) + " ";
            }
            return d && (c += d(a[1])), c;
          }];
        }
      }
      function e(b, c, d, e) {
        function f(a) {
          return {inset:a, color:[0, 0, 0, 0], lengths:[{px:0}, {px:0}, {px:0}, {px:0}]};
        }
        for (var g = [], h = [], i = 0; i < d.length || i < e.length; i++) {
          var j = d[i] || f(e[i].inset), k = e[i] || f(d[i].inset);
          g.push(j), h.push(k);
        }
        return a.mergeNestedRepeated(b, c, g, h);
      }
      var f = e.bind(null, d, ", ");
      a.addPropertiesHandler(c, f, ["box-shadow", "text-shadow"]);
    }(d), function(a, b) {
      function c(a) {
        return a.toFixed(3).replace(".000", "");
      }
      function d(a, b, c) {
        return Math.min(b, Math.max(a, c));
      }
      function e(a) {
        return /^\s*[-+]?(\d*\.)?\d+\s*$/.test(a) ? Number(a) : void 0;
      }
      function f(a, b) {
        return [a, b, c];
      }
      function g(a, b) {
        return 0 != a ? i(0, 1 / 0)(a, b) : void 0;
      }
      function h(a, b) {
        return [a, b, function(a) {
          return Math.round(d(1, 1 / 0, a));
        }];
      }
      function i(a, b) {
        return function(e, f) {
          return [e, f, function(e) {
            return c(d(a, b, e));
          }];
        };
      }
      function j(a, b) {
        return [a, b, Math.round];
      }
      a.clamp = d, a.addPropertiesHandler(e, i(0, 1 / 0), ["border-image-width", "line-height"]), a.addPropertiesHandler(e, i(0, 1), ["opacity", "shape-image-threshold"]), a.addPropertiesHandler(e, g, ["flex-grow", "flex-shrink"]), a.addPropertiesHandler(e, h, ["orphans", "widows"]), a.addPropertiesHandler(e, j, ["z-index"]), a.parseNumber = e, a.mergeNumbers = f, a.numberToString = c;
    }(d, f), function(a, b) {
      function c(a, b) {
        return "visible" == a || "visible" == b ? [0, 1, function(c) {
          return 0 >= c ? a : c >= 1 ? b : "visible";
        }] : void 0;
      }
      a.addPropertiesHandler(String, c, ["visibility"]);
    }(d), function(a, b) {
      function c(a) {
        a = a.trim(), f.fillStyle = "#000", f.fillStyle = a;
        var b = f.fillStyle;
        if (f.fillStyle = "#fff", f.fillStyle = a, b == f.fillStyle) {
          f.fillRect(0, 0, 1, 1);
          var c = f.getImageData(0, 0, 1, 1).data;
          f.clearRect(0, 0, 1, 1);
          var d = c[3] / 255;
          return [c[0] * d, c[1] * d, c[2] * d, d];
        }
      }
      function d(b, c) {
        return [b, c, function(b) {
          function c(a) {
            return Math.max(0, Math.min(255, a));
          }
          if (b[3]) {
            for (var d = 0; 3 > d; d++) {
              b[d] = Math.round(c(b[d] / b[3]));
            }
          }
          return b[3] = a.numberToString(a.clamp(0, 1, b[3])), "rgba(" + b.join(",") + ")";
        }];
      }
      var e = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
      e.width = e.height = 1;
      var f = e.getContext("2d");
      a.addPropertiesHandler(c, d, ["background-color", "border-bottom-color", "border-left-color", "border-right-color", "border-top-color", "color", "outline-color", "text-decoration-color"]), a.consumeColor = a.consumeParenthesised.bind(null, c), a.mergeColors = d;
    }(d, f), function(a, b) {
      function c(a, b) {
        if (b = b.trim().toLowerCase(), "0" == b && "px".search(a) >= 0) {
          return {px:0};
        }
        if (/^[^(]*$|^calc/.test(b)) {
          b = b.replace(/calc\(/g, "(");
          var c = {};
          b = b.replace(a, function(a) {
            return c[a] = null, "U" + a;
          });
          for (var d = "U(" + a.source + ")", e = b.replace(/[-+]?(\d*\.)?\d+/g, "N").replace(new RegExp("N" + d, "g"), "D").replace(/\s[+-]\s/g, "O").replace(/\s/g, ""), f = [/N\*(D)/g, /(N|D)[*\/]N/g, /(N|D)O\1/g, /\((N|D)\)/g], g = 0; g < f.length;) {
            f[g].test(e) ? (e = e.replace(f[g], "$1"), g = 0) : g++;
          }
          if ("D" == e) {
            for (var h in c) {
              var i = eval(b.replace(new RegExp("U" + h, "g"), "").replace(new RegExp(d, "g"), "*0"));
              if (!isFinite(i)) {
                return;
              }
              c[h] = i;
            }
            return c;
          }
        }
      }
      function d(a, b) {
        return e(a, b, !0);
      }
      function e(b, c, d) {
        var e, f = [];
        for (e in b) {
          f.push(e);
        }
        for (e in c) {
          f.indexOf(e) < 0 && f.push(e);
        }
        return b = f.map(function(a) {
          return b[a] || 0;
        }), c = f.map(function(a) {
          return c[a] || 0;
        }), [b, c, function(b) {
          var c = b.map(function(c, e) {
            return 1 == b.length && d && (c = Math.max(c, 0)), a.numberToString(c) + f[e];
          }).join(" + ");
          return b.length > 1 ? "calc(" + c + ")" : c;
        }];
      }
      var f = "px|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc", g = c.bind(null, new RegExp(f, "g")), h = c.bind(null, new RegExp(f + "|%", "g")), i = c.bind(null, /deg|rad|grad|turn/g);
      a.parseLength = g, a.parseLengthOrPercent = h, a.consumeLengthOrPercent = a.consumeParenthesised.bind(null, h), a.parseAngle = i, a.mergeDimensions = e;
      var j = a.consumeParenthesised.bind(null, g), k = a.consumeRepeated.bind(void 0, j, /^/), l = a.consumeRepeated.bind(void 0, k, /^,/);
      a.consumeSizePairList = l;
      var m = function(a) {
        var b = l(a);
        return b && "" == b[1] ? b[0] : void 0;
      }, n = a.mergeNestedRepeated.bind(void 0, d, " "), o = a.mergeNestedRepeated.bind(void 0, n, ",");
      a.mergeNonNegativeSizePair = n, a.addPropertiesHandler(m, o, ["background-size"]), a.addPropertiesHandler(h, d, ["border-bottom-width", "border-image-width", "border-left-width", "border-right-width", "border-top-width", "flex-basis", "font-size", "height", "line-height", "max-height", "max-width", "outline-width", "width"]), a.addPropertiesHandler(h, e, ["border-bottom-left-radius", "border-bottom-right-radius", "border-top-left-radius", "border-top-right-radius", "bottom", "left", "letter-spacing", 
      "margin-bottom", "margin-left", "margin-right", "margin-top", "min-height", "min-width", "outline-offset", "padding-bottom", "padding-left", "padding-right", "padding-top", "perspective", "right", "shape-margin", "text-indent", "top", "vertical-align", "word-spacing"]);
    }(d, f), function(a, b) {
      function c(b) {
        return a.consumeLengthOrPercent(b) || a.consumeToken(/^auto/, b);
      }
      function d(b) {
        var d = a.consumeList([a.ignore(a.consumeToken.bind(null, /^rect/)), a.ignore(a.consumeToken.bind(null, /^\(/)), a.consumeRepeated.bind(null, c, /^,/), a.ignore(a.consumeToken.bind(null, /^\)/))], b);
        return d && 4 == d[0].length ? d[0] : void 0;
      }
      function e(b, c) {
        return "auto" == b || "auto" == c ? [!0, !1, function(d) {
          var e = d ? b : c;
          if ("auto" == e) {
            return "auto";
          }
          var f = a.mergeDimensions(e, e);
          return f[2](f[0]);
        }] : a.mergeDimensions(b, c);
      }
      function f(a) {
        return "rect(" + a + ")";
      }
      var g = a.mergeWrappedNestedRepeated.bind(null, f, e, ", ");
      a.parseBox = d, a.mergeBoxes = g, a.addPropertiesHandler(d, g, ["clip"]);
    }(d, f), function(a, b) {
      function c(a) {
        return function(b) {
          var c = 0;
          return a.map(function(a) {
            return a === k ? b[c++] : a;
          });
        };
      }
      function d(a) {
        return a;
      }
      function e(b) {
        if (b = b.toLowerCase().trim(), "none" == b) {
          return [];
        }
        for (var c, d = /\s*(\w+)\(([^)]*)\)/g, e = [], f = 0; c = d.exec(b);) {
          if (c.index != f) {
            return;
          }
          f = c.index + c[0].length;
          var g = c[1], h = n[g];
          if (!h) {
            return;
          }
          var i = c[2].split(","), j = h[0];
          if (j.length < i.length) {
            return;
          }
          for (var k = [], o = 0; o < j.length; o++) {
            var p, q = i[o], r = j[o];
            if (p = q ? {A:function(b) {
              return "0" == b.trim() ? m : a.parseAngle(b);
            }, N:a.parseNumber, T:a.parseLengthOrPercent, L:a.parseLength}[r.toUpperCase()](q) : {a:m, n:k[0], t:l}[r], void 0 === p) {
              return;
            }
            k.push(p);
          }
          if (e.push({t:g, d:k}), d.lastIndex == b.length) {
            return e;
          }
        }
      }
      function f(a) {
        return a.toFixed(6).replace(".000000", "");
      }
      function g(b, c) {
        if (b.decompositionPair !== c) {
          b.decompositionPair = c;
          var d = a.makeMatrixDecomposition(b);
        }
        if (c.decompositionPair !== b) {
          c.decompositionPair = b;
          var e = a.makeMatrixDecomposition(c);
        }
        return null == d[0] || null == e[0] ? [[!1], [!0], function(a) {
          return a ? c[0].d : b[0].d;
        }] : (d[0].push(0), e[0].push(1), [d, e, function(b) {
          var c = a.quat(d[0][3], e[0][3], b[5]), g = a.composeMatrix(b[0], b[1], b[2], c, b[4]), h = g.map(f).join(",");
          return h;
        }]);
      }
      function h(a) {
        return a.replace(/[xy]/, "");
      }
      function i(a) {
        return a.replace(/(x|y|z|3d)?$/, "3d");
      }
      function j(b, c) {
        var d = a.makeMatrixDecomposition && !0, e = !1;
        if (!b.length || !c.length) {
          b.length || (e = !0, b = c, c = []);
          for (var f = 0; f < b.length; f++) {
            var j = b[f].t, k = b[f].d, l = "scale" == j.substr(0, 5) ? 1 : 0;
            c.push({t:j, d:k.map(function(a) {
              if ("number" == typeof a) {
                return l;
              }
              var b = {};
              for (var c in a) {
                b[c] = l;
              }
              return b;
            })});
          }
        }
        var m = function(a, b) {
          return "perspective" == a && "perspective" == b || ("matrix" == a || "matrix3d" == a) && ("matrix" == b || "matrix3d" == b);
        }, o = [], p = [], q = [];
        if (b.length != c.length) {
          if (!d) {
            return;
          }
          var r = g(b, c);
          o = [r[0]], p = [r[1]], q = [["matrix", [r[2]]]];
        } else {
          for (var f = 0; f < b.length; f++) {
            var j, s = b[f].t, t = c[f].t, u = b[f].d, v = c[f].d, w = n[s], x = n[t];
            if (m(s, t)) {
              if (!d) {
                return;
              }
              var r = g([b[f]], [c[f]]);
              o.push(r[0]), p.push(r[1]), q.push(["matrix", [r[2]]]);
            } else {
              if (s == t) {
                j = s;
              } else {
                if (w[2] && x[2] && h(s) == h(t)) {
                  j = h(s), u = w[2](u), v = x[2](v);
                } else {
                  if (!w[1] || !x[1] || i(s) != i(t)) {
                    if (!d) {
                      return;
                    }
                    var r = g(b, c);
                    o = [r[0]], p = [r[1]], q = [["matrix", [r[2]]]];
                    break;
                  }
                  j = i(s), u = w[1](u), v = x[1](v);
                }
              }
              for (var y = [], z = [], A = [], B = 0; B < u.length; B++) {
                var C = "number" == typeof u[B] ? a.mergeNumbers : a.mergeDimensions, r = C(u[B], v[B]);
                y[B] = r[0], z[B] = r[1], A.push(r[2]);
              }
              o.push(y), p.push(z), q.push([j, A]);
            }
          }
        }
        if (e) {
          var D = o;
          o = p, p = D;
        }
        return [o, p, function(a) {
          return a.map(function(a, b) {
            var c = a.map(function(a, c) {
              return q[b][1][c](a);
            }).join(",");
            return "matrix" == q[b][0] && 16 == c.split(",").length && (q[b][0] = "matrix3d"), q[b][0] + "(" + c + ")";
          }).join(" ");
        }];
      }
      var k = null, l = {px:0}, m = {deg:0}, n = {matrix:["NNNNNN", [k, k, 0, 0, k, k, 0, 0, 0, 0, 1, 0, k, k, 0, 1], d], matrix3d:["NNNNNNNNNNNNNNNN", d], rotate:["A"], rotatex:["A"], rotatey:["A"], rotatez:["A"], rotate3d:["NNNA"], perspective:["L"], scale:["Nn", c([k, k, 1]), d], scalex:["N", c([k, 1, 1]), c([k, 1])], scaley:["N", c([1, k, 1]), c([1, k])], scalez:["N", c([1, 1, k])], scale3d:["NNN", d], skew:["Aa", null, d], skewx:["A", null, c([k, m])], skewy:["A", null, c([m, k])], translate:["Tt", 
      c([k, k, l]), d], translatex:["T", c([k, l, l]), c([k, l])], translatey:["T", c([l, k, l]), c([l, k])], translatez:["L", c([l, l, k])], translate3d:["TTL", d]};
      a.addPropertiesHandler(e, j, ["transform"]);
    }(d, f), function(a, b) {
      function c(a, b) {
        b.concat([a]).forEach(function(b) {
          b in document.documentElement.style && (d[a] = b);
        });
      }
      var d = {};
      c("transform", ["webkitTransform", "msTransform"]), c("transformOrigin", ["webkitTransformOrigin"]), c("perspective", ["webkitPerspective"]), c("perspectiveOrigin", ["webkitPerspectiveOrigin"]), a.propertyName = function(a) {
        return d[a] || a;
      };
    }(d, f);
  }(), !function() {
    if (void 0 === document.createElement("div").animate([]).oncancel) {
      var a;
      if (window.performance && performance.now) {
        var a = function() {
          return performance.now();
        };
      } else {
        var a = function() {
          return Date.now();
        };
      }
      var b = function(a, b, c) {
        this.target = a, this.currentTime = b, this.timelineTime = c, this.type = "cancel", this.bubbles = !1, this.cancelable = !1, this.currentTarget = a, this.defaultPrevented = !1, this.eventPhase = Event.AT_TARGET, this.timeStamp = Date.now();
      }, c = window.Element.prototype.animate;
      window.Element.prototype.animate = function(d, e) {
        var f = c.call(this, d, e);
        f._cancelHandlers = [], f.oncancel = null;
        var g = f.cancel;
        f.cancel = function() {
          g.call(this);
          var c = new b(this, null, a()), d = this._cancelHandlers.concat(this.oncancel ? [this.oncancel] : []);
          setTimeout(function() {
            d.forEach(function(a) {
              a.call(c.target, c);
            });
          }, 0);
        };
        var h = f.addEventListener;
        f.addEventListener = function(a, b) {
          "function" == typeof b && "cancel" == a ? this._cancelHandlers.push(b) : h.call(this, a, b);
        };
        var i = f.removeEventListener;
        return f.removeEventListener = function(a, b) {
          if ("cancel" == a) {
            var c = this._cancelHandlers.indexOf(b);
            c >= 0 && this._cancelHandlers.splice(c, 1);
          } else {
            i.call(this, a, b);
          }
        }, f;
      };
    }
  }(), function(a) {
    var b = document.documentElement, c = null, d = !1;
    try {
      var e = getComputedStyle(b).getPropertyValue("opacity"), f = "0" == e ? "1" : "0";
      c = b.animate({opacity:[f, f]}, {duration:1}), c.currentTime = 0, d = getComputedStyle(b).getPropertyValue("opacity") == f;
    } catch (g) {
    } finally {
      c && c.cancel();
    }
    if (!d) {
      var h = window.Element.prototype.animate;
      window.Element.prototype.animate = function(b, c) {
        return window.Symbol && Symbol.iterator && Array.prototype.from && b[Symbol.iterator] && (b = Array.from(b)), Array.isArray(b) || null === b || (b = a.convertToArrayForm(b)), h.call(this, b, c);
      };
    }
  }(c), !function(a, b, c) {
    function d(a) {
      var b = window.document.timeline;
      b.currentTime = a, b._discardAnimations(), 0 == b._animations.length ? f = !1 : requestAnimationFrame(d);
    }
    var e = window.requestAnimationFrame;
    window.requestAnimationFrame = function(a) {
      return e(function(b) {
        window.document.timeline._updateAnimationsPromises(), a(b), window.document.timeline._updateAnimationsPromises();
      });
    }, b.AnimationTimeline = function() {
      this._animations = [], this.currentTime = void 0;
    }, b.AnimationTimeline.prototype = {getAnimations:function() {
      return this._discardAnimations(), this._animations.slice();
    }, _updateAnimationsPromises:function() {
      b.animationsWithPromises = b.animationsWithPromises.filter(function(a) {
        return a._updatePromises();
      });
    }, _discardAnimations:function() {
      this._updateAnimationsPromises(), this._animations = this._animations.filter(function(a) {
        return "finished" != a.playState && "idle" != a.playState;
      });
    }, _play:function(a) {
      var c = new b.Animation(a, this);
      return this._animations.push(c), b.restartWebAnimationsNextTick(), c._updatePromises(), c._animation.play(), c._updatePromises(), c;
    }, play:function(a) {
      return a && a.remove(), this._play(a);
    }};
    var f = !1;
    b.restartWebAnimationsNextTick = function() {
      f || (f = !0, requestAnimationFrame(d));
    };
    var g = new b.AnimationTimeline;
    b.timeline = g;
    try {
      Object.defineProperty(window.document, "timeline", {configurable:!0, get:function() {
        return g;
      }});
    } catch (h) {
    }
    try {
      window.document.timeline = g;
    } catch (h$5) {
    }
  }(c, e, f), function(a, b, c) {
    b.animationsWithPromises = [], b.Animation = function(b, c) {
      if (this.id = "", b && b._id && (this.id = b._id), this.effect = b, b && (b._animation = this), !c) {
        throw new Error("Animation with null timeline is not supported");
      }
      this._timeline = c, this._sequenceNumber = a.sequenceNumber++, this._holdTime = 0, this._paused = !1, this._isGroup = !1, this._animation = null, this._childAnimations = [], this._callback = null, this._oldPlayState = "idle", this._rebuildUnderlyingAnimation(), this._animation.cancel(), this._updatePromises();
    }, b.Animation.prototype = {_updatePromises:function() {
      var a = this._oldPlayState, b = this.playState;
      return this._readyPromise && b !== a && ("idle" == b ? (this._rejectReadyPromise(), this._readyPromise = void 0) : "pending" == a ? this._resolveReadyPromise() : "pending" == b && (this._readyPromise = void 0)), this._finishedPromise && b !== a && ("idle" == b ? (this._rejectFinishedPromise(), this._finishedPromise = void 0) : "finished" == b ? this._resolveFinishedPromise() : "finished" == a && (this._finishedPromise = void 0)), this._oldPlayState = this.playState, this._readyPromise || this._finishedPromise;
    }, _rebuildUnderlyingAnimation:function() {
      this._updatePromises();
      var a, c, d, e, f = !!this._animation;
      f && (a = this.playbackRate, c = this._paused, d = this.startTime, e = this.currentTime, this._animation.cancel(), this._animation._wrapper = null, this._animation = null), (!this.effect || this.effect instanceof window.KeyframeEffect) && (this._animation = b.newUnderlyingAnimationForKeyframeEffect(this.effect), b.bindAnimationForKeyframeEffect(this)), (this.effect instanceof window.SequenceEffect || this.effect instanceof window.GroupEffect) && (this._animation = b.newUnderlyingAnimationForGroup(this.effect), 
      b.bindAnimationForGroup(this)), this.effect && this.effect._onsample && b.bindAnimationForCustomEffect(this), f && (1 != a && (this.playbackRate = a), null !== d ? this.startTime = d : null !== e ? this.currentTime = e : null !== this._holdTime && (this.currentTime = this._holdTime), c && this.pause()), this._updatePromises();
    }, _updateChildren:function() {
      if (this.effect && "idle" != this.playState) {
        var a = this.effect._timing.delay;
        this._childAnimations.forEach(function(c) {
          this._arrangeChildren(c, a), this.effect instanceof window.SequenceEffect && (a += b.groupChildDuration(c.effect));
        }.bind(this));
      }
    }, _setExternalAnimation:function(a) {
      if (this.effect && this._isGroup) {
        for (var b = 0; b < this.effect.children.length; b++) {
          this.effect.children[b]._animation = a, this._childAnimations[b]._setExternalAnimation(a);
        }
      }
    }, _constructChildAnimations:function() {
      if (this.effect && this._isGroup) {
        var a = this.effect._timing.delay;
        this._removeChildAnimations(), this.effect.children.forEach(function(c) {
          var d = window.document.timeline._play(c);
          this._childAnimations.push(d), d.playbackRate = this.playbackRate, this._paused && d.pause(), c._animation = this.effect._animation, this._arrangeChildren(d, a), this.effect instanceof window.SequenceEffect && (a += b.groupChildDuration(c));
        }.bind(this));
      }
    }, _arrangeChildren:function(a, b) {
      null === this.startTime ? a.currentTime = this.currentTime - b / this.playbackRate : a.startTime !== this.startTime + b / this.playbackRate && (a.startTime = this.startTime + b / this.playbackRate);
    }, get timeline() {
      return this._timeline;
    }, get playState() {
      return this._animation ? this._animation.playState : "idle";
    }, get finished() {
      return window.Promise ? (this._finishedPromise || (-1 == b.animationsWithPromises.indexOf(this) && b.animationsWithPromises.push(this), this._finishedPromise = new Promise(function(a, b) {
        this._resolveFinishedPromise = function() {
          a(this);
        }, this._rejectFinishedPromise = function() {
          b({type:DOMException.ABORT_ERR, name:"AbortError"});
        };
      }.bind(this)), "finished" == this.playState && this._resolveFinishedPromise()), this._finishedPromise) : (console.warn("Animation Promises require JavaScript Promise constructor"), null);
    }, get ready() {
      return window.Promise ? (this._readyPromise || (-1 == b.animationsWithPromises.indexOf(this) && b.animationsWithPromises.push(this), this._readyPromise = new Promise(function(a, b) {
        this._resolveReadyPromise = function() {
          a(this);
        }, this._rejectReadyPromise = function() {
          b({type:DOMException.ABORT_ERR, name:"AbortError"});
        };
      }.bind(this)), "pending" !== this.playState && this._resolveReadyPromise()), this._readyPromise) : (console.warn("Animation Promises require JavaScript Promise constructor"), null);
    }, get onfinish() {
      return this._animation.onfinish;
    }, set onfinish(a) {
      "function" == typeof a ? this._animation.onfinish = function(b) {
        b.target = this, a.call(this, b);
      }.bind(this) : this._animation.onfinish = a;
    }, get oncancel() {
      return this._animation.oncancel;
    }, set oncancel(a) {
      "function" == typeof a ? this._animation.oncancel = function(b) {
        b.target = this, a.call(this, b);
      }.bind(this) : this._animation.oncancel = a;
    }, get currentTime() {
      this._updatePromises();
      var a = this._animation.currentTime;
      return this._updatePromises(), a;
    }, set currentTime(a) {
      this._updatePromises(), this._animation.currentTime = isFinite(a) ? a : Math.sign(a) * Number.MAX_VALUE, this._register(), this._forEachChild(function(b, c) {
        b.currentTime = a - c;
      }), this._updatePromises();
    }, get startTime() {
      return this._animation.startTime;
    }, set startTime(a) {
      this._updatePromises(), this._animation.startTime = isFinite(a) ? a : Math.sign(a) * Number.MAX_VALUE, this._register(), this._forEachChild(function(b, c) {
        b.startTime = a + c;
      }), this._updatePromises();
    }, get playbackRate() {
      return this._animation.playbackRate;
    }, set playbackRate(a) {
      this._updatePromises();
      var b = this.currentTime;
      this._animation.playbackRate = a, this._forEachChild(function(b) {
        b.playbackRate = a;
      }), "paused" != this.playState && "idle" != this.playState && this.play(), null !== b && (this.currentTime = b), this._updatePromises();
    }, play:function() {
      this._updatePromises(), this._paused = !1, this._animation.play(), -1 == this._timeline._animations.indexOf(this) && this._timeline._animations.push(this), this._register(), b.awaitStartTime(this), this._forEachChild(function(a) {
        var b = a.currentTime;
        a.play(), a.currentTime = b;
      }), this._updatePromises();
    }, pause:function() {
      this._updatePromises(), this.currentTime && (this._holdTime = this.currentTime), this._animation.pause(), this._register(), this._forEachChild(function(a) {
        a.pause();
      }), this._paused = !0, this._updatePromises();
    }, finish:function() {
      this._updatePromises(), this._animation.finish(), this._register(), this._updatePromises();
    }, cancel:function() {
      this._updatePromises(), this._animation.cancel(), this._register(), this._removeChildAnimations(), this._updatePromises();
    }, reverse:function() {
      this._updatePromises();
      var a = this.currentTime;
      this._animation.reverse(), this._forEachChild(function(a) {
        a.reverse();
      }), null !== a && (this.currentTime = a), this._updatePromises();
    }, addEventListener:function(a, b) {
      var c = b;
      "function" == typeof b && (c = function(a) {
        a.target = this, b.call(this, a);
      }.bind(this), b._wrapper = c), this._animation.addEventListener(a, c);
    }, removeEventListener:function(a, b) {
      this._animation.removeEventListener(a, b && b._wrapper || b);
    }, _removeChildAnimations:function() {
      for (; this._childAnimations.length;) {
        this._childAnimations.pop().cancel();
      }
    }, _forEachChild:function(b) {
      var c = 0;
      if (this.effect.children && this._childAnimations.length < this.effect.children.length && this._constructChildAnimations(), this._childAnimations.forEach(function(a) {
        b.call(this, a, c), this.effect instanceof window.SequenceEffect && (c += a.effect.activeDuration);
      }.bind(this)), "pending" != this.playState) {
        var d = this.effect._timing, e = this.currentTime;
        null !== e && (e = a.calculateTimeFraction(a.calculateActiveDuration(d), e, d)), (null == e || isNaN(e)) && this._removeChildAnimations();
      }
    }}, window.Animation = b.Animation;
  }(c, e, f), function(a, b, c) {
    function d(b) {
      this._frames = a.normalizeKeyframes(b);
    }
    function e() {
      for (var a = !1; i.length;) {
        var b = i.shift();
        b._updateChildren(), a = !0;
      }
      return a;
    }
    var f = function(a) {
      if (a._animation = void 0, a instanceof window.SequenceEffect || a instanceof window.GroupEffect) {
        for (var b = 0; b < a.children.length; b++) {
          f(a.children[b]);
        }
      }
    };
    b.removeMulti = function(a) {
      for (var b = [], c = 0; c < a.length; c++) {
        var d = a[c];
        d._parent ? (-1 == b.indexOf(d._parent) && b.push(d._parent), d._parent.children.splice(d._parent.children.indexOf(d), 1), d._parent = null, f(d)) : d._animation && d._animation.effect == d && (d._animation.cancel(), d._animation.effect = new KeyframeEffect(null, []), d._animation._callback && (d._animation._callback._animation = null), d._animation._rebuildUnderlyingAnimation(), f(d));
      }
      for (c = 0; c < b.length; c++) {
        b[c]._rebuild();
      }
    }, b.KeyframeEffect = function(b, c, e, f) {
      return this.target = b, this._parent = null, e = a.numericTimingToObject(e), this._timingInput = a.cloneTimingInput(e), this._timing = a.normalizeTimingInput(e), this.timing = a.makeTiming(e, !1, this), this.timing._effect = this, "function" == typeof c ? (a.deprecated("Custom KeyframeEffect", "2015-06-22", "Use KeyframeEffect.onsample instead."), this._normalizedKeyframes = c) : this._normalizedKeyframes = new d(c), this._keyframes = c, this.activeDuration = a.calculateActiveDuration(this._timing), 
      this._id = f, this;
    }, b.KeyframeEffect.prototype = {getFrames:function() {
      return "function" == typeof this._normalizedKeyframes ? this._normalizedKeyframes : this._normalizedKeyframes._frames;
    }, set onsample(a) {
      if ("function" == typeof this.getFrames()) {
        throw new Error("Setting onsample on custom effect KeyframeEffect is not supported.");
      }
      this._onsample = a, this._animation && this._animation._rebuildUnderlyingAnimation();
    }, get parent() {
      return this._parent;
    }, clone:function() {
      if ("function" == typeof this.getFrames()) {
        throw new Error("Cloning custom effects is not supported.");
      }
      var b = new KeyframeEffect(this.target, [], a.cloneTimingInput(this._timingInput), this._id);
      return b._normalizedKeyframes = this._normalizedKeyframes, b._keyframes = this._keyframes, b;
    }, remove:function() {
      b.removeMulti([this]);
    }};
    var g = Element.prototype.animate;
    Element.prototype.animate = function(a, c) {
      var d = "";
      return c && c.id && (d = c.id), b.timeline._play(new b.KeyframeEffect(this, a, c, d));
    };
    var h = document.createElementNS("http://www.w3.org/1999/xhtml", "div");
    b.newUnderlyingAnimationForKeyframeEffect = function(a) {
      if (a) {
        var b = a.target || h, c = a._keyframes;
        "function" == typeof c && (c = []);
        var d = a._timingInput;
        d.id = a._id;
      } else {
        var b = h, c = [], d = 0;
      }
      return g.apply(b, [c, d]);
    }, b.bindAnimationForKeyframeEffect = function(a) {
      a.effect && "function" == typeof a.effect._normalizedKeyframes && b.bindAnimationForCustomEffect(a);
    };
    var i = [];
    b.awaitStartTime = function(a) {
      null === a.startTime && a._isGroup && (0 == i.length && requestAnimationFrame(e), i.push(a));
    };
    var j = window.getComputedStyle;
    Object.defineProperty(window, "getComputedStyle", {configurable:!0, enumerable:!0, value:function() {
      window.document.timeline._updateAnimationsPromises();
      var a = j.apply(this, arguments);
      return e() && (a = j.apply(this, arguments)), window.document.timeline._updateAnimationsPromises(), a;
    }}), window.KeyframeEffect = b.KeyframeEffect, window.Element.prototype.getAnimations = function() {
      return document.timeline.getAnimations().filter(function(a) {
        return null !== a.effect && a.effect.target == this;
      }.bind(this));
    };
  }(c, e, f), function(a, b, c) {
    function d(a) {
      a._registered || (a._registered = !0, g.push(a), h || (h = !0, requestAnimationFrame(e)));
    }
    function e(a) {
      var b = g;
      g = [], b.sort(function(a, b) {
        return a._sequenceNumber - b._sequenceNumber;
      }), b = b.filter(function(a) {
        a();
        var b = a._animation ? a._animation.playState : "idle";
        return "running" != b && "pending" != b && (a._registered = !1), a._registered;
      }), g.push.apply(g, b), g.length ? (h = !0, requestAnimationFrame(e)) : h = !1;
    }
    var f = (document.createElementNS("http://www.w3.org/1999/xhtml", "div"), 0);
    b.bindAnimationForCustomEffect = function(b) {
      var c, e = b.effect.target, g = "function" == typeof b.effect.getFrames();
      c = g ? b.effect.getFrames() : b.effect._onsample;
      var h = b.effect.timing, i = null;
      h = a.normalizeTimingInput(h);
      var j = function() {
        var d = j._animation ? j._animation.currentTime : null;
        null !== d && (d = a.calculateTimeFraction(a.calculateActiveDuration(h), d, h), isNaN(d) && (d = null)), d !== i && (g ? c(d, e, b.effect) : c(d, b.effect, b.effect._animation)), i = d;
      };
      j._animation = b, j._registered = !1, j._sequenceNumber = f++, b._callback = j, d(j);
    };
    var g = [], h = !1;
    b.Animation.prototype._register = function() {
      this._callback && d(this._callback);
    };
  }(c, e, f), function(a, b, c) {
    function d(a) {
      return a._timing.delay + a.activeDuration + a._timing.endDelay;
    }
    function e(b, c, d) {
      this._id = d, this._parent = null, this.children = b || [], this._reparent(this.children), c = a.numericTimingToObject(c), this._timingInput = a.cloneTimingInput(c), this._timing = a.normalizeTimingInput(c, !0), this.timing = a.makeTiming(c, !0, this), this.timing._effect = this, "auto" === this._timing.duration && (this._timing.duration = this.activeDuration);
    }
    window.SequenceEffect = function() {
      e.apply(this, arguments);
    }, window.GroupEffect = function() {
      e.apply(this, arguments);
    }, e.prototype = {_isAncestor:function(a) {
      for (var b = this; null !== b;) {
        if (b == a) {
          return !0;
        }
        b = b._parent;
      }
      return !1;
    }, _rebuild:function() {
      for (var a = this; a;) {
        "auto" === a.timing.duration && (a._timing.duration = a.activeDuration), a = a._parent;
      }
      this._animation && this._animation._rebuildUnderlyingAnimation();
    }, _reparent:function(a) {
      b.removeMulti(a);
      for (var c = 0; c < a.length; c++) {
        a[c]._parent = this;
      }
    }, _putChild:function(a, b) {
      for (var c = b ? "Cannot append an ancestor or self" : "Cannot prepend an ancestor or self", d = 0; d < a.length; d++) {
        if (this._isAncestor(a[d])) {
          throw {type:DOMException.HIERARCHY_REQUEST_ERR, name:"HierarchyRequestError", message:c};
        }
      }
      for (var d = 0; d < a.length; d++) {
        b ? this.children.push(a[d]) : this.children.unshift(a[d]);
      }
      this._reparent(a), this._rebuild();
    }, append:function() {
      this._putChild(arguments, !0);
    }, prepend:function() {
      this._putChild(arguments, !1);
    }, get parent() {
      return this._parent;
    }, get firstChild() {
      return this.children.length ? this.children[0] : null;
    }, get lastChild() {
      return this.children.length ? this.children[this.children.length - 1] : null;
    }, clone:function() {
      for (var b = a.cloneTimingInput(this._timingInput), c = [], d = 0; d < this.children.length; d++) {
        c.push(this.children[d].clone());
      }
      return this instanceof GroupEffect ? new GroupEffect(c, b) : new SequenceEffect(c, b);
    }, remove:function() {
      b.removeMulti([this]);
    }}, window.SequenceEffect.prototype = Object.create(e.prototype), Object.defineProperty(window.SequenceEffect.prototype, "activeDuration", {get:function() {
      var a = 0;
      return this.children.forEach(function(b) {
        a += d(b);
      }), Math.max(a, 0);
    }}), window.GroupEffect.prototype = Object.create(e.prototype), Object.defineProperty(window.GroupEffect.prototype, "activeDuration", {get:function() {
      var a = 0;
      return this.children.forEach(function(b) {
        a = Math.max(a, d(b));
      }), a;
    }}), b.newUnderlyingAnimationForGroup = function(c) {
      var d, e = null, f = function(b) {
        var c = d._wrapper;
        return c && "pending" != c.playState && c.effect ? null == b ? void c._removeChildAnimations() : 0 == b && c.playbackRate < 0 && (e || (e = a.normalizeTimingInput(c.effect.timing)), b = a.calculateTimeFraction(a.calculateActiveDuration(e), -1, e), isNaN(b) || null == b) ? (c._forEachChild(function(a) {
          a.currentTime = -1;
        }), void c._removeChildAnimations()) : void 0 : void 0;
      }, g = new KeyframeEffect(null, [], c._timing, c._id);
      return g.onsample = f, d = b.timeline._play(g);
    }, b.bindAnimationForGroup = function(a) {
      a._animation._wrapper = a, a._isGroup = !0, b.awaitStartTime(a), a._constructChildAnimations(), a._setExternalAnimation(a);
    }, b.groupChildDuration = d;
  }(c, e, f), b["true"] = a;
}({}, function() {
  return this;
}());
Polymer({is:"cascaded-animation", behaviors:[Polymer.NeonAnimationBehavior], configure:function(config) {
  this._animations = [];
  var nodes = config.nodes;
  var effects = [];
  var nodeDelay = config.nodeDelay || 50;
  config.timing = config.timing || {};
  config.timing.delay = config.timing.delay || 0;
  var oldDelay = config.timing.delay;
  var abortedConfigure;
  for (var node, index = 0; node = nodes[index]; index++) {
    config.timing.delay += nodeDelay;
    config.node = node;
    var animation = document.createElement(config.animation);
    if (animation.isNeonAnimation) {
      var effect = animation.configure(config);
      this._animations.push(animation);
      effects.push(effect);
    } else {
      console.warn(this.is + ":", config.animation, "not found!");
      abortedConfigure = true;
      break;
    }
  }
  config.timing.delay = oldDelay;
  config.node = null;
  if (abortedConfigure) {
    return;
  }
  this._effect = new GroupEffect(effects);
  return this._effect;
}, complete:function() {
  for (var animation, index = 0; animation = this._animations[index]; index++) {
    animation.complete(animation.config);
  }
}});
Polymer({is:"fade-in-animation", behaviors:[Polymer.NeonAnimationBehavior], configure:function(config) {
  var node = config.node;
  this._effect = new KeyframeEffect(node, [{"opacity":"0"}, {"opacity":"1"}], this.timingFromConfig(config));
  return this._effect;
}});
Polymer({is:"fade-out-animation", behaviors:[Polymer.NeonAnimationBehavior], configure:function(config) {
  var node = config.node;
  this._effect = new KeyframeEffect(node, [{"opacity":"1"}, {"opacity":"0"}], this.timingFromConfig(config));
  return this._effect;
}});
Polymer.NeonSharedElementAnimationBehaviorImpl = {properties:{sharedElements:{type:Object}}, findSharedElements:function(config) {
  var fromPage = config.fromPage;
  var toPage = config.toPage;
  if (!fromPage || !toPage) {
    console.warn(this.is + ":", !fromPage ? "fromPage" : "toPage", "is undefined!");
    return null;
  }
  if (!fromPage.sharedElements || !toPage.sharedElements) {
    console.warn(this.is + ":", "sharedElements are undefined for", !fromPage.sharedElements ? fromPage : toPage);
    return null;
  }
  var from = fromPage.sharedElements[config.id];
  var to = toPage.sharedElements[config.id];
  if (!from || !to) {
    console.warn(this.is + ":", "sharedElement with id", config.id, "not found in", !from ? fromPage : toPage);
    return null;
  }
  this.sharedElements = {from:from, to:to};
  return this.sharedElements;
}};
Polymer.NeonSharedElementAnimationBehavior = [Polymer.NeonAnimationBehavior, Polymer.NeonSharedElementAnimationBehaviorImpl];
Polymer({is:"hero-animation", behaviors:[Polymer.NeonSharedElementAnimationBehavior], configure:function(config) {
  var shared = this.findSharedElements(config);
  if (!shared) {
    return;
  }
  var fromRect = shared.from.getBoundingClientRect();
  var toRect = shared.to.getBoundingClientRect();
  var deltaLeft = fromRect.left - toRect.left;
  var deltaTop = fromRect.top - toRect.top;
  var deltaWidth = fromRect.width / toRect.width;
  var deltaHeight = fromRect.height / toRect.height;
  this._effect = new KeyframeEffect(shared.to, [{"transform":"translate(" + deltaLeft + "px," + deltaTop + "px) scale(" + deltaWidth + "," + deltaHeight + ")"}, {"transform":"none"}], this.timingFromConfig(config));
  this.setPrefixedProperty(shared.to, "transformOrigin", "0 0");
  shared.to.style.zIndex = 10000;
  shared.from.style.visibility = "hidden";
  return this._effect;
}, complete:function(config) {
  var shared = this.findSharedElements(config);
  if (!shared) {
    return null;
  }
  shared.to.style.zIndex = "";
  shared.from.style.visibility = "";
}});
Polymer({is:"opaque-animation", behaviors:[Polymer.NeonAnimationBehavior], configure:function(config) {
  var node = config.node;
  this._effect = new KeyframeEffect(node, [{"opacity":"1"}, {"opacity":"1"}], this.timingFromConfig(config));
  node.style.opacity = "0";
  return this._effect;
}, complete:function(config) {
  config.node.style.opacity = "";
}});
Polymer({is:"ripple-animation", behaviors:[Polymer.NeonSharedElementAnimationBehavior], configure:function(config) {
  var shared = this.findSharedElements(config);
  if (!shared) {
    return null;
  }
  var translateX, translateY;
  var toRect = shared.to.getBoundingClientRect();
  if (config.gesture) {
    translateX = config.gesture.x - (toRect.left + toRect.width / 2);
    translateY = config.gesture.y - (toRect.top + toRect.height / 2);
  } else {
    var fromRect = shared.from.getBoundingClientRect();
    translateX = fromRect.left + fromRect.width / 2 - (toRect.left + toRect.width / 2);
    translateY = fromRect.top + fromRect.height / 2 - (toRect.top + toRect.height / 2);
  }
  var translate = "translate(" + translateX + "px," + translateY + "px)";
  var size = Math.max(toRect.width + Math.abs(translateX) * 2, toRect.height + Math.abs(translateY) * 2);
  var diameter = Math.sqrt(2 * size * size);
  var scaleX = diameter / toRect.width;
  var scaleY = diameter / toRect.height;
  var scale = "scale(" + scaleX + "," + scaleY + ")";
  this._effect = new KeyframeEffect(shared.to, [{"transform":translate + " scale(0)"}, {"transform":translate + " " + scale}], this.timingFromConfig(config));
  this.setPrefixedProperty(shared.to, "transformOrigin", "50% 50%");
  shared.to.style.borderRadius = "50%";
  return this._effect;
}, complete:function() {
  if (this.sharedElements) {
    this.setPrefixedProperty(this.sharedElements.to, "transformOrigin", "");
    this.sharedElements.to.style.borderRadius = "";
  }
}});
Polymer({is:"scale-down-animation", behaviors:[Polymer.NeonAnimationBehavior], configure:function(config) {
  var node = config.node;
  var scaleProperty = "scale(0, 0)";
  if (config.axis === "x") {
    scaleProperty = "scale(0, 1)";
  } else {
    if (config.axis === "y") {
      scaleProperty = "scale(1, 0)";
    }
  }
  this._effect = new KeyframeEffect(node, [{"transform":"scale(1,1)"}, {"transform":scaleProperty}], this.timingFromConfig(config));
  if (config.transformOrigin) {
    this.setPrefixedProperty(node, "transformOrigin", config.transformOrigin);
  }
  return this._effect;
}});
Polymer({is:"scale-up-animation", behaviors:[Polymer.NeonAnimationBehavior], configure:function(config) {
  var node = config.node;
  var scaleProperty = "scale(0)";
  if (config.axis === "x") {
    scaleProperty = "scale(0, 1)";
  } else {
    if (config.axis === "y") {
      scaleProperty = "scale(1, 0)";
    }
  }
  this._effect = new KeyframeEffect(node, [{"transform":scaleProperty}, {"transform":"scale(1, 1)"}], this.timingFromConfig(config));
  if (config.transformOrigin) {
    this.setPrefixedProperty(node, "transformOrigin", config.transformOrigin);
  }
  return this._effect;
}});
Polymer({is:"slide-down-animation", behaviors:[Polymer.NeonAnimationBehavior], configure:function(config) {
  var node = config.node;
  this._effect = new KeyframeEffect(node, [{"transform":"translateY(0%)"}, {"transform":"translateY(100%)"}], this.timingFromConfig(config));
  if (config.transformOrigin) {
    this.setPrefixedProperty(node, "transformOrigin", config.transformOrigin);
  } else {
    this.setPrefixedProperty(node, "transformOrigin", "50% 0");
  }
  return this._effect;
}});
Polymer({is:"slide-up-animation", behaviors:[Polymer.NeonAnimationBehavior], configure:function(config) {
  var node = config.node;
  this._effect = new KeyframeEffect(node, [{"transform":"translate(0)"}, {"transform":"translateY(-100%)"}], this.timingFromConfig(config));
  if (config.transformOrigin) {
    this.setPrefixedProperty(node, "transformOrigin", config.transformOrigin);
  } else {
    this.setPrefixedProperty(node, "transformOrigin", "50% 0");
  }
  return this._effect;
}});
Polymer({is:"transform-animation", behaviors:[Polymer.NeonAnimationBehavior], configure:function(config) {
  var node = config.node;
  var transformFrom = config.transformFrom || "none";
  var transformTo = config.transformTo || "none";
  this._effect = new KeyframeEffect(node, [{"transform":transformFrom}, {"transform":transformTo}], this.timingFromConfig(config));
  if (config.transformOrigin) {
    this.setPrefixedProperty(node, "transformOrigin", config.transformOrigin);
  }
  return this._effect;
}});
Polymer.NeonAnimatableBehavior = {properties:{animationConfig:{type:Object}, entryAnimation:{observer:"_entryAnimationChanged", type:String}, exitAnimation:{observer:"_exitAnimationChanged", type:String}}, _entryAnimationChanged:function() {
  this.animationConfig = this.animationConfig || {};
  this.animationConfig["entry"] = [{name:this.entryAnimation, node:this}];
}, _exitAnimationChanged:function() {
  this.animationConfig = this.animationConfig || {};
  this.animationConfig["exit"] = [{name:this.exitAnimation, node:this}];
}, _copyProperties:function(config1, config2) {
  for (var property in config2) {
    config1[property] = config2[property];
  }
}, _cloneConfig:function(config) {
  var clone = {isClone:true};
  this._copyProperties(clone, config);
  return clone;
}, _getAnimationConfigRecursive:function(type, map, allConfigs) {
  if (!this.animationConfig) {
    return;
  }
  if (this.animationConfig.value && typeof this.animationConfig.value === "function") {
    this._warn(this._logf("playAnimation", "Please put 'animationConfig' inside of your components 'properties' object instead of outside of it."));
    return;
  }
  var thisConfig;
  if (type) {
    thisConfig = this.animationConfig[type];
  } else {
    thisConfig = this.animationConfig;
  }
  if (!Array.isArray(thisConfig)) {
    thisConfig = [thisConfig];
  }
  if (thisConfig) {
    for (var config, index = 0; config = thisConfig[index]; index++) {
      if (config.animatable) {
        config.animatable._getAnimationConfigRecursive(config.type || type, map, allConfigs);
      } else {
        if (config.id) {
          var cachedConfig = map[config.id];
          if (cachedConfig) {
            if (!cachedConfig.isClone) {
              map[config.id] = this._cloneConfig(cachedConfig);
              cachedConfig = map[config.id];
            }
            this._copyProperties(cachedConfig, config);
          } else {
            map[config.id] = config;
          }
        } else {
          allConfigs.push(config);
        }
      }
    }
  }
}, getAnimationConfig:function(type) {
  var map = {};
  var allConfigs = [];
  this._getAnimationConfigRecursive(type, map, allConfigs);
  for (var key in map) {
    allConfigs.push(map[key]);
  }
  return allConfigs;
}};
Polymer.NeonAnimationRunnerBehaviorImpl = {properties:{_player:{type:Object}}, _configureAnimationEffects:function(allConfigs) {
  var allAnimations = [];
  if (allConfigs.length > 0) {
    for (var config, index = 0; config = allConfigs[index]; index++) {
      var animation = document.createElement(config.name);
      if (animation.isNeonAnimation) {
        var effect = animation.configure(config);
        if (effect) {
          allAnimations.push({animation:animation, config:config, effect:effect});
        }
      } else {
        console.warn(this.is + ":", config.name, "not found!");
      }
    }
  }
  return allAnimations;
}, _runAnimationEffects:function(allEffects) {
  return document.timeline.play(new GroupEffect(allEffects));
}, _completeAnimations:function(allAnimations) {
  for (var animation, index = 0; animation = allAnimations[index]; index++) {
    animation.animation.complete(animation.config);
  }
}, playAnimation:function(type, cookie) {
  var allConfigs = this.getAnimationConfig(type);
  if (!allConfigs) {
    return;
  }
  try {
    var allAnimations = this._configureAnimationEffects(allConfigs);
    var allEffects = allAnimations.map(function(animation) {
      return animation.effect;
    });
    if (allEffects.length > 0) {
      this._player = this._runAnimationEffects(allEffects);
      this._player.onfinish = function() {
        this._completeAnimations(allAnimations);
        if (this._player) {
          this._player.cancel();
          this._player = null;
        }
        this.fire("neon-animation-finish", cookie, {bubbles:false});
      }.bind(this);
      return;
    }
  } catch (e) {
    console.warn("Couldnt play", "(", type, allConfigs, ").", e);
  }
  this.fire("neon-animation-finish", cookie, {bubbles:false});
}, cancelAnimation:function() {
  if (this._player) {
    this._player.cancel();
  }
}};
Polymer.NeonAnimationRunnerBehavior = [Polymer.NeonAnimatableBehavior, Polymer.NeonAnimationRunnerBehaviorImpl];
(function() {
  Polymer({is:"neon-animated-pages", behaviors:[Polymer.IronResizableBehavior, Polymer.IronSelectableBehavior, Polymer.NeonAnimationRunnerBehavior], properties:{activateEvent:{type:String, value:""}, animateInitialSelection:{type:Boolean, value:false}}, listeners:{"iron-select":"_onIronSelect", "neon-animation-finish":"_onNeonAnimationFinish"}, _onIronSelect:function(event) {
    var selectedPage = event.detail.item;
    if (this.items.indexOf(selectedPage) < 0) {
      return;
    }
    var oldPage = this._valueToItem(this._prevSelected) || false;
    this._prevSelected = this.selected;
    if (!oldPage && !this.animateInitialSelection) {
      this._completeSelectedChanged();
      return;
    }
    this.animationConfig = [];
    this.animationConfig = [];
    if (this.entryAnimation) {
      this.animationConfig.push({name:this.entryAnimation, node:selectedPage});
    } else {
      if (selectedPage.getAnimationConfig) {
        this.animationConfig.push({animatable:selectedPage, type:"entry"});
      }
    }
    if (oldPage) {
      if (oldPage.classList.contains("neon-animating")) {
        this._squelchNextFinishEvent = true;
        this.cancelAnimation();
        this._completeSelectedChanged();
        this._squelchNextFinishEvent = false;
      }
      if (this.exitAnimation) {
        this.animationConfig.push({name:this.exitAnimation, node:oldPage});
      } else {
        if (oldPage.getAnimationConfig) {
          this.animationConfig.push({animatable:oldPage, type:"exit"});
        }
      }
      oldPage.classList.add("neon-animating");
    }
    selectedPage.classList.add("neon-animating");
    if (this.animationConfig.length >= 1) {
      if (!this.isAttached) {
        this.async(function() {
          this.playAnimation(undefined, {fromPage:null, toPage:selectedPage});
        });
      } else {
        this.playAnimation(undefined, {fromPage:oldPage, toPage:selectedPage});
      }
    } else {
      this._completeSelectedChanged(oldPage, selectedPage);
    }
  }, _completeSelectedChanged:function(oldPage, selectedPage) {
    if (selectedPage) {
      selectedPage.classList.remove("neon-animating");
    }
    if (oldPage) {
      oldPage.classList.remove("neon-animating");
    }
    if (!selectedPage || !oldPage) {
      var nodes = Polymer.dom(this.$.content).getDistributedNodes();
      for (var node, index = 0; node = nodes[index]; index++) {
        node.classList && node.classList.remove("neon-animating");
      }
    }
    this.async(this._notifyPageResize);
  }, _onNeonAnimationFinish:function(event) {
    if (this._squelchNextFinishEvent) {
      this._squelchNextFinishEvent = false;
      return;
    }
    this._completeSelectedChanged(event.detail.fromPage, event.detail.toPage);
  }, _notifyPageResize:function() {
    var selectedPage = this.selectedItem || this._valueToItem(this.selected);
    this.resizerShouldNotify = function(element) {
      return element == selectedPage;
    };
    this.notifyResize();
  }});
})();
Polymer({is:"neon-animatable", behaviors:[Polymer.NeonAnimatableBehavior, Polymer.IronResizableBehavior]});
Polymer({is:"reverse-ripple-animation", behaviors:[Polymer.NeonSharedElementAnimationBehavior], configure:function(config) {
  var shared = this.findSharedElements(config);
  if (!shared) {
    return null;
  }
  var translateX, translateY;
  var fromRect = shared.from.getBoundingClientRect();
  if (config.gesture) {
    translateX = config.gesture.x - (fromRect.left + fromRect.width / 2);
    translateY = config.gesture.y - (fromRect.top + fromRect.height / 2);
  } else {
    var toRect = shared.to.getBoundingClientRect();
    translateX = toRect.left + toRect.width / 2 - (fromRect.left + fromRect.width / 2);
    translateY = toRect.top + toRect.height / 2 - (fromRect.top + fromRect.height / 2);
  }
  var translate = "translate(" + translateX + "px," + translateY + "px)";
  var size = Math.max(fromRect.width + Math.abs(translateX) * 2, fromRect.height + Math.abs(translateY) * 2);
  var diameter = Math.sqrt(2 * size * size);
  var scaleX = diameter / fromRect.width;
  var scaleY = diameter / fromRect.height;
  var scale = "scale(" + scaleX + "," + scaleY + ")";
  this._effect = new KeyframeEffect(shared.from, [{"transform":translate + " " + scale}, {"transform":translate + " scale(0)"}], this.timingFromConfig(config));
  this.setPrefixedProperty(shared.from, "transformOrigin", "50% 50%");
  shared.from.style.borderRadius = "50%";
  return this._effect;
}, complete:function() {
  if (this.sharedElements) {
    this.setPrefixedProperty(this.sharedElements.from, "transformOrigin", "");
    this.sharedElements.from.style.borderRadius = "";
  }
}});
Polymer({is:"slide-from-left-animation", behaviors:[Polymer.NeonAnimationBehavior], configure:function(config) {
  var node = config.node;
  this._effect = new KeyframeEffect(node, [{"transform":"translateX(-100%)"}, {"transform":"none"}], this.timingFromConfig(config));
  if (config.transformOrigin) {
    this.setPrefixedProperty(node, "transformOrigin", config.transformOrigin);
  } else {
    this.setPrefixedProperty(node, "transformOrigin", "0 50%");
  }
  return this._effect;
}});
Polymer({is:"slide-from-right-animation", behaviors:[Polymer.NeonAnimationBehavior], configure:function(config) {
  var node = config.node;
  this._effect = new KeyframeEffect(node, [{"transform":"translateX(100%)"}, {"transform":"none"}], this.timingFromConfig(config));
  if (config.transformOrigin) {
    this.setPrefixedProperty(node, "transformOrigin", config.transformOrigin);
  } else {
    this.setPrefixedProperty(node, "transformOrigin", "0 50%");
  }
  return this._effect;
}});
Polymer({is:"slide-from-top-animation", behaviors:[Polymer.NeonAnimationBehavior], configure:function(config) {
  var node = config.node;
  this._effect = new KeyframeEffect(node, [{"transform":"translateY(-100%)"}, {"transform":"translateY(0%)"}], this.timingFromConfig(config));
  if (config.transformOrigin) {
    this.setPrefixedProperty(node, "transformOrigin", config.transformOrigin);
  } else {
    this.setPrefixedProperty(node, "transformOrigin", "50% 0");
  }
  return this._effect;
}});
Polymer({is:"slide-from-bottom-animation", behaviors:[Polymer.NeonAnimationBehavior], configure:function(config) {
  var node = config.node;
  this._effect = new KeyframeEffect(node, [{"transform":"translateY(100%)"}, {"transform":"translateY(0)"}], this.timingFromConfig(config));
  if (config.transformOrigin) {
    this.setPrefixedProperty(node, "transformOrigin", config.transformOrigin);
  } else {
    this.setPrefixedProperty(node, "transformOrigin", "50% 0");
  }
  return this._effect;
}});
Polymer({is:"slide-left-animation", behaviors:[Polymer.NeonAnimationBehavior], configure:function(config) {
  var node = config.node;
  this._effect = new KeyframeEffect(node, [{"transform":"none"}, {"transform":"translateX(-100%)"}], this.timingFromConfig(config));
  if (config.transformOrigin) {
    this.setPrefixedProperty(node, "transformOrigin", config.transformOrigin);
  } else {
    this.setPrefixedProperty(node, "transformOrigin", "0 50%");
  }
  return this._effect;
}});
Polymer({is:"slide-right-animation", behaviors:[Polymer.NeonAnimationBehavior], configure:function(config) {
  var node = config.node;
  this._effect = new KeyframeEffect(node, [{"transform":"none"}, {"transform":"translateX(100%)"}], this.timingFromConfig(config));
  if (config.transformOrigin) {
    this.setPrefixedProperty(node, "transformOrigin", config.transformOrigin);
  } else {
    this.setPrefixedProperty(node, "transformOrigin", "0 50%");
  }
  return this._effect;
}});
Polymer.NeonSharedElementAnimatableBehaviorImpl = {properties:{sharedElements:{type:Object, value:{}}}};
Polymer.NeonSharedElementAnimatableBehavior = [Polymer.NeonAnimatableBehavior, Polymer.NeonSharedElementAnimatableBehaviorImpl];
Polymer({is:"paper-card", properties:{heading:{type:String, value:"", observer:"_headingChanged"}, image:{type:String, value:""}, preloadImage:{type:Boolean, value:false}, fadeImage:{type:Boolean, value:false}, elevation:{type:Number, value:1, reflectToAttribute:true}, animatedShadow:{type:Boolean, value:false}, animated:{type:Boolean, reflectToAttribute:true, readOnly:true, computed:"_computeAnimated(animatedShadow)"}}, _headingChanged:function(heading) {
  var label = this.getAttribute("aria-label");
  this.setAttribute("aria-label", heading);
}, _computeHeadingClass:function(image) {
  var cls = "title-text";
  if (image) {
    cls += " over-image";
  }
  return cls;
}, _computeAnimated:function(animatedShadow) {
  return animatedShadow;
}});
Polymer.IronCheckedElementBehaviorImpl = {properties:{checked:{type:Boolean, value:false, reflectToAttribute:true, notify:true, observer:"_checkedChanged"}, toggles:{type:Boolean, value:true, reflectToAttribute:true}, value:{type:String, value:"on", observer:"_valueChanged"}}, observers:["_requiredChanged(required)"], created:function() {
  this._hasIronCheckedElementBehavior = true;
}, _getValidity:function(_value) {
  return this.disabled || !this.required || this.required && this.checked;
}, _requiredChanged:function() {
  if (this.required) {
    this.setAttribute("aria-required", "true");
  } else {
    this.removeAttribute("aria-required");
  }
}, _checkedChanged:function() {
  this.active = this.checked;
  this.fire("iron-change");
}, _valueChanged:function() {
  if (this.value === undefined || this.value === null) {
    this.value = "on";
  }
}};
Polymer.IronCheckedElementBehavior = [Polymer.IronFormElementBehavior, Polymer.IronValidatableBehavior, Polymer.IronCheckedElementBehaviorImpl];
Polymer.PaperInkyFocusBehaviorImpl = {observers:["_focusedChanged(receivedFocusFromKeyboard)"], _focusedChanged:function(receivedFocusFromKeyboard) {
  if (receivedFocusFromKeyboard) {
    this.ensureRipple();
  }
  if (this.hasRipple()) {
    this._ripple.holdDown = receivedFocusFromKeyboard;
  }
}, _createRipple:function() {
  var ripple = Polymer.PaperRippleBehavior._createRipple();
  ripple.id = "ink";
  ripple.setAttribute("center", "");
  ripple.classList.add("circle");
  return ripple;
}};
Polymer.PaperInkyFocusBehavior = [Polymer.IronButtonState, Polymer.IronControlState, Polymer.PaperRippleBehavior, Polymer.PaperInkyFocusBehaviorImpl];
Polymer.PaperCheckedElementBehaviorImpl = {_checkedChanged:function() {
  Polymer.IronCheckedElementBehaviorImpl._checkedChanged.call(this);
  if (this.hasRipple()) {
    if (this.checked) {
      this._ripple.setAttribute("checked", "");
    } else {
      this._ripple.removeAttribute("checked");
    }
  }
}, _buttonStateChanged:function() {
  Polymer.PaperRippleBehavior._buttonStateChanged.call(this);
  if (this.disabled) {
    return;
  }
  if (this.isAttached) {
    this.checked = this.active;
  }
}};
Polymer.PaperCheckedElementBehavior = [Polymer.PaperInkyFocusBehavior, Polymer.IronCheckedElementBehavior, Polymer.PaperCheckedElementBehaviorImpl];
Polymer({is:"paper-checkbox", behaviors:[Polymer.PaperCheckedElementBehavior], hostAttributes:{role:"checkbox", "aria-checked":false, tabindex:0}, properties:{ariaActiveAttribute:{type:String, value:"aria-checked"}}, _computeCheckboxClass:function(checked, invalid) {
  var className = "";
  if (checked) {
    className += "checked ";
  }
  if (invalid) {
    className += "invalid";
  }
  return className;
}, _computeCheckmarkClass:function(checked) {
  return checked ? "" : "hidden";
}, _createRipple:function() {
  this._rippleContainer = this.$.checkboxContainer;
  return Polymer.PaperInkyFocusBehaviorImpl._createRipple.call(this);
}});
Polymer.PaperDialogBehaviorImpl = {hostAttributes:{"role":"dialog", "tabindex":"-1"}, properties:{modal:{type:Boolean, value:false}}, observers:["_modalChanged(modal, _readied)"], listeners:{"tap":"_onDialogClick"}, ready:function() {
  this.__prevNoCancelOnOutsideClick = this.noCancelOnOutsideClick;
  this.__prevNoCancelOnEscKey = this.noCancelOnEscKey;
  this.__prevWithBackdrop = this.withBackdrop;
}, _modalChanged:function(modal, readied) {
  if (modal) {
    this.setAttribute("aria-modal", "true");
  } else {
    this.setAttribute("aria-modal", "false");
  }
  if (!readied) {
    return;
  }
  if (modal) {
    this.__prevNoCancelOnOutsideClick = this.noCancelOnOutsideClick;
    this.__prevNoCancelOnEscKey = this.noCancelOnEscKey;
    this.__prevWithBackdrop = this.withBackdrop;
    this.noCancelOnOutsideClick = true;
    this.noCancelOnEscKey = true;
    this.withBackdrop = true;
  } else {
    this.noCancelOnOutsideClick = this.noCancelOnOutsideClick && this.__prevNoCancelOnOutsideClick;
    this.noCancelOnEscKey = this.noCancelOnEscKey && this.__prevNoCancelOnEscKey;
    this.withBackdrop = this.withBackdrop && this.__prevWithBackdrop;
  }
}, _updateClosingReasonConfirmed:function(confirmed) {
  this.closingReason = this.closingReason || {};
  this.closingReason.confirmed = confirmed;
}, _onDialogClick:function(event) {
  var path = Polymer.dom(event).path;
  for (var i = 0; i < path.indexOf(this); i++) {
    var target = path[i];
    if (target.hasAttribute && (target.hasAttribute("dialog-dismiss") || target.hasAttribute("dialog-confirm"))) {
      this._updateClosingReasonConfirmed(target.hasAttribute("dialog-confirm"));
      this.close();
      event.stopPropagation();
      break;
    }
  }
}};
Polymer.PaperDialogBehavior = [Polymer.IronOverlayBehavior, Polymer.PaperDialogBehaviorImpl];
(function() {
  Polymer({is:"paper-dialog", behaviors:[Polymer.PaperDialogBehavior, Polymer.NeonAnimationRunnerBehavior], listeners:{"neon-animation-finish":"_onNeonAnimationFinish"}, _renderOpened:function() {
    this.cancelAnimation();
    if (this.withBackdrop) {
      this.backdropElement.open();
    }
    this.playAnimation("entry");
  }, _renderClosed:function() {
    this.cancelAnimation();
    if (this.withBackdrop) {
      this.backdropElement.close();
    }
    this.playAnimation("exit");
  }, _onNeonAnimationFinish:function() {
    if (this.opened) {
      this._finishRenderOpened();
    } else {
      this._finishRenderClosed();
    }
  }});
})();
Polymer({is:"paper-dialog-scrollable", properties:{dialogElement:{type:Object}}, listeners:{"scrollable.scroll":"_scroll"}, get scrollTarget() {
  return this.$.scrollable;
}, ready:function() {
  this._ensureTarget();
}, attached:function() {
  this.classList.add("no-padding");
  this._ensureTarget();
  requestAnimationFrame(this._scroll.bind(this));
}, _scroll:function() {
  this.toggleClass("is-scrolled", this.scrollTarget.scrollTop > 0);
  this.toggleClass("can-scroll", this.scrollTarget.offsetHeight < this.scrollTarget.scrollHeight);
  this.toggleClass("scrolled-to-bottom", this.scrollTarget.scrollTop + this.scrollTarget.offsetHeight >= this.scrollTarget.scrollHeight);
}, _ensureTarget:function() {
  this.dialogElement = this.dialogElement || Polymer.dom(this).parentNode;
  if (this.dialogElement && this.dialogElement.behaviors && this.dialogElement.behaviors.indexOf(Polymer.PaperDialogBehaviorImpl) >= 0) {
    this.dialogElement.sizingTarget = this.scrollTarget;
    this.scrollTarget.classList.remove("fit");
  } else {
    if (this.dialogElement) {
      this.scrollTarget.classList.add("fit");
    }
  }
}});
(function() {
  var sharedPanel = null;
  function classNames(obj) {
    var classes = [];
    for (var key in obj) {
      if (obj.hasOwnProperty(key) && obj[key]) {
        classes.push(key);
      }
    }
    return classes.join(" ");
  }
  Polymer({is:"paper-drawer-panel", behaviors:[Polymer.IronResizableBehavior], properties:{defaultSelected:{type:String, value:"main"}, disableEdgeSwipe:{type:Boolean, value:false}, disableSwipe:{type:Boolean, value:false}, dragging:{type:Boolean, value:false, readOnly:true, notify:true}, drawerWidth:{type:String, value:"256px"}, edgeSwipeSensitivity:{type:Number, value:30}, forceNarrow:{type:Boolean, value:false}, hasTransform:{type:Boolean, value:function() {
    return "transform" in this.style;
  }}, hasWillChange:{type:Boolean, value:function() {
    return "willChange" in this.style;
  }}, narrow:{reflectToAttribute:true, type:Boolean, value:false, readOnly:true, notify:true}, peeking:{type:Boolean, value:false, readOnly:true, notify:true}, responsiveWidth:{type:String, value:"600px"}, rightDrawer:{type:Boolean, value:false}, selected:{reflectToAttribute:true, notify:true, type:String, value:null}, drawerToggleAttribute:{type:String, value:"paper-drawer-toggle"}, drawerFocusSelector:{type:String, value:'a[href]:not([tabindex="-1"]),' + 'area[href]:not([tabindex="-1"]),' + 'input:not([disabled]):not([tabindex="-1"]),' + 
  'select:not([disabled]):not([tabindex="-1"]),' + 'textarea:not([disabled]):not([tabindex="-1"]),' + 'button:not([disabled]):not([tabindex="-1"]),' + 'iframe:not([tabindex="-1"]),' + '[tabindex]:not([tabindex="-1"]),' + '[contentEditable=true]:not([tabindex="-1"])'}, _transition:{type:Boolean, value:false}}, listeners:{tap:"_onTap", track:"_onTrack", down:"_downHandler", up:"_upHandler", transitionend:"_onTransitionEnd"}, observers:["_forceNarrowChanged(forceNarrow, defaultSelected)", "_toggleFocusListener(selected)"], 
  ready:function() {
    this._transition = true;
    this._boundFocusListener = this._didFocus.bind(this);
  }, togglePanel:function() {
    if (this._isMainSelected()) {
      this.openDrawer();
    } else {
      this.closeDrawer();
    }
  }, openDrawer:function() {
    this.selected = "drawer";
  }, closeDrawer:function() {
    this.selected = "main";
  }, _onTransitionEnd:function(e) {
    var target = Polymer.dom(e).localTarget;
    if (target !== this) {
      return;
    }
    if (e.propertyName === "left" || e.propertyName === "right") {
      this.notifyResize();
    }
    if (e.propertyName === "transform" && this.selected === "drawer") {
      var focusedChild = this._getAutoFocusedNode();
      focusedChild && focusedChild.focus();
    }
  }, _computeIronSelectorClass:function(narrow, transition, dragging, rightDrawer, peeking) {
    return classNames({dragging:dragging, "narrow-layout":narrow, "right-drawer":rightDrawer, "left-drawer":!rightDrawer, transition:transition, peeking:peeking});
  }, _computeDrawerStyle:function(drawerWidth) {
    return "width:" + drawerWidth + ";";
  }, _computeMainStyle:function(narrow, rightDrawer, drawerWidth) {
    var style = "";
    style += "left:" + (narrow || rightDrawer ? "0" : drawerWidth) + ";";
    if (rightDrawer) {
      style += "right:" + (narrow ? "" : drawerWidth) + ";";
    }
    return style;
  }, _computeMediaQuery:function(forceNarrow, responsiveWidth) {
    return forceNarrow ? "" : "(max-width: " + responsiveWidth + ")";
  }, _computeSwipeOverlayHidden:function(narrow, disableEdgeSwipe) {
    return !narrow || disableEdgeSwipe;
  }, _onTrack:function(event) {
    if (sharedPanel && this !== sharedPanel) {
      return;
    }
    switch(event.detail.state) {
      case "start":
        this._trackStart(event);
        break;
      case "track":
        this._trackX(event);
        break;
      case "end":
        this._trackEnd(event);
        break;
    }
  }, _responsiveChange:function(narrow) {
    this._setNarrow(narrow);
    this.selected = this.narrow ? this.defaultSelected : null;
    this.setScrollDirection(this._swipeAllowed() ? "y" : "all");
    this.fire("paper-responsive-change", {narrow:this.narrow});
  }, _onQueryMatchesChanged:function(event) {
    this._responsiveChange(event.detail.value);
  }, _forceNarrowChanged:function() {
    this._responsiveChange(this.forceNarrow || this.$.mq.queryMatches);
  }, _swipeAllowed:function() {
    return this.narrow && !this.disableSwipe;
  }, _isMainSelected:function() {
    return this.selected === "main";
  }, _startEdgePeek:function() {
    this.width = this.$.drawer.offsetWidth;
    this._moveDrawer(this._translateXForDeltaX(this.rightDrawer ? -this.edgeSwipeSensitivity : this.edgeSwipeSensitivity));
    this._setPeeking(true);
  }, _stopEdgePeek:function() {
    if (this.peeking) {
      this._setPeeking(false);
      this._moveDrawer(null);
    }
  }, _downHandler:function(event) {
    if (!this.dragging && this._isMainSelected() && this._isEdgeTouch(event) && !sharedPanel) {
      this._startEdgePeek();
      event.preventDefault();
      sharedPanel = this;
    }
  }, _upHandler:function() {
    this._stopEdgePeek();
    sharedPanel = null;
  }, _onTap:function(event) {
    var targetElement = Polymer.dom(event).localTarget;
    var isTargetToggleElement = targetElement && this.drawerToggleAttribute && targetElement.hasAttribute(this.drawerToggleAttribute);
    if (isTargetToggleElement) {
      this.togglePanel();
    }
  }, _isEdgeTouch:function(event) {
    var x = event.detail.x;
    return !this.disableEdgeSwipe && this._swipeAllowed() && (this.rightDrawer ? x >= this.offsetWidth - this.edgeSwipeSensitivity : x <= this.edgeSwipeSensitivity);
  }, _trackStart:function(event) {
    if (this._swipeAllowed()) {
      sharedPanel = this;
      this._setDragging(true);
      if (this._isMainSelected()) {
        this._setDragging(this.peeking || this._isEdgeTouch(event));
      }
      if (this.dragging) {
        this.width = this.$.drawer.offsetWidth;
        this._transition = false;
      }
    }
  }, _translateXForDeltaX:function(deltaX) {
    var isMain = this._isMainSelected();
    if (this.rightDrawer) {
      return Math.max(0, isMain ? this.width + deltaX : deltaX);
    } else {
      return Math.min(0, isMain ? deltaX - this.width : deltaX);
    }
  }, _trackX:function(event) {
    if (this.dragging) {
      var dx = event.detail.dx;
      if (this.peeking) {
        if (Math.abs(dx) <= this.edgeSwipeSensitivity) {
          return;
        }
        this._setPeeking(false);
      }
      this._moveDrawer(this._translateXForDeltaX(dx));
    }
  }, _trackEnd:function(event) {
    if (this.dragging) {
      var xDirection = event.detail.dx > 0;
      this._setDragging(false);
      this._transition = true;
      sharedPanel = null;
      this._moveDrawer(null);
      if (this.rightDrawer) {
        this[xDirection ? "closeDrawer" : "openDrawer"]();
      } else {
        this[xDirection ? "openDrawer" : "closeDrawer"]();
      }
    }
  }, _transformForTranslateX:function(translateX) {
    if (translateX === null) {
      return "";
    }
    return this.hasWillChange ? "translateX(" + translateX + "px)" : "translate3d(" + translateX + "px, 0, 0)";
  }, _moveDrawer:function(translateX) {
    this.transform(this._transformForTranslateX(translateX), this.$.drawer);
  }, _getDrawerContent:function() {
    return Polymer.dom(this.$.drawerContent).getDistributedNodes()[0];
  }, _getAutoFocusedNode:function() {
    var drawerContent = this._getDrawerContent();
    return this.drawerFocusSelector ? Polymer.dom(drawerContent).querySelector(this.drawerFocusSelector) || drawerContent : null;
  }, _toggleFocusListener:function(selected) {
    if (selected === "drawer") {
      this.addEventListener("focus", this._boundFocusListener, true);
    } else {
      this.removeEventListener("focus", this._boundFocusListener, true);
    }
  }, _didFocus:function(event) {
    var autoFocusedNode = this._getAutoFocusedNode();
    if (!autoFocusedNode) {
      return;
    }
    var path = Polymer.dom(event).path;
    var focusedChild = path[0];
    var drawerContent = this._getDrawerContent();
    var focusedChildCameFromDrawer = path.indexOf(drawerContent) !== -1;
    if (!focusedChildCameFromDrawer) {
      event.stopPropagation();
      autoFocusedNode.focus();
    }
  }, _isDrawerClosed:function(narrow, selected) {
    return !narrow || selected !== "drawer";
  }});
})();
Polymer({is:"paper-fab", behaviors:[Polymer.PaperButtonBehavior], properties:{src:{type:String, value:""}, icon:{type:String, value:""}, mini:{type:Boolean, value:false, reflectToAttribute:true}, label:{type:String, observer:"_labelChanged"}}, _labelChanged:function() {
  this.setAttribute("aria-label", this.label);
}, _computeIsIconFab:function(icon, src) {
  return icon.length > 0 || src.length > 0;
}});
Polymer.PaperInputHelper = {};
Polymer.PaperInputHelper.NextLabelID = 1;
Polymer.PaperInputHelper.NextAddonID = 1;
Polymer.PaperInputBehaviorImpl = {properties:{label:{type:String}, value:{notify:true, type:String}, disabled:{type:Boolean, value:false}, invalid:{type:Boolean, value:false, notify:true}, preventInvalidInput:{type:Boolean}, allowedPattern:{type:String}, type:{type:String}, list:{type:String}, pattern:{type:String}, required:{type:Boolean, value:false}, errorMessage:{type:String}, charCounter:{type:Boolean, value:false}, noLabelFloat:{type:Boolean, value:false}, alwaysFloatLabel:{type:Boolean, value:false}, 
autoValidate:{type:Boolean, value:false}, validator:{type:String}, autocomplete:{type:String, value:"off"}, autofocus:{type:Boolean}, inputmode:{type:String}, minlength:{type:Number}, maxlength:{type:Number}, min:{type:String}, max:{type:String}, step:{type:String}, name:{type:String}, placeholder:{type:String, value:""}, readonly:{type:Boolean, value:false}, size:{type:Number}, autocapitalize:{type:String, value:"none"}, autocorrect:{type:String, value:"off"}, autosave:{type:String}, results:{type:Number}, 
accept:{type:String}, multiple:{type:Boolean}, _ariaDescribedBy:{type:String, value:""}, _ariaLabelledBy:{type:String, value:""}}, listeners:{"addon-attached":"_onAddonAttached"}, keyBindings:{"shift+tab:keydown":"_onShiftTabDown"}, hostAttributes:{tabindex:0}, get inputElement() {
  return this.$.input;
}, get _focusableElement() {
  return this.inputElement;
}, registered:function() {
  this._typesThatHaveText = ["date", "datetime", "datetime-local", "month", "time", "week", "file"];
}, attached:function() {
  this._updateAriaLabelledBy();
  if (this.inputElement && this._typesThatHaveText.indexOf(this.inputElement.type) !== -1) {
    this.alwaysFloatLabel = true;
  }
}, _appendStringWithSpace:function(str, more) {
  if (str) {
    str = str + " " + more;
  } else {
    str = more;
  }
  return str;
}, _onAddonAttached:function(event) {
  var target = event.path ? event.path[0] : event.target;
  if (target.id) {
    this._ariaDescribedBy = this._appendStringWithSpace(this._ariaDescribedBy, target.id);
  } else {
    var id = "paper-input-add-on-" + Polymer.PaperInputHelper.NextAddonID++;
    target.id = id;
    this._ariaDescribedBy = this._appendStringWithSpace(this._ariaDescribedBy, id);
  }
}, validate:function() {
  return this.inputElement.validate();
}, _focusBlurHandler:function(event) {
  if (this._shiftTabPressed) {
    return;
  }
  Polymer.IronControlState._focusBlurHandler.call(this, event);
  if (this.focused) {
    this._focusableElement.focus();
  }
}, _onShiftTabDown:function(event) {
  var oldTabIndex = this.getAttribute("tabindex");
  this._shiftTabPressed = true;
  this.setAttribute("tabindex", "-1");
  this.async(function() {
    this.setAttribute("tabindex", oldTabIndex);
    this._shiftTabPressed = false;
  }, 1);
}, _handleAutoValidate:function() {
  if (this.autoValidate) {
    this.validate();
  }
}, updateValueAndPreserveCaret:function(newValue) {
  try {
    var start = this.inputElement.selectionStart;
    this.value = newValue;
    this.inputElement.selectionStart = start;
    this.inputElement.selectionEnd = start;
  } catch (e) {
    this.value = newValue;
  }
}, _computeAlwaysFloatLabel:function(alwaysFloatLabel, placeholder) {
  return placeholder || alwaysFloatLabel;
}, _updateAriaLabelledBy:function() {
  var label = Polymer.dom(this.root).querySelector("label");
  if (!label) {
    this._ariaLabelledBy = "";
    return;
  }
  var labelledBy;
  if (label.id) {
    labelledBy = label.id;
  } else {
    labelledBy = "paper-input-label-" + Polymer.PaperInputHelper.NextLabelID++;
    label.id = labelledBy;
  }
  this._ariaLabelledBy = labelledBy;
}, _onChange:function(event) {
  if (this.shadowRoot) {
    this.fire(event.type, {sourceEvent:event}, {node:this, bubbles:event.bubbles, cancelable:event.cancelable});
  }
}};
Polymer.PaperInputBehavior = [Polymer.IronControlState, Polymer.IronA11yKeysBehavior, Polymer.PaperInputBehaviorImpl];
Polymer.PaperInputAddonBehavior = {hostAttributes:{"add-on":""}, attached:function() {
  this.fire("addon-attached");
}, update:function(state) {
}};
Polymer({is:"paper-input-char-counter", behaviors:[Polymer.PaperInputAddonBehavior], properties:{_charCounterStr:{type:String, value:"0"}}, update:function(state) {
  if (!state.inputElement) {
    return;
  }
  state.value = state.value || "";
  var counter = state.value.length.toString();
  if (state.inputElement.hasAttribute("maxlength")) {
    counter += "/" + state.inputElement.getAttribute("maxlength");
  }
  this._charCounterStr = counter;
}});
Polymer({is:"paper-input-container", properties:{noLabelFloat:{type:Boolean, value:false}, alwaysFloatLabel:{type:Boolean, value:false}, attrForValue:{type:String, value:"bind-value"}, autoValidate:{type:Boolean, value:false}, invalid:{observer:"_invalidChanged", type:Boolean, value:false}, focused:{readOnly:true, type:Boolean, value:false, notify:true}, _addons:{type:Array}, _inputHasContent:{type:Boolean, value:false}, _inputSelector:{type:String, value:"input,textarea,.paper-input-input"}, _boundOnFocus:{type:Function, 
value:function() {
  return this._onFocus.bind(this);
}}, _boundOnBlur:{type:Function, value:function() {
  return this._onBlur.bind(this);
}}, _boundOnInput:{type:Function, value:function() {
  return this._onInput.bind(this);
}}, _boundValueChanged:{type:Function, value:function() {
  return this._onValueChanged.bind(this);
}}}, listeners:{"addon-attached":"_onAddonAttached", "iron-input-validate":"_onIronInputValidate"}, get _valueChangedEvent() {
  return this.attrForValue + "-changed";
}, get _propertyForValue() {
  return Polymer.CaseMap.dashToCamelCase(this.attrForValue);
}, get _inputElement() {
  return Polymer.dom(this).querySelector(this._inputSelector);
}, get _inputElementValue() {
  return this._inputElement[this._propertyForValue] || this._inputElement.value;
}, ready:function() {
  if (!this._addons) {
    this._addons = [];
  }
  this.addEventListener("focus", this._boundOnFocus, true);
  this.addEventListener("blur", this._boundOnBlur, true);
}, attached:function() {
  if (this.attrForValue) {
    this._inputElement.addEventListener(this._valueChangedEvent, this._boundValueChanged);
  } else {
    this.addEventListener("input", this._onInput);
  }
  if (this._inputElementValue != "") {
    this._handleValueAndAutoValidate(this._inputElement);
  } else {
    this._handleValue(this._inputElement);
  }
}, _onAddonAttached:function(event) {
  if (!this._addons) {
    this._addons = [];
  }
  var target = event.target;
  if (this._addons.indexOf(target) === -1) {
    this._addons.push(target);
    if (this.isAttached) {
      this._handleValue(this._inputElement);
    }
  }
}, _onFocus:function() {
  this._setFocused(true);
}, _onBlur:function() {
  this._setFocused(false);
  this._handleValueAndAutoValidate(this._inputElement);
}, _onInput:function(event) {
  this._handleValueAndAutoValidate(event.target);
}, _onValueChanged:function(event) {
  this._handleValueAndAutoValidate(event.target);
}, _handleValue:function(inputElement) {
  var value = this._inputElementValue;
  if (value || value === 0 || inputElement.type === "number" && !inputElement.checkValidity()) {
    this._inputHasContent = true;
  } else {
    this._inputHasContent = false;
  }
  this.updateAddons({inputElement:inputElement, value:value, invalid:this.invalid});
}, _handleValueAndAutoValidate:function(inputElement) {
  if (this.autoValidate) {
    var valid;
    if (inputElement.validate) {
      valid = inputElement.validate(this._inputElementValue);
    } else {
      valid = inputElement.checkValidity();
    }
    this.invalid = !valid;
  }
  this._handleValue(inputElement);
}, _onIronInputValidate:function(event) {
  this.invalid = this._inputElement.invalid;
}, _invalidChanged:function() {
  if (this._addons) {
    this.updateAddons({invalid:this.invalid});
  }
}, updateAddons:function(state) {
  for (var addon, index = 0; addon = this._addons[index]; index++) {
    addon.update(state);
  }
}, _computeInputContentClass:function(noLabelFloat, alwaysFloatLabel, focused, invalid, _inputHasContent) {
  var cls = "input-content";
  if (!noLabelFloat) {
    var label = this.querySelector("label");
    if (alwaysFloatLabel || _inputHasContent) {
      cls += " label-is-floating";
      this.$.labelAndInputContainer.style.position = "static";
      if (invalid) {
        cls += " is-invalid";
      } else {
        if (focused) {
          cls += " label-is-highlighted";
        }
      }
    } else {
      if (label) {
        this.$.labelAndInputContainer.style.position = "relative";
      }
    }
  } else {
    if (_inputHasContent) {
      cls += " label-is-hidden";
    }
  }
  return cls;
}, _computeUnderlineClass:function(focused, invalid) {
  var cls = "underline";
  if (invalid) {
    cls += " is-invalid";
  } else {
    if (focused) {
      cls += " is-highlighted";
    }
  }
  return cls;
}, _computeAddOnContentClass:function(focused, invalid) {
  var cls = "add-on-content";
  if (invalid) {
    cls += " is-invalid";
  } else {
    if (focused) {
      cls += " is-highlighted";
    }
  }
  return cls;
}});
Polymer({is:"paper-input-error", behaviors:[Polymer.PaperInputAddonBehavior], properties:{invalid:{readOnly:true, reflectToAttribute:true, type:Boolean}}, update:function(state) {
  this._setInvalid(state.invalid);
}});
Polymer({is:"paper-input", behaviors:[Polymer.IronFormElementBehavior, Polymer.PaperInputBehavior]});
(function() {
  Polymer.IronDropdownScrollManager = {get currentLockingElement() {
    return this._lockingElements[this._lockingElements.length - 1];
  }, elementIsScrollLocked:function(element) {
    var currentLockingElement = this.currentLockingElement;
    if (currentLockingElement === undefined) {
      return false;
    }
    var scrollLocked;
    if (this._hasCachedLockedElement(element)) {
      return true;
    }
    if (this._hasCachedUnlockedElement(element)) {
      return false;
    }
    scrollLocked = !!currentLockingElement && currentLockingElement !== element && !this._composedTreeContains(currentLockingElement, element);
    if (scrollLocked) {
      this._lockedElementCache.push(element);
    } else {
      this._unlockedElementCache.push(element);
    }
    return scrollLocked;
  }, pushScrollLock:function(element) {
    if (this._lockingElements.indexOf(element) >= 0) {
      return;
    }
    if (this._lockingElements.length === 0) {
      this._lockScrollInteractions();
    }
    this._lockingElements.push(element);
    this._lockedElementCache = [];
    this._unlockedElementCache = [];
  }, removeScrollLock:function(element) {
    var index = this._lockingElements.indexOf(element);
    if (index === -1) {
      return;
    }
    this._lockingElements.splice(index, 1);
    this._lockedElementCache = [];
    this._unlockedElementCache = [];
    if (this._lockingElements.length === 0) {
      this._unlockScrollInteractions();
    }
  }, _lockingElements:[], _lockedElementCache:null, _unlockedElementCache:null, _originalBodyStyles:{}, _isScrollingKeypress:function(event) {
    return Polymer.IronA11yKeysBehavior.keyboardEventMatchesKeys(event, "pageup pagedown home end up left down right");
  }, _hasCachedLockedElement:function(element) {
    return this._lockedElementCache.indexOf(element) > -1;
  }, _hasCachedUnlockedElement:function(element) {
    return this._unlockedElementCache.indexOf(element) > -1;
  }, _composedTreeContains:function(element, child) {
    var contentElements;
    var distributedNodes;
    var contentIndex;
    var nodeIndex;
    if (element.contains(child)) {
      return true;
    }
    contentElements = Polymer.dom(element).querySelectorAll("content");
    for (contentIndex = 0; contentIndex < contentElements.length; ++contentIndex) {
      distributedNodes = Polymer.dom(contentElements[contentIndex]).getDistributedNodes();
      for (nodeIndex = 0; nodeIndex < distributedNodes.length; ++nodeIndex) {
        if (this._composedTreeContains(distributedNodes[nodeIndex], child)) {
          return true;
        }
      }
    }
    return false;
  }, _scrollInteractionHandler:function(event) {
    var scrolledElement = Polymer.dom(event).rootTarget;
    if (Polymer.IronDropdownScrollManager.elementIsScrollLocked(scrolledElement)) {
      if (event.type === "keydown" && !Polymer.IronDropdownScrollManager._isScrollingKeypress(event)) {
        return;
      }
      event.preventDefault();
    }
  }, _lockScrollInteractions:function() {
    this._originalBodyStyles.overflow = document.body.style.overflow;
    this._originalBodyStyles.overflowX = document.body.style.overflowX;
    this._originalBodyStyles.overflowY = document.body.style.overflowY;
    document.body.style.overflow = "hidden";
    document.body.style.overflowX = "hidden";
    document.body.style.overflowY = "hidden";
    document.addEventListener("wheel", this._scrollInteractionHandler, true);
    document.addEventListener("mousewheel", this._scrollInteractionHandler, true);
    document.addEventListener("DOMMouseScroll", this._scrollInteractionHandler, true);
    document.addEventListener("touchmove", this._scrollInteractionHandler, true);
    document.addEventListener("keydown", this._scrollInteractionHandler, true);
  }, _unlockScrollInteractions:function() {
    document.body.style.overflow = this._originalBodyStyles.overflow;
    document.body.style.overflowX = this._originalBodyStyles.overflowX;
    document.body.style.overflowY = this._originalBodyStyles.overflowY;
    document.removeEventListener("wheel", this._scrollInteractionHandler, true);
    document.removeEventListener("mousewheel", this._scrollInteractionHandler, true);
    document.removeEventListener("DOMMouseScroll", this._scrollInteractionHandler, true);
    document.removeEventListener("touchmove", this._scrollInteractionHandler, true);
    document.removeEventListener("keydown", this._scrollInteractionHandler, true);
  }};
})();
(function() {
  Polymer({is:"iron-dropdown", behaviors:[Polymer.IronControlState, Polymer.IronA11yKeysBehavior, Polymer.IronOverlayBehavior, Polymer.NeonAnimationRunnerBehavior], properties:{horizontalAlign:{type:String, value:"left", reflectToAttribute:true}, verticalAlign:{type:String, value:"top", reflectToAttribute:true}, openAnimationConfig:{type:Object}, closeAnimationConfig:{type:Object}, focusTarget:{type:Object}, noAnimations:{type:Boolean, value:false}, allowOutsideScroll:{type:Boolean, value:false}}, 
  listeners:{"neon-animation-finish":"_onNeonAnimationFinish"}, observers:["_updateOverlayPosition(positionTarget, verticalAlign, horizontalAlign, verticalOffset, horizontalOffset)"], get containedElement() {
    return Polymer.dom(this.$.content).getDistributedNodes()[0];
  }, get _focusTarget() {
    return this.focusTarget || this.containedElement;
  }, detached:function() {
    this.cancelAnimation();
    Polymer.IronDropdownScrollManager.removeScrollLock(this);
  }, _openedChanged:function() {
    if (this.opened && this.disabled) {
      this.cancel();
    } else {
      this.cancelAnimation();
      this.sizingTarget = this.containedElement || this.sizingTarget;
      this._updateAnimationConfig();
      if (this.opened && !this.allowOutsideScroll) {
        Polymer.IronDropdownScrollManager.pushScrollLock(this);
      } else {
        Polymer.IronDropdownScrollManager.removeScrollLock(this);
      }
      Polymer.IronOverlayBehaviorImpl._openedChanged.apply(this, arguments);
    }
  }, _renderOpened:function() {
    if (!this.noAnimations && this.animationConfig.open) {
      this.$.contentWrapper.classList.add("animating");
      this.playAnimation("open");
    } else {
      Polymer.IronOverlayBehaviorImpl._renderOpened.apply(this, arguments);
    }
  }, _renderClosed:function() {
    if (!this.noAnimations && this.animationConfig.close) {
      this.$.contentWrapper.classList.add("animating");
      this.playAnimation("close");
    } else {
      Polymer.IronOverlayBehaviorImpl._renderClosed.apply(this, arguments);
    }
  }, _onNeonAnimationFinish:function() {
    this.$.contentWrapper.classList.remove("animating");
    if (this.opened) {
      this._finishRenderOpened();
    } else {
      this._finishRenderClosed();
    }
  }, _updateAnimationConfig:function() {
    var animations = (this.openAnimationConfig || []).concat(this.closeAnimationConfig || []);
    for (var i = 0; i < animations.length; i++) {
      animations[i].node = this.containedElement;
    }
    this.animationConfig = {open:this.openAnimationConfig, close:this.closeAnimationConfig};
  }, _updateOverlayPosition:function() {
    if (this.isAttached) {
      this.notifyResize();
    }
  }, _applyFocus:function() {
    var focusTarget = this.focusTarget || this.containedElement;
    if (focusTarget && this.opened && !this.noAutoFocus) {
      focusTarget.focus();
    } else {
      Polymer.IronOverlayBehaviorImpl._applyFocus.apply(this, arguments);
    }
  }});
})();
Polymer({is:"paper-menu-grow-height-animation", behaviors:[Polymer.NeonAnimationBehavior], configure:function(config) {
  var node = config.node;
  var rect = node.getBoundingClientRect();
  var height = rect.height;
  this._effect = new KeyframeEffect(node, [{height:height / 2 + "px"}, {height:height + "px"}], this.timingFromConfig(config));
  return this._effect;
}});
Polymer({is:"paper-menu-grow-width-animation", behaviors:[Polymer.NeonAnimationBehavior], configure:function(config) {
  var node = config.node;
  var rect = node.getBoundingClientRect();
  var width = rect.width;
  this._effect = new KeyframeEffect(node, [{width:width / 2 + "px"}, {width:width + "px"}], this.timingFromConfig(config));
  return this._effect;
}});
Polymer({is:"paper-menu-shrink-width-animation", behaviors:[Polymer.NeonAnimationBehavior], configure:function(config) {
  var node = config.node;
  var rect = node.getBoundingClientRect();
  var width = rect.width;
  this._effect = new KeyframeEffect(node, [{width:width + "px"}, {width:width - width / 20 + "px"}], this.timingFromConfig(config));
  return this._effect;
}});
Polymer({is:"paper-menu-shrink-height-animation", behaviors:[Polymer.NeonAnimationBehavior], configure:function(config) {
  var node = config.node;
  var rect = node.getBoundingClientRect();
  var height = rect.height;
  var top = rect.top;
  this.setPrefixedProperty(node, "transformOrigin", "0 0");
  this._effect = new KeyframeEffect(node, [{height:height + "px", transform:"translateY(0)"}, {height:height / 2 + "px", transform:"translateY(-20px)"}], this.timingFromConfig(config));
  return this._effect;
}});
(function() {
  var PaperMenuButton = Polymer({is:"paper-menu-button", behaviors:[Polymer.IronA11yKeysBehavior, Polymer.IronControlState], properties:{opened:{type:Boolean, value:false, notify:true, observer:"_openedChanged"}, horizontalAlign:{type:String, value:"left", reflectToAttribute:true}, verticalAlign:{type:String, value:"top", reflectToAttribute:true}, horizontalOffset:{type:Number, value:0, notify:true}, verticalOffset:{type:Number, value:0, notify:true}, noAnimations:{type:Boolean, value:false}, ignoreSelect:{type:Boolean, 
  value:false}, openAnimationConfig:{type:Object, value:function() {
    return [{name:"fade-in-animation", timing:{delay:100, duration:200}}, {name:"paper-menu-grow-width-animation", timing:{delay:100, duration:150, easing:PaperMenuButton.ANIMATION_CUBIC_BEZIER}}, {name:"paper-menu-grow-height-animation", timing:{delay:100, duration:275, easing:PaperMenuButton.ANIMATION_CUBIC_BEZIER}}];
  }}, closeAnimationConfig:{type:Object, value:function() {
    return [{name:"fade-out-animation", timing:{duration:150}}, {name:"paper-menu-shrink-width-animation", timing:{delay:100, duration:50, easing:PaperMenuButton.ANIMATION_CUBIC_BEZIER}}, {name:"paper-menu-shrink-height-animation", timing:{duration:200, easing:"ease-in"}}];
  }}, _dropdownContent:{type:Object}}, hostAttributes:{role:"group", "aria-haspopup":"true"}, listeners:{"iron-select":"_onIronSelect"}, get contentElement() {
    return Polymer.dom(this.$.content).getDistributedNodes()[0];
  }, toggle:function() {
    if (this.opened) {
      this.close();
    } else {
      this.open();
    }
  }, open:function() {
    if (this.disabled) {
      return;
    }
    this.$.dropdown.open();
  }, close:function() {
    this.$.dropdown.close();
  }, _onIronSelect:function(event) {
    if (!this.ignoreSelect) {
      this.close();
    }
  }, _openedChanged:function(opened, oldOpened) {
    if (opened) {
      this._dropdownContent = this.contentElement;
      this.fire("paper-dropdown-open");
    } else {
      if (oldOpened != null) {
        this.fire("paper-dropdown-close");
      }
    }
  }, _disabledChanged:function(disabled) {
    Polymer.IronControlState._disabledChanged.apply(this, arguments);
    if (disabled && this.opened) {
      this.close();
    }
  }, __onIronOverlayCanceled:function(event) {
    var uiEvent = event.detail;
    var target = Polymer.dom(uiEvent).rootTarget;
    var trigger = this.$.trigger;
    var path = Polymer.dom(uiEvent).path;
    if (path.indexOf(trigger) > -1) {
      event.preventDefault();
    }
  }});
  PaperMenuButton.ANIMATION_CUBIC_BEZIER = "cubic-bezier(.3,.95,.5,1)";
  PaperMenuButton.MAX_ANIMATION_TIME_MS = 400;
  Polymer.PaperMenuButton = PaperMenuButton;
})();
(function() {
  Polymer({is:"paper-dropdown-menu", behaviors:[Polymer.IronButtonState, Polymer.IronControlState, Polymer.IronFormElementBehavior, Polymer.IronValidatableBehavior], properties:{selectedItemLabel:{type:String, notify:true, readOnly:true}, selectedItem:{type:Object, notify:true, readOnly:true}, value:{type:String, notify:true, readOnly:true}, label:{type:String}, placeholder:{type:String}, errorMessage:{type:String}, opened:{type:Boolean, notify:true, value:false, observer:"_openedChanged"}, noLabelFloat:{type:Boolean, 
  value:false, reflectToAttribute:true}, alwaysFloatLabel:{type:Boolean, value:false}, noAnimations:{type:Boolean, value:false}, horizontalAlign:{type:String, value:"right"}, verticalAlign:{type:String, value:"top"}}, listeners:{"tap":"_onTap"}, keyBindings:{"up down":"open", "esc":"close"}, hostAttributes:{role:"combobox", "aria-autocomplete":"none", "aria-haspopup":"true"}, observers:["_selectedItemChanged(selectedItem)"], attached:function() {
    var contentElement = this.contentElement;
    if (contentElement && contentElement.selectedItem) {
      this._setSelectedItem(contentElement.selectedItem);
    }
  }, get contentElement() {
    return Polymer.dom(this.$.content).getDistributedNodes()[0];
  }, open:function() {
    this.$.menuButton.open();
  }, close:function() {
    this.$.menuButton.close();
  }, _onIronSelect:function(event) {
    this._setSelectedItem(event.detail.item);
  }, _onIronDeselect:function(event) {
    this._setSelectedItem(null);
  }, _onTap:function(event) {
    if (Polymer.Gestures.findOriginalTarget(event) === this) {
      this.open();
    }
  }, _selectedItemChanged:function(selectedItem) {
    var value = "";
    if (!selectedItem) {
      value = "";
    } else {
      value = selectedItem.label || selectedItem.textContent.trim();
    }
    this._setValue(value);
    this._setSelectedItemLabel(value);
  }, _computeMenuVerticalOffset:function(noLabelFloat) {
    return noLabelFloat ? -4 : 8;
  }, _getValidity:function(_value) {
    return this.disabled || !this.required || this.required && !!this.value;
  }, _openedChanged:function() {
    var openState = this.opened ? "true" : "false";
    var e = this.contentElement;
    if (e) {
      e.setAttribute("aria-expanded", openState);
    }
  }});
})();
(function() {
  var SHADOW_WHEN_SCROLLING = 1;
  var SHADOW_ALWAYS = 2;
  var MODE_CONFIGS = {outerScroll:{"scroll":true}, shadowMode:{"standard":SHADOW_ALWAYS, "waterfall":SHADOW_WHEN_SCROLLING, "waterfall-tall":SHADOW_WHEN_SCROLLING}, tallMode:{"waterfall-tall":true}};
  Polymer({is:"paper-header-panel", properties:{mode:{type:String, value:"standard", observer:"_modeChanged", reflectToAttribute:true}, shadow:{type:Boolean, value:false}, tallClass:{type:String, value:"tall"}, atTop:{type:Boolean, value:true, notify:true, readOnly:true, reflectToAttribute:true}}, observers:["_computeDropShadowHidden(atTop, mode, shadow)"], ready:function() {
    this.scrollHandler = this._scroll.bind(this);
  }, attached:function() {
    this._addListener();
    this._keepScrollingState();
  }, detached:function() {
    this._removeListener();
  }, get header() {
    return Polymer.dom(this.$.headerContent).getDistributedNodes()[0];
  }, get scroller() {
    return this._getScrollerForMode(this.mode);
  }, get visibleShadow() {
    return this.$.dropShadow.classList.contains("has-shadow");
  }, _computeDropShadowHidden:function(atTop, mode, shadow) {
    var shadowMode = MODE_CONFIGS.shadowMode[mode];
    if (this.shadow) {
      this.toggleClass("has-shadow", true, this.$.dropShadow);
    } else {
      if (shadowMode === SHADOW_ALWAYS) {
        this.toggleClass("has-shadow", true, this.$.dropShadow);
      } else {
        if (shadowMode === SHADOW_WHEN_SCROLLING && !atTop) {
          this.toggleClass("has-shadow", true, this.$.dropShadow);
        } else {
          this.toggleClass("has-shadow", false, this.$.dropShadow);
        }
      }
    }
  }, _computeMainContainerClass:function(mode) {
    var classes = {};
    classes["flex"] = mode !== "cover";
    return Object.keys(classes).filter(function(className) {
      return classes[className];
    }).join(" ");
  }, _addListener:function() {
    this.scroller.addEventListener("scroll", this.scrollHandler, false);
  }, _removeListener:function() {
    this.scroller.removeEventListener("scroll", this.scrollHandler);
  }, _modeChanged:function(newMode, oldMode) {
    var configs = MODE_CONFIGS;
    var header = this.header;
    var animateDuration = 200;
    if (header) {
      if (configs.tallMode[oldMode] && !configs.tallMode[newMode]) {
        header.classList.remove(this.tallClass);
        this.async(function() {
          header.classList.remove("animate");
        }, animateDuration);
      } else {
        this.toggleClass("animate", configs.tallMode[newMode], header);
      }
    }
    this._keepScrollingState();
  }, _keepScrollingState:function() {
    var main = this.scroller;
    var header = this.header;
    this._setAtTop(main.scrollTop === 0);
    if (header && this.tallClass && MODE_CONFIGS.tallMode[this.mode]) {
      this.toggleClass(this.tallClass, this.atTop || header.classList.contains(this.tallClass) && main.scrollHeight < this.offsetHeight, header);
    }
  }, _scroll:function() {
    this._keepScrollingState();
    this.fire("content-scroll", {target:this.scroller}, {bubbles:false});
  }, _getScrollerForMode:function(mode) {
    return MODE_CONFIGS.outerScroll[mode] ? this : this.$.mainContainer;
  }});
})();
(function() {
  Polymer.PaperScrollHeaderPanel = Polymer({is:"paper-scroll-header-panel", behaviors:[Polymer.IronResizableBehavior], properties:{condenses:{type:Boolean, value:false}, noDissolve:{type:Boolean, value:false}, noReveal:{type:Boolean, value:false}, fixed:{type:Boolean, value:false}, keepCondensedHeader:{type:Boolean, value:false}, headerHeight:{type:Number, value:0}, condensedHeaderHeight:{type:Number, value:0}, scrollAwayTopbar:{type:Boolean, value:false}, headerState:{type:Number, readOnly:true, 
  notify:true, value:0}, _defaultCondsensedHeaderHeight:{type:Number, value:0}}, observers:["_setup(headerHeight, condensedHeaderHeight, fixed)", "_condensedHeaderHeightChanged(condensedHeaderHeight)", "_headerHeightChanged(headerHeight, condensedHeaderHeight)", "_condensesChanged(condenses)"], listeners:{"iron-resize":"measureHeaderHeight"}, ready:function() {
    this._scrollHandler = this._scroll.bind(this);
    this.scroller.addEventListener("scroll", this._scrollHandler);
  }, attached:function() {
    this.async(this.measureHeaderHeight, 1);
  }, get header() {
    return Polymer.dom(this.$.headerContent).getDistributedNodes()[0];
  }, get content() {
    return Polymer.dom(this.$.mainContent).getDistributedNodes()[0];
  }, get scroller() {
    return this.$.mainContainer;
  }, get _headerMaxDelta() {
    return this.keepCondensedHeader ? this._headerMargin : this.headerHeight;
  }, get _headerMargin() {
    return this.headerHeight - this.condensedHeaderHeight;
  }, _y:0, _prevScrollTop:0, measureHeaderHeight:function() {
    var header = this.header;
    if (header && header.offsetHeight) {
      this.headerHeight = header.offsetHeight;
    }
  }, scroll:function(top, smooth) {
    if (smooth) {
      var easingFn = function easeOutQuad(t, b, c, d) {
        t /= d;
        return -c * t * (t - 2) + b;
      };
      var animationId = Math.random();
      var duration = 200;
      var startTime = Date.now();
      var currentScrollTop = this.scroller.scrollTop;
      var deltaScrollTop = top - currentScrollTop;
      this._currentAnimationId = animationId;
      (function updateFrame() {
        var now = Date.now();
        var elapsedTime = now - startTime;
        if (elapsedTime > duration) {
          this.scroller.scrollTop = top;
          this._updateScrollState(top);
        } else {
          if (this._currentAnimationId === animationId) {
            this.scroller.scrollTop = easingFn(elapsedTime, currentScrollTop, deltaScrollTop, duration);
            requestAnimationFrame(updateFrame.bind(this));
          }
        }
      }).call(this);
    } else {
      this.scroller.scrollTop = top;
      this._updateScrollState(top);
    }
  }, condense:function(smooth) {
    if (this.condenses && !this.fixed && !this.noReveal) {
      switch(this.headerState) {
        case 1:
          this.scroll(this.scroller.scrollTop - (this._headerMaxDelta - this._headerMargin), smooth);
          break;
        case 0:
        case 3:
          this.scroll(this._headerMargin, smooth);
          break;
      }
    }
  }, scrollToTop:function(smooth) {
    this.scroll(0, smooth);
  }, _headerHeightChanged:function(headerHeight) {
    if (this._defaultCondsensedHeaderHeight !== null) {
      this._defaultCondsensedHeaderHeight = Math.round(headerHeight * 1 / 3);
      this.condensedHeaderHeight = this._defaultCondsensedHeaderHeight;
    }
  }, _condensedHeaderHeightChanged:function(condensedHeaderHeight) {
    if (condensedHeaderHeight) {
      if (this._defaultCondsensedHeaderHeight != condensedHeaderHeight) {
        this._defaultCondsensedHeaderHeight = null;
      }
    }
  }, _condensesChanged:function() {
    this._updateScrollState(this.scroller.scrollTop);
    this._condenseHeader(null);
  }, _setup:function() {
    var s = this.scroller.style;
    s.paddingTop = this.fixed ? "" : this.headerHeight + "px";
    s.top = this.fixed ? this.headerHeight + "px" : "";
    if (this.fixed) {
      this._setHeaderState(0);
      this._transformHeader(null);
    } else {
      switch(this.headerState) {
        case 1:
          this._transformHeader(this._headerMaxDelta);
          break;
        case 2:
          this._transformHeader(this._headerMargin);
          break;
      }
    }
  }, _transformHeader:function(y) {
    this._translateY(this.$.headerContainer, -y);
    if (this.condenses) {
      this._condenseHeader(y);
    }
    this.fire("paper-header-transform", {y:y, height:this.headerHeight, condensedHeight:this.condensedHeaderHeight});
  }, _condenseHeader:function(y) {
    var reset = y === null;
    if (!this.scrollAwayTopbar && this.header && this.header.$ && this.header.$.topBar) {
      this._translateY(this.header.$.topBar, reset ? null : Math.min(y, this._headerMargin));
    }
    if (!this.noDissolve) {
      this.$.headerBg.style.opacity = reset ? "" : (this._headerMargin - y) / this._headerMargin;
    }
    this._translateY(this.$.headerBg, reset ? null : y / 2);
    if (!this.noDissolve) {
      this.$.condensedHeaderBg.style.opacity = reset ? "" : y / this._headerMargin;
      this._translateY(this.$.condensedHeaderBg, reset ? null : y / 2);
    }
  }, _translateY:function(node, y) {
    this.transform(y === null ? "" : "translate3d(0, " + y + "px, 0)", node);
  }, _scroll:function(event) {
    if (this.header) {
      this._updateScrollState(this.scroller.scrollTop);
      this.fire("content-scroll", {target:this.scroller}, {cancelable:false});
    }
  }, _updateScrollState:function(scrollTop) {
    var deltaScrollTop = scrollTop - this._prevScrollTop;
    var y = Math.max(0, this.noReveal ? scrollTop : this._y + deltaScrollTop);
    if (y > this._headerMaxDelta) {
      y = this._headerMaxDelta;
      if (this.keepCondensedHeader) {
        this._setHeaderState(2);
      } else {
        this._setHeaderState(1);
      }
    } else {
      if (this.condenses && scrollTop >= this._headerMargin) {
        y = Math.max(y, this._headerMargin);
        this._setHeaderState(2);
      } else {
        if (y === 0) {
          this._setHeaderState(0);
        } else {
          this._setHeaderState(3);
        }
      }
    }
    if (!this.fixed && y !== this._y) {
      this._transformHeader(y);
    }
    this._prevScrollTop = Math.max(scrollTop, 0);
    this._y = y;
  }});
  Polymer.PaperScrollHeaderPanel.HEADER_STATE_EXPANDED = 0;
  Polymer.PaperScrollHeaderPanel.HEADER_STATE_HIDDEN = 1;
  Polymer.PaperScrollHeaderPanel.HEADER_STATE_CONDENSED = 2;
  Polymer.PaperScrollHeaderPanel.HEADER_STATE_INTERPOLATED = 3;
})();
Polymer({is:"paper-icon-button", hostAttributes:{role:"button", tabindex:"0"}, behaviors:[Polymer.PaperInkyFocusBehavior], properties:{src:{type:String}, icon:{type:String}, alt:{type:String, observer:"_altChanged"}}, _altChanged:function(newValue, oldValue) {
  var label = this.getAttribute("aria-label");
  if (!label || oldValue == label) {
    this.setAttribute("aria-label", newValue);
  }
}});
Polymer({is:"paper-textarea", behaviors:[Polymer.PaperInputBehavior, Polymer.IronFormElementBehavior], properties:{_ariaLabelledBy:{observer:"_ariaLabelledByChanged", type:String}, _ariaDescribedBy:{observer:"_ariaDescribedByChanged", type:String}, rows:{type:Number, value:1}, maxRows:{type:Number, value:0}}, _ariaLabelledByChanged:function(ariaLabelledBy) {
  this.$.input.textarea.setAttribute("aria-labelledby", ariaLabelledBy);
}, _ariaDescribedByChanged:function(ariaDescribedBy) {
  this.$.input.textarea.setAttribute("aria-describedby", ariaDescribedBy);
}, get _focusableElement() {
  return this.$.input.textarea;
}});
Polymer.PaperItemBehaviorImpl = {hostAttributes:{role:"option", tabindex:"0"}};
Polymer.PaperItemBehavior = [Polymer.IronButtonState, Polymer.IronControlState, Polymer.PaperItemBehaviorImpl];
Polymer({is:"paper-icon-item", behaviors:[Polymer.PaperItemBehavior]});
Polymer({is:"paper-item-body"});
Polymer({is:"paper-item", behaviors:[Polymer.PaperItemBehavior]});
console.warn("This file is deprecated. Please use `iron-flex-layout/iron-flex-layout-classes.html`, and one of the specific dom-modules instead");
console.warn("This file is deprecated. Please use `iron-flex-layout/iron-flex-layout-classes.html`, and one of the specific dom-modules instead");
Polymer({is:"paper-toolbar", hostAttributes:{"role":"toolbar"}, properties:{bottomJustify:{type:String, value:""}, justify:{type:String, value:""}, middleJustify:{type:String, value:""}}, attached:function() {
  this._observer = this._observe(this);
  this._updateAriaLabelledBy();
}, detached:function() {
  if (this._observer) {
    this._observer.disconnect();
  }
}, _observe:function(node) {
  var observer = new MutationObserver(function() {
    this._updateAriaLabelledBy();
  }.bind(this));
  observer.observe(node, {childList:true, subtree:true});
  return observer;
}, _updateAriaLabelledBy:function() {
  var labelledBy = [];
  var contents = Polymer.dom(this.root).querySelectorAll("content");
  for (var content, index = 0; content = contents[index]; index++) {
    var nodes = Polymer.dom(content).getDistributedNodes();
    for (var node, jndex = 0; node = nodes[jndex]; jndex++) {
      if (node.classList && node.classList.contains("title")) {
        if (node.id) {
          labelledBy.push(node.id);
        } else {
          var id = "paper-toolbar-label-" + Math.floor(Math.random() * 10000);
          node.id = id;
          labelledBy.push(id);
        }
      }
    }
  }
  if (labelledBy.length > 0) {
    this.setAttribute("aria-labelledby", labelledBy.join(" "));
  }
}, _computeBarExtraClasses:function(barJustify) {
  if (!barJustify) {
    return "";
  }
  return barJustify + (barJustify === "justified" ? "" : "-justified");
}});
Polymer({properties:{dismissIcon:{type:String, value:"", observer:"_dismissIconChanged"}, responsiveWidth:{type:String, value:"600px"}, narrow:{type:Boolean, reflectToAttribute:true, observer:"_narrowChanged", notify:true}, modal:{type:Boolean, value:true}, _autoCloseDisabled:{type:Boolean, value:true}, _layered:{type:Boolean, value:false}, _affirmativeBtn:Object}, behaviors:[Polymer.PaperDialogBehavior], attached:function() {
  this.sizingTarget = this.$.scroller;
  var nodes = Polymer.dom(this.$.affirmative).getDistributedNodes();
  if (nodes.length) {
    this._affirmativeBtn = nodes[0];
  }
  this._dismissIconChanged();
}, _dismissIconChanged:function() {
  if (!this.dismissIcon) {
    this.$.dismissBtn.icon = this._affirmativeBtn ? "close" : "arrow-back";
  } else {
    this.$.dismissBtn.icon = this.dismissIcon;
  }
}, _narrowChanged:function() {
  if (!this.narrow) {
    this.style.width = this.responsiveWidth;
    this.modal = true;
  } else {
    this.style.width = "auto";
    this.modal = false;
  }
  this.fire("paper-responsive-change", {narrow:this.narrow});
}});
Polymer.IronMenuBehaviorImpl = {properties:{focusedItem:{observer:"_focusedItemChanged", readOnly:true, type:Object}, attrForItemTitle:{type:String}}, hostAttributes:{"role":"menu", "tabindex":"0"}, observers:["_updateMultiselectable(multi)"], listeners:{"focus":"_onFocus", "keydown":"_onKeydown", "iron-items-changed":"_onIronItemsChanged"}, keyBindings:{"up":"_onUpKey", "down":"_onDownKey", "esc":"_onEscKey", "shift+tab:keydown":"_onShiftTabDown"}, attached:function() {
  this._resetTabindices();
}, select:function(value) {
  if (this._defaultFocusAsync) {
    this.cancelAsync(this._defaultFocusAsync);
    this._defaultFocusAsync = null;
  }
  var item = this._valueToItem(value);
  if (item && item.hasAttribute("disabled")) {
    return;
  }
  this._setFocusedItem(item);
  Polymer.IronMultiSelectableBehaviorImpl.select.apply(this, arguments);
}, _resetTabindices:function() {
  var selectedItem = this.multi ? this.selectedItems && this.selectedItems[0] : this.selectedItem;
  this.items.forEach(function(item) {
    item.setAttribute("tabindex", item === selectedItem ? "0" : "-1");
  }, this);
}, _updateMultiselectable:function(multi) {
  if (multi) {
    this.setAttribute("aria-multiselectable", "true");
  } else {
    this.removeAttribute("aria-multiselectable");
  }
}, _focusWithKeyboardEvent:function(event) {
  for (var i = 0, item; item = this.items[i]; i++) {
    var attr = this.attrForItemTitle || "textContent";
    var title = item[attr] || item.getAttribute(attr);
    if (!item.hasAttribute("disabled") && title && title.trim().charAt(0).toLowerCase() === String.fromCharCode(event.keyCode).toLowerCase()) {
      this._setFocusedItem(item);
      break;
    }
  }
}, _focusPrevious:function() {
  var length = this.items.length;
  var curFocusIndex = Number(this.indexOf(this.focusedItem));
  for (var i = 1; i < length; i++) {
    var item = this.items[(curFocusIndex - i + length) % length];
    if (!item.hasAttribute("disabled")) {
      this._setFocusedItem(item);
      return;
    }
  }
}, _focusNext:function() {
  var length = this.items.length;
  var curFocusIndex = Number(this.indexOf(this.focusedItem));
  for (var i = 1; i < length; i++) {
    var item = this.items[(curFocusIndex + i) % length];
    if (!item.hasAttribute("disabled")) {
      this._setFocusedItem(item);
      return;
    }
  }
}, _applySelection:function(item, isSelected) {
  if (isSelected) {
    item.setAttribute("aria-selected", "true");
  } else {
    item.removeAttribute("aria-selected");
  }
  Polymer.IronSelectableBehavior._applySelection.apply(this, arguments);
}, _focusedItemChanged:function(focusedItem, old) {
  old && old.setAttribute("tabindex", "-1");
  if (focusedItem) {
    focusedItem.setAttribute("tabindex", "0");
    focusedItem.focus();
  }
}, _onIronItemsChanged:function(event) {
  if (event.detail.addedNodes.length) {
    this._resetTabindices();
  }
}, _onShiftTabDown:function(event) {
  var oldTabIndex = this.getAttribute("tabindex");
  Polymer.IronMenuBehaviorImpl._shiftTabPressed = true;
  this._setFocusedItem(null);
  this.setAttribute("tabindex", "-1");
  this.async(function() {
    this.setAttribute("tabindex", oldTabIndex);
    Polymer.IronMenuBehaviorImpl._shiftTabPressed = false;
  }, 1);
}, _onFocus:function(event) {
  if (Polymer.IronMenuBehaviorImpl._shiftTabPressed) {
    return;
  }
  var rootTarget = Polymer.dom(event).rootTarget;
  if (rootTarget !== this && typeof rootTarget.tabIndex !== "undefined" && !this.isLightDescendant(rootTarget)) {
    return;
  }
  this._defaultFocusAsync = this.async(function() {
    var selectedItem = this.multi ? this.selectedItems && this.selectedItems[0] : this.selectedItem;
    this._setFocusedItem(null);
    if (selectedItem) {
      this._setFocusedItem(selectedItem);
    } else {
      if (this.items[0]) {
        this._focusNext();
      }
    }
  });
}, _onUpKey:function(event) {
  this._focusPrevious();
  event.detail.keyboardEvent.preventDefault();
}, _onDownKey:function(event) {
  this._focusNext();
  event.detail.keyboardEvent.preventDefault();
}, _onEscKey:function(event) {
  this.focusedItem.blur();
}, _onKeydown:function(event) {
  if (!this.keyboardEventMatchesKeys(event, "up down esc")) {
    this._focusWithKeyboardEvent(event);
  }
  event.stopPropagation();
}, _activateHandler:function(event) {
  Polymer.IronSelectableBehavior._activateHandler.call(this, event);
  event.stopPropagation();
}};
Polymer.IronMenuBehaviorImpl._shiftTabPressed = false;
Polymer.IronMenuBehavior = [Polymer.IronMultiSelectableBehavior, Polymer.IronA11yKeysBehavior, Polymer.IronMenuBehaviorImpl];
(function() {
  Polymer({is:"paper-menu", behaviors:[Polymer.IronMenuBehavior]});
})();
Polymer.IronRangeBehavior = {properties:{value:{type:Number, value:0, notify:true, reflectToAttribute:true}, min:{type:Number, value:0, notify:true}, max:{type:Number, value:100, notify:true}, step:{type:Number, value:1, notify:true}, ratio:{type:Number, value:0, readOnly:true, notify:true}}, observers:["_update(value, min, max, step)"], _calcRatio:function(value) {
  return (this._clampValue(value) - this.min) / (this.max - this.min);
}, _clampValue:function(value) {
  return Math.min(this.max, Math.max(this.min, this._calcStep(value)));
}, _calcStep:function(value) {
  value = parseFloat(value);
  if (!this.step) {
    return value;
  }
  var numSteps = Math.round((value - this.min) / this.step);
  if (this.step < 1) {
    return numSteps / (1 / this.step) + this.min;
  } else {
    return numSteps * this.step + this.min;
  }
}, _validateValue:function() {
  var v = this._clampValue(this.value);
  this.value = this.oldValue = isNaN(v) ? this.oldValue : v;
  return this.value !== v;
}, _update:function() {
  this._validateValue();
  this._setRatio(this._calcRatio(this.value) * 100);
}};
Polymer({is:"paper-progress", behaviors:[Polymer.IronRangeBehavior], properties:{secondaryProgress:{type:Number, value:0}, secondaryRatio:{type:Number, value:0, readOnly:true}, indeterminate:{type:Boolean, value:false, observer:"_toggleIndeterminate"}, disabled:{type:Boolean, value:false, reflectToAttribute:true, observer:"_disabledChanged"}}, observers:["_progressChanged(secondaryProgress, value, min, max)"], hostAttributes:{role:"progressbar"}, _toggleIndeterminate:function(indeterminate) {
  this.toggleClass("indeterminate", indeterminate, this.$.primaryProgress);
}, _transformProgress:function(progress, ratio) {
  var transform = "scaleX(" + ratio / 100 + ")";
  progress.style.transform = progress.style.webkitTransform = transform;
}, _mainRatioChanged:function(ratio) {
  this._transformProgress(this.$.primaryProgress, ratio);
}, _progressChanged:function(secondaryProgress, value, min, max) {
  secondaryProgress = this._clampValue(secondaryProgress);
  value = this._clampValue(value);
  var secondaryRatio = this._calcRatio(secondaryProgress) * 100;
  var mainRatio = this._calcRatio(value) * 100;
  this._setSecondaryRatio(secondaryRatio);
  this._transformProgress(this.$.secondaryProgress, secondaryRatio);
  this._transformProgress(this.$.primaryProgress, mainRatio);
  this.secondaryProgress = secondaryProgress;
  this.setAttribute("aria-valuenow", value);
  this.setAttribute("aria-valuemin", min);
  this.setAttribute("aria-valuemax", max);
}, _disabledChanged:function(disabled) {
  this.setAttribute("aria-disabled", disabled ? "true" : "false");
}, _hideSecondaryProgress:function(secondaryRatio) {
  return secondaryRatio === 0;
}});
Polymer({is:"paper-radio-button", behaviors:[Polymer.PaperCheckedElementBehavior], hostAttributes:{role:"radio", "aria-checked":false, tabindex:0}, properties:{ariaActiveAttribute:{type:String, value:"aria-checked"}}, ready:function() {
  this._rippleContainer = this.$.radioContainer;
}});
Polymer.IronMenubarBehaviorImpl = {hostAttributes:{"role":"menubar"}, keyBindings:{"left":"_onLeftKey", "right":"_onRightKey"}, _onUpKey:function(event) {
  this.focusedItem.click();
  event.detail.keyboardEvent.preventDefault();
}, _onDownKey:function(event) {
  this.focusedItem.click();
  event.detail.keyboardEvent.preventDefault();
}, get _isRTL() {
  return window.getComputedStyle(this)["direction"] === "rtl";
}, _onLeftKey:function(event) {
  if (this._isRTL) {
    this._focusNext();
  } else {
    this._focusPrevious();
  }
  event.detail.keyboardEvent.preventDefault();
}, _onRightKey:function(event) {
  if (this._isRTL) {
    this._focusPrevious();
  } else {
    this._focusNext();
  }
  event.detail.keyboardEvent.preventDefault();
}, _onKeydown:function(event) {
  if (this.keyboardEventMatchesKeys(event, "up down left right esc")) {
    return;
  }
  this._focusWithKeyboardEvent(event);
}};
Polymer.IronMenubarBehavior = [Polymer.IronMenuBehavior, Polymer.IronMenubarBehaviorImpl];
Polymer({is:"paper-radio-group", behaviors:[Polymer.IronMenubarBehavior], hostAttributes:{role:"radiogroup", tabindex:0}, properties:{attrForSelected:{type:String, value:"name"}, selectedAttribute:{type:String, value:"checked"}, selectable:{type:String, value:"paper-radio-button"}, allowEmptySelection:{type:Boolean, value:false}}, select:function(value) {
  var newItem = this._valueToItem(value);
  if (newItem && newItem.hasAttribute("disabled")) {
    return;
  }
  if (this.selected) {
    var oldItem = this._valueToItem(this.selected);
    if (this.selected == value) {
      if (this.allowEmptySelection) {
        value = "";
      } else {
        if (oldItem) {
          oldItem.checked = true;
        }
        return;
      }
    }
    if (oldItem) {
      oldItem.checked = false;
    }
  }
  Polymer.IronSelectableBehavior.select.apply(this, [value]);
  this.fire("paper-radio-group-changed");
}, _activateFocusedItem:function() {
  this._itemActivate(this._valueForItem(this.focusedItem), this.focusedItem);
}, _onUpKey:function(event) {
  this._focusPrevious();
  event.preventDefault();
  this._activateFocusedItem();
}, _onDownKey:function(event) {
  this._focusNext();
  event.preventDefault();
  this._activateFocusedItem();
}, _onLeftKey:function(event) {
  Polymer.IronMenubarBehaviorImpl._onLeftKey.apply(this, arguments);
  this._activateFocusedItem();
}, _onRightKey:function(event) {
  Polymer.IronMenubarBehaviorImpl._onRightKey.apply(this, arguments);
  this._activateFocusedItem();
}});
Polymer({is:"paper-slider", behaviors:[Polymer.IronA11yKeysBehavior, Polymer.IronFormElementBehavior, Polymer.PaperInkyFocusBehavior, Polymer.IronRangeBehavior], properties:{snaps:{type:Boolean, value:false, notify:true}, pin:{type:Boolean, value:false, notify:true}, secondaryProgress:{type:Number, value:0, notify:true, observer:"_secondaryProgressChanged"}, editable:{type:Boolean, value:false}, immediateValue:{type:Number, value:0, readOnly:true, notify:true}, maxMarkers:{type:Number, value:0, notify:true}, 
expand:{type:Boolean, value:false, readOnly:true}, dragging:{type:Boolean, value:false, readOnly:true}, transiting:{type:Boolean, value:false, readOnly:true}, markers:{type:Array, readOnly:true, value:[]}}, observers:["_updateKnob(value, min, max, snaps, step)", "_valueChanged(value)", "_immediateValueChanged(immediateValue)", "_updateMarkers(maxMarkers, min, max, snaps)"], hostAttributes:{role:"slider", tabindex:0}, keyBindings:{"left down pagedown home":"_decrementKey", "right up pageup end":"_incrementKey"}, 
increment:function() {
  this.value = this._clampValue(this.value + this.step);
}, decrement:function() {
  this.value = this._clampValue(this.value - this.step);
}, _updateKnob:function(value, min, max, snaps, step) {
  this.setAttribute("aria-valuemin", min);
  this.setAttribute("aria-valuemax", max);
  this.setAttribute("aria-valuenow", value);
  this._positionKnob(this._calcRatio(value));
}, _valueChanged:function() {
  this.fire("value-change");
}, _immediateValueChanged:function() {
  if (this.dragging) {
    this.fire("immediate-value-change");
  } else {
    this.value = this.immediateValue;
  }
}, _secondaryProgressChanged:function() {
  this.secondaryProgress = this._clampValue(this.secondaryProgress);
}, _expandKnob:function() {
  this._setExpand(true);
}, _resetKnob:function() {
  this.cancelDebouncer("expandKnob");
  this._setExpand(false);
}, _positionKnob:function(ratio) {
  this._setImmediateValue(this._calcStep(this._calcKnobPosition(ratio)));
  this._setRatio(this._calcRatio(this.immediateValue));
  this.$.sliderKnob.style.left = this.ratio * 100 + "%";
  if (this.dragging) {
    this._knobstartx = this.ratio * this._w;
    this.translate3d(0, 0, 0, this.$.sliderKnob);
  }
}, _calcKnobPosition:function(ratio) {
  return (this.max - this.min) * ratio + this.min;
}, _onTrack:function(event) {
  event.stopPropagation();
  switch(event.detail.state) {
    case "start":
      this._trackStart(event);
      break;
    case "track":
      this._trackX(event);
      break;
    case "end":
      this._trackEnd();
      break;
  }
}, _trackStart:function(event) {
  this._w = this.$.sliderBar.offsetWidth;
  this._x = this.ratio * this._w;
  this._startx = this._x;
  this._knobstartx = this._startx;
  this._minx = -this._startx;
  this._maxx = this._w - this._startx;
  this.$.sliderKnob.classList.add("dragging");
  this._setDragging(true);
}, _trackX:function(e) {
  if (!this.dragging) {
    this._trackStart(e);
  }
  var dx = Math.min(this._maxx, Math.max(this._minx, e.detail.dx));
  this._x = this._startx + dx;
  var immediateValue = this._calcStep(this._calcKnobPosition(this._x / this._w));
  this._setImmediateValue(immediateValue);
  var translateX = this._calcRatio(this.immediateValue) * this._w - this._knobstartx;
  this.translate3d(translateX + "px", 0, 0, this.$.sliderKnob);
}, _trackEnd:function() {
  var s = this.$.sliderKnob.style;
  this.$.sliderKnob.classList.remove("dragging");
  this._setDragging(false);
  this._resetKnob();
  this.value = this.immediateValue;
  s.transform = s.webkitTransform = "";
  this.fire("change");
}, _knobdown:function(event) {
  this._expandKnob();
  event.preventDefault();
  this.focus();
}, _bardown:function(event) {
  this._w = this.$.sliderBar.offsetWidth;
  var rect = this.$.sliderBar.getBoundingClientRect();
  var ratio = (event.detail.x - rect.left) / this._w;
  var prevRatio = this.ratio;
  this._setTransiting(true);
  this._positionKnob(ratio);
  this.debounce("expandKnob", this._expandKnob, 60);
  if (prevRatio === this.ratio) {
    this._setTransiting(false);
  }
  this.async(function() {
    this.fire("change");
  });
  event.preventDefault();
  this.focus();
}, _knobTransitionEnd:function(event) {
  if (event.target === this.$.sliderKnob) {
    this._setTransiting(false);
  }
}, _updateMarkers:function(maxMarkers, min, max, snaps) {
  if (!snaps) {
    this._setMarkers([]);
  }
  var steps = Math.round((max - min) / this.step);
  if (steps > maxMarkers) {
    steps = maxMarkers;
  }
  this._setMarkers(new Array(steps));
}, _mergeClasses:function(classes) {
  return Object.keys(classes).filter(function(className) {
    return classes[className];
  }).join(" ");
}, _getClassNames:function() {
  return this._mergeClasses({disabled:this.disabled, pin:this.pin, snaps:this.snaps, ring:this.immediateValue <= this.min, expand:this.expand, dragging:this.dragging, transiting:this.transiting, editable:this.editable});
}, _incrementKey:function(event) {
  if (!this.disabled) {
    if (event.detail.key === "end") {
      this.value = this.max;
    } else {
      this.increment();
    }
    this.fire("change");
  }
}, _decrementKey:function(event) {
  if (!this.disabled) {
    if (event.detail.key === "home") {
      this.value = this.min;
    } else {
      this.decrement();
    }
    this.fire("change");
  }
}, _changeValue:function(event) {
  this.value = event.target.value;
  this.fire("change");
}, _inputKeyDown:function(event) {
  event.stopPropagation();
}, _createRipple:function() {
  this._rippleContainer = this.$.sliderKnob;
  return Polymer.PaperInkyFocusBehaviorImpl._createRipple.call(this);
}, _focusedChanged:function(receivedFocusFromKeyboard) {
  if (receivedFocusFromKeyboard) {
    this.ensureRipple();
  }
  if (this.hasRipple()) {
    if (receivedFocusFromKeyboard) {
      this._ripple.style.display = "";
    } else {
      this._ripple.style.display = "none";
    }
    this._ripple.holdDown = receivedFocusFromKeyboard;
  }
}});
Polymer.PaperSpinnerBehavior = {listeners:{"animationend":"__reset", "webkitAnimationEnd":"__reset"}, properties:{active:{type:Boolean, value:false, reflectToAttribute:true, observer:"__activeChanged"}, alt:{type:String, value:"loading", observer:"__altChanged"}, __coolingDown:{type:Boolean, value:false}}, __computeContainerClasses:function(active, coolingDown) {
  return [active || coolingDown ? "active" : "", coolingDown ? "cooldown" : ""].join(" ");
}, __activeChanged:function(active, old) {
  this.__setAriaHidden(!active);
  this.__coolingDown = !active && old;
}, __altChanged:function(alt) {
  if (alt === this.getPropertyInfo("alt").value) {
    this.alt = this.getAttribute("aria-label") || alt;
  } else {
    this.__setAriaHidden(alt === "");
    this.setAttribute("aria-label", alt);
  }
}, __setAriaHidden:function(hidden) {
  var attr = "aria-hidden";
  if (hidden) {
    this.setAttribute(attr, "true");
  } else {
    this.removeAttribute(attr);
  }
}, __reset:function() {
  this.active = false;
  this.__coolingDown = false;
}};
Polymer({is:"paper-spinner", behaviors:[Polymer.PaperSpinnerBehavior]});
Polymer({is:"paper-tab", behaviors:[Polymer.IronControlState, Polymer.IronButtonState, Polymer.PaperRippleBehavior], properties:{link:{type:Boolean, value:false, reflectToAttribute:true}}, hostAttributes:{role:"tab"}, listeners:{down:"_updateNoink", tap:"_onTap"}, attached:function() {
  this._updateNoink();
}, get _parentNoink() {
  var parent = Polymer.dom(this).parentNode;
  return !!parent && !!parent.noink;
}, _updateNoink:function() {
  this.noink = !!this.noink || !!this._parentNoink;
}, _onTap:function(event) {
  if (this.link) {
    var anchor = this.queryEffectiveChildren("a");
    if (!anchor) {
      return;
    }
    if (event.target === anchor) {
      return;
    }
    anchor.click();
  }
}});
Polymer({is:"paper-tabs", behaviors:[Polymer.IronResizableBehavior, Polymer.IronMenubarBehavior], properties:{noink:{type:Boolean, value:false, observer:"_noinkChanged"}, noBar:{type:Boolean, value:false}, noSlide:{type:Boolean, value:false}, scrollable:{type:Boolean, value:false}, disableDrag:{type:Boolean, value:false}, hideScrollButtons:{type:Boolean, value:false}, alignBottom:{type:Boolean, value:false}, selectable:{type:String, value:"paper-tab"}, autoselect:{type:Boolean, value:false}, autoselectDelay:{type:Number, 
value:0}, _step:{type:Number, value:10}, _holdDelay:{type:Number, value:1}, _leftHidden:{type:Boolean, value:false}, _rightHidden:{type:Boolean, value:false}, _previousTab:{type:Object}}, hostAttributes:{role:"tablist"}, listeners:{"iron-resize":"_onTabSizingChanged", "iron-items-changed":"_onTabSizingChanged", "iron-select":"_onIronSelect", "iron-deselect":"_onIronDeselect"}, keyBindings:{"left:keyup right:keyup":"_onArrowKeyup"}, created:function() {
  this._holdJob = null;
  this._pendingActivationItem = undefined;
  this._pendingActivationTimeout = undefined;
  this._bindDelayedActivationHandler = this._delayedActivationHandler.bind(this);
  this.addEventListener("blur", this._onBlurCapture.bind(this), true);
}, ready:function() {
  this.setScrollDirection("y", this.$.tabsContainer);
}, detached:function() {
  this._cancelPendingActivation();
}, _noinkChanged:function(noink) {
  var childTabs = Polymer.dom(this).querySelectorAll("paper-tab");
  childTabs.forEach(noink ? this._setNoinkAttribute : this._removeNoinkAttribute);
}, _setNoinkAttribute:function(element) {
  element.setAttribute("noink", "");
}, _removeNoinkAttribute:function(element) {
  element.removeAttribute("noink");
}, _computeScrollButtonClass:function(hideThisButton, scrollable, hideScrollButtons) {
  if (!scrollable || hideScrollButtons) {
    return "hidden";
  }
  if (hideThisButton) {
    return "not-visible";
  }
  return "";
}, _computeTabsContentClass:function(scrollable) {
  return scrollable ? "scrollable" : "horizontal";
}, _computeSelectionBarClass:function(noBar, alignBottom) {
  if (noBar) {
    return "hidden";
  } else {
    if (alignBottom) {
      return "align-bottom";
    }
  }
  return "";
}, _onTabSizingChanged:function() {
  this.debounce("_onTabSizingChanged", function() {
    this._scroll();
    this._tabChanged(this.selectedItem);
  }, 10);
}, _onIronSelect:function(event) {
  this._tabChanged(event.detail.item, this._previousTab);
  this._previousTab = event.detail.item;
  this.cancelDebouncer("tab-changed");
}, _onIronDeselect:function(event) {
  this.debounce("tab-changed", function() {
    this._tabChanged(null, this._previousTab);
  }, 1);
}, _activateHandler:function() {
  this._cancelPendingActivation();
  Polymer.IronMenuBehaviorImpl._activateHandler.apply(this, arguments);
}, _scheduleActivation:function(item, delay) {
  this._pendingActivationItem = item;
  this._pendingActivationTimeout = this.async(this._bindDelayedActivationHandler, delay);
}, _delayedActivationHandler:function() {
  var item = this._pendingActivationItem;
  this._pendingActivationItem = undefined;
  this._pendingActivationTimeout = undefined;
  item.fire(this.activateEvent, null, {bubbles:true, cancelable:true});
}, _cancelPendingActivation:function() {
  if (this._pendingActivationTimeout !== undefined) {
    this.cancelAsync(this._pendingActivationTimeout);
    this._pendingActivationItem = undefined;
    this._pendingActivationTimeout = undefined;
  }
}, _onArrowKeyup:function(event) {
  if (this.autoselect) {
    this._scheduleActivation(this.focusedItem, this.autoselectDelay);
  }
}, _onBlurCapture:function(event) {
  if (event.target === this._pendingActivationItem) {
    this._cancelPendingActivation();
  }
}, get _tabContainerScrollSize() {
  return Math.max(0, this.$.tabsContainer.scrollWidth - this.$.tabsContainer.offsetWidth);
}, _scroll:function(e, detail) {
  if (!this.scrollable) {
    return;
  }
  var ddx = detail && -detail.ddx || 0;
  this._affectScroll(ddx);
}, _down:function(e) {
  this.async(function() {
    if (this._defaultFocusAsync) {
      this.cancelAsync(this._defaultFocusAsync);
      this._defaultFocusAsync = null;
    }
  }, 1);
}, _affectScroll:function(dx) {
  this.$.tabsContainer.scrollLeft += dx;
  var scrollLeft = this.$.tabsContainer.scrollLeft;
  this._leftHidden = scrollLeft === 0;
  this._rightHidden = scrollLeft === this._tabContainerScrollSize;
}, _onLeftScrollButtonDown:function() {
  this._scrollToLeft();
  this._holdJob = setInterval(this._scrollToLeft.bind(this), this._holdDelay);
}, _onRightScrollButtonDown:function() {
  this._scrollToRight();
  this._holdJob = setInterval(this._scrollToRight.bind(this), this._holdDelay);
}, _onScrollButtonUp:function() {
  clearInterval(this._holdJob);
  this._holdJob = null;
}, _scrollToLeft:function() {
  this._affectScroll(-this._step);
}, _scrollToRight:function() {
  this._affectScroll(this._step);
}, _tabChanged:function(tab, old) {
  if (!tab) {
    this._positionBar(0, 0);
    return;
  }
  var r = this.$.tabsContent.getBoundingClientRect();
  var w = r.width;
  var tabRect = tab.getBoundingClientRect();
  var tabOffsetLeft = tabRect.left - r.left;
  this._pos = {width:this._calcPercent(tabRect.width, w), left:this._calcPercent(tabOffsetLeft, w)};
  if (this.noSlide || old == null) {
    this._positionBar(this._pos.width, this._pos.left);
    return;
  }
  var oldRect = old.getBoundingClientRect();
  var oldIndex = this.items.indexOf(old);
  var index = this.items.indexOf(tab);
  var m = 5;
  this.$.selectionBar.classList.add("expand");
  var moveRight = oldIndex < index;
  var isRTL = this._isRTL;
  if (isRTL) {
    moveRight = !moveRight;
  }
  if (moveRight) {
    this._positionBar(this._calcPercent(tabRect.left + tabRect.width - oldRect.left, w) - m, this._left);
  } else {
    this._positionBar(this._calcPercent(oldRect.left + oldRect.width - tabRect.left, w) - m, this._calcPercent(tabOffsetLeft, w) + m);
  }
  if (this.scrollable) {
    this._scrollToSelectedIfNeeded(tabRect.width, tabOffsetLeft);
  }
}, _scrollToSelectedIfNeeded:function(tabWidth, tabOffsetLeft) {
  var l = tabOffsetLeft - this.$.tabsContainer.scrollLeft;
  if (l < 0) {
    this.$.tabsContainer.scrollLeft += l;
  } else {
    l += tabWidth - this.$.tabsContainer.offsetWidth;
    if (l > 0) {
      this.$.tabsContainer.scrollLeft += l;
    }
  }
}, _calcPercent:function(w, w0) {
  return 100 * w / w0;
}, _positionBar:function(width, left) {
  width = width || 0;
  left = left || 0;
  this._width = width;
  this._left = left;
  this.transform("translate3d(" + left + "%, 0, 0) scaleX(" + width / 100 + ")", this.$.selectionBar);
}, _onBarTransitionEnd:function(e) {
  var cl = this.$.selectionBar.classList;
  if (cl.contains("expand")) {
    cl.remove("expand");
    cl.add("contract");
    this._positionBar(this._pos.width, this._pos.left);
  } else {
    if (cl.contains("contract")) {
      cl.remove("contract");
    }
  }
}});
(function() {
  var currentToast = null;
  Polymer({is:"paper-toast", behaviors:[Polymer.IronOverlayBehavior], properties:{duration:{type:Number, value:3000}, text:{type:String, value:""}, noCancelOnOutsideClick:{type:Boolean, value:true}, noAutoFocus:{type:Boolean, value:true}}, listeners:{"transitionend":"__onTransitionEnd"}, get visible() {
    console.warn("`visible` is deprecated, use `opened` instead");
    return this.opened;
  }, get _canAutoClose() {
    return this.duration > 0 && this.duration !== Infinity;
  }, created:function() {
    this._autoClose = null;
    Polymer.IronA11yAnnouncer.requestAvailability();
  }, show:function(properties) {
    if (typeof properties == "string") {
      properties = {text:properties};
    }
    for (var property in properties) {
      if (property.indexOf("_") === 0) {
        console.warn('The property "' + property + '" is private and was not set.');
      } else {
        if (property in this) {
          this[property] = properties[property];
        } else {
          console.warn('The property "' + property + '" is not valid.');
        }
      }
    }
    this.open();
  }, hide:function() {
    this.close();
  }, center:function() {
    if (this.fitInto === window) {
      this.style.bottom = this.style.left = "";
    } else {
      var rect = this.fitInto.getBoundingClientRect();
      this.style.left = rect.left + "px";
      this.style.bottom = window.innerHeight - rect.bottom + "px";
    }
  }, __onTransitionEnd:function(e) {
    if (e && e.target === this && e.propertyName === "opacity") {
      if (this.opened) {
        this._finishRenderOpened();
      } else {
        this._finishRenderClosed();
      }
    }
  }, _openedChanged:function() {
    if (this._autoClose !== null) {
      this.cancelAsync(this._autoClose);
      this._autoClose = null;
    }
    if (this.opened) {
      if (currentToast && currentToast !== this) {
        currentToast.close();
      }
      currentToast = this;
      this.fire("iron-announce", {text:this.text});
      if (this._canAutoClose) {
        this._autoClose = this.async(this.close, this.duration);
      }
    } else {
      if (currentToast === this) {
        currentToast = null;
      }
    }
    Polymer.IronOverlayBehaviorImpl._openedChanged.apply(this, arguments);
  }, _renderOpened:function() {
    this.classList.add("paper-toast-open");
  }, _renderClosed:function() {
    this.classList.remove("paper-toast-open");
  }, _onIronResize:function() {
    Polymer.IronOverlayBehaviorImpl._onIronResize.apply(this, arguments);
    if (this.opened) {
      this.style.position = "";
    }
  }});
})();
Polymer({is:"paper-toggle-button", behaviors:[Polymer.PaperCheckedElementBehavior], hostAttributes:{role:"button", "aria-pressed":"false", tabindex:0}, properties:{}, listeners:{track:"_ontrack"}, _ontrack:function(event) {
  var track = event.detail;
  if (track.state === "start") {
    this._trackStart(track);
  } else {
    if (track.state === "track") {
      this._trackMove(track);
    } else {
      if (track.state === "end") {
        this._trackEnd(track);
      }
    }
  }
}, _trackStart:function(track) {
  this._width = this.$.toggleBar.offsetWidth / 2;
  this._trackChecked = this.checked;
  this.$.toggleButton.classList.add("dragging");
}, _trackMove:function(track) {
  var dx = track.dx;
  this._x = Math.min(this._width, Math.max(0, this._trackChecked ? this._width + dx : dx));
  this.translate3d(this._x + "px", 0, 0, this.$.toggleButton);
  this._userActivate(this._x > this._width / 2);
}, _trackEnd:function(track) {
  this.$.toggleButton.classList.remove("dragging");
  this.transform("", this.$.toggleButton);
}, _createRipple:function() {
  this._rippleContainer = this.$.toggleButton;
  var ripple = Polymer.PaperRippleBehavior._createRipple();
  ripple.id = "ink";
  ripple.setAttribute("recenters", "");
  ripple.classList.add("circle", "toggle-ink");
  return ripple;
}});
Polymer({is:"paper-tooltip", hostAttributes:{role:"tooltip", tabindex:-1}, behaviors:[Polymer.NeonAnimationRunnerBehavior], properties:{for:{type:String, observer:"_forChanged"}, manualMode:{type:Boolean, value:false}, position:{type:String, value:"bottom"}, fitToVisibleBounds:{type:Boolean, value:false}, offset:{type:Number, value:14}, marginTop:{type:Number, value:14}, animationDelay:{type:Number, value:500}, animationConfig:{type:Object, value:function() {
  return {"entry":[{name:"fade-in-animation", node:this, timing:{delay:0}}], "exit":[{name:"fade-out-animation", node:this}]};
}}, _showing:{type:Boolean, value:false}}, listeners:{"neon-animation-finish":"_onAnimationFinish", "mouseenter":"hide"}, get target() {
  var parentNode = Polymer.dom(this).parentNode;
  var ownerRoot = Polymer.dom(this).getOwnerRoot();
  var target;
  if (this.for) {
    target = Polymer.dom(ownerRoot).querySelector("#" + this.for);
  } else {
    target = parentNode.nodeType == Node.DOCUMENT_FRAGMENT_NODE ? ownerRoot.host : parentNode;
  }
  return target;
}, attached:function() {
  this._target = this.target;
  if (this.manualMode) {
    return;
  }
  this.listen(this._target, "mouseenter", "show");
  this.listen(this._target, "focus", "show");
  this.listen(this._target, "mouseleave", "hide");
  this.listen(this._target, "blur", "hide");
  this.listen(this._target, "tap", "hide");
}, detached:function() {
  if (this._target && !this.manualMode) {
    this.unlisten(this._target, "mouseenter", "show");
    this.unlisten(this._target, "focus", "show");
    this.unlisten(this._target, "mouseleave", "hide");
    this.unlisten(this._target, "blur", "hide");
    this.unlisten(this._target, "tap", "hide");
  }
}, show:function() {
  if (this._showing) {
    return;
  }
  if (Polymer.dom(this).textContent.trim() === "") {
    return;
  }
  this.cancelAnimation();
  this._showing = true;
  this.toggleClass("hidden", false, this.$.tooltip);
  this.updatePosition();
  this.animationConfig.entry[0].timing.delay = this.animationDelay;
  this._animationPlaying = true;
  this.playAnimation("entry");
}, hide:function() {
  if (!this._showing) {
    return;
  }
  if (this._animationPlaying) {
    this.cancelAnimation();
    this._showing = false;
    this._onAnimationFinish();
    return;
  }
  this._showing = false;
  this._animationPlaying = true;
  this.playAnimation("exit");
}, _forChanged:function() {
  this._target = this.target;
}, updatePosition:function() {
  if (!this._target || !this.offsetParent) {
    return;
  }
  var offset = this.offset;
  if (this.marginTop != 14 && this.offset == 14) {
    offset = this.marginTop;
  }
  var parentRect = this.offsetParent.getBoundingClientRect();
  var targetRect = this._target.getBoundingClientRect();
  var thisRect = this.getBoundingClientRect();
  var horizontalCenterOffset = (targetRect.width - thisRect.width) / 2;
  var verticalCenterOffset = (targetRect.height - thisRect.height) / 2;
  var targetLeft = targetRect.left - parentRect.left;
  var targetTop = targetRect.top - parentRect.top;
  var tooltipLeft, tooltipTop;
  switch(this.position) {
    case "top":
      tooltipLeft = targetLeft + horizontalCenterOffset;
      tooltipTop = targetTop - thisRect.height - offset;
      break;
    case "bottom":
      tooltipLeft = targetLeft + horizontalCenterOffset;
      tooltipTop = targetTop + targetRect.height + offset;
      break;
    case "left":
      tooltipLeft = targetLeft - thisRect.width - offset;
      tooltipTop = targetTop + verticalCenterOffset;
      break;
    case "right":
      tooltipLeft = targetLeft + targetRect.width + offset;
      tooltipTop = targetTop + verticalCenterOffset;
      break;
  }
  if (this.fitToVisibleBounds) {
    if (tooltipLeft + thisRect.width > window.innerWidth) {
      this.style.right = "0px";
      this.style.left = "auto";
    } else {
      this.style.left = Math.max(0, tooltipLeft) + "px";
      this.style.right = "auto";
    }
    if (tooltipTop + thisRect.height > window.innerHeight) {
      this.style.bottom = "0px";
      this.style.top = "auto";
    } else {
      this.style.top = Math.max(0, tooltipTop) + "px";
      this.style.bottom = "auto";
    }
  } else {
    this.style.left = tooltipLeft + "px";
    this.style.top = tooltipTop + "px";
  }
}, _onAnimationFinish:function() {
  this._animationPlaying = false;
  if (!this._showing) {
    this.toggleClass("hidden", true, this.$.tooltip);
  }
}});
Promise.all = Promise.all || function() {
  var args = Array.prototype.slice.call(arguments.length === 1 && Array.isArray(arguments[0]) ? arguments[0] : arguments);
  return new Promise(function(resolve, reject) {
    if (args.length === 0) {
      return resolve([]);
    }
    var remaining = args.length;
    function res(i, val) {
      try {
        if (val && (typeof val === "object" || typeof val === "function")) {
          var then = val.then;
          if (typeof then === "function") {
            then.call(val, function(val) {
              res(i, val);
            }, reject);
            return;
          }
        }
        args[i] = val;
        if (--remaining === 0) {
          resolve(args);
        }
      } catch (ex) {
        reject(ex);
      }
    }
    for (var i = 0; i < args.length; i++) {
      res(i, args[i]);
    }
  });
};
Promise.race = Promise.race || function(values) {
  return new Promise(function(resolve, reject) {
    for (var i = 0, len = values.length; i < len; i++) {
      values[i].then(resolve, reject);
    }
  });
};
Polymer({is:"app-drawer", properties:{opened:{type:Boolean, value:false, notify:true, reflectToAttribute:true}, persistent:{type:Boolean, value:false, reflectToAttribute:true}, align:{type:String, value:"left"}, position:{type:String, readOnly:true, value:"left", reflectToAttribute:true}, swipeOpen:{type:Boolean, value:false, reflectToAttribute:true}, noFocusTrap:{type:Boolean, value:false}}, observers:["resetLayout(position)", "_resetPosition(align, isAttached)"], _translateOffset:0, _trackDetails:null, 
_drawerState:0, _boundEscKeydownHandler:null, _firstTabStop:null, _lastTabStop:null, ready:function() {
  this.setScrollDirection("y");
  this._setTransitionDuration("0s");
}, attached:function() {
  Polymer.RenderStatus.afterNextRender(this, function() {
    this._setTransitionDuration("");
    this._boundEscKeydownHandler = this._escKeydownHandler.bind(this);
    this._resetDrawerState();
    this.listen(this, "track", "_track");
    this.addEventListener("transitionend", this._transitionend.bind(this));
    this.addEventListener("keydown", this._tabKeydownHandler.bind(this));
  });
}, detached:function() {
  document.removeEventListener("keydown", this._boundEscKeydownHandler);
}, open:function() {
  this.opened = true;
}, close:function() {
  this.opened = false;
}, toggle:function() {
  this.opened = !this.opened;
}, getWidth:function() {
  return this.$.contentContainer.offsetWidth;
}, resetLayout:function() {
  this.debounce("_resetLayout", function() {
    this.fire("app-drawer-reset-layout");
  }, 1);
}, _isRTL:function() {
  return window.getComputedStyle(this).direction === "rtl";
}, _resetPosition:function() {
  switch(this.align) {
    case "start":
      this._setPosition(this._isRTL() ? "right" : "left");
      return;
    case "end":
      this._setPosition(this._isRTL() ? "left" : "right");
      return;
  }
  this._setPosition(this.align);
}, _escKeydownHandler:function(event) {
  var ESC_KEYCODE = 27;
  if (event.keyCode === ESC_KEYCODE) {
    event.preventDefault();
    this.close();
  }
}, _track:function(event) {
  if (this.persistent) {
    return;
  }
  event.preventDefault();
  switch(event.detail.state) {
    case "start":
      this._trackStart(event);
      break;
    case "track":
      this._trackMove(event);
      break;
    case "end":
      this._trackEnd(event);
      break;
  }
}, _trackStart:function(event) {
  this._drawerState = this._DRAWER_STATE.TRACKING;
  this._setTransitionDuration("0s");
  this.style.visibility = "visible";
  var rect = this.$.contentContainer.getBoundingClientRect();
  if (this.position === "left") {
    this._translateOffset = rect.left;
  } else {
    this._translateOffset = rect.right - window.innerWidth;
  }
  this._trackDetails = [];
}, _trackMove:function(event) {
  this._translateDrawer(event.detail.dx + this._translateOffset);
  this._trackDetails.push({dx:event.detail.dx, timeStamp:Date.now()});
}, _trackEnd:function(event) {
  var x = event.detail.dx + this._translateOffset;
  var drawerWidth = this.getWidth();
  var isPositionLeft = this.position === "left";
  var isInEndState = isPositionLeft ? x >= 0 || x <= -drawerWidth : x <= 0 || x >= drawerWidth;
  if (!isInEndState) {
    var trackDetails = this._trackDetails;
    this._trackDetails = null;
    this._flingDrawer(event, trackDetails);
    if (this._drawerState === this._DRAWER_STATE.FLINGING) {
      return;
    }
  }
  var halfWidth = drawerWidth / 2;
  if (event.detail.dx < -halfWidth) {
    this.opened = this.position === "right";
  } else {
    if (event.detail.dx > halfWidth) {
      this.opened = this.position === "left";
    }
  }
  if (isInEndState) {
    this._resetDrawerState();
  }
  this._setTransitionDuration("");
  this._resetDrawerTranslate();
  this.style.visibility = "";
}, _calculateVelocity:function(event, trackDetails) {
  var now = Date.now();
  var timeLowerBound = now - 100;
  var trackDetail;
  var min = 0;
  var max = trackDetails.length - 1;
  while (min <= max) {
    var mid = min + max >> 1;
    var d = trackDetails[mid];
    if (d.timeStamp >= timeLowerBound) {
      trackDetail = d;
      max = mid - 1;
    } else {
      min = mid + 1;
    }
  }
  if (trackDetail) {
    var dx = event.detail.dx - trackDetail.dx;
    var dt = now - trackDetail.timeStamp || 1;
    return dx / dt;
  }
  return 0;
}, _flingDrawer:function(event, trackDetails) {
  var velocity = this._calculateVelocity(event, trackDetails);
  if (Math.abs(velocity) < this._MIN_FLING_THRESHOLD) {
    return;
  }
  this._drawerState = this._DRAWER_STATE.FLINGING;
  var x = event.detail.dx + this._translateOffset;
  var drawerWidth = this.getWidth();
  var isPositionLeft = this.position === "left";
  var isVelocityPositive = velocity > 0;
  var isClosingLeft = !isVelocityPositive && isPositionLeft;
  var isClosingRight = isVelocityPositive && !isPositionLeft;
  var dx;
  if (isClosingLeft) {
    dx = -(x + drawerWidth);
  } else {
    if (isClosingRight) {
      dx = drawerWidth - x;
    } else {
      dx = -x;
    }
  }
  if (isVelocityPositive) {
    velocity = Math.max(velocity, this._MIN_TRANSITION_VELOCITY);
    this.opened = this.position === "left";
  } else {
    velocity = Math.min(velocity, -this._MIN_TRANSITION_VELOCITY);
    this.opened = this.position === "right";
  }
  this._setTransitionDuration(this._FLING_INITIAL_SLOPE * dx / velocity + "ms");
  this._setTransitionTimingFunction(this._FLING_TIMING_FUNCTION);
  this._resetDrawerTranslate();
}, _transitionend:function(event) {
  var target = Polymer.dom(event).rootTarget;
  if (target === this.$.contentContainer || target === this.$.scrim) {
    if (this._drawerState === this._DRAWER_STATE.FLINGING) {
      this._setTransitionDuration("");
      this._setTransitionTimingFunction("");
      this.style.visibility = "";
    }
    this._resetDrawerState();
  }
}, _setTransitionDuration:function(duration) {
  this.$.contentContainer.style.transitionDuration = duration;
  this.$.scrim.style.transitionDuration = duration;
}, _setTransitionTimingFunction:function(timingFunction) {
  this.$.contentContainer.style.transitionTimingFunction = timingFunction;
  this.$.scrim.style.transitionTimingFunction = timingFunction;
}, _translateDrawer:function(x) {
  var drawerWidth = this.getWidth();
  if (this.position === "left") {
    x = Math.max(-drawerWidth, Math.min(x, 0));
    this.$.scrim.style.opacity = 1 + x / drawerWidth;
  } else {
    x = Math.max(0, Math.min(x, drawerWidth));
    this.$.scrim.style.opacity = 1 - x / drawerWidth;
  }
  this.translate3d(x + "px", "0", "0", this.$.contentContainer);
}, _resetDrawerTranslate:function() {
  this.$.scrim.style.opacity = "";
  this.transform("", this.$.contentContainer);
}, _resetDrawerState:function() {
  var oldState = this._drawerState;
  if (this.opened) {
    this._drawerState = this.persistent ? this._DRAWER_STATE.OPENED_PERSISTENT : this._DRAWER_STATE.OPENED;
  } else {
    this._drawerState = this._DRAWER_STATE.CLOSED;
  }
  if (oldState !== this._drawerState) {
    if (this._drawerState === this._DRAWER_STATE.OPENED) {
      this._setKeyboardFocusTrap();
      document.addEventListener("keydown", this._boundEscKeydownHandler);
      document.body.style.overflow = "hidden";
    } else {
      document.removeEventListener("keydown", this._boundEscKeydownHandler);
      document.body.style.overflow = "";
    }
    if (oldState !== this._DRAWER_STATE.INIT) {
      this.fire("app-drawer-transitioned");
    }
  }
}, _setKeyboardFocusTrap:function() {
  if (this.noFocusTrap) {
    return;
  }
  var focusableElementsSelector = ['a[href]:not([tabindex="-1"])', 'area[href]:not([tabindex="-1"])', 'input:not([disabled]):not([tabindex="-1"])', 'select:not([disabled]):not([tabindex="-1"])', 'textarea:not([disabled]):not([tabindex="-1"])', 'button:not([disabled]):not([tabindex="-1"])', 'iframe:not([tabindex="-1"])', '[tabindex]:not([tabindex="-1"])', '[contentEditable=true]:not([tabindex="-1"])'].join(",");
  var focusableElements = Polymer.dom(this).querySelectorAll(focusableElementsSelector);
  if (focusableElements.length > 0) {
    this._firstTabStop = focusableElements[0];
    this._lastTabStop = focusableElements[focusableElements.length - 1];
  } else {
    this._firstTabStop = null;
    this._lastTabStop = null;
  }
  var tabindex = this.getAttribute("tabindex");
  if (tabindex && parseInt(tabindex, 10) > -1) {
    this.focus();
  } else {
    if (this._firstTabStop) {
      this._firstTabStop.focus();
    }
  }
}, _tabKeydownHandler:function(event) {
  if (this.noFocusTrap) {
    return;
  }
  var TAB_KEYCODE = 9;
  if (this._drawerState === this._DRAWER_STATE.OPENED && event.keyCode === TAB_KEYCODE) {
    if (event.shiftKey) {
      if (this._firstTabStop && Polymer.dom(event).localTarget === this._firstTabStop) {
        event.preventDefault();
        this._lastTabStop.focus();
      }
    } else {
      if (this._lastTabStop && Polymer.dom(event).localTarget === this._lastTabStop) {
        event.preventDefault();
        this._firstTabStop.focus();
      }
    }
  }
}, _MIN_FLING_THRESHOLD:0.2, _MIN_TRANSITION_VELOCITY:1.2, _FLING_TIMING_FUNCTION:"cubic-bezier(0.667, 1, 0.667, 1)", _FLING_INITIAL_SLOPE:1.5, _DRAWER_STATE:{INIT:0, OPENED:1, OPENED_PERSISTENT:2, CLOSED:3, TRACKING:4, FLINGING:5}});
Polymer({is:"app-drawer-layout", behaviors:[Polymer.IronResizableBehavior], properties:{forceNarrow:{type:Boolean, value:false}, responsiveWidth:{type:String, value:"640px"}, _narrow:Boolean}, listeners:{"tap":"_tapHandler", "app-drawer-reset-layout":"resetLayout"}, observers:["resetLayout(_narrow, isAttached)"], get drawer() {
  return Polymer.dom(this.$.drawerContent).getDistributedNodes()[0];
}, _tapHandler:function(e) {
  var target = Polymer.dom(e).localTarget;
  if (target && target.hasAttribute("drawer-toggle")) {
    this.drawer.toggle();
  }
}, resetLayout:function() {
  this.debounce("_resetLayout", function() {
    if (!this.isAttached) {
      return;
    }
    var drawer = this.drawer;
    var drawerWidth = this.drawer.getWidth();
    var contentContainer = this.$.contentContainer;
    if (this._narrow) {
      drawer.opened = drawer.persistent = false;
      contentContainer.classList.add("narrow");
      contentContainer.style.marginLeft = "";
      contentContainer.style.marginRight = "";
    } else {
      drawer.opened = drawer.persistent = true;
      contentContainer.classList.remove("narrow");
      if (drawer.position == "right") {
        contentContainer.style.marginLeft = "";
        contentContainer.style.marginRight = drawerWidth + "px";
      } else {
        contentContainer.style.marginLeft = drawerWidth + "px";
        contentContainer.style.marginRight = "";
      }
    }
    this.notifyResize();
  });
}, _computeMediaQuery:function(forceNarrow, responsiveWidth) {
  return forceNarrow ? "(min-width: 0px)" : "(max-width: " + responsiveWidth + ")";
}});
Polymer.IronScrollTargetBehavior = {properties:{scrollTarget:{type:HTMLElement, value:function() {
  return this._defaultScrollTarget;
}}}, observers:["_scrollTargetChanged(scrollTarget, isAttached)"], _scrollTargetChanged:function(scrollTarget, isAttached) {
  var eventTarget;
  if (this._oldScrollTarget) {
    eventTarget = this._oldScrollTarget === this._doc ? window : this._oldScrollTarget;
    eventTarget.removeEventListener("scroll", this._boundScrollHandler);
    this._oldScrollTarget = null;
  }
  if (!isAttached) {
    return;
  }
  if (scrollTarget === "document") {
    this.scrollTarget = this._doc;
  } else {
    if (typeof scrollTarget === "string") {
      this.scrollTarget = this.domHost ? this.domHost.$[scrollTarget] : Polymer.dom(this.ownerDocument).querySelector("#" + scrollTarget);
    } else {
      if (this._isValidScrollTarget()) {
        eventTarget = scrollTarget === this._doc ? window : scrollTarget;
        this._boundScrollHandler = this._boundScrollHandler || this._scrollHandler.bind(this);
        this._oldScrollTarget = scrollTarget;
        eventTarget.addEventListener("scroll", this._boundScrollHandler);
      }
    }
  }
}, _scrollHandler:function scrollHandler() {
}, get _defaultScrollTarget() {
  return this._doc;
}, get _doc() {
  return this.ownerDocument.documentElement;
}, get _scrollTop() {
  if (this._isValidScrollTarget()) {
    return this.scrollTarget === this._doc ? window.pageYOffset : this.scrollTarget.scrollTop;
  }
  return 0;
}, get _scrollLeft() {
  if (this._isValidScrollTarget()) {
    return this.scrollTarget === this._doc ? window.pageXOffset : this.scrollTarget.scrollLeft;
  }
  return 0;
}, set _scrollTop(top) {
  if (this.scrollTarget === this._doc) {
    window.scrollTo(window.pageXOffset, top);
  } else {
    if (this._isValidScrollTarget()) {
      this.scrollTarget.scrollTop = top;
    }
  }
}, set _scrollLeft(left) {
  if (this.scrollTarget === this._doc) {
    window.scrollTo(left, window.pageYOffset);
  } else {
    if (this._isValidScrollTarget()) {
      this.scrollTarget.scrollLeft = left;
    }
  }
}, scroll:function(left, top) {
  if (this.scrollTarget === this._doc) {
    window.scrollTo(left, top);
  } else {
    if (this._isValidScrollTarget()) {
      this.scrollTarget.scrollLeft = left;
      this.scrollTarget.scrollTop = top;
    }
  }
}, get _scrollTargetWidth() {
  if (this._isValidScrollTarget()) {
    return this.scrollTarget === this._doc ? window.innerWidth : this.scrollTarget.offsetWidth;
  }
  return 0;
}, get _scrollTargetHeight() {
  if (this._isValidScrollTarget()) {
    return this.scrollTarget === this._doc ? window.innerHeight : this.scrollTarget.offsetHeight;
  }
  return 0;
}, _isValidScrollTarget:function() {
  return this.scrollTarget instanceof HTMLElement;
}};
Polymer.AppLayout = Polymer.AppLayout || {};
Polymer.AppLayout._scrollEffects = Polymer.AppLayout._scrollEffects || {};
Polymer.AppLayout.scrollTimingFunction = function easeOutQuad(t, b, c, d) {
  t /= d;
  return -c * t * (t - 2) + b;
};
Polymer.AppLayout.registerEffect = function registerEffect(effectName, effectDef) {
  if (Polymer.AppLayout._scrollEffects[effectName] != null) {
    throw new Error("effect `" + effectName + "` is already registered.");
  }
  Polymer.AppLayout._scrollEffects[effectName] = effectDef;
};
Polymer.AppLayout.scroll = function scroll(options) {
  options = options || {};
  var docEl = document.documentElement;
  var target = options.target || docEl;
  var hasNativeScrollBehavior = "scrollBehavior" in target.style && target.scroll;
  var scrollClassName = "app-layout-silent-scroll";
  var scrollTop = options.top || 0;
  var scrollLeft = options.left || 0;
  var scrollTo = target === docEl ? window.scrollTo : function scrollTo(scrollLeft, scrollTop) {
    target.scrollLeft = scrollLeft;
    target.scrollTop = scrollTop;
  };
  if (options.behavior === "smooth") {
    if (hasNativeScrollBehavior) {
      target.scroll(options);
    } else {
      var timingFn = Polymer.AppLayout.scrollTimingFunction;
      var startTime = Date.now();
      var currentScrollTop = target === docEl ? window.pageYOffset : target.scrollTop;
      var currentScrollLeft = target === docEl ? window.pageXOffset : target.scrollLeft;
      var deltaScrollTop = scrollTop - currentScrollTop;
      var deltaScrollLeft = scrollLeft - currentScrollLeft;
      var duration = 300;
      (function updateFrame() {
        var now = Date.now();
        var elapsedTime = now - startTime;
        if (elapsedTime < duration) {
          scrollTo(timingFn(elapsedTime, currentScrollLeft, deltaScrollLeft, duration), timingFn(elapsedTime, currentScrollTop, deltaScrollTop, duration));
          requestAnimationFrame(updateFrame.bind(this));
        }
      }).call(this);
    }
  } else {
    if (options.behavior === "silent") {
      docEl.classList.add(scrollClassName);
      clearInterval(Polymer.AppLayout._scrollTimer);
      Polymer.AppLayout._scrollTimer = setTimeout(function() {
        docEl.classList.remove(scrollClassName);
        Polymer.AppLayout._scrollTimer = null;
      }, 100);
      scrollTo(scrollLeft, scrollTop);
    } else {
      scrollTo(scrollLeft, scrollTop);
    }
  }
};
Polymer.AppScrollEffectsBehavior = [Polymer.IronScrollTargetBehavior, {properties:{effects:{type:String}, effectsConfig:{type:Object, value:function() {
  return {};
}}, disabled:{type:Boolean, reflectToAttribute:true, value:false}}, observers:["_effectsChanged(effects, effectsConfig)"], _updateScrollState:function() {
}, isOnScreen:function() {
  return false;
}, isContentBelow:function() {
  return false;
}, _effectsRunFn:null, _effects:null, get _clampedScrollTop() {
  return Math.max(0, this._scrollTop);
}, detached:function() {
  this._tearDownEffects();
}, createEffect:function(effectName, effectConfig) {
  var effectDef = Polymer.AppLayout._scrollEffects[effectName];
  if (!effectDef) {
    throw new ReferenceError(this._getUndefinedMsg(effectName));
  }
  var prop = this._boundEffect(effectDef, effectConfig || {});
  prop.setUp();
  return prop;
}, _effectsChanged:function(effects, effectsConfig) {
  this._tearDownEffects();
  if (effects === "") {
    return;
  }
  effects.split(" ").forEach(function(effectName) {
    var effectDef;
    if (effectName !== "") {
      if (effectDef = Polymer.AppLayout._scrollEffects[effectName]) {
        this._effects.push(this._boundEffect(effectDef, effectsConfig[effectName]));
      } else {
        this._warn(this._logf("_effectsChanged", this._getUndefinedMsg(effectName)));
      }
    }
  }, this);
  this._setUpEffect();
}, _layoutIfDirty:function() {
  return this.offsetWidth;
}, _boundEffect:function(effectDef, effectsConfig) {
  effectsConfig = effectsConfig || {};
  var startsAt = parseFloat(effectsConfig.startsAt || 0);
  var endsAt = parseFloat(effectsConfig.endsAt || 1);
  var deltaS = endsAt - startsAt;
  var noop = Function();
  var runFn = startsAt === 0 && endsAt === 1 ? effectDef.run : function(progress, y) {
    effectDef.run.call(this, Math.max(0, (progress - startsAt) / deltaS), y);
  };
  return {setUp:effectDef.setUp ? effectDef.setUp.bind(this, effectsConfig) : noop, run:effectDef.run ? runFn.bind(this) : noop, tearDown:effectDef.tearDown ? effectDef.tearDown.bind(this) : noop};
}, _setUpEffect:function() {
  if (this.isAttached && this._effects) {
    this._effectsRunFn = [];
    this._effects.forEach(function(effectDef) {
      if (effectDef.setUp() !== false) {
        this._effectsRunFn.push(effectDef.run);
      }
    }, this);
  }
}, _tearDownEffects:function() {
  if (this._effects) {
    this._effects.forEach(function(effectDef) {
      effectDef.tearDown();
    });
  }
  this._effectsRunFn = [];
  this._effects = [];
}, _runEffects:function(p, y) {
  if (this._effectsRunFn) {
    this._effectsRunFn.forEach(function(run) {
      run(p, y);
    });
  }
}, _scrollHandler:function() {
  if (!this.disabled) {
    this._updateScrollState(this._clampedScrollTop);
  }
}, _getUndefinedMsg:function(effectName) {
  return "Scroll effect `" + effectName + "` is undefined. " + "Did you forget to import app-layout/app-scroll-effects/effects/" + effectName + ".html ?";
}}];
Polymer({is:"app-header", behaviors:[Polymer.AppScrollEffectsBehavior, Polymer.IronResizableBehavior], properties:{condenses:{type:Boolean, value:false}, fixed:{type:Boolean, value:false}, reveals:{type:Boolean, value:false}, shadow:{type:Boolean, reflectToAttribute:true, value:false}}, observers:["resetLayout(isAttached, condenses, fixed)"], listeners:{"iron-resize":"_resizeHandler"}, _height:0, _dHeight:0, _primaryElTop:0, _primaryEl:null, _top:0, _progress:0, _wasScrollingDown:false, _initScrollTop:0, 
_initTimestamp:0, _lastTimestamp:0, _lastScrollTop:0, get _maxHeaderTop() {
  return this.fixed ? this._dHeight : this._height + 5;
}, _getPrimaryEl:function() {
  var primaryEl;
  var nodes = Polymer.dom(this.$.content).getDistributedNodes();
  for (var i = 0; i < nodes.length; i++) {
    if (nodes[i].nodeType === Node.ELEMENT_NODE) {
      var node = nodes[i];
      if (node.hasAttribute("primary")) {
        primaryEl = node;
        break;
      } else {
        if (!primaryEl) {
          primaryEl = node;
        }
      }
    }
  }
  return primaryEl;
}, resetLayout:function() {
  this.fire("app-header-reset-layout");
  this.debounce("_resetLayout", function() {
    if (this.offsetWidth === 0 && this.offsetHeight === 0) {
      return;
    }
    var scrollTop = this._clampedScrollTop;
    var firstSetup = this._height === 0 || scrollTop === 0;
    var currentDisabled = this.disabled;
    this._height = this.offsetHeight;
    this._primaryEl = this._getPrimaryEl();
    this.disabled = true;
    if (!firstSetup) {
      this._updateScrollState(0, true);
    }
    if (this._mayMove()) {
      this._dHeight = this._primaryEl ? this._height - this._primaryEl.offsetHeight : 0;
    } else {
      this._dHeight = 0;
    }
    this._primaryElTop = this._primaryEl ? this._primaryEl.offsetTop : 0;
    this._setUpEffect();
    if (firstSetup) {
      this._updateScrollState(scrollTop, true);
    } else {
      this._updateScrollState(this._lastScrollTop, true);
      this._layoutIfDirty();
    }
    this.disabled = currentDisabled;
  });
}, _updateScrollState:function(scrollTop, forceUpdate) {
  if (this._height === 0) {
    return;
  }
  var progress = 0;
  var top = 0;
  var lastTop = this._top;
  var lastScrollTop = this._lastScrollTop;
  var maxHeaderTop = this._maxHeaderTop;
  var dScrollTop = scrollTop - this._lastScrollTop;
  var absDScrollTop = Math.abs(dScrollTop);
  var isScrollingDown = scrollTop > this._lastScrollTop;
  var now = Date.now();
  if (this._mayMove()) {
    top = this._clamp(this.reveals ? lastTop + dScrollTop : scrollTop, 0, maxHeaderTop);
  }
  if (scrollTop >= this._dHeight) {
    top = this.condenses ? Math.max(this._dHeight, top) : top;
    this.style.transitionDuration = "0ms";
  }
  if (this.reveals && !this.disabled && absDScrollTop < 100) {
    if (now - this._initTimestamp > 300 || this._wasScrollingDown !== isScrollingDown) {
      this._initScrollTop = scrollTop;
      this._initTimestamp = now;
    }
    if (scrollTop >= maxHeaderTop) {
      if (Math.abs(this._initScrollTop - scrollTop) > 30 || absDScrollTop > 10) {
        if (isScrollingDown && scrollTop >= maxHeaderTop) {
          top = maxHeaderTop;
        } else {
          if (!isScrollingDown && scrollTop >= this._dHeight) {
            top = this.condenses ? this._dHeight : 0;
          }
        }
        var scrollVelocity = dScrollTop / (now - this._lastTimestamp);
        this.style.transitionDuration = this._clamp((top - lastTop) / scrollVelocity, 0, 300) + "ms";
      } else {
        top = this._top;
      }
    }
  }
  if (this._dHeight === 0) {
    progress = scrollTop > 0 ? 1 : 0;
  } else {
    progress = top / this._dHeight;
  }
  if (!forceUpdate) {
    this._lastScrollTop = scrollTop;
    this._top = top;
    this._wasScrollingDown = isScrollingDown;
    this._lastTimestamp = now;
  }
  if (forceUpdate || progress !== this._progress || lastTop !== top || scrollTop === 0) {
    this._progress = progress;
    this._runEffects(progress, top);
    this._transformHeader(top);
  }
}, _mayMove:function() {
  return this.condenses || !this.fixed;
}, willCondense:function() {
  return this._dHeight > 0 && this.condenses;
}, isOnScreen:function() {
  return this._height !== 0 && this._top < this._height;
}, isContentBelow:function() {
  if (this._top === 0) {
    return this._clampedScrollTop > 0;
  }
  return this._clampedScrollTop - this._maxHeaderTop >= 0;
}, _transformHeader:function(y) {
  this.translate3d(0, -y + "px", 0);
  if (this._primaryEl && this.condenses && y >= this._primaryElTop) {
    this.translate3d(0, Math.min(y, this._dHeight) - this._primaryElTop + "px", 0, this._primaryEl);
  }
}, _resizeHandler:function() {
  this.resetLayout();
}, _clamp:function(v, min, max) {
  return Math.min(max, Math.max(min, v));
}, getScrollState:function() {
  return {progress:this._progress, top:this._top};
}});
Polymer({is:"app-header-layout", behaviors:[Polymer.IronResizableBehavior], properties:{hasScrollingRegion:{type:Boolean, value:false, reflectToAttribute:true}}, listeners:{"iron-resize":"_resizeHandler", "app-header-reset-layout":"resetLayout"}, observers:["resetLayout(isAttached, hasScrollingRegion)"], get header() {
  return Polymer.dom(this.$.header).getDistributedNodes()[0];
}, resetLayout:function() {
  this._updateScroller();
  this.debounce("_resetLayout", this._updateContentPosition);
}, _updateContentPosition:function() {
  var header = this.header;
  if (!this.isAttached || !header) {
    return;
  }
  var headerHeight = header.offsetHeight;
  if (!this.hasScrollingRegion) {
    var rect = this.getBoundingClientRect();
    var rightOffset = document.documentElement.clientWidth - rect.right;
    header.style.left = rect.left + "px";
    header.style.right = rightOffset + "px";
  } else {
    header.style.left = "";
    header.style.right = "";
  }
  var containerStyle = this.$.contentContainer.style;
  if (header.fixed && !header.willCondense() && this.hasScrollingRegion) {
    containerStyle.marginTop = headerHeight + "px";
    containerStyle.paddingTop = "";
  } else {
    containerStyle.paddingTop = headerHeight + "px";
    containerStyle.marginTop = "";
  }
}, _updateScroller:function() {
  if (!this.isAttached) {
    return;
  }
  var header = this.header;
  if (header) {
    header.scrollTarget = this.hasScrollingRegion ? this.$.contentContainer : this.ownerDocument.documentElement;
  }
}, _resizeHandler:function() {
  this.resetLayout();
}});
Polymer({is:"app-toolbar"});
Polymer.AppLayout.registerEffect("blend-background", {setUp:function setUp() {
  this.$.backgroundFrontLayer.style.willChange = "opacity";
  this.$.backgroundFrontLayer.style.webkitTransform = "translateZ(0)";
  this.$.backgroundRearLayer.style.willChange = "opacity";
  this.$.backgroundRearLayer.style.webkitTransform = "translateZ(0)";
  this.$.backgroundRearLayer.style.opacity = 0;
}, run:function run(p, y) {
  this.$.backgroundFrontLayer.style.opacity = 1 - p;
  this.$.backgroundRearLayer.style.opacity = p;
}});
Polymer.AppLayout.registerEffect("fade-background", {setUp:function setUp(config) {
  var duration = config.duration || "0.5s";
  this.$.backgroundFrontLayer.style.willChange = "opacity";
  this.$.backgroundFrontLayer.style.webkitTransform = "translateZ(0)";
  this.$.backgroundFrontLayer.style.transitionProperty = "opacity";
  this.$.backgroundFrontLayer.style.transitionDuration = duration;
  this.$.backgroundRearLayer.style.willChange = "opacity";
  this.$.backgroundRearLayer.style.webkitTransform = "translateZ(0)";
  this.$.backgroundRearLayer.style.transitionProperty = "opacity";
  this.$.backgroundRearLayer.style.transitionDuration = duration;
}, run:function run(p, y) {
  if (p >= 1) {
    this.$.backgroundFrontLayer.style.opacity = 0;
    this.$.backgroundRearLayer.style.opacity = 1;
  } else {
    this.$.backgroundFrontLayer.style.opacity = 1;
    this.$.backgroundRearLayer.style.opacity = 0;
  }
}});
Polymer.AppLayout.registerEffect("waterfall", {run:function run(p, y) {
  this.shadow = this.isOnScreen() && this.isContentBelow();
}});
(function() {
  function interpolate(progress, points, fn, ctx) {
    fn.apply(ctx, points.map(function(point) {
      return point[0] + (point[1] - point[0]) * progress;
    }));
  }
  Polymer.AppLayout.registerEffect("resize-title", {setUp:function setUp() {
    var title = Polymer.dom(this).querySelector("[title]");
    var condensedTitle = Polymer.dom(this).querySelector("[condensed-title]");
    if (!condensedTitle) {
      this._warn(this._logf("effects[resize-title]", "undefined `condensed-title`"));
      return false;
    }
    if (!title) {
      this._warn(this._logf("effects[resize-title]", "undefined `title`"));
      return false;
    }
    condensedTitle.style.willChange = "opacity";
    title.style.willChange = "opacity";
    condensedTitle.style.webkitTransform = "translateZ(0)";
    title.style.webkitTransform = "translateZ(0)";
    var titleClientRect = title.getBoundingClientRect();
    var condensedTitleClientRect = condensedTitle.getBoundingClientRect();
    var fx = {};
    fx.scale = parseInt(window.getComputedStyle(condensedTitle)["font-size"], 10) / parseInt(window.getComputedStyle(title)["font-size"], 10);
    fx.titleDX = titleClientRect.left - condensedTitleClientRect.left;
    fx.titleDY = titleClientRect.top - condensedTitleClientRect.top;
    fx.condensedTitle = condensedTitle;
    fx.title = title;
    this._fxResizeTitle = fx;
  }, tearDown:function tearDown() {
    delete this._fxResizeTitle;
  }, run:function run(p, y) {
    var fx = this._fxResizeTitle;
    if (!this.condenses) {
      y = 0;
    }
    if (p >= 1) {
      fx.title.style.opacity = 0;
      fx.condensedTitle.style.opacity = 1;
    } else {
      fx.title.style.opacity = 1;
      fx.condensedTitle.style.opacity = 0;
    }
    interpolate(Math.min(1, p), [[1, fx.scale], [0, -fx.titleDX], [y, y - fx.titleDY]], function(scale, translateX, translateY) {
      this.transform("translate(" + translateX + "px, " + translateY + "px) " + "scale3d(" + scale + ", " + scale + ", 1)", fx.title);
    }, this);
  }});
})();
Polymer.AppLayout.registerEffect("parallax-background", {setUp:function setUp(config) {
  var scalar = parseFloat(config.scalar);
  this._deltaBg = this.$.backgroundFrontLayer.offsetHeight - this.$.background.offsetHeight;
  if (this._deltaBg === 0) {
    if (isNaN(scalar)) {
      scalar = 0.8;
    }
    this._deltaBg = this._dHeight * scalar;
  } else {
    if (isNaN(scalar)) {
      scalar = 1;
    }
    this._deltaBg = this._deltaBg * scalar;
  }
}, tearDown:function tearDown() {
  delete this._deltaBg;
}, run:function run(p, y) {
  this.transform("translate3d(0px, " + this._deltaBg * Math.min(1, p) + "px, 0px)", this.$.backgroundFrontLayer);
  if (this.$.backgroundRearLayer) {
    this.transform("translate3d(0px, " + this._deltaBg * Math.min(1, p) + "px, 0px)", this.$.backgroundRearLayer);
  }
}});
Polymer.AppLayout.registerEffect("material", {setUp:function setUp() {
  this.effects = "waterfall resize-title blend-background parallax-background";
  return false;
}});
Polymer.AppLayout.registerEffect("resize-snapped-title", {setUp:function setUp(config) {
  var title = Polymer.dom(this).querySelector("[title]");
  var condensedTitle = Polymer.dom(this).querySelector("[condensed-title]");
  var duration = config.duration || "0.2s";
  var fx = {};
  if (!condensedTitle) {
    this._warn(this._logf("effects[resize-snapped-title]", "undefined `condensed-title`"));
    return false;
  }
  if (!title) {
    this._warn(this._logf("effects[resize-snapped-title]", "undefined `title`"));
    return false;
  }
  title.style.transitionProperty = "opacity";
  title.style.transitionDuration = duration;
  condensedTitle.style.transitionProperty = "opacity";
  condensedTitle.style.transitionDuration = duration;
  fx.condensedTitle = condensedTitle;
  fx.title = title;
  this._fxResizeSnappedTitle = fx;
}, tearDown:function tearDown() {
  var fx = this._fxResizeSnappedTitle;
  fx.title.style.transition = "";
  fx.condensedTitle.style.transition = "";
  delete this._fxResizeSnappedTitle;
}, run:function run(p, y) {
  var fx = this._fxResizeSnappedTitle;
  if (p > 0) {
    fx.title.style.opacity = 0;
    fx.condensedTitle.style.opacity = 1;
  } else {
    fx.title.style.opacity = 1;
    fx.condensedTitle.style.opacity = 0;
  }
}});
(function() {
  var sharedPanel = null;
  function classNames(obj) {
    var classes = [];
    for (var key in obj) {
      if (obj.hasOwnProperty(key) && obj[key]) {
        classes.push(key);
      }
    }
    return classes.join(" ");
  }
  Polymer({is:"paper-multidrawer-panel", behaviors:[Polymer.IronResizableBehavior], properties:{defaultSelected:{type:String, value:"main"}, disableLeftEdgeSwipe:{type:Boolean, value:false}, disableRightEdgeSwipe:{type:Boolean, value:false}, disableSwipe:{type:Boolean, value:false}, dragging:{type:Boolean, value:false, readOnly:true, notify:true}, drawerWidth:{type:String, value:"256px"}, leftDrawerWidth:{type:String, value:null}, rightDrawerWidth:{type:String, value:null}, edgeSwipeSensitivity:{type:Number, 
  value:30}, forceNarrow:{type:Boolean, value:false}, forceLeftDrawerTemporary:{type:Boolean, value:false, observer:"_forceLeftDrawerTemporaryChanged"}, forceRightDrawerTemporary:{type:Boolean, value:false, observer:"_forceRightDrawerTemporaryChanged"}, hasTransform:{type:Boolean, value:function() {
    return "transform" in this.style;
  }}, hasWillChange:{type:Boolean, value:function() {
    return "willChange" in this.style;
  }}, narrow:{reflectToAttribute:true, type:Boolean, value:false, readOnly:true, notify:true}, leftDrawerTemporary:{reflectToAttribute:true, type:Boolean, value:false, readOnly:true, notify:true}, rightDrawerTemporary:{reflectToAttribute:true, type:Boolean, value:false, readOnly:true, notify:true}, peeking:{type:Boolean, value:false, readOnly:true, notify:true}, responsiveWidth:{type:String, value:"600px"}, responsiveWidthLeft:{type:String, value:null}, responsiveWidthRight:{type:String, value:null}, 
  selected:{reflectToAttribute:true, notify:true, type:String, value:null}, leftDrawerToggleAttribute:{type:String, value:"paper-multidrawer-toggle-left"}, rightDrawerToggleAttribute:{type:String, value:"paper-multidrawer-toggle-right"}, _transition:{type:Boolean, value:false}, _leftDrawer:{type:Boolean, value:false, readOnly:true, notify:true}, _rightDrawer:{type:Boolean, value:false, readOnly:true, notify:true}, _movingDrawer:{type:Object, value:null}, _lastInteractedDrawer:{type:String, value:null, 
  readOnly:true}}, listeners:{tap:"_onTap", track:"_onTrack", down:"_downHandler", up:"_upHandler"}, observers:["_forceNarrowChanged(forceNarrow, defaultSelected)"], ready:function() {
    this._transition = true;
    this._set_leftDrawer(!!Polymer.dom(this.$.leftDrawerContent).getDistributedNodes().length);
    this._responsiveChange(this.$.mqResponsiveWidthLeft.queryMatches || this.forceLeftDrawerTemporary, "leftDrawerTemporary");
    this._set_rightDrawer(!!Polymer.dom(this.$.rightDrawerContent).getDistributedNodes().length);
    this._responsiveChange(this.$.mqResponsiveWidthRight.queryMatches || this.forceRightDrawerTemporary, "rightDrawerTemporary");
  }, toggleLeftPanel:function() {
    console.log("toggleLeftPanel:", this.leftDrawerTemporary);
    console.log("toggleLeftPanel.main:", this._isMainSelected());
    if (true || this.leftDrawerTemporary) {
      if (this._isMainSelected() || this._isRightDrawerSelected()) {
        this.openLeftDrawer();
      } else {
      }
    }
  }, toggleRightPanel:function() {
    if (this.rightDrawerTemporary) {
      if (this._isMainSelected() || this._isLeftDrawerSelected()) {
        this.openRightDrawer();
      } else {
        this.closeDrawer();
      }
    }
  }, openLeftDrawer:function() {
    if (this._leftDrawer) {
      this._set_lastInteractedDrawer("left");
      this.selected = "leftDrawer";
      this._movingDrawer = this.$.leftDrawer;
    }
  }, openRightDrawer:function() {
    if (this._rightDrawer) {
      this._set_lastInteractedDrawer("right");
      this.selected = "rightDrawer";
      this._movingDrawer = this.$.rightDrawer;
    }
  }, closeDrawer:function() {
    this.selected = "main";
    this._movingDrawer = null;
  }, _onMainTransitionEnd:function(e) {
    if (e.currentTarget === this.$.main && (e.propertyName === "left" || e.propertyName === "right")) {
      this.notifyResize();
    }
  }, _computeIronSelectorClass:function(narrow, transition, leftDrawer, rightDrawer, dragging, peeking, leftDrawerTemporary, rightDrawerTemporary) {
    return classNames({"dragging":dragging, "narrow-layout":narrow, "left-drawer":leftDrawer, "right-drawer":rightDrawer, transition:transition, peeking:peeking, "left-drawer-temporary":leftDrawerTemporary || narrow && leftDrawer, "right-drawer-temporary":rightDrawerTemporary || narrow && rightDrawer});
  }, _computeDrawerStyle:function(drawerWidth, drawerWidthBySide) {
    return "width:" + (drawerWidthBySide ? drawerWidthBySide : drawerWidth) + ";";
  }, _computeMainStyle:function(narrow, leftDrawer, rightDrawer, forceLeftDrawerTemporary, forceRightDrawerTemporary, drawerWidth, leftDrawerWidth, rightDrawerWidth) {
    var style = "";
    if (narrow || forceLeftDrawerTemporary || !leftDrawer) {
      style += "left:0;";
    } else {
      style += "left:0" + (leftDrawerWidth ? leftDrawerWidth : drawerWidth) + ";";
    }
    if (narrow || forceRightDrawerTemporary || !rightDrawer) {
      style += "right:0;";
    } else {
      style += "right:" + (rightDrawerWidth ? rightDrawerWidth : drawerWidth) + ";";
    }
    return style;
  }, _computeMediaQuery:function(forceNarrow, queryWidth) {
    return forceNarrow ? "" : "(max-width: " + queryWidth + ")";
  }, _computeSideMediaQuery:function(forceNarrow, forceTemporary, queryWidth) {
    return forceNarrow || forceTemporary ? "" : "(max-width: " + queryWidth + ")";
  }, _responsiveChange:function(value, source) {
    switch(source) {
      case "narrow":
        this._setNarrow(value);
        if (this.narrow) {
          this.selected = this.defaultSelected;
        }
        this.setScrollDirection(this._swipeAllowed() ? "y" : "all");
        this.fire("paper-responsive-change", {narrow:this.narrow});
        break;
      case "leftDrawerTemporary":
        if (this._leftDrawer) {
          if (this.narrow) {
            this._setLeftDrawerTemporary(true);
          } else {
            this._setLeftDrawerTemporary(value);
          }
          this.selected = this.defaultSelected;
          this.setScrollDirection(this._swipeAllowed() ? "y" : "all");
          this.fire("paper-responsive-change", {leftDrawerTemporary:this.leftDrawerTemporary});
        }
        break;
      case "rightDrawerTemporary":
        if (this._rightDrawer) {
          if (this.narrow) {
            this._setRightDrawerTemporary(true);
          } else {
            this._setRightDrawerTemporary(value);
          }
          this.selected = this.defaultSelected;
          this.setScrollDirection(this._swipeAllowed() ? "y" : "all");
          this.fire("paper-responsive-change", {rightDrawerTemporary:this.rightDrawerTemporary});
        }
        break;
      default:
        break;
    }
  }, _onQueryMatchesChanged:function(event) {
    var target = event.target || event.srcElement;
    switch(target.id) {
      case "mqResponsiveWidth":
        this._responsiveChange(event.detail.value, "narrow");
        break;
      case "mqResponsiveWidthLeft":
        this._responsiveChange(event.detail.value, "leftDrawerTemporary");
        break;
      case "mqResponsiveWidthRight":
        this._responsiveChange(event.detail.value, "rightDrawerTemporary");
        break;
      default:
        break;
    }
  }, _forceNarrowChanged:function() {
    this._responsiveChange(this.forceNarrow || this.$.mqResponsiveWidth.queryMatches, "narrow");
  }, _forceLeftDrawerTemporaryChanged:function() {
    this._responsiveChange(this.forceLeftDrawerTemporary || this.$.mqResponsiveWidthLeft.queryMatches, "leftDrawerTemporary");
  }, _forceRightDrawerTemporaryChanged:function() {
    this._responsiveChange(this.forceRightDrawerTemporary || this.$.mqResponsiveWidthRight.queryMatches, "rightDrawerTemporary");
  }, _swipeAllowed:function() {
    return (this.narrow || this.leftDrawerTemporary || this.rightDrawerTemporary) && !this.disableSwipe;
  }, _isMainSelected:function() {
    return this.selected === "main";
  }, _isLeftDrawerSelected:function() {
    return this.selected === "leftDrawer";
  }, _isRightDrawerSelected:function() {
    return this.selected === "rightDrawer";
  }, _onTap:function(event) {
    var targetElement = Polymer.dom(event).localTarget;
    var isTargetLeftToggleElement = targetElement && this.leftDrawerToggleAttribute && targetElement.hasAttribute(this.leftDrawerToggleAttribute);
    if (isTargetLeftToggleElement) {
      this.toggleLeftPanel();
    }
    var isTargetRightToggleElement = targetElement && this.rightDrawerToggleAttribute && targetElement.hasAttribute(this.rightDrawerToggleAttribute);
    if (isTargetRightToggleElement) {
      this.toggleRightPanel();
    }
  }, _downHandler:function(event) {
    var edge = this._isEdgeTouch(event);
    if (!this.dragging && this._isMainSelected() && !!edge && !sharedPanel) {
      this._startEdgePeek(edge);
      event.preventDefault();
      sharedPanel = this;
    }
  }, _upHandler:function() {
    this._stopEdgePeek();
    sharedPanel = null;
  }, _onTrack:function(event) {
    if (sharedPanel && this !== sharedPanel) {
      return;
    }
    switch(event.detail.state) {
      case "start":
        this._trackStart(event);
        break;
      case "track":
        this._trackX(event);
        break;
      case "end":
        this._trackEnd(event);
        break;
    }
  }, _isEdgeTouch:function(event) {
    var x = event.detail.x;
    if (this._swipeAllowed()) {
      if (x <= this.edgeSwipeSensitivity && this.leftDrawerTemporary && !this.disableLeftEdgeSwipe) {
        this._set_lastInteractedDrawer("left");
        return "left";
      } else {
        if (x >= this.offsetWidth - this.edgeSwipeSensitivity && this.rightDrawerTemporary && !this.disableRightEdgeSwipe) {
          this._set_lastInteractedDrawer("right");
          return "right";
        }
      }
    }
    return false;
  }, _startEdgePeek:function(edge) {
    var x;
    switch(edge) {
      case "left":
        this._movingDrawer = this.$.leftDrawer;
        x = this.edgeSwipeSensitivity;
        break;
      case "right":
        this._movingDrawer = this.$.rightDrawer;
        x = -this.edgeSwipeSensitivity;
        break;
      default:
        return;
    }
    this.width = this._movingDrawer.offsetWidth;
    this._moveDrawer(this._movingDrawer, this._translateXForDeltaX(x));
    this._setPeeking(true);
  }, _stopEdgePeek:function() {
    if (this.peeking) {
      this._setPeeking(false);
      this._moveDrawer(this._movingDrawer, null);
    }
  }, _trackStart:function(event) {
    var edge;
    if (this._swipeAllowed()) {
      sharedPanel = this;
      this._setDragging(true);
      if (this._isMainSelected()) {
        edge = this._isEdgeTouch(event);
        this._setDragging(this.peeking || !!edge);
      }
      if (this.dragging) {
        if (!this._movingDrawer) {
          switch(edge) {
            case "left":
              this._movingDrawer = this.$.leftDrawer;
              break;
            case "right":
              this._movingDrawer = this.$.rightDrawer;
              break;
            default:
              return;
          }
        }
        this.width = this._movingDrawer.offsetWidth;
        this._transition = false;
      }
    }
  }, _trackEnd:function(event) {
    if (this.dragging) {
      var xDirection = event.detail.dx > 0;
      this._setDragging(false);
      this._transition = true;
      sharedPanel = null;
      this._moveDrawer(this._movingDrawer, null);
      if (this._movingDrawer.id === "rightDrawer") {
        if (xDirection) {
          this.closeDrawer();
          this._movingDrawer = null;
        } else {
          this.openRightDrawer();
        }
      } else {
        if (!xDirection) {
          this.closeDrawer();
          this._movingDrawer = null;
        } else {
          this.openLeftDrawer();
        }
      }
    }
  }, _trackX:function(event) {
    if (this.dragging) {
      var dx = event.detail.dx;
      if (this.peeking) {
        if (Math.abs(dx) <= this.edgeSwipeSensitivity) {
          return;
        }
        this._setPeeking(false);
      }
      this._moveDrawer(this._movingDrawer, this._translateXForDeltaX(dx));
    }
  }, _translateXForDeltaX:function(deltaX) {
    var isMain = this._isMainSelected();
    if (this._movingDrawer.id === "rightDrawer") {
      return Math.max(0, isMain ? this.width + deltaX : deltaX);
    } else {
      return Math.min(0, isMain ? deltaX - this.width : deltaX);
    }
  }, _transformForTranslateX:function(translateX) {
    if (translateX === null) {
      return "";
    }
    return this.hasWillChange ? "translateX(" + translateX + "px)" : "translate3d(" + translateX + "px, 0, 0)";
  }, _moveDrawer:function(drawer, translateX) {
    this.transform(this._transformForTranslateX(translateX), drawer);
  }});
})();
DialogBehavior = {closeDialog:function(dia) {
  $(dia).fadeOut({duration:400, complete:function() {
    $(dia).dialog("close");
  }});
}, destroyDialog:function(dia) {
  $(dia).fadeOut({duration:400, complete:function() {
    $(dia).dialog("destroy");
  }});
}, openDialog:function(dia, _width) {
  var width = _width || "80%";
  if (window.matchMedia("(max-width: 480px)").matches) {
    width = "95%";
  }
  var sd = $(dia).dialog({open:function(event, ui) {
    $(dia).hide();
    $(dia).fadeIn(1000);
  }, resizable:true, draggable:true, closeText:"", title:"", height:"auto", width:width, modal:true});
  sd.parent().css("z-index", "555111");
  return sd;
}};
RegistryBehavior = {onRegistrySave:function() {
  this.debounce("onRegistrySave", function() {
    this._onRegistrySave();
  }, 250);
}, _onRegistrySave:function() {
  this._doSave(this._currentRegistryName);
}, onRegistrySaveUnder:function() {
  var json = this.getState();
  var prompt = Lobibox.prompt("text", {height:200, title:tr("te.enter_name"), attrs:{pattern:"[A-Za-z0-9]{3,}", value:this._currentRegistryName}, callback:function($this, type, ev) {
    console.log("callback:", prompt.getValue());
    if (!_.isEmpty(prompt.getValue())) {
      this._doSave(prompt.getValue());
    }
  }.bind(this)});
}, _doSave:function(name) {
  var json = this.getState();
  this._currentRegistryName = name;
  var attributes = this._registryAttributes;
  if (attributes == null) {
    attributes = {subject:this._registrySubject};
  }
  var params = {service:"registry", method:"set", parameter:{key:this._registryKey + "/" + name, attributes:attributes, value:JSON.stringify(json)}, async:true, context:this, failed:function(e) {
    console.error("_doSave:", e);
    if (e == null) {
      return;
    }
    this.notify(tr("error"), "error", 8000);
  }, completed:function(ret) {
    this.notify(tr("registry.saved"), "success", 8000);
  }};
  simpl4.util.Rpc.rpcAsync(params);
}, selectFromList:function(menu, valueList, nameList) {
  var win = Lobibox.window({title:tr("registry.select"), width:300, height:400, modal:true, content:function() {
    return $(menu);
  }, buttons:{select:{text:tr("button.select")}, close:{text:tr("button.cancel"), closeOnClick:true}}, callback:function($this, type, ev) {
    if (type === "select") {
      var selected = $this.$el[0].querySelector("#registryMenuId").selected;
      if (selected == null) {
        return;
      }
      this._currentRegistryName = nameList[selected];
      var state = JSON.parse(valueList[selected]);
      this.setState(state);
      win.destroy();
    }
  }.bind(this)});
}, onRegistryLoad:function() {
  this.debounce("onRegistryLoad", function() {
    this._onRegistryLoad();
  }, 250);
}, _onRegistryLoad:function() {
  var attributes = this._registryAttributes;
  if (attributes == null) {
    attributes = {subject:this._registrySubject};
  }
  var params = {service:"registry", method:"getAll", parameter:{attributes:attributes}, async:true, context:this, failed:function(e) {
    console.error("getRegistry:", e);
    this.notify(tr("error"), "error", 8000);
  }, completed:function(ret) {
    console.log("getRegistry.ret:", ret);
    var menu = '<paper-menu id="registryMenuId">';
    var valueList = [];
    var nameList = [];
    for (var i = 0; i < ret.length; i++) {
      var key = ret[i].key;
      var name = key.substring(key.lastIndexOf("/") + 1);
      menu += '<paper-item style="min-height:24px; font-size:14px;">' + name + "</paper-item>";
      valueList.push(ret[i].value);
      nameList.push(name);
    }
    menu += "</paper-menu>";
    this.selectFromList(menu, valueList, nameList);
  }};
  simpl4.util.Rpc.rpcAsync(params);
}};
"use strict";
if (!String.format) {
  String.format = function(format) {
    var args = Array.prototype.slice.call(arguments, 1);
    return format.replace(/{(\d+)}/g, function(match, number) {
      return typeof args[number] !== "undefined" ? args[number] : match;
    });
  };
}
if (!String.slugify) {
  String.slugify = function(input) {
    return input.replace(/^\s\s*/, "").replace(/\s\s*$/, "").toLowerCase().replace(/[^a-z0-9_\-~!\+\s]+/g, "").replace(/[\s]+/g, "-");
  };
}
var Simpl4 = Simpl4 || {};
Simpl4.Utils = function() {
  var isArrayMatch = function(target, toMatch) {
    var found, targetMap, i, j, cur;
    found = false;
    targetMap = {};
    if (!target || !toMatch) {
      return false;
    }
    for (i = 0, j = target.length; i < j; i++) {
      cur = target[i];
      targetMap[cur] = true;
    }
    for (i = 0, j = toMatch.length; !found && i < j; i++) {
      cur = toMatch[i];
      found = !!targetMap[cur];
    }
    return found;
  };
  return {isArrayMatch:isArrayMatch};
}();
Simpl4.Cache = function() {
  var cache = new Cache(-1, false, new Cache.LocalStorageCacheStorage);
  var getItem = function(item) {
    return cache.getItem(item);
  };
  var removeItem = function(item) {
    return cache.removeItem(item);
  };
  var setItem = function(key, value, options) {
    return cache.setItem(key, value, options);
  };
  var removeWhere = function(test) {
    return cache.removeWhere(test);
  };
  return {setItem:setItem, getItem:getItem, removeItem:removeItem, removeWhere:removeWhere};
}();
CSSImportBehavior = {convertSheetsToStyles:function(root) {
  var SHEET_SELECTOR = "link[rel=stylesheet]";
  var sheets = root.querySelectorAll(SHEET_SELECTOR);
  for (var i = 0, l = sheets.length, s, c; i < l && (s = sheets[i]); i++) {
    var href = this.hrefForSheet(s, this.ownerDocument.baseURI);
    c = this.createStyleElement(this.importRuleForSheet(s, this.ownerDocument.baseURI), this.ownerDocument);
    this.importHref(href, this._onCssResponse.bind(this));
    s.parentNode.removeChild(s);
  }
}, importSheet:function(href) {
  this.importHref(href, this._onCssResponse.bind(this));
}, _onCssResponse:function(e) {
  var _import = e.target.import;
  var css = _import.body.textContent;
  var scope = this.selectedPage.scope;
  if (scope) {
    var ast = mensch.parse(css);
    this._visitCssRules(ast.stylesheet.rules, this._visitCssNode.bind(this), scope);
    css = mensch.stringify(ast);
  }
  var c = this.createStyleElement(css, this.ownerDocument);
  document.head.appendChild(c);
}, _visitCssNode:function(node, scope) {
  if (node.type == "rule") {
    this._visitCssRule(node, scope);
  } else {
    if (node.type == "media") {
      if (node.rules) {
        this._visitCssRules(node.rules, this._visitCssRule.bind(this), scope);
      }
    }
  }
}, _visitCssRules:function(items, fn, scope) {
  return items.reduce(function(results, item) {
    if (item.type !== "comment") {
      fn(item, scope);
    }
  }, []);
}, _visitCssRule:function(node, scope) {
  if (node.selectors) {
    for (var i = 0; i < node.selectors.length; i++) {
      var s = node.selectors[i];
      var colon = s.indexOf(":");
      if (colon >= 0) {
        node.selectors[i] = this._insert(s, colon, "." + scope);
      } else {
        node.selectors[i] = s + "." + scope;
      }
    }
  }
  if (node.rules) {
    this._visitCssRules(node.rules, this._visitCssRule.bind(this), scope);
  }
}, importRuleForSheet:function(sheet, baseUrl) {
  var href = (new URL(sheet.getAttribute("href"), baseUrl)).href;
  return "@import '" + href + "';";
}, hrefForSheet:function(sheet, baseUrl) {
  var href = (new URL(sheet.getAttribute("href"), baseUrl)).href;
  return href;
}, createStyleElement:function(cssText, scope) {
  scope = scope || document;
  scope = scope.createElement ? scope : scope.ownerDocument;
  var style = scope.createElement("style");
  style.textContent = cssText;
  return style;
}, _insert:function(str, index, ins) {
  if (index > 0) {
    return str.substring(0, index) + ins + str.substring(index, str.length);
  } else {
    return ins + str;
  }
}};
(function() {
  if (window.console.debug == null) {
    window.console.debug = window.console.log;
  }
  function getParameterByName(name) {
    var match = RegExp("[?&]" + name + "=([^&]*)").exec(window.location.search);
    return match && decodeURIComponent(match[1].replace(/\+/g, " "));
  }
  function getQueryParameter(reqKey) {
    var uri = window.location.toString();
    var ret = "";
    if (uri.indexOf("?") > 0) {
      var query = uri.substring(uri.indexOf("?"));
      var hash = query.substring(query.indexOf("#"));
      if (hash != -1) {
        query = uri.substring(0, hash);
        var params = query.split("&");
        for (var i = 0; i < params.length; i++) {
          var pos = params[i].indexOf("=");
          var key = params[i].substring(0, pos);
          if (key == reqKey) {
            ret = params[i].substring(pos + 1);
          }
        }
      }
    }
    return ret;
  }
  function removeQueryParameter() {
    var uri = window.location.toString();
    if (uri.indexOf("?") > 0) {
      var hash = "";
      if (uri.indexOf("#") > 0) {
        hash = uri.substring(uri.indexOf("#"));
      }
      var clean_uri = uri.substring(0, uri.indexOf("?")) + hash;
      try {
        window.history.replaceState({}, document.title, clean_uri);
      } catch (e) {
        console.error(e.stack);
      }
    }
  }
  window.queryParams = function(a) {
    if (a == "") {
      return {};
    }
    var b = {};
    for (var i = 0; i < a.length; ++i) {
      var p = a[i].split("=", 2);
      if (p.length == 1) {
        b[p[0]] = "";
      } else {
        b[p[0]] = decodeURIComponent(p[1].replace(/\+/g, " "));
      }
    }
    return b;
  }(window.location.search.substr(1).split("&"));
  var scripts = document.querySelectorAll("head > script");
  for (var i = 0; i < scripts.length; i++) {
    var src = scripts[i].src;
    if (src.match(/sw\/surface/)) {
      var x = src.split("/sw");
      var baseUrl = x[0];
      simpl4.util.BaseManager.setBaseUrl(baseUrl);
      break;
    }
  }
  if (simpl4.util.BaseManager.getBaseUrl() == null) {
    var links = document.querySelectorAll("head > link");
    for (var i = 0; i < links.length; i++) {
      var href = links[i].href;
      if (href.match(/sw\/surface/)) {
        var x = href.split("/sw");
        var baseUrl = x[0];
        simpl4.util.BaseManager.setBaseUrl(baseUrl);
        break;
      }
    }
  }
  var pathElements = window.location.pathname.split("/");
  var repoIndex = pathElements.indexOf("repo");
  var namespace = pathElements[repoIndex + 1];
  if (pathElements.length > 4) {
    var loc = window.location;
    var head = document.getElementsByTagName("head")[0];
    if (head.querySelector("base")) {
      head.removeChild(head.querySelector("base"));
    }
    var base = document.createElement("base");
    base.href = simpl4.util.BaseManager.getBaseUrl() + "/repo/" + namespace + "/";
    head.appendChild(base);
  }
  window.is_chromium = navigator.userAgent.toLowerCase().indexOf("chrome") > -1;
  simpl4.util.BaseManager.setNamespace(namespace);
  window.startPage = getParameterByName("page");
  var qtheme = getParameterByName("theme");
  var qlang = getParameterByName("lang");
  var lang = Simpl4.Cache.getItem("lang");
  if (qlang) {
    simpl4.util.BaseManager.setLanguage(qlang);
    simpl4.util.Globals.set("lang", qlang);
  } else {
    var def = window.defaultLang || "en";
    simpl4.util.BaseManager.setLanguage(lang ? lang : def);
    simpl4.util.Globals.set("lang", lang ? lang : def);
  }
  Simpl4.Cache.setItem("lang", simpl4.util.BaseManager.getLanguage());
  if (qtheme) {
    Simpl4.Cache.setItem("theme", qtheme);
  }
  var themeImport = document.querySelectorAll('head > [href*="theme.html"]');
  if (themeImport.length == 0) {
    var themeName = qtheme || Simpl4.Cache.getItem("theme");
    if (themeName == null) {
      themeName = "indigo-red";
    }
    var themeLink = document.createElement("link");
    themeLink.rel = "import";
    themeLink.href = "theme-" + themeName + ".html";
    document.getElementsByTagName("head")[0].appendChild(themeLink);
  }
  var passwd = getParameterByName("passwd");
  var user = getParameterByName("user");
  if (user && passwd) {
    simpl4.util.BaseManager.setUser(user);
    simpl4.util.BaseManager.setPassword(passwd);
    console.log("setting(" + user + "," + passwd + ")");
  } else {
    simpl4.util.BaseManager.setUser("guest");
    simpl4.util.BaseManager.setPassword("guest");
  }
  moment.locale(simpl4.util.BaseManager.getLanguage());
  window.simpl4FormManager = simpl4.util.FormManager;
  window.simpl4MessageManager = simpl4.util.MessageManager;
  window.simpl4EntityManager = simpl4.util.EntityManager;
  window.simpl4Globals = simpl4.util.Globals;
  window.clone = simpl4.util.Merge.clone;
  simpl4MessageManager.installBaseMessages();
  window.tr = simpl4MessageManager.tr;
  window.S4Map = simpl4.util.Map;
  window.S4MultiMap = simpl4.util.MultiMap;
  TrBehavior = {tr:function() {
    return simpl4MessageManager.tr(input);
  }};
  if (window.channel == null) {
    window.channel = postal.channel();
  }
  var awFont = new Font;
  awFont.src = simpl4.util.BaseManager.getBaseUrl() + "/sw/surface/fontawesome-webfont.woff?v=4.3.0";
  awFont.fontFamily = "FontAwesome";
  awFont.fontWeight = "normal";
  awFont.fontStyle = "normal";
  awFont.onload = function() {
  };
  Lobibox.base.OPTIONS.buttons.yes.text = tr("yes");
  Lobibox.base.OPTIONS.buttons.no.text = tr("no");
  Lobibox.notify.OPTIONS.error.title = tr("error");
  Lobibox.notify.OPTIONS.warning.title = tr("warning");
  Lobibox.notify.OPTIONS.success.title = tr("success");
  Lobibox.notify.OPTIONS.info.title = tr("info");
  Polymer({is:"simpl-globals", properties:{namespace:{type:String, value:"xxx"}}, behaviors:[CSSImportBehavior], ready:function() {
    this.selectedPage = {scope:"asciidoctor-default"};
    this.importSheet("asciidoc.css");
  }, namespaceChanged:function() {
    simpl4MessageManager.installMessages(this.namespace);
  }, getProperties:function() {
    var ret = null;
    jQuery.ajax({url:"properties.yaml", async:false, dataType:"json"}).done(function(data) {
      data.lang = simpl4MessageManager.getLanguage();
      window.globals = data;
      if (data.mainNamespace) {
        simpl4.util.BaseManager.setNamespace(data.mainNamespace);
      }
      ret = data;
    }.bind(this));
    return ret;
  }});
  ToolbarButtonBehavior = {_toolbarButtonPressed:function(e) {
    var target = e.target || e.srcElement;
    var action = target.getAttribute("on-tap");
    this[action]();
  }, created:function() {
    document.addEventListener("toolbar-button-pressed", this._toolbarButtonPressed.bind(this));
  }};
  TranslationsBehavior = {properties:{}, created:function() {
  }, tr:function(m) {
    return window.tr(m);
  }};
  WhitespaceBehavior = {attached:function() {
    $(".grid").contents().filter(function() {
      return this.nodeType === 3;
    }).remove();
  }};
  ModernizrBehavior = {attached:function() {
    var el = document.documentElement;
    var classNames = el.className.length ? el.className.split(/\s/) : [];
    for (var i = 0; i < classNames.length; i++) {
      var clazz = classNames[i];
      if (!$(this).hasClass(clazz)) {
        this.classList.add(clazz);
      }
    }
  }};
  StyleScopeBehavior = {setStyleScope:function(main_el) {
    var args = [];
    for (i = 1; i < arguments.length; i++) {
      if (arguments[i] != null) {
        args.push(arguments[i]);
      }
    }
    if (args.length == 0) {
      return;
    }
    this._domVisitor(main_el, function(el) {
      for (i = 0; i < args.length; i++) {
        if (!$(el).hasClass(args[i]) && el.nodeType == 1) {
          if (el.classList == null) {
          } else {
            try {
              el.classList.add(args[i]);
            } catch (e) {
              console.log("classList:", e);
            }
          }
        }
      }
    });
  }, _domVisitor:function(el, f) {
    if (el) {
      f(el);
      for (var i = 0; i < el.childNodes.length; i++) {
        this._domVisitor(el.childNodes[i], f);
      }
    }
  }};
})();
Polymer({is:"simpl-login", ready:function() {
  this.heading = "Login";
  this.submit = "Login";
  this.identification = "Username";
  this.identifier = "";
  this.password = "";
}, validate:function() {
  this.$.identifierInput.invalid = !!!this.identifier;
  this.$.passwordInput.invalid = !!!this.password;
  if (!this.password || !this.password) {
    return this.shake();
  }
  var namespace = this.namespace || simpl4.util.BaseManager.getNamespace();
  var ret = jQuery.ajax({url:"/sw/" + namespace + "/checkcredentials/", async:false, data:"credentials=" + this.identifier + ":" + this.password, method:"POST"});
  if (ret.status == 200) {
    simpl4.util.BaseManager.setUser(this.identifier);
    simpl4.util.BaseManager.setPassword(this.password);
    this.showOk(tr("login.ok"));
    this.shakeOk();
    this.async(function() {
      this.fireLoginOk();
      this.$.passwordInput.value = "";
    }, 2500);
  } else {
    this.showError(tr("login.error"));
    this.shake();
  }
}, showError:function(msg) {
  this.$.toastId.show(msg, "error", "10000");
}, showOk:function(msg) {
  this.$.toastId.show(msg, "success", "10000");
}, shakeOk:function() {
  var animation = this.animate([{transform:"translateY(-1px)"}, {transform:"translateY(1px)"}], {direction:"alternate", duration:3600, iterations:1});
  animation.play();
}, shake:function() {
  var animation = this.animate([{transform:"translateX(-10px)"}, {transform:"translateX(10px)"}], {direction:"alternate", duration:250, iterations:10});
  animation.play();
}, fireLoginOk:function() {
  this.fire("login-ok", {identifier:this.identifier, password:this.password});
}});
MainBehavior = {properties:{logoLinkLang:{computed:"substituteLang(logoLink)"}, logoLink:{type:String}, logo:{value:"logo212121.svg", type:String}, logoUrl:{computed:"getLogoUrl(logo)"}, logoData:{computed:"getLogoData(logo)"}, loginMessage:{value:"Login", type:String}, selectedPage:{notify:true, type:Object}, mmenuBackground:{value:null, type:String}, mmenuClasses:{value:null, type:String}, mmenuName:{value:"menu", type:String}, responsiveWidth:{value:"700px", type:String}, signInOutIcon:{value:"", 
type:String}, useKeyboard:{value:false, type:Boolean}, waitOnPages:{value:2}, target:{type:Object, value:function() {
  return document.body;
}}}, observers:["routeChanged(route)"], pageCache:function() {
  return {};
}, onToolbarReady:function() {
  this.pagesReady();
}, onMenuReady:function() {
  this.pagesReady();
}, pagesReady:function() {
  this.waitOnPages--;
  if (this.waitOnPages === 0) {
    this.allPages = this._getPages();
    channel.publish("main.pagesReady", {});
  }
}, _getPages:function() {
  var menuEntries = document.querySelectorAll("a.menuentry");
  var pages = [];
  for (var i = 0; i < menuEntries.length; i++) {
    pages.push(menuEntries[i].page);
  }
  return pages;
}, buildToolbar:function() {
  var nodes = document.querySelector("#dispatcherId").getNodes();
  var parent = this.querySelector("#toolbarIconsId");
  if (nodes == null) {
    nodes = [];
  }
  for (var i = 0; i < nodes.length; i++) {
    var node = nodes[i];
    if (node.uri && node.uri.startsWith("mainToolbar:")) {
      for (var j = 0; j < node.children.length; j++) {
        var child = node.children[j];
        if (this._isNodeDisabled(child)) {
          continue;
        }
        this._createToolbarEntry(parent, child);
      }
    }
  }
  this.onToolbarReady();
}, attached:function() {
  this.buildToolbar();
  this.async(function() {
    this._attached();
  });
}, _attached:function() {
  if (Detectizr.device.model == "android") {
    this.entryAnimation = "fade-in-animation";
    this.exitAnimation = "fade-out-animation";
  } else {
    this.entryAnimation = "scale-up-animation";
    this.exitAnimation = "scale-down-animation";
  }
  this.helpMessage = tr("button.help");
  this.drawerPanel = this.$.drawerPanel;
  this.neonPages = this.$.pages;
  console.log("Detectizr:" + JSON.stringify(Detectizr, null, 2));
  var isTouch = "ontouchstart" in window || navigator.msMaxTouchPoints > 0;
  console.log("isTouch:" + isTouch);
  var isSafari = Detectizr.browser.name == "safari";
  console.log("isSafari:" + isSafari);
  var mc = this.querySelector("#mainContainer");
  Polymer.dom(mc).setAttribute("scrollbar", "");
  var hc = this.querySelector("#headerContainer");
  hc.style.zIndex = 1;
  var shouldHandleEvent = function(evt) {
    var node = evt.target;
    while (node != document.body) {
      var isDatatables = node.id && node.id.toLowerCase().indexOf("datatables") >= 0;
      if (isDatatables) {
        return false;
      }
      if (node.getAttribute("no-smooth-scroll") != null) {
        return false;
      }
      node = node.parentNode;
    }
    return true;
  };
  this._scrollbar = window.Scrollbar.init(mc, {speed:isTouch ? 1 : 4, damping:isTouch ? 0.1 : 0.05, paddingTop:64, renderByPixels:true, alwaysShowTracks:true, overscrollEffect:"bounce", overscrollDamping:0.1, shouldHandleEvent:shouldHandleEvent, thumbMinSize:10});
  var shp = this.$.scrollHeaderPanelId;
  this._scrollbar.addListener(function(e) {
    shp._updateScrollState(e.offset.y);
  });
  this.async(function() {
    this._scrollbar.update();
  }, 1000);
  this.observeOverlayBackdrop();
}, scrollbarUpdate:function() {
  this._scrollbar.update();
}, getScrollbarOffset:function() {
  return this._scrollbar.offset;
}, observeOverlayBackdrop:function() {
  var MutationObserver = window.MutationObserver || window.WebKitMutationObserver;
  var obs = new MutationObserver(function(mutations, observer) {
    var o = document.querySelectorAll("iron-overlay-backdrop");
    var scrollContainer = document.querySelector("#mainContainer article.scroll-content");
    if (o.length > 0) {
      scrollContainer.style.display = "initial";
    } else {
      scrollContainer.style.display = "block";
    }
  });
  obs.observe($("body").get(0), {childList:true});
}, getGlobals:function() {
  if (this.globals == null) {
    this.globals = simpl4Globals.getAll();
  }
  return this.globals;
}, routeChanged:function() {
  if (this._scrollbar) {
    this._scrollbar.scrollTo(0, 0);
    this.async(function() {
      this._scrollbar.update();
    }, 1000);
  } else {
    $("#mainContainer").scrollTop(0);
  }
  this.route = this.route.toString();
  var route = this.route;
  if (route.match(/^!/)) {
    route = route.substring(1);
  }
  if (this.route != route) {
    this.route = route;
  }
  channel.publish("route.changed", {route:this.route});
  try {
    if (window._paq) {
      var action = this.route == "0" ? "main" : this.route;
      if (this.lastAction != action) {
        _paq.push(["trackEvent", "webdemo", action + "/" + Simpl4.Cache.getItem("lang")]);
      }
      this.lastAction = action;
    }
  } catch (e) {
    console.error("trackEvent:", e.stack);
  }
}, togglePanel:function() {
}, keyHandler:function(e, detail, sender) {
  var num = parseInt(detail.key);
  if (!isNaN(num) && num <= simpl4PageRegistry.getPages().length) {
    this.neonPages.selectIndex(num - 1);
    return;
  }
  switch(detail.key) {
    case "left":
    case "up":
      this.neonPages.selectPrevious();
      break;
    case "right":
    case "down":
      this.neonPages.selectNext();
      break;
    case "space":
      detail.shift ? this.neonPages.selectPrevious() : this.neonPages.selectNext();
      break;
  }
}, menuItemSelected:function(e) {
  var page = e.detail.page;
  if (e.detail.isSelected && page.url) {
    channel.publish("menuItem.selected", e.detail);
    document.title = "simpl4-" + page.name;
    this.selectedPage = page;
    this.route = page.hash;
    if (this.pageCache[page.url] !== true) {
      this.importHref(this._buildUrl(page), this.onResponse.bind(this));
    } else {
    }
  }
  this.$.drawerPanel.closeDrawer();
}, onResponse:function(e) {
  var _import = e.target.import;
  var body = _import.body;
  var head = _import.head;
  this.pageCache[this.selectedPage.url] = true;
  var insertPoint = this.neonPages.selectedItem.firstElementChild;
  while (insertPoint.firstChild) {
    Polymer.dom(insertPoint).removeChild(insertPoint.firstChild);
  }
  $(insertPoint).hide();
  if (head.firstElementChild) {
    if (head.firstElementChild.set) {
      head.firstElementChild.set("globals", this.getGlobals());
      head.firstElementChild.set("tr", function(text) {
        return tr(text);
      });
    }
    console.log("HEAD;", head.firstElementChild);
    Polymer.dom(insertPoint).appendChild(head.firstElementChild);
  }
  if (body.firstElementChild) {
    if (body.childNodes.length > 0) {
      for (var i = 0; i < body.childNodes.length; i++) {
        var node = body.childNodes[i];
        if (node.nodeType != 1) {
          continue;
        }
        Polymer.dom(insertPoint).appendChild(node);
        this.$.dispatcherId.filterLocalLinks(node);
      }
    }
  }
  this.async(function() {
    this.convertSheetsToStyles(insertPoint);
    var scope = this.selectedPage.scope;
    if (this.isAsciidoc(this.selectedPage.url) && scope == null) {
      scope = "asciidoctor-default";
    }
    this.setStyleScope(insertPoint, scope);
    this.async(function() {
      $(insertPoint).fadeIn(700);
    }, 0);
  }, 2);
}, getLogoLink:function() {
  return this.substituteLang(this.logoLink);
}, substituteLang:function(url, notemp) {
  if (url == null || url == "") {
    return;
  }
  if (url.indexOf("%l") != -1) {
    url = url.replace("%l", this.getGlobals().lang);
  }
  if (!url.match(/^http/)) {
    if (url.match(/^[a-zA-Z].*/)) {
      url = "./" + url;
    }
    if (notemp == null) {
      url += "?t=1";
    }
  }
  return url;
}, _buildUrl:function(page) {
  var url = page.url;
  var hasRpc = url.indexOf("?rpc=") > 0 || url.indexOf("&rpc=") > 0;
  if (hasRpc) {
    var password = simpl4.util.BaseManager.getPassword();
    var username = simpl4.util.BaseManager.getUser();
    var credentials = simpl4.util.Base64.encode(username + ":" + password);
    url += "&credentials=" + credentials;
  }
  if (_.isEmpty(page.appendix)) {
    return url;
  }
  var hasQuery = url.indexOf("?") >= 0;
  var hasHash = url.indexOf("#") >= 0;
  var appendix = (hasQuery ? "&" : "?") + this._maskedEval(page.appendix, page, "paramError=1");
  return hasHash ? url.replace("#", appendix + "#") : url + appendix;
}, _maskedEval:function(scr, env, def) {
  try {
    env._ = _;
    env.tr = tr;
    env.moment = moment;
    return metaes.evaluate(scr.toString(), env);
  } catch (e) {
    console.error("\t" + e);
    console.debug("Main._maskedEval.script:" + scr);
    console.debug("Main._maskedEval.env:" + JSON.stringify(env, null, 2));
  }
  return def;
}, getHelpDialogStyle:function() {
  var h = $(window).height() * 0.9;
  return "height:" + h + "px;";
}, showHelp:function(e) {
  if (window._paq && !this.$.helpDialog.opened) {
    var action = this.route == "0" ? "main" : this.route;
    _paq.push(["trackEvent", "webclient", action + "_help"]);
  }
  this.$.helpDialog.toggle();
}, externalButtonEventHandler:function(e) {
  this.fire("toolbar-button-pressed", e.target || e.srcElement, {key1:"value1"});
}, isAsciidoc:function(url) {
  return url.indexOf(".adoc") > 0;
}, getLogoUrl:function() {
  if (this.logo.endsWith(".svg")) {
    return null;
  } else {
    return this.logo;
  }
}, getLogoData:function() {
  if (this.logo.endsWith(".svg")) {
    return {path:this.logo, repo:simpl4.util.BaseManager.getNamespace()};
  } else {
    return null;
  }
}, loginOk:function(e) {
  this.loginMessage = "User:" + e.detail.identifier;
  this.$.loginDialog.toggle();
}, login:function(e) {
  this.$.loginDialog.toggle();
}, getLangIcon:function() {
  var lang = Simpl4.Cache.getItem("lang");
  return lang == "de" || lang == null ? "en.svg" : "de.svg";
}, changeTheme:function(theme) {
  Simpl4.Cache.setItem("theme", theme);
  location.search = "";
  history.go(0);
}, reload:function(e) {
  var lang = Simpl4.Cache.getItem("lang");
  Simpl4.Cache.setItem("lang", lang == "de" || lang == null ? "en" : "de");
  location.search = "";
  window.location.reload();
}, setSelected:function(page) {
}, _createToolbarEntry:function(parent, node) {
  var icon = this._createIcon(node);
  var li = document.createElement("li");
  var a = document.createElement("a");
  var pr = document.createElement("paper-ripple");
  var t = document.createTextNode(node.name);
  Polymer.dom(parent).appendChild(li);
  Polymer.dom(li).appendChild(a);
  if (browser.name != "ie" || browser.major != "9" && browser.major != "10") {
    Polymer.dom(parent).appendChild(pr);
  }
  Polymer.dom(a).appendChild(icon);
  Polymer.dom(a).setAttribute("style", "cursor:pointer");
  Polymer.dom(a).setAttribute("id", "hash_" + node.hash);
  Polymer.dom(a).classList.add("menuentry");
  Polymer.dom(a).appendChild(t);
  Polymer.dom(li).setAttribute("style", "list-style:none");
  Polymer.dom(li).setAttribute("id", "x" + node.hash);
  a.page = node;
  node.provider = this;
}, _addNodeClasses:function(el, classes) {
  if (classes == null) {
    return;
  }
  var classArray = classes.split(",");
  for (var i = 0; i < classArray.length; i++) {
    el.classList.add(classArray[i]);
  }
}, _isNodeDisabled:function(node) {
  return node.disabled === true;
}, _createIcon:function(node) {
  var icon = null;
  if (node.aweicon) {
    icon = document.createElement("font-awesome");
    Polymer.dom(icon).setAttribute("icon", node.aweicon);
  } else {
    if (node.icon) {
      icon = document.createElement("iron-icon");
      this._addNodeClasses(icon, "small");
      Polymer.dom(icon).setAttribute("icon", node.icon);
    }
  }
  return icon;
}};
Polymer({is:"simpl-main", behaviors:[MainBehavior, CSSImportBehavior, ModernizrBehavior, StyleScopeBehavior]});
(function($) {
  var _PLUGIN_ = "mmenu", _VERSION_ = "5.3.4";
  if ($[_PLUGIN_]) {
    return;
  }
  $[_PLUGIN_] = function($menu, opts, conf) {
    this.$menu = $menu;
    this._api = ["bind", "init", "update", "setSelected", "getInstance", "openPanel", "closePanel", "closeAllPanels"];
    this.opts = opts;
    this.conf = conf;
    this.vars = {};
    this.cbck = {};
    if (typeof this.___deprecated == "function") {
      this.___deprecated();
    }
    this._initMenu();
    this._initAnchors();
    var $panels = this.$menu.children(this.conf.panelNodetype);
    this._initAddons();
    this.init($panels);
    if (typeof this.___debug == "function") {
      this.___debug();
    }
    return this;
  };
  $[_PLUGIN_].version = _VERSION_;
  $[_PLUGIN_].addons = {};
  $[_PLUGIN_].uniqueId = 0;
  $[_PLUGIN_].defaults = {extensions:[], navbar:{add:true, title:"Menu", titleLink:"panel"}, onClick:{setSelected:true}, slidingSubmenus:true};
  $[_PLUGIN_].configuration = {classNames:{divider:"Divider", inset:"Inset", panel:"Panel", selected:"Selected", spacer:"Spacer", vertical:"Vertical"}, clone:false, openingInterval:25, panelNodetype:"ul, ol, div", transitionDuration:400};
  $[_PLUGIN_].prototype = {init:function($panels) {
    $panels = $panels.not("." + _c.nopanel);
    $panels = this._initPanels($panels);
    this.trigger("init", $panels);
    this.trigger("update");
  }, update:function() {
    this.trigger("update");
  }, setSelected:function($i) {
    this.$menu.find("." + _c.listview).children().removeClass(_c.selected);
    $i.addClass(_c.selected);
    this.trigger("setSelected", $i);
  }, openPanel:function($panel) {
    var $l = $panel.parent();
    if ($l.hasClass(_c.vertical)) {
      var $sub = $l.parents("." + _c.subopened);
      if ($sub.length) {
        return this.openPanel($sub.first());
      }
      $l.addClass(_c.opened);
    } else {
      if ($panel.hasClass(_c.current)) {
        return;
      }
      var $panels = this.$menu.children("." + _c.panel), $current = $panels.filter("." + _c.current);
      $panels.removeClass(_c.highest).removeClass(_c.current).not($panel).not($current).not("." + _c.vertical).addClass(_c.hidden);
      if (!$[_PLUGIN_].support.csstransitions) {
        $current.addClass(_c.hidden);
      }
      if ($panel.hasClass(_c.opened)) {
        $panel.nextAll("." + _c.opened).addClass(_c.highest).removeClass(_c.opened).removeClass(_c.subopened);
      } else {
        $panel.addClass(_c.highest);
        $current.addClass(_c.subopened);
      }
      $panel.removeClass(_c.hidden).addClass(_c.current);
      setTimeout(function() {
        $panel.removeClass(_c.subopened).addClass(_c.opened);
      }, this.conf.openingInterval);
    }
    this.trigger("openPanel", $panel);
  }, closePanel:function($panel) {
    var $l = $panel.parent();
    if ($l.hasClass(_c.vertical)) {
      $l.removeClass(_c.opened);
      this.trigger("closePanel", $panel);
    }
  }, closeAllPanels:function() {
    this.$menu.find("." + _c.listview).children().removeClass(_c.selected).filter("." + _c.vertical).removeClass(_c.opened);
    var $pnls = this.$menu.children("." + _c.panel), $frst = $pnls.first();
    this.$menu.children("." + _c.panel).not($frst).removeClass(_c.subopened).removeClass(_c.opened).removeClass(_c.current).removeClass(_c.highest).addClass(_c.hidden);
    this.openPanel($frst);
  }, togglePanel:function($panel) {
    var $l = $panel.parent();
    if ($l.hasClass(_c.vertical)) {
      this[$l.hasClass(_c.opened) ? "closePanel" : "openPanel"]($panel);
    }
  }, getInstance:function() {
    return this;
  }, bind:function(event, fn) {
    this.cbck[event] = this.cbck[event] || [];
    this.cbck[event].push(fn);
  }, trigger:function() {
    var that = this, args = Array.prototype.slice.call(arguments), evnt = args.shift();
    if (this.cbck[evnt]) {
      for (var e = 0, l = this.cbck[evnt].length; e < l; e++) {
        this.cbck[evnt][e].apply(that, args);
      }
    }
  }, _initMenu:function() {
    var that = this;
    if (this.opts.offCanvas && this.conf.clone) {
      this.$menu = this.$menu.clone(true);
      this.$menu.add(this.$menu.find("[id]")).filter("[id]").each(function() {
        $(this).attr("id", _c.mm($(this).attr("id")));
      });
    }
    this.$menu.contents().each(function() {
      if ($(this)[0].nodeType == 3) {
        $(this).remove();
      }
    });
    this.$menu.parent().addClass(_c.wrapper);
    var clsn = [_c.menu];
    if (!this.opts.slidingSubmenus) {
      clsn.push(_c.vertical);
    }
    this.opts.extensions = this.opts.extensions.length ? "mm-" + this.opts.extensions.join(" mm-") : "";
    if (this.opts.extensions) {
      clsn.push(this.opts.extensions);
    }
    this.$menu.addClass(clsn.join(" "));
  }, _initPanels:function($panels) {
    var that = this;
    var $lists = this.__findAddBack($panels, "ul, ol");
    this.__refactorClass($lists, this.conf.classNames.inset, "inset").addClass(_c.nolistview + " " + _c.nopanel);
    $lists.not("." + _c.nolistview).addClass(_c.listview);
    var $lis = this.__findAddBack($panels, "." + _c.listview).children();
    this.__refactorClass($lis, this.conf.classNames.selected, "selected");
    this.__refactorClass($lis, this.conf.classNames.divider, "divider");
    this.__refactorClass($lis, this.conf.classNames.spacer, "spacer");
    this.__refactorClass(this.__findAddBack($panels, "." + this.conf.classNames.panel), this.conf.classNames.panel, "panel");
    var $curpanels = $(), $oldpanels = $panels.add($panels.find("." + _c.panel)).add(this.__findAddBack($panels, "." + _c.listview).children().children(this.conf.panelNodetype)).not("." + _c.nopanel);
    this.__refactorClass($oldpanels, this.conf.classNames.vertical, "vertical");
    if (!this.opts.slidingSubmenus) {
      $oldpanels.addClass(_c.vertical);
    }
    $oldpanels.each(function() {
      var $t = $(this), $p = $t;
      if ($t.is("ul, ol")) {
        $t.wrap('<div class="' + _c.panel + '" />');
        $p = $t.parent();
      } else {
        $p.addClass(_c.panel);
      }
      var id = $t.attr("id");
      $t.removeAttr("id");
      $p.attr("id", id || that.__getUniqueId());
      if ($t.hasClass(_c.vertical)) {
        $t.removeClass(that.conf.classNames.vertical);
        $p.add($p.parent()).addClass(_c.vertical);
      }
      $curpanels = $curpanels.add($p);
    });
    var $allpanels = $("." + _c.panel, this.$menu);
    $curpanels.each(function(i) {
      var $t = $(this), $p = $t.parent(), $a = $p.children("a, span").first();
      if (!$p.is("." + _c.menu)) {
        $p.data(_d.sub, $t);
        $t.data(_d.parent, $p);
      }
      if (!$p.children("." + _c.next).length) {
        if ($p.parent().is("." + _c.listview)) {
          var id = $t.attr("id"), $b = $('<a class="' + _c.next + '" href="#' + id + '" data-target="#' + id + '" />').insertBefore($a);
          if ($a.is("span")) {
            $b.addClass(_c.fullsubopen);
          }
        }
      }
      if (!$t.children("." + _c.navbar).length) {
        if (!$p.hasClass(_c.vertical)) {
          if ($p.parent().is("." + _c.listview)) {
            var $p = $p.closest("." + _c.panel);
          } else {
            var $a = $p.closest("." + _c.panel).find('a[href="#' + $t.attr("id") + '"]').first(), $p = $a.closest("." + _c.panel);
          }
          var $navbar = $('<div class="' + _c.navbar + '" />');
          if ($p.length) {
            var id = $p.attr("id");
            switch(that.opts.navbar.titleLink) {
              case "anchor":
                _url = $a.attr("href");
                break;
              case "panel":
              case "parent":
                _url = "#" + id;
                break;
              case "none":
              default:
                _url = false;
                break;
            }
            $navbar.append('<a class="' + _c.btn + " " + _c.prev + '" href="#' + id + '" data-target="#' + id + '"></a>').append('<a class="' + _c.title + '"' + (_url ? ' href="' + _url + '"' : "") + ">" + $a.text() + "</a>").prependTo($t);
            if (that.opts.navbar.add) {
              $t.addClass(_c.hasnavbar);
            }
          } else {
            if (that.opts.navbar.title) {
              $navbar.append('<a class="' + _c.title + '">' + that.opts.navbar.title + "</a>").prependTo($t);
              if (that.opts.navbar.add) {
                $t.addClass(_c.hasnavbar);
              }
            }
          }
        }
      }
    });
    var $s = this.__findAddBack($panels, "." + _c.listview).children("." + _c.selected).removeClass(_c.selected).last().addClass(_c.selected);
    $s.add($s.parentsUntil("." + _c.menu, "li")).filter("." + _c.vertical).addClass(_c.opened).end().not("." + _c.vertical).each(function() {
      $(this).parentsUntil("." + _c.menu, "." + _c.panel).not("." + _c.vertical).first().addClass(_c.opened).parentsUntil("." + _c.menu, "." + _c.panel).not("." + _c.vertical).first().addClass(_c.opened).addClass(_c.subopened);
    });
    $s.children("." + _c.panel).not("." + _c.vertical).addClass(_c.opened).parentsUntil("." + _c.menu, "." + _c.panel).not("." + _c.vertical).first().addClass(_c.opened).addClass(_c.subopened);
    var $current = $allpanels.filter("." + _c.opened);
    if (!$current.length) {
      $current = $curpanels.first();
    }
    $current.addClass(_c.opened).last().addClass(_c.current);
    $curpanels.not("." + _c.vertical).not($current.last()).addClass(_c.hidden).end().appendTo(this.$menu);
    return $curpanels;
  }, _initAnchors:function() {
    var that = this;
    glbl.$body.on(_e.click + "-oncanvas", "a[href]", function(e) {
      var $t = $(this), fired = false, inMenu = that.$menu.find($t).length;
      for (var a in $[_PLUGIN_].addons) {
        if (fired = $[_PLUGIN_].addons[a].clickAnchor.call(that, $t, inMenu)) {
          break;
        }
      }
      if (!fired && inMenu) {
        var _h = $t.attr("href");
        if (_h.length > 1 && _h.slice(0, 1) == "#") {
          try {
            var $h = $(_h, that.$menu);
            if ($h.is("." + _c.panel)) {
              fired = true;
              that[$t.parent().hasClass(_c.vertical) ? "togglePanel" : "openPanel"]($h);
            }
          } catch (err) {
          }
        }
      }
      if (fired) {
        e.preventDefault();
      }
      if (!fired && inMenu) {
        if ($t.is("." + _c.listview + " > li > a") && !$t.is('[rel="external"]') && !$t.is('[target="_blank"]')) {
          if (that.__valueOrFn(that.opts.onClick.setSelected, $t)) {
            that.setSelected($(e.target).parent());
          }
          var preventDefault = that.__valueOrFn(that.opts.onClick.preventDefault, $t, _h.slice(0, 1) == "#");
          if (preventDefault) {
            e.preventDefault();
          }
          if (that.__valueOrFn(that.opts.onClick.blockUI, $t, !preventDefault)) {
            glbl.$html.addClass(_c.blocking);
          }
          if (that.__valueOrFn(that.opts.onClick.close, $t, preventDefault)) {
            that.close();
          }
        }
      }
    });
  }, _initAddons:function() {
    for (var a in $[_PLUGIN_].addons) {
      $[_PLUGIN_].addons[a].add.call(this);
      $[_PLUGIN_].addons[a].add = function() {
      };
    }
    for (var a in $[_PLUGIN_].addons) {
      $[_PLUGIN_].addons[a].setup.call(this);
    }
  }, __api:function() {
    var that = this, api = {};
    $.each(this._api, function(i) {
      var fn = this;
      api[fn] = function() {
        var re = that[fn].apply(that, arguments);
        return typeof re == "undefined" ? api : re;
      };
    });
    return api;
  }, __valueOrFn:function(o, $e, d) {
    if (typeof o == "function") {
      return o.call($e[0]);
    }
    if (typeof o == "undefined" && typeof d != "undefined") {
      return d;
    }
    return o;
  }, __refactorClass:function($e, o, c) {
    return $e.filter("." + o).removeClass(o).addClass(_c[c]);
  }, __findAddBack:function($e, s) {
    return $e.find(s).add($e.filter(s));
  }, __filterListItems:function($i) {
    return $i.not("." + _c.divider).not("." + _c.hidden);
  }, __transitionend:function($e, fn, duration) {
    var _ended = false, _fn = function() {
      if (!_ended) {
        fn.call($e[0]);
      }
      _ended = true;
    };
    $e.one(_e.transitionend, _fn);
    $e.one(_e.webkitTransitionEnd, _fn);
    setTimeout(_fn, duration * 1.1);
  }, __getUniqueId:function() {
    return _c.mm($[_PLUGIN_].uniqueId++);
  }};
  $.fn[_PLUGIN_] = function(opts, conf) {
    initPlugin($(this));
    opts = $.extend(true, {}, $[_PLUGIN_].defaults, opts);
    conf = $.extend(true, {}, $[_PLUGIN_].configuration, conf);
    return this.each(function() {
      var $menu = $(this);
      if ($menu.data(_PLUGIN_)) {
        return;
      }
      var _menu = new $[_PLUGIN_]($menu, opts, conf);
      $menu.data(_PLUGIN_, _menu.__api());
    });
  };
  $[_PLUGIN_].support = {touch:"ontouchstart" in window || navigator.msMaxTouchPoints, csstransitions:function() {
    if (typeof Modernizr !== "undefined") {
      return Modernizr.csstransitions;
    }
    var b = document.body || document.documentElement, s = b.style, p = "transition";
    if (typeof s[p] == "string") {
      return true;
    }
    var v = ["Moz", "webkit", "Webkit", "Khtml", "O", "ms"];
    p = p.charAt(0).toUpperCase() + p.substr(1);
    for (var i = 0; i < v.length; i++) {
      if (typeof s[v[i] + p] == "string") {
        return true;
      }
    }
    return false;
  }()};
  var _c, _d, _e, glbl;
  function initPlugin(t) {
    if ($[_PLUGIN_].glbl) {
    }
    glbl = {$wndw:$(window), $html:t, $body:t};
    _c = {};
    _d = {};
    _e = {};
    $.each([_c, _d, _e], function(i, o) {
      o.add = function(a) {
        a = a.split(" ");
        for (var b = 0, l = a.length; b < l; b++) {
          o[a[b]] = o.mm(a[b]);
        }
      };
    });
    _c.mm = function(c) {
      return "mm-" + c;
    };
    _c.add("wrapper menu panel nopanel current highest opened subopened navbar hasnavbar title btn prev next listview nolistview inset vertical selected divider spacer hidden fullsubopen");
    _c.umm = function(c) {
      if (c.slice(0, 3) == "mm-") {
        c = c.slice(3);
      }
      return c;
    };
    _d.mm = function(d) {
      return "mm-" + d;
    };
    _d.add("parent sub");
    _e.mm = function(e) {
      return e + ".mm";
    };
    _e.add("transitionend webkitTransitionEnd mousedown mouseup touchstart touchmove touchend click keydown");
    $[_PLUGIN_]._c = _c;
    $[_PLUGIN_]._d = _d;
    $[_PLUGIN_]._e = _e;
    $[_PLUGIN_].glbl = glbl;
  }
})(jQuery);
(function($) {
  var _PLUGIN_ = "mmenu", _ADDON_ = "autoHeight";
  $[_PLUGIN_].addons[_ADDON_] = {setup:function() {
    if (!this.opts.offCanvas) {
      return;
    }
    switch(this.opts.offCanvas.position) {
      case "left":
      case "right":
        return;
        break;
    }
    var that = this, opts = this.opts[_ADDON_], conf = this.conf[_ADDON_];
    glbl = $[_PLUGIN_].glbl;
    if (typeof opts == "boolean" && opts) {
      opts = {height:"auto"};
    }
    if (typeof opts != "object") {
      opts = {};
    }
    opts = this.opts[_ADDON_] = $.extend(true, {}, $[_PLUGIN_].defaults[_ADDON_], opts);
    if (opts.height != "auto") {
      return;
    }
    this.$menu.addClass(_c.autoheight);
    var update = function($panl) {
      var $p = this.$menu.children("." + _c.current);
      _top = parseInt($p.css("top"), 10) || 0;
      _bot = parseInt($p.css("bottom"), 10) || 0;
      this.$menu.addClass(_c.measureheight);
      $panl = $panl || this.$menu.children("." + _c.current);
      if ($panl.is("." + _c.vertical)) {
        $panl = $panl.parents("." + _c.panel).not("." + _c.vertical).first();
      }
      this.$menu.height($panl.outerHeight() + _top + _bot).removeClass(_c.measureheight);
    };
    this.bind("update", update);
    this.bind("openPanel", update);
    this.bind("closePanel", update);
    this.bind("open", update);
    glbl.$wndw.off(_e.resize + "-autoheight").on(_e.resize + "-autoheight", function(e) {
      update.call(that);
    });
  }, add:function() {
    _c = $[_PLUGIN_]._c;
    _d = $[_PLUGIN_]._d;
    _e = $[_PLUGIN_]._e;
    _c.add("autoheight measureheight");
    _e.add("resize");
  }, clickAnchor:function($a, inMenu) {
  }};
  $[_PLUGIN_].defaults[_ADDON_] = {height:"default"};
  var _c, _d, _e, glbl;
})(jQuery);
(function($) {
  var _PLUGIN_ = "mmenu", _ADDON_ = "backButton";
  $[_PLUGIN_].addons[_ADDON_] = {setup:function() {
    if (!this.opts.offCanvas) {
      return;
    }
    var that = this, opts = this.opts[_ADDON_], conf = this.conf[_ADDON_];
    glbl = $[_PLUGIN_].glbl;
    if (typeof opts == "boolean") {
      opts = {close:opts};
    }
    if (typeof opts != "object") {
      opts = {};
    }
    opts = $.extend(true, {}, $[_PLUGIN_].defaults[_ADDON_], opts);
    if (opts.close) {
      var _hash = "#" + that.$menu.attr("id");
      this.bind("opened", function(e) {
        if (location.hash != _hash) {
          history.pushState(null, document.title, _hash);
        }
      });
      $(window).on("popstate", function(e) {
        if (glbl.$html.hasClass(_c.opened)) {
          e.stopPropagation();
          that.close();
        } else {
          if (location.hash == _hash) {
            e.stopPropagation();
            that.open();
          }
        }
      });
    }
  }, add:function() {
    if (!window.history || !window.history.pushState) {
      $[_PLUGIN_].addons[_ADDON_].setup = function() {
      };
      return;
    }
    _c = $[_PLUGIN_]._c;
    _d = $[_PLUGIN_]._d;
    _e = $[_PLUGIN_]._e;
  }, clickAnchor:function($a, inMenu) {
  }};
  $[_PLUGIN_].defaults[_ADDON_] = {close:false};
  var _c, _d, _e, glbl;
})(jQuery);
(function($) {
  var _PLUGIN_ = "mmenu", _ADDON_ = "counters";
  $[_PLUGIN_].addons[_ADDON_] = {setup:function() {
    var that = this, opts = this.opts[_ADDON_], conf = this.conf[_ADDON_];
    glbl = $[_PLUGIN_].glbl;
    if (typeof opts == "boolean") {
      opts = {add:opts, update:opts};
    }
    if (typeof opts != "object") {
      opts = {};
    }
    opts = this.opts[_ADDON_] = $.extend(true, {}, $[_PLUGIN_].defaults[_ADDON_], opts);
    this.bind("init", function($panels) {
      this.__refactorClass($("em", $panels), this.conf.classNames[_ADDON_].counter, "counter");
    });
    if (opts.add) {
      this.bind("init", function($panels) {
        $panels.each(function() {
          var $prnt = $(this).data(_d.parent);
          if ($prnt) {
            if (!$prnt.children("em." + _c.counter).length) {
              $prnt.prepend($('<em class="' + _c.counter + '" />'));
            }
          }
        });
      });
    }
    if (opts.update) {
      this.bind("update", function() {
        this.$menu.find("." + _c.panel).each(function() {
          var $panl = $(this), $prnt = $panl.data(_d.parent);
          if (!$prnt) {
            return;
          }
          var $cntr = $prnt.children("em." + _c.counter);
          if (!$cntr.length) {
            return;
          }
          $panl = $panl.children("." + _c.listview);
          if (!$panl.length) {
            return;
          }
          $cntr.html(that.__filterListItems($panl.children()).length);
        });
      });
    }
  }, add:function() {
    _c = $[_PLUGIN_]._c;
    _d = $[_PLUGIN_]._d;
    _e = $[_PLUGIN_]._e;
    _c.add("counter search noresultsmsg");
  }, clickAnchor:function($a, inMenu) {
  }};
  $[_PLUGIN_].defaults[_ADDON_] = {add:false, update:false};
  $[_PLUGIN_].configuration.classNames[_ADDON_] = {counter:"Counter"};
  var _c, _d, _e, glbl;
})(jQuery);
(function($) {
  var _PLUGIN_ = "mmenu", _ADDON_ = "dividers";
  $[_PLUGIN_].addons[_ADDON_] = {setup:function() {
    var that = this, opts = this.opts[_ADDON_], conf = this.conf[_ADDON_];
    glbl = $[_PLUGIN_].glbl;
    if (typeof opts == "boolean") {
      opts = {add:opts, fixed:opts};
    }
    if (typeof opts != "object") {
      opts = {};
    }
    opts = this.opts[_ADDON_] = $.extend(true, {}, $[_PLUGIN_].defaults[_ADDON_], opts);
    this.bind("init", function($panels) {
      this.__refactorClass($("li", this.$menu), this.conf.classNames[_ADDON_].collapsed, "collapsed");
    });
    if (opts.add) {
      this.bind("init", function($panels) {
        switch(opts.addTo) {
          case "panels":
            var $wrapper = $panels;
            break;
          default:
            var $wrapper = $(opts.addTo, this.$menu).filter("." + _c.panel);
            break;
        }
        $("." + _c.divider, $wrapper).remove();
        $wrapper.find("." + _c.listview).not("." + _c.vertical).each(function() {
          var last = "";
          that.__filterListItems($(this).children()).each(function() {
            var crnt = $.trim($(this).children("a, span").text()).slice(0, 1).toLowerCase();
            if (crnt != last && crnt.length) {
              last = crnt;
              $('<li class="' + _c.divider + '">' + crnt + "</li>").insertBefore(this);
            }
          });
        });
      });
    }
    if (opts.collapse) {
      this.bind("init", function($panels) {
        $("." + _c.divider, $panels).each(function() {
          var $l = $(this), $e = $l.nextUntil("." + _c.divider, "." + _c.collapsed);
          if ($e.length) {
            if (!$l.children("." + _c.subopen).length) {
              $l.wrapInner("<span />");
              $l.prepend('<a href="#" class="' + _c.subopen + " " + _c.fullsubopen + '" />');
            }
          }
        });
      });
    }
    if (opts.fixed) {
      var update = function($panl) {
        $panl = $panl || this.$menu.children("." + _c.current);
        var $dvdr = $panl.find("." + _c.divider).not("." + _c.hidden);
        if ($dvdr.length) {
          this.$menu.addClass(_c.hasdividers);
          var scrl = $panl.scrollTop() || 0, text = "";
          if ($panl.is(":visible")) {
            $panl.find("." + _c.divider).not("." + _c.hidden).each(function() {
              if ($(this).position().top + scrl < scrl + 1) {
                text = $(this).text();
              }
            });
          }
          this.$fixeddivider.text(text);
        } else {
          this.$menu.removeClass(_c.hasdividers);
        }
      };
      this.$fixeddivider = $('<ul class="' + _c.listview + " " + _c.fixeddivider + '"><li class="' + _c.divider + '"></li></ul>').prependTo(this.$menu).children();
      this.bind("openPanel", update);
      this.bind("init", function($panels) {
        $panels.off(_e.scroll + "-dividers " + _e.touchmove + "-dividers").on(_e.scroll + "-dividers " + _e.touchmove + "-dividers", function(e) {
          update.call(that, $(this));
        });
      });
    }
  }, add:function() {
    _c = $[_PLUGIN_]._c;
    _d = $[_PLUGIN_]._d;
    _e = $[_PLUGIN_]._e;
    _c.add("collapsed uncollapsed fixeddivider hasdividers");
    _e.add("scroll");
  }, clickAnchor:function($a, inMenu) {
    if (this.opts[_ADDON_].collapse && inMenu) {
      var $l = $a.parent();
      if ($l.is("." + _c.divider)) {
        var $e = $l.nextUntil("." + _c.divider, "." + _c.collapsed);
        $l.toggleClass(_c.opened);
        $e[$l.hasClass(_c.opened) ? "addClass" : "removeClass"](_c.uncollapsed);
        return true;
      }
    }
    return false;
  }};
  $[_PLUGIN_].defaults[_ADDON_] = {add:false, addTo:"panels", fixed:false, collapse:false};
  $[_PLUGIN_].configuration.classNames[_ADDON_] = {collapsed:"Collapsed"};
  var _c, _d, _e, glbl;
})(jQuery);
(function($) {
  var _PLUGIN_ = "mmenu", _ADDON_ = "dragOpen";
  $[_PLUGIN_].addons[_ADDON_] = {setup:function() {
    if (!this.opts.offCanvas) {
      return;
    }
    var that = this, opts = this.opts[_ADDON_], conf = this.conf[_ADDON_];
    glbl = $[_PLUGIN_].glbl;
    if (typeof opts == "boolean") {
      opts = {open:opts};
    }
    if (typeof opts != "object") {
      opts = {};
    }
    opts = this.opts[_ADDON_] = $.extend(true, {}, $[_PLUGIN_].defaults[_ADDON_], opts);
    if (opts.open) {
      var drag = {}, _stage = 0, _direction = false, _dimension = false, _distance = 0, _maxDistance = 0;
      var new_distance, drag_distance, css_value, doPanstart, getSlideNodes;
      switch(this.opts.offCanvas.position) {
        case "left":
        case "right":
          drag.events = "panleft panright";
          drag.typeLower = "x";
          drag.typeUpper = "X";
          _dimension = "width";
          break;
        case "top":
        case "bottom":
          drag.events = "panup pandown";
          drag.typeLower = "y";
          drag.typeUpper = "Y";
          _dimension = "height";
          break;
      }
      switch(this.opts.offCanvas.position) {
        case "right":
        case "bottom":
          drag.negative = true;
          doPanstart = function(pos) {
            if (pos >= glbl.$wndw[_dimension]() - opts.maxStartPos) {
              _stage = 1;
            }
          };
          break;
        default:
          drag.negative = false;
          doPanstart = function(pos) {
            if (pos <= opts.maxStartPos) {
              _stage = 1;
            }
          };
          break;
      }
      switch(this.opts.offCanvas.position) {
        case "left":
          drag.open_dir = "right";
          drag.close_dir = "left";
          break;
        case "right":
          drag.open_dir = "left";
          drag.close_dir = "right";
          break;
        case "top":
          drag.open_dir = "down";
          drag.close_dir = "up";
          break;
        case "bottom":
          drag.open_dir = "up";
          drag.close_dir = "down";
          break;
      }
      switch(this.opts.offCanvas.zposition) {
        case "front":
          getSlideNodes = function() {
            return this.$menu;
          };
          break;
        default:
          getSlideNodes = function() {
            return $("." + _c.slideout);
          };
          break;
      }
      var $dragNode = this.__valueOrFn(opts.pageNode, this.$menu, glbl.$page);
      if (typeof $dragNode == "string") {
        $dragNode = $($dragNode);
      }
      var _hammer = new Hammer($dragNode[0], opts.vendors.hammer);
      _hammer.on("panstart", function(e) {
        doPanstart(e.center[drag.typeLower]);
        glbl.$slideOutNodes = getSlideNodes();
        _direction = drag.open_dir;
      }).on(drag.events + " panend", function(e) {
        if (_stage > 0) {
          e.preventDefault();
        }
      }).on(drag.events, function(e) {
        new_distance = e["delta" + drag.typeUpper];
        if (drag.negative) {
          new_distance = -new_distance;
        }
        if (new_distance != _distance) {
          _direction = new_distance >= _distance ? drag.open_dir : drag.close_dir;
        }
        _distance = new_distance;
        if (_distance > opts.threshold) {
          if (_stage == 1) {
            if (glbl.$html.hasClass(_c.opened)) {
              return;
            }
            _stage = 2;
            that._openSetup();
            that.trigger("opening");
            glbl.$html.addClass(_c.dragging);
            _maxDistance = minMax(glbl.$wndw[_dimension]() * conf[_dimension].perc, conf[_dimension].min, conf[_dimension].max);
          }
        }
        if (_stage == 2) {
          drag_distance = minMax(_distance, 10, _maxDistance) - (that.opts.offCanvas.zposition == "front" ? _maxDistance : 0);
          if (drag.negative) {
            drag_distance = -drag_distance;
          }
          css_value = "translate" + drag.typeUpper + "(" + drag_distance + "px )";
          glbl.$slideOutNodes.css({"-webkit-transform":"-webkit-" + css_value, "transform":css_value});
        }
      }).on("panend", function(e) {
        if (_stage == 2) {
          glbl.$html.removeClass(_c.dragging);
          glbl.$slideOutNodes.css("transform", "");
          that[_direction == drag.open_dir ? "_openFinish" : "close"]();
        }
        _stage = 0;
      });
    }
  }, add:function() {
    if (typeof Hammer != "function" || Hammer.VERSION < 2) {
      $[_PLUGIN_].addons[_ADDON_].setup = function() {
      };
      return;
    }
    _c = $[_PLUGIN_]._c;
    _d = $[_PLUGIN_]._d;
    _e = $[_PLUGIN_]._e;
    _c.add("dragging");
  }, clickAnchor:function($a, inMenu) {
  }};
  $[_PLUGIN_].defaults[_ADDON_] = {open:false, maxStartPos:100, threshold:50, vendors:{hammer:{}}};
  $[_PLUGIN_].configuration[_ADDON_] = {width:{perc:0.8, min:140, max:440}, height:{perc:0.8, min:140, max:880}};
  var _c, _d, _e, glbl;
  function minMax(val, min, max) {
    if (val < min) {
      val = min;
    }
    if (val > max) {
      val = max;
    }
    return val;
  }
})(jQuery);
(function($) {
  var _PLUGIN_ = "mmenu", _ADDON_ = "fixedElements";
  $[_PLUGIN_].addons[_ADDON_] = {setup:function() {
    if (!this.opts.offCanvas) {
      return;
    }
    var that = this, opts = this.opts[_ADDON_], conf = this.conf[_ADDON_];
    glbl = $[_PLUGIN_].glbl;
    opts = this.opts[_ADDON_] = $.extend(true, {}, $[_PLUGIN_].defaults[_ADDON_], opts);
    var setPage = function($page) {
      var _fixd = this.conf.classNames[_ADDON_].fixed;
      this.__refactorClass($page.find("." + _fixd), _fixd, "slideout").appendTo(glbl.$body);
    };
    setPage.call(this, glbl.$page);
    this.bind("setPage", setPage);
  }, add:function() {
    _c = $[_PLUGIN_]._c;
    _d = $[_PLUGIN_]._d;
    _e = $[_PLUGIN_]._e;
    _c.add("fixed");
  }, clickAnchor:function($a, inMenu) {
  }};
  $[_PLUGIN_].configuration.classNames[_ADDON_] = {fixed:"Fixed"};
  var _c, _d, _e, glbl;
})(jQuery);
(function($) {
  var _PLUGIN_ = "mmenu", _ADDON_ = "iconPanels";
  $[_PLUGIN_].addons[_ADDON_] = {setup:function() {
    var that = this, opts = this.opts[_ADDON_], conf = this.conf[_ADDON_];
    glbl = $[_PLUGIN_].glbl;
    if (typeof opts == "boolean") {
      opts = {add:opts};
    }
    if (typeof opts == "number") {
      opts = {add:true, visible:opts};
    }
    if (typeof opts != "object") {
      opts = {};
    }
    opts = this.opts[_ADDON_] = $.extend(true, {}, $[_PLUGIN_].defaults[_ADDON_], opts);
    opts.visible++;
    if (opts.add) {
      this.$menu.addClass(_c.iconpanel);
      var clsn = [];
      for (var i = 0; i <= opts.visible; i++) {
        clsn.push(_c.iconpanel + "-" + i);
      }
      clsn = clsn.join(" ");
      var update = function($panl) {
        var $allp = that.$menu.children("." + _c.panel).removeClass(clsn);
        var $curp = $allp.filter("." + _c.subopened);
        $curp.removeClass(_c.hidden).add($panl).slice(-opts.visible).each(function(x) {
          $(this).addClass(_c.iconpanel + "-" + x);
        });
      };
      this.bind("openPanel", update);
      this.bind("init", function($panels) {
        update.call(that, that.$menu.children("." + _c.current));
        if (opts.hideNavbars) {
          $panels.removeClass(_c.hasnavbar);
        }
        $panels.each(function() {
          if (!$(this).children("." + _c.subblocker).length) {
            $(this).prepend('<a href="#' + $(this).closest("." + _c.panel).attr("id") + '" class="' + _c.subblocker + '" />');
          }
        });
      });
    }
  }, add:function() {
    _c = $[_PLUGIN_]._c;
    _d = $[_PLUGIN_]._d;
    _e = $[_PLUGIN_]._e;
    _c.add("iconpanel subblocker");
  }, clickAnchor:function($a, inMenu) {
  }};
  $[_PLUGIN_].defaults[_ADDON_] = {add:false, visible:3, hideNavbars:false};
  var _c, _d, _e, glbl;
})(jQuery);
(function($) {
  var _PLUGIN_ = "mmenu", _ADDON_ = "navbars";
  $[_PLUGIN_].addons[_ADDON_] = {setup:function() {
    var that = this, navs = this.opts[_ADDON_], conf = this.conf[_ADDON_];
    glbl = $[_PLUGIN_].glbl;
    if (typeof navs == "undefined") {
      return;
    }
    if (!(navs instanceof Array)) {
      navs = [navs];
    }
    var _pos = {};
    $.each(navs, function(n) {
      var opts = navs[n];
      if (typeof opts == "boolean" && opts) {
        opts = {};
      }
      if (typeof opts != "object") {
        opts = {};
      }
      if (typeof opts.content == "undefined") {
        opts.content = ["prev", "title"];
      }
      if (!(opts.content instanceof Array)) {
        opts.content = [opts.content];
      }
      opts = $.extend(true, {}, that.opts.navbar, opts);
      var poss = opts.position, hght = opts.height;
      if (typeof hght != "number") {
        hght = 1;
      }
      hght = Math.min(4, Math.max(1, hght));
      if (poss != "bottom") {
        poss = "top";
      }
      if (!_pos[poss]) {
        _pos[poss] = 0;
      }
      _pos[poss]++;
      var $navbar = $("<div />").addClass(_c.navbar + " " + _c.navbar + "-" + poss + " " + _c.navbar + "-" + poss + "-" + _pos[poss] + " " + _c.navbar + "-size-" + hght);
      _pos[poss] += hght - 1;
      for (var c = 0, l = opts.content.length; c < l; c++) {
        var ctnt = $[_PLUGIN_].addons[_ADDON_][opts.content[c]] || false;
        if (ctnt) {
          ctnt.call(that, $navbar, opts, conf);
        } else {
          ctnt = opts.content[c];
          if (!(ctnt instanceof $)) {
            ctnt = $(opts.content[c]);
          }
          ctnt.each(function() {
            $navbar.append($(this));
          });
        }
      }
      var _content = Math.ceil($navbar.children().not("." + _c.btn).length / hght);
      if (_content > 1) {
        $navbar.addClass(_c.navbar + "-content-" + _content);
      }
      if ($navbar.children("." + _c.btn).length) {
        $navbar.addClass(_c.hasbtns);
      }
      $navbar.prependTo(that.$menu);
    });
    for (var poss in _pos) {
      that.$menu.addClass(_c.hasnavbar + "-" + poss + "-" + _pos[poss]);
    }
  }, add:function() {
    _c = $[_PLUGIN_]._c;
    _d = $[_PLUGIN_]._d;
    _e = $[_PLUGIN_]._e;
    _c.add("close hasbtns");
  }, clickAnchor:function($a, inMenu) {
  }};
  $[_PLUGIN_].configuration[_ADDON_] = {breadcrumbSeparator:"/"};
  $[_PLUGIN_].configuration.classNames[_ADDON_] = {panelTitle:"Title", panelNext:"Next", panelPrev:"Prev"};
  var _c, _d, _e, glbl;
})(jQuery);
(function($) {
  var _PLUGIN_ = "mmenu", _ADDON_ = "navbars", _CONTENT_ = "breadcrumbs";
  $[_PLUGIN_].addons[_ADDON_][_CONTENT_] = function($navbar, opts, conf) {
    var _c = $[_PLUGIN_]._c, _d = $[_PLUGIN_]._d;
    _c.add("breadcrumbs separator");
    $navbar.append('<span class="' + _c.breadcrumbs + '"></span>');
    this.bind("init", function($panels) {
      $panels.removeClass(_c.hasnavbar).each(function() {
        var crumbs = [], $panl = $(this), $bcrb = $('<span class="' + _c.breadcrumbs + '"></span>'), $crnt = $(this).children().first(), first = true;
        while ($crnt && $crnt.length) {
          if (!$crnt.is("." + _c.panel)) {
            $crnt = $crnt.closest("." + _c.panel);
          }
          var text = $crnt.children("." + _c.navbar).children("." + _c.title).text();
          crumbs.unshift(first ? "<span>" + text + "</span>" : '<a href="#' + $crnt.attr("id") + '">' + text + "</a>");
          first = false;
          $crnt = $crnt.data(_d.parent);
        }
        $bcrb.append(crumbs.join('<span class="' + _c.separator + '">' + conf.breadcrumbSeparator + "</span>")).appendTo($panl.children("." + _c.navbar));
      });
    });
    var update = function() {
      var $panl = this.$menu.children("." + _c.current);
      var $node = $navbar.find("." + _c.breadcrumbs), $bcrb = $panl.children("." + _c.navbar).children("." + _c.breadcrumbs);
      $node.html($bcrb.html());
    };
    this.bind("openPanel", update);
    this.bind("init", update);
  };
})(jQuery);
(function($) {
  var _PLUGIN_ = "mmenu", _ADDON_ = "navbars", _CONTENT_ = "close";
  $[_PLUGIN_].addons[_ADDON_][_CONTENT_] = function($navbar, opts) {
    var _c = $[_PLUGIN_]._c, glbl = $[_PLUGIN_].glbl;
    $navbar.append('<a class="' + _c.close + " " + _c.btn + '" href="#"></a>');
    var setPage = function($page) {
      $navbar.find("." + _c.close).attr("href", "#" + $page.attr("id"));
    };
    setPage.call(this, glbl.$page);
    this.bind("setPage", setPage);
  };
})(jQuery);
(function($) {
  var _PLUGIN_ = "mmenu", _ADDON_ = "navbars", _CONTENT_ = "next";
  $[_PLUGIN_].addons[_ADDON_][_CONTENT_] = function($navbar, opts) {
    var _c = $[_PLUGIN_]._c;
    $navbar.append('<a class="' + _c.next + " " + _c.btn + '" href="#"></a>');
    var update = function($panel) {
      $panel = $panel || this.$menu.children("." + _c.current);
      var $node = $navbar.find("." + _c.next), $orgn = $panel.find("." + this.conf.classNames[_ADDON_].panelNext);
      var _url = $orgn.attr("href"), _txt = $orgn.html();
      $node[_url ? "attr" : "removeAttr"]("href", _url);
      $node[_url || _txt ? "removeClass" : "addClass"](_c.hidden);
      $node.html(_txt);
    };
    this.bind("openPanel", update);
    this.bind("init", function() {
      update.call(this);
    });
  };
})(jQuery);
(function($) {
  var _PLUGIN_ = "mmenu", _ADDON_ = "navbars", _CONTENT_ = "prev";
  $[_PLUGIN_].addons[_ADDON_][_CONTENT_] = function($navbar, opts) {
    var _c = $[_PLUGIN_]._c;
    $navbar.append('<a class="' + _c.prev + " " + _c.btn + '" href="#"></a>');
    this.bind("init", function($panl) {
      $panl.removeClass(_c.hasnavbar);
    });
    var update = function() {
      var $panl = this.$menu.children("." + _c.current);
      var $node = $navbar.find("." + _c.prev), $orgn = $panl.find("." + this.conf.classNames[_ADDON_].panelPrev);
      if (!$orgn.length) {
        $orgn = $panl.children("." + _c.navbar).children("." + _c.prev);
      }
      var _url = $orgn.attr("href"), _txt = $orgn.html();
      $node[_url ? "attr" : "removeAttr"]("href", _url);
      $node[_url || _txt ? "removeClass" : "addClass"](_c.hidden);
      $node.html(_txt);
    };
    this.bind("openPanel", update);
    this.bind("init", update);
  };
})(jQuery);
(function($) {
  var _PLUGIN_ = "mmenu", _ADDON_ = "navbars", _CONTENT_ = "searchfield";
  $[_PLUGIN_].addons[_ADDON_][_CONTENT_] = function($navbar, opts) {
    var _c = $[_PLUGIN_]._c;
    var $srch = $('<div class="' + _c.search + '" />').appendTo($navbar);
    if (typeof this.opts.searchfield != "object") {
      this.opts.searchfield = {};
    }
    this.opts.searchfield.add = true;
    this.opts.searchfield.addTo = $srch;
  };
})(jQuery);
(function($) {
  var _PLUGIN_ = "mmenu", _ADDON_ = "navbars", _CONTENT_ = "title";
  $[_PLUGIN_].addons[_ADDON_][_CONTENT_] = function($navbar, opts) {
    var _c = $[_PLUGIN_]._c;
    $navbar.append('<a class="' + _c.title + '"></a>');
    var update = function($panel) {
      $panel = $panel || this.$menu.children("." + _c.current);
      var $node = $navbar.find("." + _c.title), $orgn = $panel.find("." + this.conf.classNames[_ADDON_].panelTitle);
      if (!$orgn.length) {
        $orgn = $panel.children("." + _c.navbar).children("." + _c.title);
      }
      var _url = $orgn.attr("href"), _txt = $orgn.html() || opts.title;
      $node[_url ? "attr" : "removeAttr"]("href", _url);
      $node[_url || _txt ? "removeClass" : "addClass"](_c.hidden);
      $node.html(_txt);
    };
    this.bind("openPanel", update);
    this.bind("init", function() {
      update.call(this);
    });
  };
})(jQuery);
(function($) {
  var _PLUGIN_ = "mmenu", _ADDON_ = "offCanvas";
  $[_PLUGIN_].addons[_ADDON_] = {setup:function() {
    if (!this.opts[_ADDON_]) {
      return;
    }
    var that = this, opts = this.opts[_ADDON_], conf = this.conf[_ADDON_];
    glbl = $[_PLUGIN_].glbl;
    this._api = $.merge(this._api, ["open", "close", "setPage"]);
    if (opts.position == "top" || opts.position == "bottom") {
      opts.zposition = "front";
    }
    if (typeof conf.pageSelector != "string") {
      conf.pageSelector = "> " + conf.pageNodetype;
    }
    glbl.$allMenus = (glbl.$allMenus || $()).add(this.$menu);
    this.vars.opened = false;
    var clsn = [_c.offcanvas];
    if (opts.position != "left") {
      clsn.push(_c.mm(opts.position));
    }
    if (opts.zposition != "back") {
      clsn.push(_c.mm(opts.zposition));
    }
    this.$menu.addClass(clsn.join(" ")).parent().removeClass(_c.wrapper);
    this.setPage(glbl.$page);
    this._initBlocker();
    this["_initWindow_" + _ADDON_]();
    this.$menu[conf.menuInjectMethod + "To"](conf.menuWrapperSelector);
  }, add:function() {
    _c = $[_PLUGIN_]._c;
    _d = $[_PLUGIN_]._d;
    _e = $[_PLUGIN_]._e;
    _c.add("offcanvas slideout modal background opening blocker page");
    _d.add("style");
    _e.add("resize");
  }, clickAnchor:function($a, inMenu) {
    if (!this.opts[_ADDON_]) {
      return false;
    }
    var id = this.$menu.attr("id");
    if (id && id.length) {
      if (this.conf.clone) {
        id = _c.umm(id);
      }
      if ($a.is('[href="#' + id + '"]')) {
        this.open();
        return true;
      }
    }
    if (!glbl.$page) {
      return;
    }
    var id = glbl.$page.first().attr("id");
    if (id && id.length) {
      if ($a.is('[href="#' + id + '"]')) {
        this.close();
        return true;
      }
    }
    return false;
  }};
  $[_PLUGIN_].defaults[_ADDON_] = {position:"left", zposition:"back", modal:false, moveBackground:true};
  $[_PLUGIN_].configuration[_ADDON_] = {pageNodetype:"div", pageSelector:null, wrapPageIfNeeded:true, menuWrapperSelector:"body", menuInjectMethod:"prepend"};
  $[_PLUGIN_].prototype.open = function() {
    if (this.vars.opened) {
      return;
    }
    var that = this;
    this._openSetup();
    setTimeout(function() {
      that._openFinish();
    }, this.conf.openingInterval);
    this.trigger("open");
  };
  $[_PLUGIN_].prototype._openSetup = function() {
    var that = this;
    this.closeAllOthers();
    glbl.$page.each(function() {
      $(this).data(_d.style, $(this).attr("style") || "");
    });
    glbl.$wndw.trigger(_e.resize + "-offcanvas", [true]);
    var clsn = [_c.opened];
    if (this.opts[_ADDON_].modal) {
      clsn.push(_c.modal);
    }
    if (this.opts[_ADDON_].moveBackground) {
      clsn.push(_c.background);
    }
    if (this.opts[_ADDON_].position != "left") {
      clsn.push(_c.mm(this.opts[_ADDON_].position));
    }
    if (this.opts[_ADDON_].zposition != "back") {
      clsn.push(_c.mm(this.opts[_ADDON_].zposition));
    }
    if (this.opts.extensions) {
      clsn.push(this.opts.extensions);
    }
    glbl.$html.addClass(clsn.join(" "));
    setTimeout(function() {
      that.vars.opened = true;
    }, this.conf.openingInterval);
    this.$menu.addClass(_c.current + " " + _c.opened);
  };
  $[_PLUGIN_].prototype._openFinish = function() {
    var that = this;
    this.__transitionend(glbl.$page.first(), function() {
      that.trigger("opened");
    }, this.conf.transitionDuration);
    glbl.$html.addClass(_c.opening);
    this.trigger("opening");
  };
  $[_PLUGIN_].prototype.close = function() {
    if (!this.vars.opened) {
      return;
    }
    var that = this;
    this.__transitionend(glbl.$page.first(), function() {
      that.$menu.removeClass(_c.current).removeClass(_c.opened);
      glbl.$html.removeClass(_c.opened).removeClass(_c.modal).removeClass(_c.background).removeClass(_c.mm(that.opts[_ADDON_].position)).removeClass(_c.mm(that.opts[_ADDON_].zposition));
      if (that.opts.extensions) {
        glbl.$html.removeClass(that.opts.extensions);
      }
      glbl.$page.each(function() {
        $(this).attr("style", $(this).data(_d.style));
      });
      that.vars.opened = false;
      that.trigger("closed");
    }, this.conf.transitionDuration);
    glbl.$html.removeClass(_c.opening);
    this.trigger("close");
    this.trigger("closing");
  };
  $[_PLUGIN_].prototype.closeAllOthers = function() {
    glbl.$allMenus.not(this.$menu).each(function() {
      var api = $(this).data(_PLUGIN_);
      if (api && api.close) {
        api.close();
      }
    });
  };
  $[_PLUGIN_].prototype.setPage = function($page) {
    var that = this, conf = this.conf[_ADDON_];
    if (!$page || !$page.length) {
      $page = glbl.$body.find(conf.pageSelector);
      if ($page.length > 1 && conf.wrapPageIfNeeded) {
        $page = $page.wrapAll("<" + this.conf[_ADDON_].pageNodetype + " />").parent();
      }
    }
    $page.each(function() {
      $(this).attr("id", $(this).attr("id") || that.__getUniqueId());
    });
    $page.addClass(_c.page + " " + _c.slideout);
    glbl.$page = $page;
    this.trigger("setPage", $page);
  };
  $[_PLUGIN_].prototype["_initWindow_" + _ADDON_] = function() {
    glbl.$wndw.off(_e.keydown + "-offcanvas").on(_e.keydown + "-offcanvas", function(e) {
      if (glbl.$html.hasClass(_c.opened)) {
        if (e.keyCode == 9) {
          e.preventDefault();
          return false;
        }
      }
    });
    var _h = 0;
    glbl.$wndw.off(_e.resize + "-offcanvas").on(_e.resize + "-offcanvas", function(e, force) {
      if (glbl.$page.length == 1) {
        if (force || glbl.$html.hasClass(_c.opened)) {
          var nh = glbl.$wndw.height();
          if (force || nh != _h) {
            _h = nh;
            glbl.$page.css("minHeight", nh);
          }
        }
      }
    });
  };
  $[_PLUGIN_].prototype._initBlocker = function() {
    var that = this;
    if (!glbl.$blck) {
      glbl.$blck = $('<div id="' + _c.blocker + '" class="' + _c.slideout + '" />');
    }
    glbl.$blck.appendTo(glbl.$body).off(_e.touchstart + "-offcanvas " + _e.touchmove + "-offcanvas").on(_e.touchstart + "-offcanvas " + _e.touchmove + "-offcanvas", function(e) {
      e.preventDefault();
      e.stopPropagation();
      glbl.$blck.trigger(_e.mousedown + "-offcanvas");
    }).off(_e.mousedown + "-offcanvas").on(_e.mousedown + "-offcanvas", function(e) {
      e.preventDefault();
      if (!glbl.$html.hasClass(_c.modal)) {
        that.closeAllOthers();
        that.close();
      }
    });
  };
  var _c, _d, _e, glbl;
})(jQuery);
(function($) {
  var _PLUGIN_ = "mmenu", _ADDON_ = "searchfield";
  $[_PLUGIN_].addons[_ADDON_] = {setup:function() {
    var that = this, opts = this.opts[_ADDON_], conf = this.conf[_ADDON_];
    glbl = $[_PLUGIN_].glbl;
    if (typeof opts == "boolean") {
      opts = {add:opts};
    }
    if (typeof opts != "object") {
      opts = {};
    }
    opts = this.opts[_ADDON_] = $.extend(true, {}, $[_PLUGIN_].defaults[_ADDON_], opts);
    this.bind("close", function() {
      this.$menu.find("." + _c.search).find("input").blur();
    });
    this.bind("init", function($panels) {
      if (opts.add) {
        switch(opts.addTo) {
          case "panels":
            var $wrapper = $panels;
            break;
          default:
            var $wrapper = $(opts.addTo, this.$menu);
            break;
        }
        $wrapper.each(function() {
          var $panl = $(this);
          if ($panl.is("." + _c.panel) && $panl.is("." + _c.vertical)) {
            return;
          }
          if (!$panl.children("." + _c.search).length) {
            var _srch = conf.form ? "form" : "div";
            var $srch = $("<" + _srch + ' class="' + _c.search + '" />');
            if (conf.form && typeof conf.form == "object") {
              for (var f in conf.form) {
                $srch.attr(f, conf.form[f]);
              }
            }
            $srch.append('<input placeholder="' + opts.placeholder + '" type="text" autocomplete="off" />');
            if ($panl.hasClass(_c.search)) {
              $panl.replaceWith($srch);
            } else {
              $panl.prepend($srch).addClass(_c.hassearch);
            }
          }
          if (opts.noResults) {
            var inPanel = $panl.closest("." + _c.panel).length;
            if (!inPanel) {
              $panl = that.$menu.children("." + _c.panel).first();
            }
            if (!$panl.children("." + _c.noresultsmsg).length) {
              var $lst = $panl.children("." + _c.listview).first();
              $('<div class="' + _c.noresultsmsg + '" />').append(opts.noResults)[$lst.length ? "insertAfter" : "prependTo"]($lst.length ? $lst : $panl);
            }
          }
        });
        if (opts.search) {
          $("." + _c.search, this.$menu).each(function() {
            var $srch = $(this), inPanel = $srch.closest("." + _c.panel).length;
            if (inPanel) {
              var $pnls = $srch.closest("." + _c.panel), $panl = $pnls;
            } else {
              var $pnls = $("." + _c.panel, that.$menu), $panl = that.$menu;
            }
            var $inpt = $srch.children("input"), $itms = that.__findAddBack($pnls, "." + _c.listview).children("li"), $dvdr = $itms.filter("." + _c.divider), $rslt = that.__filterListItems($itms);
            var _anchor = "> a", _both = _anchor + ", > span";
            var search = function() {
              var query = $inpt.val().toLowerCase();
              $pnls.scrollTop(0);
              $rslt.add($dvdr).addClass(_c.hidden).find("." + _c.fullsubopensearch).removeClass(_c.fullsubopen).removeClass(_c.fullsubopensearch);
              $rslt.each(function() {
                var $item = $(this), _search = _anchor;
                if (opts.showTextItems || opts.showSubPanels && $item.find("." + _c.next)) {
                  _search = _both;
                }
                if ($(_search, $item).text().toLowerCase().indexOf(query) > -1) {
                  $item.add($item.prevAll("." + _c.divider).first()).removeClass(_c.hidden);
                }
              });
              if (opts.showSubPanels) {
                $pnls.each(function(i) {
                  var $panl = $(this);
                  that.__filterListItems($panl.find("." + _c.listview).children()).each(function() {
                    var $li = $(this), $su = $li.data(_d.sub);
                    $li.removeClass(_c.nosubresults);
                    if ($su) {
                      $su.find("." + _c.listview).children().removeClass(_c.hidden);
                    }
                  });
                });
              }
              $($pnls.get().reverse()).each(function(i) {
                var $panl = $(this), $prnt = $panl.data(_d.parent);
                if ($prnt) {
                  if (that.__filterListItems($panl.find("." + _c.listview).children()).length) {
                    if ($prnt.hasClass(_c.hidden)) {
                      $prnt.children("." + _c.next).not("." + _c.fullsubopen).addClass(_c.fullsubopen).addClass(_c.fullsubopensearch);
                    }
                    $prnt.removeClass(_c.hidden).removeClass(_c.nosubresults).prevAll("." + _c.divider).first().removeClass(_c.hidden);
                  } else {
                    if (!inPanel) {
                      if ($panl.hasClass(_c.opened)) {
                        setTimeout(function() {
                          that.openPanel($prnt.closest("." + _c.panel));
                        }, (i + 1) * (that.conf.openingInterval * 1.5));
                      }
                      $prnt.addClass(_c.nosubresults);
                    }
                  }
                }
              });
              $panl[$rslt.not("." + _c.hidden).length ? "removeClass" : "addClass"](_c.noresults);
              this.update();
            };
            $inpt.off(_e.keyup + "-searchfield " + _e.change + "-searchfield").on(_e.keyup + "-searchfield", function(e) {
              if (!preventKeypressSearch(e.keyCode)) {
                search.call(that);
              }
            }).on(_e.change + "-searchfield", function(e) {
              search.call(that);
            });
          });
        }
      }
    });
  }, add:function() {
    _c = $[_PLUGIN_]._c;
    _d = $[_PLUGIN_]._d;
    _e = $[_PLUGIN_]._e;
    _c.add("search hassearch noresultsmsg noresults nosubresults fullsubopensearch");
    _e.add("change keyup");
  }, clickAnchor:function($a, inMenu) {
  }};
  $[_PLUGIN_].defaults[_ADDON_] = {add:false, addTo:"panels", search:true, placeholder:"Search", noResults:"No results found.", showTextItems:false, showSubPanels:true};
  $[_PLUGIN_].configuration[_ADDON_] = {form:false};
  var _c, _d, _e, glbl;
  function preventKeypressSearch(c) {
    switch(c) {
      case 9:
      case 16:
      case 17:
      case 18:
      case 37:
      case 38:
      case 39:
      case 40:
        return true;
    }
    return false;
  }
})(jQuery);
(function($) {
  var _PLUGIN_ = "mmenu", _ADDON_ = "sectionIndexer";
  $[_PLUGIN_].addons[_ADDON_] = {setup:function() {
    var that = this, opts = this.opts[_ADDON_], conf = this.conf[_ADDON_];
    glbl = $[_PLUGIN_].glbl;
    if (typeof opts == "boolean") {
      opts = {add:opts};
    }
    if (typeof opts != "object") {
      opts = {};
    }
    opts = this.opts[_ADDON_] = $.extend(true, {}, $[_PLUGIN_].defaults[_ADDON_], opts);
    this.bind("init", function($panels) {
      if (opts.add) {
        switch(opts.addTo) {
          case "panels":
            var $wrapper = $panels;
            break;
          default:
            var $wrapper = $(opts.addTo, this.$menu).filter("." + _c.panel);
            break;
        }
        $wrapper.find("." + _c.divider).closest("." + _c.panel).addClass(_c.hasindexer);
      }
      if (!this.$indexer && this.$menu.children("." + _c.hasindexer).length) {
        this.$indexer = $('<div class="' + _c.indexer + '" />').prependTo(this.$menu).append('<a href="#a">a</a>' + '<a href="#b">b</a>' + '<a href="#c">c</a>' + '<a href="#d">d</a>' + '<a href="#e">e</a>' + '<a href="#f">f</a>' + '<a href="#g">g</a>' + '<a href="#h">h</a>' + '<a href="#i">i</a>' + '<a href="#j">j</a>' + '<a href="#k">k</a>' + '<a href="#l">l</a>' + '<a href="#m">m</a>' + '<a href="#n">n</a>' + '<a href="#o">o</a>' + '<a href="#p">p</a>' + '<a href="#q">q</a>' + '<a href="#r">r</a>' + 
        '<a href="#s">s</a>' + '<a href="#t">t</a>' + '<a href="#u">u</a>' + '<a href="#v">v</a>' + '<a href="#w">w</a>' + '<a href="#x">x</a>' + '<a href="#y">y</a>' + '<a href="#z">z</a>');
        this.$indexer.children().on(_e.mouseover + "-sectionindexer " + _c.touchstart + "-sectionindexer", function(e) {
          var lttr = $(this).attr("href").slice(1), $panl = that.$menu.children("." + _c.current), $list = $panl.find("." + _c.listview);
          var newTop = false, oldTop = $panl.scrollTop(), lstTop = $list.position().top + parseInt($list.css("margin-top"), 10) + parseInt($list.css("padding-top"), 10) + oldTop;
          $panl.scrollTop(0);
          $list.children("." + _c.divider).not("." + _c.hidden).each(function() {
            if (newTop === false && lttr == $(this).text().slice(0, 1).toLowerCase()) {
              newTop = $(this).position().top + lstTop;
            }
          });
          $panl.scrollTop(newTop !== false ? newTop : oldTop);
        });
        var update = function($panl) {
          that.$menu[($panl.hasClass(_c.hasindexer) ? "add" : "remove") + "Class"](_c.hasindexer);
        };
        this.bind("openPanel", update);
        update.call(this, this.$menu.children("." + _c.current));
      }
    });
  }, add:function() {
    _c = $[_PLUGIN_]._c;
    _d = $[_PLUGIN_]._d;
    _e = $[_PLUGIN_]._e;
    _c.add("indexer hasindexer");
    _e.add("mouseover touchstart");
  }, clickAnchor:function($a, inMenu) {
    if ($a.parent().is("." + _c.indexer)) {
      return true;
    }
  }};
  $[_PLUGIN_].defaults[_ADDON_] = {add:false, addTo:"panels"};
  var _c, _d, _e, glbl;
})(jQuery);
(function($) {
  var _PLUGIN_ = "mmenu", _ADDON_ = "swipeClose";
  $[_PLUGIN_].addons[_ADDON_] = {setup:function() {
    var that = this, opts = this.opts[_ADDON_], conf = this.conf[_ADDON_];
    glbl = $[_PLUGIN_].glbl;
    if (typeof opts == "boolean") {
      opts = {close:opts};
    }
    if (typeof opts != "object") {
      opts = {};
    }
    opts = this.opts[_ADDON_] = $.extend(true, {}, $[_PLUGIN_].defaults[_ADDON_], opts);
    if (opts.close) {
      var closeGesture, prevGesture;
      switch(this.opts.offCanvas.position) {
        case "left":
          closeGesture = "swipeleft";
          break;
        case "right":
          closeGesture = "swiperight";
          break;
        case "top":
          closeGesture = "swipeup";
          break;
        case "bottom":
          closeGesture = "swipedown";
          break;
      }
      if (this.opts.extensions.indexOf("mm-leftsubpanel") != -1) {
        prevGesture = "swipeleft";
      } else {
        prevGesture = "swiperight";
      }
      var _hammer = new Hammer(this.$menu[0], opts.vendors.hammer);
      _hammer.on(closeGesture, function(e) {
        if (that.opts.offCanvas) {
          var prev = that.$menu.find("." + _c.prev + ":visible");
          if (prev.length == 0) {
            that.close();
          } else {
            if (closeGesture != prevGesture) {
              that.close();
            }
          }
        }
      }).on(prevGesture, function(e) {
        var prev = that.$menu.find("." + _c.prev + ":visible");
        if (prev.length > 0) {
          prev.click();
        }
      });
    }
  }, add:function() {
    if (typeof Hammer != "function" || Hammer.VERSION < 2) {
      $[_PLUGIN_].addons[_ADDON_].setup = function() {
      };
      return;
    }
    _c = $[_PLUGIN_]._c;
    _d = $[_PLUGIN_]._d;
    _e = $[_PLUGIN_]._e;
  }, clickAnchor:function($a, inMenu) {
  }};
  $[_PLUGIN_].defaults[_ADDON_] = {close:false, vendors:{hammer:{}}};
  $[_PLUGIN_].configuration[_ADDON_] = {};
  var _c, _d, _e, glbl;
})(jQuery);
(function($) {
  var _PLUGIN_ = "mmenu", _ADDON_ = "toggles";
  $[_PLUGIN_].addons[_ADDON_] = {setup:function() {
    var that = this, opts = this.opts[_ADDON_], conf = this.conf[_ADDON_];
    glbl = $[_PLUGIN_].glbl;
    this.bind("init", function($panels) {
      this.__refactorClass($("input", $panels), this.conf.classNames[_ADDON_].toggle, "toggle");
      this.__refactorClass($("input", $panels), this.conf.classNames[_ADDON_].check, "check");
      $("input." + _c.toggle + ", input." + _c.check, $panels).each(function() {
        var $inpt = $(this), $prnt = $inpt.closest("li"), cl = $inpt.hasClass(_c.toggle) ? "toggle" : "check", id = $inpt.attr("id") || that.__getUniqueId();
        if (!$prnt.children('label[for="' + id + '"]').length) {
          $inpt.attr("id", id);
          $prnt.prepend($inpt);
          $('<label for="' + id + '" class="' + _c[cl] + '"></label>').insertBefore($prnt.children("a, span").last());
        }
      });
    });
  }, add:function() {
    _c = $[_PLUGIN_]._c;
    _d = $[_PLUGIN_]._d;
    _e = $[_PLUGIN_]._e;
    _c.add("toggle check");
  }, clickAnchor:function($a, inMenu) {
  }};
  $[_PLUGIN_].configuration.classNames[_ADDON_] = {toggle:"Toggle", check:"Check"};
  var _c, _d, _e, glbl;
})(jQuery);
Polymer({is:"simpl-mmenu", properties:{name:String, classes:String, slidingSubmenus:String, background:String, searchfield:String, context:{observer:"contextChanged", type:String}}, observers:[], behaviors:[StyleScopeBehavior], attached:function() {
  this.context = null;
  this.roles = window.roles || [];
  this.backgroundColor = "invalid";
  this.classes = "mm-white mm-zoom-panels";
  var nodes = document.querySelector("#dispatcherId").getNodes();
  this._createTree(nodes);
  this._createMenu();
  this.setStyleScope(this._mainmenu, "style-scope", this.tagName.toLowerCase());
  var subscription = channel.subscribe("context.changed", function(data) {
    this.context = data.context;
  }.bind(this));
  var subscription = channel.subscribe("roles.changed", function(data) {
    console.log("roles.changed", data);
    this.roles = data.roles;
    $(this._mainmenu).remove();
    this.async(function() {
      this._createTree(nodes);
      this._createMenu();
      this.setStyleScope(this._mainmenu, "style-scope", this.tagName.toLowerCase());
      document.querySelector("#dispatcherId").initListener();
    }, 200);
  }.bind(this));
  this.fire("menu-ready", {});
}, getMenuApi:function() {
  return $(this._mainmenu).data("mmenu");
}, setSelected:function(page) {
  var li = $(document.querySelector("#x" + page.hash));
  var i = 0;
  var $e = li.parent();
  while ($e.length > 0 && i++ < 10) {
    if ($e.prop("tagName") === "DIV") {
      this.openPanel($e);
      break;
    }
    var $e = $e.parent();
  }
  $(this._mainmenu).data("mmenu").setSelected(li);
}, openPanel:function(e) {
  $(this._mainmenu).data("mmenu").openPanel(e);
}, _createMenu:function() {
  var menu = $(this._mainmenu).mmenu({slidingSubmenus:this.slidingSubmenus == "true", searchfield:{add:this.searchfield != "false", noResults:tr("mmenu.noResults"), placeholder:tr("mmenu.search.placeholder")}, navbar:{add:true, title:tr("mmenu.title")}, navbars:{content:["searchfield"], height:2}, body:$(this._mainmenu), classes:this.classes, offCanvas:false});
  var b = this.background;
  if (b && b.length >= 0) {
    this.backgroundColor = b;
    $(this._mainmenu).css("backgroundColor", b);
    menu.addClass("mm-background");
    $(this).addClass("mm-background");
  }
  setTimeout(function() {
  }.bind(this), 5000);
  this.async(function() {
  });
}, _createTree:function(nodes) {
  var nav = document.createElement("nav");
  this._mainmenu = nav;
  var ul = document.createElement("ul");
  Polymer.dom(this.root).appendChild(nav);
  Polymer.dom(nav).appendChild(ul);
  Polymer.dom(nav).setAttribute("id", "mainmenu");
  Polymer.dom(nav).classList.add("nav");
  this._createNodeList(ul, nodes, true);
}, _createNodeList:function(ul, nodes, firstLevel) {
  for (var i = 0; i < nodes.length; i++) {
    if (nodes[i].uri && nodes[i].uri.startsWith("mainToolbar:")) {
      continue;
    }
    var node = nodes[i];
    if (this._isNodeDisabled(node) || !this._hasNeededRoles(node)) {
      continue;
    }
    if (!this._hasNodeChildren(node)) {
      this._createLeaf(ul, node, firstLevel);
    } else {
      var ul2 = this._createNode(ul, node, firstLevel);
      this._createNodeList(ul2, node.children, false);
    }
  }
}, _createNode:function(parent, node, firstLevel) {
  var icon = this._createIcon(node);
  var li = document.createElement("li");
  var ul = document.createElement("ul");
  var span = document.createElement("span");
  var t = document.createTextNode(node.name);
  Polymer.dom(parent).appendChild(li);
  this._addNodeClasses(li, node.classes);
  Polymer.dom(li).appendChild(span);
  Polymer.dom(li).appendChild(ul);
  Polymer.dom(li).setAttribute("style", "list-style:none");
  Polymer.dom(li).setAttribute("id", "x" + node.hash);
  this._addNodeClasses(li, "menu__item,menu__item_primary,has-sub-menu");
  Polymer.dom(span).appendChild(icon);
  Polymer.dom(span).appendChild(t);
  if (firstLevel) {
    Polymer.dom(li).classList.add("firstLevel");
  }
  return ul;
}, _createLeaf:function(parent, node, firstLevel) {
  var icon = this._createIcon(node);
  var li = document.createElement("li");
  var a = document.createElement("a");
  var pr = document.createElement("paper-ripple");
  var t = document.createTextNode(node.name);
  Polymer.dom(parent).appendChild(li);
  this._addNodeClasses(li, node.classes);
  this._addNodeClasses(li, "menu__item,menu__item_primary");
  this._addNodeClasses(pr, "ripple");
  Polymer.dom(li).appendChild(a);
  if (browser.name != "ie" || browser.major != "9" && browser.major != "10") {
    Polymer.dom(li).appendChild(pr);
  }
  Polymer.dom(a).appendChild(icon);
  Polymer.dom(a).setAttribute("style", "cursor:pointer");
  Polymer.dom(a).setAttribute("id", "hash_" + node.hash);
  Polymer.dom(a).classList.add("menuentry");
  Polymer.dom(a).appendChild(t);
  Polymer.dom(li).setAttribute("style", "list-style:none");
  Polymer.dom(li).setAttribute("id", "x" + node.hash);
  if (firstLevel) {
    Polymer.dom(li).classList.add("firstLevel");
  }
  a.page = node;
  node.provider = this;
}, _createIcon:function(node) {
  var icon = null;
  if (node.aweicon) {
    icon = document.createElement("font-awesome");
    Polymer.dom(icon).setAttribute("icon", node.aweicon);
  } else {
    if (node.icon) {
      icon = document.createElement("iron-icon");
      this._addNodeClasses(icon, "small");
      Polymer.dom(icon).setAttribute("icon", node.icon);
    }
  }
  return icon;
}, _addNodeClasses:function(el, classes) {
  if (classes == null) {
    return;
  }
  var classArray = classes.split(",");
  for (var i = 0; i < classArray.length; i++) {
    el.classList.add(classArray[i]);
  }
}, _isNodeDisabled:function(node) {
  return node.disabled === true;
}, _hasNeededRoles:function(node) {
  if (_.isEmpty(node.roles)) {
    console.log("node.roles.empty", node.roles);
    return true;
  }
  if (_.isEmpty(this.roles)) {
    console.log("this.roles.empty", this.roles);
    return false;
  }
  var self = this;
  var isSuperset = node.roles.every(function(val) {
    return self.roles.indexOf(val) >= 0;
  });
  console.log("node.roles:", node.roles);
  console.log("this.roles:", this.roles);
  console.log("isSuperset:", isSuperset);
  return isSuperset;
}, _hasNodeChildren:function(node) {
  return node.children && node.children.length > 0;
}, contextChanged:function() {
  if (this.context == null) {
    return;
  }
  this._applyMenuContext(this._mainmenu);
}, _applyMenuContext:function(main_el) {
  this._domVisitor(main_el, function(el) {
    if (el.tagName === "LI") {
      el.classList.add("ctx-hidden");
      if (el.classList.contains(this.context)) {
        el.classList.remove("ctx-hidden");
      }
    }
  }.bind(this));
}});
Math.randomString = function(n) {
  var text = "";
  var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  for (var i = 0; i < n; i++) {
    text += possible.charAt(Math.floor(Math.random() * possible.length));
  }
  return text;
};
String.prototype.getCss = function() {
  var css = {};
  var style = this.valueOf().split(";");
  for (var i = 0; i < style.length; i++) {
    style[i] = $.trim(style[i]);
    if (style[i]) {
      var s = style[i].split(":");
      css[$.trim(s[0])] = $.trim(s[1]);
    }
  }
  return css;
};
String.prototype.trim = function() {
  return this.replace(/^\s+|\s+$/g, "");
};
String.prototype.toCamel = function() {
  return this.replace(/(\-[a-z])/g, function($1) {
    return $1.toUpperCase().replace("-", "");
  });
};
String.prototype.toDash = function() {
  return this.replace(/([A-Z])/g, function($1) {
    return "-" + $1.toLowerCase();
  });
};
String.prototype.toUnderscore = function() {
  return this.replace(/([A-Z])/g, function($1) {
    return "_" + $1.toLowerCase();
  });
};
Number.prototype.isBetween = function(num1, num2, including) {
  if (!including) {
    if (this.valueOf() < num2 && this.valueOf() > num1) {
      return true;
    }
  } else {
    if (this.valueOf() <= num2 && this.valueOf() >= num1) {
      return true;
    }
  }
  return false;
};
$.fn.insertAt = function(i, selector) {
  var object = selector;
  if (typeof selector === "string") {
    object = $(selector);
  }
  i = Math.min(object.children().length, i);
  if (i == 0) {
    object.prepend(this);
    return this;
  }
  var oldIndex = this.data("index");
  this.attr("data-index", i);
  object.find(">*:nth-child(" + i + ")").after(this);
  object.children().each(function(index, el) {
    var $el = $(el);
    if (oldIndex < i && index > oldIndex && index <= i) {
      $el.attr("data-index", parseInt($el.data("data-index"), 10) - 1);
    } else {
      if (oldIndex >= i && index > i && index <= oldIndex) {
        $el.attr("data-index", parseInt($el.attr("data-index"), 10) + 1);
      }
    }
  });
  return this;
};
$.fn.disableSelection = function() {
  return this.attr("unselectable", "on").css("user-select", "none").on("selectstart", false);
};
$.fn.enableSelection = function() {
  return this.removeAttr("unselectable").css("user-select", "initial").off("selectstart");
};
$(function() {
  var STORAGE_PREFIX = "lobipanel_";
  var LobiPanel = function($el, options) {
    var me = this;
    this.hasRandomId = false;
    this.storage = null;
    this.$el = $el;
    if (!me.$el.data("inner-id")) {
      me.hasRandomId = true;
      me.$el.attr("data-inner-id", Math.randomString(10));
    }
    this.innerId = me.$el.data("inner-id");
    this.$options = me._processInput(options);
    me.$heading = this.$el.find(">.panel-heading");
    me.$body = this.$el.find(">.panel-body");
    me._init();
    me.$el.css("display", "none");
    me._applyState(me.$options.state, me.$options.stateParams);
    me.$el.css("display", "block");
    me._applyIndex(me.$options.initialIndex);
  };
  LobiPanel.prototype = {_processInput:function(options) {
    var me = this;
    if (!options) {
      options = {};
    }
    if (!me.hasRandomId) {
      me.storage = localStorage.getItem(STORAGE_PREFIX + me.innerId);
      me.storage = JSON.parse(me.storage) || {};
    }
    var opts = me._getOptionsFromAttributes();
    options = $.extend({}, $.fn.lobiPanel.DEFAULTS, me.storage, options, opts);
    var objects = ["unpin", "reload", "expand", "minimize", "close", "editTitle"];
    for (var i = 0; i < objects.length; i++) {
      var prop = objects[i];
      if (typeof options[prop] === "object") {
        options[prop] = $.extend({}, $.fn.lobiPanel.DEFAULTS[prop], options[prop], opts[prop]);
      }
    }
    return options;
  }, _init:function() {
    var me = this;
    me.$el.addClass("lobipanel");
    me.$heading.append(me._generateControls());
    var parent = me.$el.parent();
    me._appendInnerIdToParent(parent, me.innerId);
    me._enableSorting();
    me._onToggleIconsBtnClick();
    me._enableResponsiveness();
    me._setBodyHeight();
    if (me.$options.autoload) {
      me.load();
    }
    var maxWidth = "calc(100% - " + me.$heading.find(".dropdown-menu").children().length * me.$heading.find(".dropdown-menu li").first().outerWidth() + "px)";
    me.$heading.find(".panel-title").css("max-width", maxWidth);
    me._triggerEvent("init");
  }, isPanelInit:function() {
    var me = this;
    return me.$el.hasClass("lobipanel") && me.$el.data("inner-id");
  }, isPinned:function() {
    var me = this;
    return !me.$el.hasClass("panel-unpin");
  }, pin:function() {
    var me = this;
    me.disableResize();
    me.disableDrag();
    me._enableSorting();
    me._offPanelClick();
    me.$el.removeClass("panel-unpin").attr("old-style", me.$el.attr("style")).removeAttr("style").css("position", "relative");
    me.$body.css({width:"", height:""});
    me._setBodyHeight();
    me._insertInParent();
    return me;
  }, unpin:function() {
    var me = this;
    if (me.$el.hasClass("panel-collapsed")) {
      return me;
    }
    me._disableSorting();
    if (me.$el.attr("old-style")) {
      me.$el.attr("style", me.$el.attr("old-style"));
    } else {
      var width = me.$el.width();
      var height = me.$el.height();
      var left = Math.max(0, ($(window).width() - me.$el.outerWidth()) / 2);
      var top = Math.max(0, $(document).scrollTop() + ($(window).height() - me.$el.outerHeight()) / 2);
      me.$el.css({left:left, top:top, width:width, height:height + 10});
    }
    var res = me._getMaxZIndex();
    me.$el.css("z-index", res["z-index"] + 1);
    me._onPanelClick();
    me.$el.addClass("panel-unpin");
    $("body").append(me.$el);
    var panelWidth = me._getAvailableWidth(me.$el.width());
    var panelHeight = me._getAvailableHeight(me.$el.height());
    me.$el.css({position:"absolute", width:panelWidth, height:panelHeight});
    var bHeight = me._calculateBodyHeight(panelHeight);
    var bWidth = me._calculateBodyWidth(panelWidth);
    me.$body.css({width:bWidth, height:bHeight});
    if (me.$options.draggable) {
      me.enableDrag();
    }
    if (me.$options.resize !== "none") {
      me.enableResize();
    }
    return me;
  }, togglePin:function() {
    var me = this;
    if (this.isPinned()) {
      this.unpin();
    } else {
      this.pin();
    }
    return me;
  }, isMinimized:function() {
    var me = this;
    return me.$el.hasClass("panel-minimized") || me.$el.hasClass("panel-collapsed");
  }, minimize:function() {
    var me = this;
    me._triggerEvent("beforeMinimize");
    if (me.isMinimized()) {
      return me;
    }
    if (me.isPinned()) {
      me.$body.slideUp();
      me.$el.find(".panel-footer").slideUp();
      me.$el.addClass("panel-collapsed");
      me._saveState("collapsed");
      me._changeClassOfControl(me.$heading.find('[data-func="minimize"]'));
    } else {
      me.disableTooltips();
      var footer = me._getFooterForMinimizedPanels();
      var children = footer.find(">*");
      var left, top;
      top = footer.offset().top;
      if (children.length === 0) {
        left = footer.offset().left;
      } else {
        var ch = $(children[children.length - 1]);
        left = ch.offset().left + ch.width();
      }
      if (!me.$el.hasClass("panel-expanded")) {
        me.$el.attr("old-style", me.$el.attr("style"));
      }
      me.$el.animate({left:left, top:top, width:200, height:footer.height()}, 100, function() {
        if (me.$el.hasClass("panel-expanded")) {
          me.$el.removeClass("panel-expanded");
          me.$el.find(".panel-heading [data-func=expand] ." + LobiPanel.PRIVATE_OPTIONS.iconClass).removeClass(me.$options.expand.icon2).addClass(me.$options.expand.icon);
        }
        me.$el.addClass("panel-minimized");
        me.$el.removeAttr("style");
        me.disableDrag();
        me.disableResize();
        me._expandOnHeaderClick();
        footer.append(me.$el);
        $("body").addClass("lobipanel-minimized");
        var maxWidth = "calc(100% - " + me.$heading.find(".dropdown-menu li>a:visible").length * me.$heading.find(".dropdown-menu li>a:visible").first().outerWidth() + "px)";
        me.$heading.find(".panel-title").css("max-width", maxWidth);
        me._saveState("minimized");
        me._triggerEvent("onMinimize");
      });
    }
    return me;
  }, maximize:function() {
    var me = this;
    me._triggerEvent("beforeMaximize");
    if (!me.isMinimized()) {
      return me;
    }
    if (me.isPinned()) {
      me.$body.slideDown();
      me.$el.find(".panel-footer").slideDown();
      me.$el.removeClass("panel-collapsed");
      me._saveState("pinned");
      me._changeClassOfControl(me.$heading.find('[data-func="minimize"]'));
    } else {
      me.enableTooltips();
      var css = me.$el.attr("old-style").getCss();
      me.$el.css({position:css.position || "fixed", "z-index":css["z-index"], left:me.$el.offset().left, top:me.$el.offset().top, width:me.$el.width(), height:me.$el.height()});
      $("body").append(me.$el);
      delete css["position"];
      delete css["z-index"];
      me.$el.animate(css, 100, function() {
        me.$el.css("position", "");
        me.$el.removeClass("panel-minimized");
        me.$el.removeAttr("old-style");
        if (me.$options.draggable) {
          me.enableDrag();
        }
        me.enableResize();
        me._removeExpandOnHeaderClick();
        var footer = me._getFooterForMinimizedPanels();
        if (footer.children().length === 0) {
          footer.remove();
        }
        $("body").removeClass("lobipanel-minimized").addClass("lobipanel-minimized");
        var maxWidth = "calc(100% - " + me.$heading.find(".dropdown-menu li").length * me.$heading.find(".dropdown-menu li").first().outerWidth() + "px)";
        me.$heading.find(".panel-title").css("max-width", maxWidth);
        me._updateUnpinnedState();
        me._triggerEvent("onMaximize");
      });
    }
    return me;
  }, toggleMinimize:function() {
    var me = this;
    if (me.isMinimized()) {
      me.maximize();
    } else {
      me.minimize();
    }
    return me;
  }, isOnFullScreen:function() {
    var me = this;
    return me.$el.hasClass("panel-expanded");
  }, toFullScreen:function() {
    var me = this;
    me._triggerEvent("beforeFullScreen");
    if (me.$el.hasClass("panel-collapsed")) {
      return me;
    }
    me._changeClassOfControl(me.$heading.find('[data-func="expand"]'));
    me.$el.css("position", "fixed");
    var res = me._getMaxZIndex();
    if (me.isPinned() || me.isMinimized()) {
      me.enableTooltips();
      me.$el.css({"z-index":res["z-index"] + 1, left:me.$el.offset().left, top:me.$el.offset().top - $(window).scrollTop(), width:me.$el.width(), height:me.$el.height()});
      $("body").append(me.$el);
      var footer = me._getFooterForMinimizedPanels();
      if (footer.children().length === 0) {
        footer.remove();
      }
    } else {
      me.$body.css({width:"", height:""});
      me._setBodyHeight();
    }
    if (!me.isMinimized()) {
      me.$el.attr("old-style", me.$el.attr("style"));
      me.disableResize();
    } else {
      me.$el.removeClass("panel-minimized");
      me._removeExpandOnHeaderClick();
    }
    var toolbar = $("." + LobiPanel.PRIVATE_OPTIONS.toolbarClass);
    var toolbarHeight = toolbar.outerHeight() || 0;
    me.$el.animate({width:$(window).width(), height:$(window).height() - toolbarHeight, left:0, top:0}, me.$options.expandAnimation, function() {
      me.$el.css({width:"", height:"", right:0, bottom:toolbarHeight});
      me.$el.addClass("panel-expanded");
      $("body").css("overflow", "hidden");
      me.$body.css({width:me._calculateBodyWidth(me.$el.width()), height:me._calculateBodyHeight(me.$el.height())});
      me.disableDrag();
      if (me.isPinned()) {
        me._disableSorting();
      }
      me._saveState("fullscreen");
      me._triggerEvent("onFullScreen");
    });
    return me;
  }, toSmallSize:function() {
    var me = this;
    me._triggerEvent("beforeSmallSize");
    me._changeClassOfControl(me.$heading.find('[data-func="expand"]'));
    var css = me.$el.attr("old-style").getCss();
    me.$el.animate({position:"absolute", left:css.left, top:css.top, width:css.width, height:css.height, right:css.right, bottom:css.bottom}, me.$options.collapseAnimation, function() {
      me.$el.removeAttr("old-style");
      if (!me.$el.hasClass("panel-unpin")) {
        me.$el.removeAttr("style");
        me._insertInParent();
        me._enableSorting();
      } else {
        if (me.$options.draggable) {
          me.enableDrag();
        }
        me.enableResize();
      }
      me.$el.removeClass("panel-expanded");
      $("body").css("overflow", "auto");
      var bWidth = "";
      var bHeight = "";
      if (!me.isPinned()) {
        bWidth = me._calculateBodyWidth(me.getWidth());
        bHeight = me._calculateBodyHeight(me.getHeight());
      } else {
        if (me.$options.bodyHeight !== "auto") {
          bHeight = me.$options.bodyHeight;
        }
      }
      if (me.$options.bodyHeight !== "auto") {
        me._saveState("pinnned");
      } else {
        me._updateUnpinnedState();
      }
      me.$body.css({width:bWidth, height:bHeight});
      me._triggerEvent("onSmallSize");
    });
    return me;
  }, toggleSize:function() {
    var me = this;
    if (me.isOnFullScreen()) {
      me.toSmallSize();
    } else {
      me.toFullScreen();
    }
    return me;
  }, close:function(animationDuration) {
    var me = this, animationDuration = animationDuration === undefined ? 100 : animationDuration;
    me._triggerEvent("beforeClose");
    me.$el.hide(animationDuration, function() {
      if (me.isOnFullScreen()) {
        $("body").css("overflow", "auto");
      }
      me._triggerEvent("onClose");
      me.$el.remove();
      var footer = me._getFooterForMinimizedPanels();
      if (footer.children().length === 0) {
        footer.remove();
      }
    });
    return me;
  }, setPosition:function(left, top, animationDuration) {
    var me = this, animationDuration = animationDuration === undefined ? 100 : animationDuration;
    if (me.isPinned()) {
      return me;
    }
    me.$el.animate({"left":left, "top":top}, animationDuration);
    return me;
  }, setWidth:function(w, animationDuration) {
    var me = this, animationDuration = animationDuration === undefined ? 100 : animationDuration;
    if (me.isPinned()) {
      return me;
    }
    var bWidth = me._calculateBodyWidth(w);
    me.$el.animate({width:w}, animationDuration);
    me.$body.animate({width:bWidth}, animationDuration);
    return me;
  }, setHeight:function(h, animationDuration) {
    var me = this, animationDuration = animationDuration === undefined ? 100 : animationDuration;
    if (me.isPinned()) {
      return me;
    }
    var bHeight = me._calculateBodyHeight(h);
    me.$el.animate({height:h}, animationDuration);
    me.$body.animate({height:bHeight}, animationDuration);
    return me;
  }, setSize:function(w, h, animationDuration) {
    var me = this, animationDuration = animationDuration === undefined ? 100 : animationDuration;
    if (me.isPinned()) {
      return me;
    }
    var bHeight = me._calculateBodyHeight(h);
    var bWidth = me._calculateBodyWidth(w);
    me.$el.animate({height:h, width:w}, animationDuration);
    me.$body.animate({height:bHeight, width:bWidth}, animationDuration);
    return me;
  }, getPosition:function() {
    var me = this;
    var offset = me.$el.offset();
    return {x:offset.left, y:offset.top};
  }, getWidth:function() {
    var me = this;
    return me.$el.width();
  }, getHeight:function() {
    var me = this;
    return me.$el.height();
  }, bringToFront:function() {
    var me = this;
    me._triggerEvent("beforeToFront");
    var res = me._getMaxZIndex();
    if (res["id"] === me.$el.data("inner-id")) {
      return me;
    }
    me.$el.css("z-index", res["z-index"] + 1);
    me._triggerEvent("onToFront");
    return me;
  }, enableDrag:function() {
    var me = this;
    me.$el.draggable({handle:".panel-heading", containment:me.$options.constrain, start:function() {
      me.$el.css("position", "absolute");
    }, stop:function() {
      me.$el.css("position", "");
      me._updateUnpinnedState();
    }});
    return me;
  }, disableDrag:function() {
    var me = this;
    if (me.$el.hasClass("ui-draggable")) {
      me.$el.draggable("destroy");
    }
    return me;
  }, enableResize:function() {
    var me = this;
    var handles = false;
    if (me.$options.resize === "vertical") {
      handles = "n, s";
    } else {
      if (me.$options.resize === "horizontal") {
        handles = "e, w";
      } else {
        if (me.$options.resize === "both") {
          handles = "all";
        }
      }
    }
    if (!handles) {
      return me;
    }
    me.$el.resizable({minWidth:me.$options.minWidth, maxWidth:me.$options.maxWidth, minHeight:me.$options.minHeight, maxHeight:me.$options.maxHeight, handles:handles, start:function() {
      me.$el.disableSelection();
      me._triggerEvent("resizeStart");
    }, stop:function() {
      me.$el.enableSelection();
      me._triggerEvent("resizeStop");
    }, resize:function() {
      var bHeight = me._calculateBodyHeight(me.$el.height());
      var bWidth = me._calculateBodyWidth(me.$el.width());
      me.$body.css({width:bWidth, height:bHeight});
      me._updateUnpinnedState();
      me._triggerEvent("onResize");
    }});
    return me;
  }, disableResize:function() {
    var me = this;
    if (me.$el.hasClass("ui-resizable")) {
      me.$el.resizable("destroy");
    }
    return me;
  }, startLoading:function() {
    var me = this;
    var spinner = me._generateWindow8Spinner();
    me.$el.append(spinner);
    var sp = spinner.find(".spinner");
    sp.css("margin-top", 50);
    return me;
  }, stopLoading:function() {
    var me = this;
    me.$el.find(".spinner-wrapper").remove();
    return me;
  }, setLoadUrl:function(url) {
    var me = this;
    me.$options.loadUrl = url;
    return me;
  }, load:function(params) {
    var me = this;
    params = params || {};
    if (typeof params === "string") {
      params = {url:params};
    }
    var url = params.url || me.$options.loadUrl, data = params.data || {}, callback = params.callback || null;
    if (!url) {
      return me;
    }
    me._triggerEvent("beforeLoad");
    me.startLoading();
    me.$body.load(url, data, function(result, status, xhr) {
      if (callback && typeof callback === "function") {
        me.callback(result, status, xhr);
      }
      me.stopLoading();
      me._triggerEvent("loaded", result, status, xhr);
    });
    return me;
  }, destroy:function() {
    var me = this;
    me.disableDrag();
    me.disableResize();
    me.$options.sortable = false;
    me._enableSorting();
    me._removeInnerIdFromParent(me.innerId);
    me.$el.removeClass("lobipanel").removeAttr("data-inner-id").removeAttr("data-index").removeData("lobiPanel");
    me.$heading.find(".dropdown").remove();
    return me.$el;
  }, startTitleEditing:function() {
    var me = this;
    var title = me.$heading.find(".panel-title").text().trim();
    var input = $('<input value="' + title + '"/>');
    input.on("keydown", function(ev) {
      if (ev.which === 13) {
        me.finishTitleEditing();
      } else {
        if (ev.which === 27) {
          me.cancelTitleEditing();
        }
      }
    });
    me.$heading.find(".panel-title").data("old-title", title).html("").append(input);
    input[0].focus();
    input[0].select();
    me._changeClassOfControl(me.$heading.find('[data-func="editTitle"]'));
    return me;
  }, isTitleEditing:function() {
    var me = this;
    return me.$heading.find(".panel-title input").length > 0;
  }, cancelTitleEditing:function() {
    var me = this;
    var title = me.$heading.find(".panel-title");
    title.html(title.data("old-title")).find("input").remove();
    me._changeClassOfControl(me.$heading.find('[data-func="editTitle"]'));
    return me;
  }, finishTitleEditing:function() {
    var me = this, input = me.$heading.find("input");
    if (me._triggerEvent("beforeTitleChange", input.val()) === false) {
      return me;
    }
    me.$heading.find(".panel-title").html(input.val());
    input.remove();
    me._changeClassOfControl(me.$heading.find('[data-func="editTitle"]'));
    me._triggerEvent("onTitleChange", input.val());
    return me;
  }, enableTooltips:function() {
    var me = this;
    if ($(window).width() < 768) {
      return me;
    }
    var controls = me.$heading.find(".dropdown-menu>li>a");
    controls.each(function(index, el) {
      var $el = $(el);
      $el.attr("data-toggle", "tooltip").attr("data-title", $el.data("tooltip")).attr("data-placement", "bottom");
    });
    controls.each(function(ind, el) {
      $(el).tooltip({container:"body", template:'<div class="tooltip lobipanel-tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>'});
    });
    return me;
  }, disableTooltips:function() {
    var me = this;
    var $links = me.$heading.find(".dropdown-menu>li>a");
    $links.each(function(ind, el) {
      var bsTooltip = $(el).data("bs.tooltip");
      if (bsTooltip) {
        $(el).tooltip("destroy");
      }
    });
    return me;
  }, _generateControls:function() {
    var me = this;
    var dropdown = me._generateDropdown();
    var menu = dropdown.find(".dropdown-menu");
    if (me.$options.editTitle !== false) {
      menu.append(me._generateEditTitle());
    }
    if (me.$options.unpin !== false) {
      menu.append(me._generateUnpin());
    }
    if (me.$options.reload !== false) {
      menu.append(me._generateReload());
    }
    if (me.$options.minimize !== false) {
      menu.append(me._generateMinimize());
    }
    if (me.$options.expand !== false) {
      menu.append(me._generateExpand());
    }
    if (me.$options.close !== false) {
      menu.append(me._generateClose());
    }
    menu.find(">li>a").on("click", function(ev) {
      ev.preventDefault();
      ev.stopPropagation();
    });
    return dropdown;
  }, _generateDropdown:function() {
    var me = this;
    return $('<div class="dropdown"></div>').append('<ul class="dropdown-menu dropdown-menu-right"></ul>').append('<div class="dropdown-toggle" data-toggle="dropdown"><span class="' + LobiPanel.PRIVATE_OPTIONS.iconClass + " " + me.$options.toggleIcon + '"></div>');
  }, _generateEditTitle:function() {
    var me = this;
    var options = me.$options.editTitle;
    var control = $('<a data-func="editTitle"></a>');
    control.append('<i class="' + LobiPanel.PRIVATE_OPTIONS.iconClass + " " + options.icon + '"></i>');
    if (options.tooltip && typeof options.tooltip === "string") {
      control.append('<span class="control-title">' + options.tooltip + "</span>");
      control.attr("data-tooltip", options.tooltip);
    }
    me._attachEditTitleClickListener(control);
    return $("<li></li>").append(control);
  }, _attachEditTitleClickListener:function(control) {
    var me = this;
    control.on("mousedown", function(ev) {
      ev.stopPropagation();
    });
    control.on("click", function(ev) {
      ev.stopPropagation();
      me.hideTooltip(control);
      if (me.isTitleEditing()) {
        me.finishTitleEditing();
      } else {
        me.startTitleEditing();
      }
    });
  }, hideTooltip:function($el) {
    var bsTooltip = $el.data("bs.tooltip");
    if (bsTooltip) {
      $el.tooltip("hide");
    }
    return this;
  }, _generateUnpin:function() {
    var me = this;
    var options = me.$options.unpin;
    var control = $('<a data-func="unpin"></a>');
    control.append('<i class="' + LobiPanel.PRIVATE_OPTIONS.iconClass + " " + options.icon + '"></i>');
    if (options.tooltip && typeof options.tooltip === "string") {
      control.append('<span class="control-title">' + options.tooltip + "</span>");
      control.attr("data-tooltip", options.tooltip);
    }
    me._attachUnpinClickListener(control);
    return $("<li></li>").append(control);
  }, _attachUnpinClickListener:function(control) {
    var me = this;
    control.on("mousedown", function(ev) {
      ev.stopPropagation();
    });
    control.on("click", function() {
      me.hideTooltip(control);
      me.doTogglePin();
    });
  }, _generateReload:function() {
    var me = this;
    var options = me.$options.reload;
    var control = $('<a data-func="reload"></a>');
    control.append('<i class="' + LobiPanel.PRIVATE_OPTIONS.iconClass + " " + options.icon + '"></i>');
    if (options.tooltip && typeof options.tooltip === "string") {
      control.append('<span class="control-title">' + options.tooltip + "</span>");
      control.attr("data-tooltip", options.tooltip);
    }
    me._attachReloadClickListener(control);
    return $("<li></li>").append(control);
  }, _attachReloadClickListener:function(control) {
    var me = this;
    control.on("mousedown", function(ev) {
      ev.stopPropagation();
    });
    control.on("click", function() {
      me.hideTooltip(control);
      me.load();
    });
  }, _generateMinimize:function() {
    var me = this;
    var options = me.$options.minimize;
    var control = $('<a data-func="minimize"></a>');
    control.append('<i class="' + LobiPanel.PRIVATE_OPTIONS.iconClass + " " + options.icon + '"></i>');
    if (options.tooltip && typeof options.tooltip === "string") {
      control.append('<span class="control-title">' + options.tooltip + "</span>");
      control.attr("data-tooltip", options.tooltip);
    }
    me._attachMinimizeClickListener(control);
    return $("<li></li>").append(control);
  }, _attachMinimizeClickListener:function(control) {
    var me = this;
    control.on("mousedown", function(ev) {
      ev.stopPropagation();
    });
    control.on("click", function(ev) {
      ev.stopPropagation();
      me.hideTooltip(control);
      me.toggleMinimize();
    });
  }, _generateExpand:function() {
    var me = this;
    var options = me.$options.expand;
    var control = $('<a data-func="expand"></a>');
    control.append('<i class="' + LobiPanel.PRIVATE_OPTIONS.iconClass + " " + options.icon + '"></i>');
    if (options.tooltip && typeof options.tooltip === "string") {
      control.append('<span class="control-title">' + options.tooltip + "</span>");
      control.attr("data-tooltip", options.tooltip);
    }
    me._attachExpandClickListener(control);
    return $("<li></li>").append(control);
  }, _attachExpandClickListener:function(control) {
    var me = this;
    control.on("mousedown", function(ev) {
      ev.stopPropagation();
    });
    control.on("click", function(ev) {
      ev.stopPropagation();
      me.hideTooltip(control);
      me.toggleSize();
    });
  }, _generateClose:function() {
    var me = this;
    var options = me.$options.close;
    var control = $('<a data-func="close"></a>');
    control.append('<i class="' + LobiPanel.PRIVATE_OPTIONS.iconClass + " " + options.icon + '"></i>');
    if (options.tooltip && typeof options.tooltip === "string") {
      control.append('<span class="control-title">' + options.tooltip + "</span>");
      control.attr("data-tooltip", options.tooltip);
    }
    me._attachCloseClickListener(control);
    return $("<li></li>").append(control);
  }, _attachCloseClickListener:function(control) {
    var me = this;
    control.on("mousedown", function(ev) {
      ev.stopPropagation();
    });
    control.on("click", function(ev) {
      ev.stopPropagation();
      me.hideTooltip(control);
      me.close();
    });
  }, _getMaxZIndex:function() {
    var me = this;
    var panels = $(".lobipanel.panel-unpin:not(.panel-minimized.panel-expanded)"), style, max, cur;
    if (panels.length === 0) {
      return {"id":"", "z-index":LobiPanel.PRIVATE_OPTIONS.initialZIndex};
    }
    style = $(panels[0]).attr("style");
    var id = $(panels[0]).data("inner-id");
    if (!style) {
      max = LobiPanel.PRIVATE_OPTIONS.initialZIndex;
    } else {
      max = style.getCss()["z-index"];
    }
    for (var i = 1; i < panels.length; i++) {
      style = $(panels[i]).attr("style");
      if (!style) {
        cur = 0;
      } else {
        cur = style.getCss()["z-index"];
      }
      if (cur > max) {
        id = $(panels[i]).data("inner-id");
        max = cur;
      }
    }
    return {"id":id, "z-index":parseInt(max, 10)};
  }, _onPanelClick:function() {
    var me = this;
    me.$el.on("mousedown.lobiPanel", function() {
      if (me.isPinned() || me.isMinimized() || me.isOnFullScreen()) {
        return false;
      }
      me.bringToFront();
    });
  }, _offPanelClick:function() {
    var me = this;
    me.$el.off("mousedown.lobiPanel");
  }, _changeClassOfControl:function(el) {
    var me = this;
    el = $(el);
    var opts = me.$options[el.attr("data-func")];
    if (!opts.icon) {
      return;
    }
    el.find("." + LobiPanel.PRIVATE_OPTIONS.iconClass).toggleClass(opts.icon).toggleClass(opts.icon2);
  }, _getFooterForMinimizedPanels:function() {
    var me = this;
    var minimizedCtr = $("." + LobiPanel.PRIVATE_OPTIONS.toolbarClass);
    if (minimizedCtr.length === 0) {
      minimizedCtr = $('<div class="' + LobiPanel.PRIVATE_OPTIONS.toolbarClass + '"></div>');
      $("body").append(minimizedCtr);
    }
    return minimizedCtr;
  }, _expandOnHeaderClick:function() {
    var me = this;
    me.$heading.on("click.lobiPanel", function() {
      me.maximize();
      me.bringToFront();
    });
  }, _removeExpandOnHeaderClick:function() {
    var me = this;
    me.$heading.off("click.lobiPanel");
  }, _getAvailableWidth:function(calcWidth) {
    var me = this;
    if (me.$options.maxWidth) {
      calcWidth = Math.min(calcWidth, me.$options.maxWidth);
    }
    if (me.$options.minWidth) {
      calcWidth = Math.max(calcWidth, me.$options.minWidth);
    }
    return calcWidth;
  }, _getAvailableHeight:function(calcHeight) {
    var me = this;
    if (me.$options.maxHeight) {
      calcHeight = Math.min(calcHeight, me.$options.maxHeight);
    }
    if (me.$options.minHeight) {
      calcHeight = Math.max(calcHeight, me.$options.minHeight);
    }
    return calcHeight;
  }, _calculateBodyHeight:function(h) {
    var me = this;
    return h - me.$heading.outerHeight() - me.$el.find(".panel-footer").outerHeight();
  }, _calculateBodyWidth:function(w) {
    var me = this;
    return w - 2;
  }, _appendInnerIdToParent:function(parent, innerId) {
    var me = this;
    if (parent.attr(LobiPanel.PRIVATE_OPTIONS.parentAttr) === undefined) {
      parent.attr(LobiPanel.PRIVATE_OPTIONS.parentAttr, innerId);
    } else {
      if (parent.attr(LobiPanel.PRIVATE_OPTIONS.parentAttr).indexOf(innerId) > -1) {
        return;
      }
      var innerIds = parent.attr(LobiPanel.PRIVATE_OPTIONS.parentAttr);
      parent.attr(LobiPanel.PRIVATE_OPTIONS.parentAttr, innerIds + " " + innerId);
    }
    me.$el.attr("data-index", me.$el.index());
  }, _insertInParent:function() {
    var me = this;
    var parent = $("[" + LobiPanel.PRIVATE_OPTIONS.parentAttr + "~=" + me.innerId + "]");
    me.$el.insertAt(me.$el.attr("data-index"), parent);
  }, _generateWindow8Spinner:function() {
    var me = this;
    var template = ['<div class="spinner spinner-windows8">', '<div class="wBall">', '<div class="wInnerBall">', "</div>", "</div>", '<div class="wBall">', '<div class="wInnerBall">', "</div>", "</div>", '<div class="wBall">', '<div class="wInnerBall">', "</div>", "</div>", '<div class="wBall">', '<div class="wInnerBall">', "</div>", "</div>", '<div class="wBall">', '<div class="wInnerBall">', "</div>", "</div>", "</div>"].join("");
    return $('<div class="spinner-wrapper">' + template + "</div>");
  }, _enableSorting:function() {
    var me = this;
    var parent = me.$el.parent();
    if (parent.hasClass("ui-sortable")) {
      parent.sortable("destroy");
    }
    if (me.$options.sortable) {
      me.$el.addClass("lobipanel-sortable");
      parent.addClass("lobipanel-parent-sortable");
    } else {
      me.$el.removeClass("lobipanel-sortable");
    }
    parent.sortable({connectWith:".lobipanel-parent-sortable", items:".lobipanel-sortable", handle:".panel-heading", cursor:"move", placeholder:"lobipanel-placeholder", forcePlaceholderSize:true, opacity:0.7, revert:300, update:function(event, ui) {
      var innerId = ui.item.data("inner-id");
      me._removeInnerIdFromParent(innerId);
      me._appendInnerIdToParent(ui.item.parent(), innerId);
      me._updateDataIndices(ui.item);
      me._triggerEvent("dragged");
    }});
  }, _disableSorting:function() {
    var me = this;
    var parent = me.$el.parent();
    if (parent.hasClass("ui-sortable")) {
      parent.sortable("destroy");
    }
  }, _updateDataIndices:function(panel) {
    var me = this;
    var items = panel.parent().children();
    items.each(function(index, el) {
      $(el).attr("data-index", index);
      var lobiPanel = $(el).data("lobiPanel");
      if (lobiPanel && lobiPanel.$options.stateful && !lobiPanel.hasRandomId) {
        lobiPanel._saveState("pinned", {index:index});
      }
    });
    console.log("Save indices in localstorage");
  }, _removeInnerIdFromParent:function(innerId) {
    var me = this;
    var parent = $("[" + LobiPanel.PRIVATE_OPTIONS.parentAttr + "~=" + innerId + "]");
    var innerIds = parent.attr(LobiPanel.PRIVATE_OPTIONS.parentAttr).replace(innerId, "").trim().replace(/\s{2,}/g, " ");
    parent.attr(LobiPanel.PRIVATE_OPTIONS.parentAttr, innerIds);
  }, _onToggleIconsBtnClick:function() {
    var me = this;
    me.$heading.find(".toggle-controls").on("click.lobiPanel", function() {
      me.$el.toggleClass("controls-expanded");
    });
  }, _adjustForScreenSize:function() {
    var me = this;
    me.disableTooltips();
    if ($(window).width() > 768 && me.$options.tooltips) {
      me.enableTooltips();
    }
    if (me.isOnFullScreen()) {
      me.$body.css({width:me._calculateBodyWidth(me.$el.width()), height:me._calculateBodyHeight(me.$el.height())});
    }
  }, _enableResponsiveness:function() {
    var me = this;
    me._adjustForScreenSize();
    $(window).on("resize.lobiPanel", function() {
      me._adjustForScreenSize();
    });
  }, _setBodyHeight:function() {
    var me = this;
    if (me.$options.bodyHeight !== "auto") {
      me.$body.css({"height":me.$options.bodyHeight, overflow:"auto"});
    }
  }, _getOptionsFromAttributes:function() {
    var me = this;
    var $el = me.$el;
    var options = {};
    for (var key in $.fn.lobiPanel.DEFAULTS) {
      var k = key.toDash();
      var val = $el.data(k);
      if (val !== undefined) {
        if (typeof $.fn.lobiPanel.DEFAULTS[key] !== "object") {
          options[key] = val;
        } else {
          options[key] = eval("(" + val + ")");
        }
      }
    }
    return options;
  }, _saveState:function(state, params) {
    var me = this;
    console.log("Save state ", state, params);
    if (!me.hasRandomId && me.$options.stateful) {
      me.storage.state = state;
      if (params) {
        me.storage.stateParams = params;
      }
      me._saveLocalStorage(me.storage);
    }
  }, _saveLocalStorage:function(storage) {
    var me = this;
    localStorage.setItem(STORAGE_PREFIX + me.innerId, JSON.stringify(storage));
  }, _applyState:function(state, params) {
    var me = this;
    switch(state) {
      case "pinned":
        if (params && params.index !== null && params.index !== undefined) {
          me._applyIndex(params.index);
        }
        break;
      case "unpinned":
        me.unpin();
        me.setPosition(params.left, params.top, 0);
        me.setSize(params.width, params.height, 0);
        break;
      case "minimized":
        me.unpin();
        me.minimize();
        break;
      case "collapsed":
        me.minimize();
        break;
      case "fullscreen":
        me.toFullScreen();
        break;
      default:
        break;
    }
  }, _applyIndex:function(index) {
    var me = this;
    if (index !== null) {
      me.$el.insertAt(index, me.$el.parent());
    }
  }, _triggerEvent:function(eventType) {
    var me = this;
    var args = Array.prototype.slice.call(arguments, 1);
    args.unshift(me);
    me.$el.trigger(eventType + ".lobiPanel", args);
    if (me.$options[eventType] && typeof me.$options[eventType] === "function") {
      return me.$options[eventType].apply(me, args);
    }
    return true;
  }, doPin:function() {
    var me = this;
    if (me._triggerEvent("beforePin") !== false) {
      me.pin();
      me._saveState("pinned");
      me._triggerEvent("onPin");
    }
    return me;
  }, doUnpin:function() {
    var me = this;
    if (me._triggerEvent("beforeUnpin") !== false) {
      me.unpin();
      me._updateUnpinnedState();
      me._triggerEvent("onUnpin");
    }
    return me;
  }, doTogglePin:function() {
    var me = this;
    if (this.isPinned()) {
      this.doUnpin();
    } else {
      this.doPin();
    }
    return me;
  }, _updateUnpinnedState:function() {
    var me = this;
    me._saveState("unpinned", me.getAlignment());
  }, getAlignment:function() {
    var me = this;
    return {top:me.$el.css("top"), left:me.$el.css("left"), width:me.$el.css("width"), height:me.$el.css("height")};
  }};
  $.fn.lobiPanel = function(option) {
    var args = arguments, ret = null;
    this.each(function() {
      var $this = $(this);
      var data = $this.data("lobiPanel");
      var options = typeof option === "object" && option;
      if (!data) {
        $this.data("lobiPanel", data = new LobiPanel($this, options));
      }
      if (typeof option === "string") {
        args = Array.prototype.slice.call(args, 1);
        ret = data[option].apply(data, args);
      }
    });
    return ret;
  };
  LobiPanel.PRIVATE_OPTIONS = {parentAttr:"data-lobipanel-child-inner-id", toolbarClass:"lobipanel-minimized-toolbar", initialZIndex:10000, iconClass:"panel-control-icon"};
  $.fn.lobiPanel.DEFAULTS = {draggable:true, sortable:false, connectWith:".ui-sortable", resize:"both", minWidth:200, minHeight:100, maxWidth:1200, maxHeight:700, loadUrl:"", autoload:true, bodyHeight:"auto", tooltips:true, toggleIcon:"glyphicon glyphicon-cog", expandAnimation:100, collapseAnimation:100, state:"pinned", initialIndex:null, stateful:false, constrain:"document", unpin:{icon:"glyphicon glyphicon-move", tooltip:"Unpin"}, reload:{icon:"glyphicon glyphicon-refresh", tooltip:"Reload"}, minimize:{icon:"glyphicon glyphicon-minus", 
  icon2:"glyphicon glyphicon-plus", tooltip:"Minimize"}, expand:{icon:"glyphicon glyphicon-resize-full", icon2:"glyphicon glyphicon-resize-small", tooltip:"Fullscreen"}, close:{icon:"glyphicon glyphicon-remove", tooltip:"Close"}, editTitle:{icon:"glyphicon glyphicon-pencil", icon2:"glyphicon glyphicon-floppy-disk", tooltip:"Edit title"}, beforeTitleChange:null};
  $(".lobipanel").lobiPanel();
});
Polymer({is:"simpl-lobipanel", behaviors:[ModernizrBehavior, StyleScopeBehavior], attached:function() {
  this.async(function() {
    this.init();
  }, 200);
}, init:function() {
  $(".panel").lobiPanel({reload:{icon:"fa fa-refresh"}, editTitle:{icon:"fa fa-edit", icon2:"fa fa-save"}, unpin:{icon:"fa fa-arrows"}, minimize:{icon:"fa fa-chevron-up", icon2:"fa fa-chevron-down"}, close:{icon:"fa fa-times-circle"}, expand:{icon:"fa fa-expand", icon2:"fa fa-compress"}, sortable:true, reload:false, unpin:false, close:false, editTitle:false});
  this.async(function() {
    this.setStyleScope(this, "style-scope", this.tagName.toLowerCase());
  });
}});
"use strict";
(function(factory) {
  if (typeof define === "function" && define.amd) {
    define(["jquery"], factory);
  } else {
    if (typeof exports === "object") {
      module.exports = factory(require("jquery"));
    } else {
      factory(jQuery);
    }
  }
})(function($) {
  var spinningTimer;
  var Spinner;
  var Spinning = function($element, options) {
    this.$el = $element;
    this.options = $.extend({}, Spinning.rules.defaults, Spinning.rules[options.rule] || {}, options);
    this.min = Number(this.options.min) || 0;
    this.max = Number(this.options.max) || 0;
    this.$el.on({"focus.spinner":$.proxy(function(e) {
      e.preventDefault();
      $(document).trigger("mouseup.spinner");
      this.oldValue = this.value();
    }, this), "change.spinner":$.proxy(function(e) {
      e.preventDefault();
      this.value(this.$el.val());
    }, this), "keydown.spinner":$.proxy(function(e) {
      var dir = {38:"up", 40:"down"}[e.which];
      if (dir) {
        e.preventDefault();
        this.spin(dir);
      }
    }, this)});
    this.oldValue = this.value();
    this.value(this.$el.val());
    return this;
  };
  Spinning.rules = {defaults:{min:null, max:null, step:1, precision:0}, currency:{min:0.00, max:null, step:0.01, precision:2}, quantity:{min:1, max:999, step:1, precision:0}, percent:{min:1, max:100, step:1, precision:0}, month:{min:1, max:12, step:1, precision:0}, day:{min:1, max:31, step:1, precision:0}, hour:{min:0, max:23, step:1, precision:0}, minute:{min:1, max:59, step:1, precision:0}, second:{min:1, max:59, step:1, precision:0}};
  Spinning.prototype = {spin:function(dir) {
    if (this.$el.prop("disabled")) {
      return;
    }
    this.oldValue = this.value();
    var step = $.isFunction(this.options.step) ? this.options.step.call(this, dir) : this.options.step;
    var multipler = dir === "up" ? 1 : -1;
    this.value(this.oldValue + Number(step) * multipler);
  }, value:function(v) {
    if (v === null || v === undefined) {
      return this.numeric(this.$el.val());
    }
    v = this.numeric(v);
    var valid = this.validate(v);
    if (valid !== 0) {
      v = valid === -1 ? this.min : this.max;
    }
    this.$el.val(v.toFixed(this.options.precision));
    if (this.oldValue !== this.value()) {
      this.$el.trigger("changing.spinner", [this.value(), this.oldValue]);
      clearTimeout(spinningTimer);
      spinningTimer = setTimeout($.proxy(function() {
        this.$el.trigger("changed.spinner", [this.value(), this.oldValue]);
      }, this), Spinner.delay);
    }
  }, numeric:function(v) {
    v = this.options.precision > 0 ? parseFloat(v, 10) : parseInt(v, 10);
    if (isFinite(v)) {
      return v;
    }
    return v || this.options.min || 0;
  }, validate:function(val) {
    if (this.options.min !== null && val < this.min) {
      return -1;
    }
    if (this.options.max !== null && val > this.max) {
      return 1;
    }
    return 0;
  }};
  Spinner = function(element, options) {
    this.$el = $(element);
    this.$spinning = this.$el.find('[data-spin="spinner"]');
    if (this.$spinning.length === 0) {
      this.$spinning = this.$el.find(':input[type="text"]');
    }
    options = $.extend({}, options, this.$spinning.data());
    this.spinning = new Spinning(this.$spinning, options);
    this.$el.on("click.spinner", '[data-spin="up"], [data-spin="down"]', $.proxy(this, "spin")).on("mousedown.spinner", '[data-spin="up"], [data-spin="down"]', $.proxy(this, "spin"));
    $(document).on("mouseup.spinner", $.proxy(function() {
      clearTimeout(this.spinTimeout);
      clearInterval(this.spinInterval);
    }, this));
    if (options.delay) {
      this.delay(options.delay);
    }
    if (options.changed) {
      this.changed(options.changed);
    }
    if (options.changing) {
      this.changing(options.changing);
    }
  };
  Spinner.delay = 500;
  Spinner.prototype = {constructor:Spinner, spin:function(e) {
    var dir = $(e.currentTarget).data("spin");
    switch(e.type) {
      case "click":
        e.preventDefault();
        this.spinning.spin(dir);
        break;
      case "mousedown":
        if (e.which === 1) {
          this.spinTimeout = setTimeout($.proxy(this, "beginSpin", dir), 300);
        }
        break;
    }
  }, delay:function(ms) {
    var delay = Number(ms);
    if (delay >= 0) {
      this.constructor.delay = delay + 100;
    }
  }, value:function() {
    return this.spinning.value();
  }, changed:function(fn) {
    this.bindHandler("changed.spinner", fn);
  }, changing:function(fn) {
    this.bindHandler("changing.spinner", fn);
  }, bindHandler:function(t, fn) {
    if ($.isFunction(fn)) {
      this.$spinning.on(t, fn);
    } else {
      this.$spinning.off(t);
    }
  }, beginSpin:function(dir) {
    this.spinInterval = setInterval($.proxy(this.spinning, "spin", dir), 100);
  }};
  var old = $.fn.spinner;
  $.fn.spinner = function(options, value) {
    return this.each(function() {
      var data = $.data(this, "spinner");
      if (!data) {
        data = new Spinner(this, options);
        $.data(this, "spinner", data);
      }
      if (options === "delay" || options === "changed" || options === "changing") {
        data[options](value);
      } else {
        if (options === "step" && value) {
          data.spinning.step = value;
        } else {
          if (options === "spin" && value) {
            data.spinning.spin(value);
          }
        }
      }
    });
  };
  $.fn.spinner.Constructor = Spinner;
  $.fn.spinner.noConflict = function() {
    $.fn.spinner = old;
    return this;
  };
  $(function() {
    $('[data-trigger="spinner"]').spinner();
  });
  return $.fn.spinner;
});
Polymer({is:"simpl-spinner", properties:{eventname:{type:String, value:"value-changed"}, rule:{type:String, value:"quantity"}, value:{type:Object, value:0}}, observers:[], behaviors:[StyleScopeBehavior], up:function() {
  $(this.$.spinner).spinner("spin", "up");
}, down:function() {
  $(this.$.spinner).spinner("spin", "down");
}, attached:function() {
  if (this.isInited) {
    return;
  }
  $(this.$.spinner).spinner("delay", 200).spinner("rule", this.rule).spinner("changed", function(e, newVal, oldVal) {
    this.value = newVal;
    this.fire(this.eventname, {id:this.id, value:newVal});
  }.bind(this));
  $(this.$.input).keyup(function(e) {
    var val = this.$.input.value;
    val = parseInt(val);
    this.fire(this.eventname, {id:this.id, value:val});
  }.bind(this));
  this.isInited = true;
}, ready:function() {
}});
(function e(t, n, r) {
  function s(o, u) {
    if (!n[o]) {
      if (!t[o]) {
        var a = typeof require == "function" && require;
        if (!u && a) {
          return a(o, !0);
        }
        if (i) {
          return i(o, !0);
        }
        var f = new Error("Cannot find module '" + o + "'");
        throw f.code = "MODULE_NOT_FOUND", f;
      }
      var l = n[o] = {exports:{}};
      t[o][0].call(l.exports, function(e) {
        var n = t[o][1][e];
        return s(n ? n : e);
      }, l, l.exports, e, t, n, r);
    }
    return n[o].exports;
  }
  var i = typeof require == "function" && require;
  for (var o = 0; o < r.length; o++) {
    s(r[o]);
  }
  return s;
})({1:[function(require, module, exports) {
  var $, DragAndDropHandler, DragElement, HitAreasGenerator, Position, VisibleNodeIterator, node_module, util, extend = function(child, parent) {
    for (var key in parent) {
      if (hasProp.call(parent, key)) {
        child[key] = parent[key];
      }
    }
    function ctor() {
      this.constructor = child;
    }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor;
    child.__super__ = parent.prototype;
    return child;
  }, hasProp = {}.hasOwnProperty;
  node_module = require("./node");
  util = require("./util");
  Position = node_module.Position;
  $ = jQuery;
  DragAndDropHandler = function() {
    function DragAndDropHandler(tree_widget) {
      this.tree_widget = tree_widget;
      this.hovered_area = null;
      this.$ghost = null;
      this.hit_areas = [];
      this.is_dragging = false;
      this.current_item = null;
    }
    DragAndDropHandler.prototype.mouseCapture = function(position_info) {
      var $element, node_element;
      $element = $(position_info.target);
      if (!this.mustCaptureElement($element)) {
        return null;
      }
      if (this.tree_widget.options.onIsMoveHandle && !this.tree_widget.options.onIsMoveHandle($element)) {
        return null;
      }
      node_element = this.tree_widget._getNodeElement($element);
      if (node_element && this.tree_widget.options.onCanMove) {
        if (!this.tree_widget.options.onCanMove(node_element.node)) {
          node_element = null;
        }
      }
      this.current_item = node_element;
      return this.current_item !== null;
    };
    DragAndDropHandler.prototype.mouseStart = function(position_info) {
      var node, node_name, offset;
      this.refresh();
      offset = $(position_info.target).offset();
      node = this.current_item.node;
      if (this.tree_widget.options.autoEscape) {
        node_name = util.html_escape(node.name);
      } else {
        node_name = node.name;
      }
      this.drag_element = new DragElement(node_name, position_info.page_x - offset.left, position_info.page_y - offset.top, this.tree_widget.element);
      this.is_dragging = true;
      this.current_item.$element.addClass("jqtree-moving");
      return true;
    };
    DragAndDropHandler.prototype.mouseDrag = function(position_info) {
      var area, can_move_to;
      this.drag_element.move(position_info.page_x, position_info.page_y);
      area = this.findHoveredArea(position_info.page_x, position_info.page_y);
      can_move_to = this.canMoveToArea(area);
      if (can_move_to && area) {
        if (!area.node.isFolder()) {
          this.stopOpenFolderTimer();
        }
        if (this.hovered_area !== area) {
          this.hovered_area = area;
          if (this.mustOpenFolderTimer(area)) {
            this.startOpenFolderTimer(area.node);
          } else {
            this.stopOpenFolderTimer();
          }
          this.updateDropHint();
        }
      } else {
        this.removeHover();
        this.removeDropHint();
        this.stopOpenFolderTimer();
      }
      if (!area) {
        if (this.tree_widget.options.onDragMove != null) {
          this.tree_widget.options.onDragMove(this.current_item.node, position_info.original_event);
        }
      }
      return true;
    };
    DragAndDropHandler.prototype.mustCaptureElement = function($element) {
      return !$element.is("input,select,textarea");
    };
    DragAndDropHandler.prototype.canMoveToArea = function(area) {
      var position_name;
      if (!area) {
        return false;
      } else {
        if (this.tree_widget.options.onCanMoveTo) {
          position_name = Position.getName(area.position);
          return this.tree_widget.options.onCanMoveTo(this.current_item.node, area.node, position_name);
        } else {
          return true;
        }
      }
    };
    DragAndDropHandler.prototype.mouseStop = function(position_info) {
      var current_item;
      this.moveItem(position_info);
      this.clear();
      this.removeHover();
      this.removeDropHint();
      this.removeHitAreas();
      current_item = this.current_item;
      if (this.current_item) {
        this.current_item.$element.removeClass("jqtree-moving");
        this.current_item = null;
      }
      this.is_dragging = false;
      if (!this.hovered_area && current_item) {
        if (this.tree_widget.options.onDragStop != null) {
          this.tree_widget.options.onDragStop(current_item.node, position_info.original_event);
        }
      }
      return false;
    };
    DragAndDropHandler.prototype.refresh = function() {
      this.removeHitAreas();
      if (this.current_item) {
        this.generateHitAreas();
        this.current_item = this.tree_widget._getNodeElementForNode(this.current_item.node);
        if (this.is_dragging) {
          return this.current_item.$element.addClass("jqtree-moving");
        }
      }
    };
    DragAndDropHandler.prototype.removeHitAreas = function() {
      return this.hit_areas = [];
    };
    DragAndDropHandler.prototype.clear = function() {
      this.drag_element.remove();
      return this.drag_element = null;
    };
    DragAndDropHandler.prototype.removeDropHint = function() {
      if (this.previous_ghost) {
        return this.previous_ghost.remove();
      }
    };
    DragAndDropHandler.prototype.removeHover = function() {
      return this.hovered_area = null;
    };
    DragAndDropHandler.prototype.generateHitAreas = function() {
      var hit_areas_generator;
      hit_areas_generator = new HitAreasGenerator(this.tree_widget.tree, this.current_item.node, this.getTreeDimensions().bottom);
      return this.hit_areas = hit_areas_generator.generate();
    };
    DragAndDropHandler.prototype.findHoveredArea = function(x, y) {
      var area, dimensions, high, low, mid;
      dimensions = this.getTreeDimensions();
      if (x < dimensions.left || y < dimensions.top || x > dimensions.right || y > dimensions.bottom) {
        return null;
      }
      low = 0;
      high = this.hit_areas.length;
      while (low < high) {
        mid = low + high >> 1;
        area = this.hit_areas[mid];
        if (y < area.top) {
          high = mid;
        } else {
          if (y > area.bottom) {
            low = mid + 1;
          } else {
            return area;
          }
        }
      }
      return null;
    };
    DragAndDropHandler.prototype.mustOpenFolderTimer = function(area) {
      var node;
      node = area.node;
      return node.isFolder() && !node.is_open && area.position === Position.INSIDE;
    };
    DragAndDropHandler.prototype.updateDropHint = function() {
      var node_element;
      if (!this.hovered_area) {
        return;
      }
      this.removeDropHint();
      node_element = this.tree_widget._getNodeElementForNode(this.hovered_area.node);
      return this.previous_ghost = node_element.addDropHint(this.hovered_area.position);
    };
    DragAndDropHandler.prototype.startOpenFolderTimer = function(folder) {
      var openFolder;
      openFolder = function(_this) {
        return function() {
          return _this.tree_widget._openNode(folder, _this.tree_widget.options.slide, function() {
            _this.refresh();
            return _this.updateDropHint();
          });
        };
      }(this);
      this.stopOpenFolderTimer();
      return this.open_folder_timer = setTimeout(openFolder, this.tree_widget.options.openFolderDelay);
    };
    DragAndDropHandler.prototype.stopOpenFolderTimer = function() {
      if (this.open_folder_timer) {
        clearTimeout(this.open_folder_timer);
        return this.open_folder_timer = null;
      }
    };
    DragAndDropHandler.prototype.moveItem = function(position_info) {
      var doMove, event, moved_node, position, previous_parent, target_node;
      if (this.hovered_area && this.hovered_area.position !== Position.NONE && this.canMoveToArea(this.hovered_area)) {
        moved_node = this.current_item.node;
        target_node = this.hovered_area.node;
        position = this.hovered_area.position;
        previous_parent = moved_node.parent;
        if (position === Position.INSIDE) {
          this.hovered_area.node.is_open = true;
        }
        doMove = function(_this) {
          return function() {
            _this.tree_widget.tree.moveNode(moved_node, target_node, position);
            _this.tree_widget.element.empty();
            return _this.tree_widget._refreshElements();
          };
        }(this);
        event = this.tree_widget._triggerEvent("tree.move", {move_info:{moved_node:moved_node, target_node:target_node, position:Position.getName(position), previous_parent:previous_parent, do_move:doMove, original_event:position_info.original_event}});
        if (!event.isDefaultPrevented()) {
          return doMove();
        }
      }
    };
    DragAndDropHandler.prototype.getTreeDimensions = function() {
      var offset;
      offset = this.tree_widget.element.offset();
      return {left:offset.left, top:offset.top, right:offset.left + this.tree_widget.element.width(), bottom:offset.top + this.tree_widget.element.height() + 16};
    };
    return DragAndDropHandler;
  }();
  VisibleNodeIterator = function() {
    function VisibleNodeIterator(tree) {
      this.tree = tree;
    }
    VisibleNodeIterator.prototype.iterate = function() {
      var _iterateNode, is_first_node;
      is_first_node = true;
      _iterateNode = function(_this) {
        return function(node, next_node) {
          var $element, child, children_length, i, j, len, must_iterate_inside, ref;
          must_iterate_inside = (node.is_open || !node.element) && node.hasChildren();
          if (node.element) {
            $element = $(node.element);
            if (!$element.is(":visible")) {
              return;
            }
            if (is_first_node) {
              _this.handleFirstNode(node, $element);
              is_first_node = false;
            }
            if (!node.hasChildren()) {
              _this.handleNode(node, next_node, $element);
            } else {
              if (node.is_open) {
                if (!_this.handleOpenFolder(node, $element)) {
                  must_iterate_inside = false;
                }
              } else {
                _this.handleClosedFolder(node, next_node, $element);
              }
            }
          }
          if (must_iterate_inside) {
            children_length = node.children.length;
            ref = node.children;
            for (i = j = 0, len = ref.length; j < len; i = ++j) {
              child = ref[i];
              if (i === children_length - 1) {
                _iterateNode(node.children[i], null);
              } else {
                _iterateNode(node.children[i], node.children[i + 1]);
              }
            }
            if (node.is_open) {
              return _this.handleAfterOpenFolder(node, next_node, $element);
            }
          }
        };
      }(this);
      return _iterateNode(this.tree, null);
    };
    VisibleNodeIterator.prototype.handleNode = function(node, next_node, $element) {
    };
    VisibleNodeIterator.prototype.handleOpenFolder = function(node, $element) {
    };
    VisibleNodeIterator.prototype.handleClosedFolder = function(node, next_node, $element) {
    };
    VisibleNodeIterator.prototype.handleAfterOpenFolder = function(node, next_node, $element) {
    };
    VisibleNodeIterator.prototype.handleFirstNode = function(node, $element) {
    };
    return VisibleNodeIterator;
  }();
  HitAreasGenerator = function(superClass) {
    extend(HitAreasGenerator, superClass);
    function HitAreasGenerator(tree, current_node, tree_bottom) {
      HitAreasGenerator.__super__.constructor.call(this, tree);
      this.current_node = current_node;
      this.tree_bottom = tree_bottom;
    }
    HitAreasGenerator.prototype.generate = function() {
      this.positions = [];
      this.last_top = 0;
      this.iterate();
      return this.generateHitAreas(this.positions);
    };
    HitAreasGenerator.prototype.getTop = function($element) {
      return $element.offset().top;
    };
    HitAreasGenerator.prototype.addPosition = function(node, position, top) {
      var area;
      area = {top:top, node:node, position:position};
      this.positions.push(area);
      return this.last_top = top;
    };
    HitAreasGenerator.prototype.handleNode = function(node, next_node, $element) {
      var top;
      top = this.getTop($element);
      if (node === this.current_node) {
        this.addPosition(node, Position.NONE, top);
      } else {
        this.addPosition(node, Position.INSIDE, top);
      }
      if (next_node === this.current_node || node === this.current_node) {
        return this.addPosition(node, Position.NONE, top);
      } else {
        return this.addPosition(node, Position.AFTER, top);
      }
    };
    HitAreasGenerator.prototype.handleOpenFolder = function(node, $element) {
      if (node === this.current_node) {
        return false;
      }
      if (node.children[0] !== this.current_node) {
        this.addPosition(node, Position.INSIDE, this.getTop($element));
      }
      return true;
    };
    HitAreasGenerator.prototype.handleClosedFolder = function(node, next_node, $element) {
      var top;
      top = this.getTop($element);
      if (node === this.current_node) {
        return this.addPosition(node, Position.NONE, top);
      } else {
        this.addPosition(node, Position.INSIDE, top);
        if (next_node !== this.current_node) {
          return this.addPosition(node, Position.AFTER, top);
        }
      }
    };
    HitAreasGenerator.prototype.handleFirstNode = function(node, $element) {
      if (node !== this.current_node) {
        return this.addPosition(node, Position.BEFORE, this.getTop($(node.element)));
      }
    };
    HitAreasGenerator.prototype.handleAfterOpenFolder = function(node, next_node, $element) {
      if (node === this.current_node.node || next_node === this.current_node.node) {
        return this.addPosition(node, Position.NONE, this.last_top);
      } else {
        return this.addPosition(node, Position.AFTER, this.last_top);
      }
    };
    HitAreasGenerator.prototype.generateHitAreas = function(positions) {
      var group, hit_areas, j, len, position, previous_top;
      previous_top = -1;
      group = [];
      hit_areas = [];
      for (j = 0, len = positions.length; j < len; j++) {
        position = positions[j];
        if (position.top !== previous_top && group.length) {
          if (group.length) {
            this.generateHitAreasForGroup(hit_areas, group, previous_top, position.top);
          }
          previous_top = position.top;
          group = [];
        }
        group.push(position);
      }
      this.generateHitAreasForGroup(hit_areas, group, previous_top, this.tree_bottom);
      return hit_areas;
    };
    HitAreasGenerator.prototype.generateHitAreasForGroup = function(hit_areas, positions_in_group, top, bottom) {
      var area_height, area_top, i, position, position_count;
      position_count = Math.min(positions_in_group.length, 4);
      area_height = Math.round((bottom - top) / position_count);
      area_top = top;
      i = 0;
      while (i < position_count) {
        position = positions_in_group[i];
        hit_areas.push({top:area_top, bottom:area_top + area_height, node:position.node, position:position.position});
        area_top += area_height;
        i += 1;
      }
      return null;
    };
    return HitAreasGenerator;
  }(VisibleNodeIterator);
  DragElement = function() {
    function DragElement(node_name, offset_x, offset_y, $tree) {
      this.offset_x = offset_x;
      this.offset_y = offset_y;
      this.$element = $('<span class="jqtree-title jqtree-dragging">' + node_name + "</span>");
      this.$element.css("position", "absolute");
      $tree.append(this.$element);
    }
    DragElement.prototype.move = function(page_x, page_y) {
      return this.$element.offset({left:page_x - this.offset_x, top:page_y - this.offset_y});
    };
    DragElement.prototype.remove = function() {
      return this.$element.remove();
    };
    return DragElement;
  }();
  module.exports = {DragAndDropHandler:DragAndDropHandler, DragElement:DragElement, HitAreasGenerator:HitAreasGenerator};
}, {"./node":5, "./util":12}], 2:[function(require, module, exports) {
  var $, ElementsRenderer, NodeElement, html_escape, node_element, util;
  node_element = require("./node_element");
  NodeElement = node_element.NodeElement;
  util = require("./util");
  html_escape = util.html_escape;
  $ = jQuery;
  ElementsRenderer = function() {
    function ElementsRenderer(tree_widget) {
      this.tree_widget = tree_widget;
      this.opened_icon_element = this.createButtonElement(tree_widget.options.openedIcon);
      this.closed_icon_element = this.createButtonElement(tree_widget.options.closedIcon);
    }
    ElementsRenderer.prototype.render = function(from_node) {
      if (from_node && from_node.parent) {
        return this.renderFromNode(from_node);
      } else {
        return this.renderFromRoot();
      }
    };
    ElementsRenderer.prototype.renderFromRoot = function() {
      var $element;
      $element = this.tree_widget.element;
      $element.empty();
      return this.createDomElements($element[0], this.tree_widget.tree.children, true, true, 1);
    };
    ElementsRenderer.prototype.renderFromNode = function(node) {
      var $previous_li, li;
      $previous_li = $(node.element);
      li = this.createLi(node, node.getLevel());
      this.attachNodeData(node, li);
      $previous_li.after(li);
      $previous_li.remove();
      if (node.children) {
        return this.createDomElements(li, node.children, false, false, node.getLevel() + 1);
      }
    };
    ElementsRenderer.prototype.createDomElements = function(element, children, is_root_node, is_open, level) {
      var child, i, len, li, ul;
      ul = this.createUl(is_root_node);
      element.appendChild(ul);
      for (i = 0, len = children.length; i < len; i++) {
        child = children[i];
        li = this.createLi(child, level);
        ul.appendChild(li);
        this.attachNodeData(child, li);
        if (child.hasChildren()) {
          this.createDomElements(li, child.children, false, child.is_open, level + 1);
        }
      }
      return null;
    };
    ElementsRenderer.prototype.attachNodeData = function(node, li) {
      node.element = li;
      return $(li).data("node", node);
    };
    ElementsRenderer.prototype.createUl = function(is_root_node) {
      var class_string, role, ul;
      if (!is_root_node) {
        class_string = "";
        role = "group";
      } else {
        class_string = "jqtree-tree";
        role = "tree";
        if (this.tree_widget.options.rtl) {
          class_string += " jqtree-rtl";
        }
      }
      ul = document.createElement("ul");
      ul.className = "jqtree_common " + class_string;
      ul.setAttribute("role", role);
      return ul;
    };
    ElementsRenderer.prototype.createLi = function(node, level) {
      var is_selected, li;
      is_selected = this.tree_widget.select_node_handler && this.tree_widget.select_node_handler.isNodeSelected(node);
      if (node.isFolder()) {
        li = this.createFolderLi(node, level, is_selected);
      } else {
        li = this.createNodeLi(node, level, is_selected);
      }
      if (this.tree_widget.options.onCreateLi) {
        this.tree_widget.options.onCreateLi(node, $(li));
      }
      return li;
    };
    ElementsRenderer.prototype.createFolderLi = function(node, level, is_selected) {
      var button_classes, button_link, div, folder_classes, icon_element, is_folder, li;
      button_classes = this.getButtonClasses(node);
      folder_classes = this.getFolderClasses(node, is_selected);
      if (node.is_open) {
        icon_element = this.opened_icon_element;
      } else {
        icon_element = this.closed_icon_element;
      }
      li = document.createElement("li");
      li.className = "jqtree_common " + folder_classes;
      li.setAttribute("role", "presentation");
      div = document.createElement("div");
      div.className = "jqtree-element jqtree_common";
      div.setAttribute("role", "presentation");
      li.appendChild(div);
      button_link = document.createElement("a");
      button_link.className = button_classes;
      button_link.appendChild(icon_element.cloneNode(false));
      button_link.setAttribute("role", "presentation");
      button_link.setAttribute("aria-hidden", "true");
      if (this.tree_widget.options.buttonLeft) {
        div.appendChild(button_link);
      }
      div.appendChild(this.createTitleSpan(node.name, level, is_selected, node.is_open, is_folder = true));
      if (!this.tree_widget.options.buttonLeft) {
        div.appendChild(button_link);
      }
      return li;
    };
    ElementsRenderer.prototype.createNodeLi = function(node, level, is_selected) {
      var class_string, div, is_folder, li, li_classes;
      li_classes = ["jqtree_common"];
      if (is_selected) {
        li_classes.push("jqtree-selected");
      }
      class_string = li_classes.join(" ");
      li = document.createElement("li");
      li.className = class_string;
      li.setAttribute("role", "presentation");
      div = document.createElement("div");
      div.className = "jqtree-element jqtree_common";
      div.setAttribute("role", "presentation");
      li.appendChild(div);
      div.appendChild(this.createTitleSpan(node.name, level, is_selected, node.is_open, is_folder = false));
      return li;
    };
    ElementsRenderer.prototype.createTitleSpan = function(node_name, level, is_selected, is_open, is_folder) {
      var classes, title_span;
      title_span = document.createElement("span");
      classes = "jqtree-title jqtree_common";
      if (is_folder) {
        classes += " jqtree-title-folder";
      }
      title_span.className = classes;
      title_span.setAttribute("role", "treeitem");
      title_span.setAttribute("aria-level", level);
      title_span.setAttribute("aria-selected", util.getBoolString(is_selected));
      title_span.setAttribute("aria-expanded", util.getBoolString(is_open));
      if (is_selected) {
        title_span.setAttribute("tabindex", 0);
      }
      title_span.innerHTML = this.escapeIfNecessary(node_name);
      return title_span;
    };
    ElementsRenderer.prototype.getButtonClasses = function(node) {
      var classes;
      classes = ["jqtree-toggler", "jqtree_common"];
      if (!node.is_open) {
        classes.push("jqtree-closed");
      }
      if (this.tree_widget.options.buttonLeft) {
        classes.push("jqtree-toggler-left");
      } else {
        classes.push("jqtree-toggler-right");
      }
      return classes.join(" ");
    };
    ElementsRenderer.prototype.getFolderClasses = function(node, is_selected) {
      var classes;
      classes = ["jqtree-folder"];
      if (!node.is_open) {
        classes.push("jqtree-closed");
      }
      if (is_selected) {
        classes.push("jqtree-selected");
      }
      if (node.is_loading) {
        classes.push("jqtree-loading");
      }
      return classes.join(" ");
    };
    ElementsRenderer.prototype.escapeIfNecessary = function(value) {
      if (this.tree_widget.options.autoEscape) {
        return html_escape(value);
      } else {
        return value;
      }
    };
    ElementsRenderer.prototype.createButtonElement = function(value) {
      var div;
      if (typeof value === "string") {
        div = document.createElement("div");
        div.innerHTML = value;
        return document.createTextNode(div.innerHTML);
      } else {
        return $(value)[0];
      }
    };
    return ElementsRenderer;
  }();
  module.exports = ElementsRenderer;
}, {"./node_element":6, "./util":12}], 3:[function(require, module, exports) {
  var $, KeyHandler, bind = function(fn, me) {
    return function() {
      return fn.apply(me, arguments);
    };
  };
  $ = jQuery;
  KeyHandler = function() {
    var DOWN, LEFT, RIGHT, UP;
    LEFT = 37;
    UP = 38;
    RIGHT = 39;
    DOWN = 40;
    function KeyHandler(tree_widget) {
      this.selectNode = bind(this.selectNode, this);
      this.tree_widget = tree_widget;
      if (tree_widget.options.keyboardSupport) {
        $(document).bind("keydown.jqtree", $.proxy(this.handleKeyDown, this));
      }
    }
    KeyHandler.prototype.deinit = function() {
      return $(document).unbind("keydown.jqtree");
    };
    KeyHandler.prototype.moveDown = function() {
      var node;
      node = this.tree_widget.getSelectedNode();
      if (node) {
        return this.selectNode(node.getNextNode());
      } else {
        return false;
      }
    };
    KeyHandler.prototype.moveUp = function() {
      var node;
      node = this.tree_widget.getSelectedNode();
      if (node) {
        return this.selectNode(node.getPreviousNode());
      } else {
        return false;
      }
    };
    KeyHandler.prototype.moveRight = function() {
      var node;
      node = this.tree_widget.getSelectedNode();
      if (!node) {
        return true;
      } else {
        if (!node.isFolder()) {
          return true;
        } else {
          if (node.is_open) {
            return this.selectNode(node.getNextNode());
          } else {
            this.tree_widget.openNode(node);
            return false;
          }
        }
      }
    };
    KeyHandler.prototype.moveLeft = function() {
      var node;
      node = this.tree_widget.getSelectedNode();
      if (!node) {
        return true;
      } else {
        if (node.isFolder() && node.is_open) {
          this.tree_widget.closeNode(node);
          return false;
        } else {
          return this.selectNode(node.getParent());
        }
      }
    };
    KeyHandler.prototype.handleKeyDown = function(e) {
      var key;
      if (!this.tree_widget.options.keyboardSupport) {
        return true;
      }
      if ($(document.activeElement).is("textarea,input,select")) {
        return true;
      }
      if (!this.tree_widget.getSelectedNode()) {
        return true;
      }
      key = e.which;
      switch(key) {
        case DOWN:
          return this.moveDown();
        case UP:
          return this.moveUp();
        case RIGHT:
          return this.moveRight();
        case LEFT:
          return this.moveLeft();
      }
      return true;
    };
    KeyHandler.prototype.selectNode = function(node) {
      if (!node) {
        return true;
      } else {
        this.tree_widget.selectNode(node);
        if (this.tree_widget.scroll_handler && !this.tree_widget.scroll_handler.isScrolledIntoView($(node.element).find(".jqtree-element"))) {
          this.tree_widget.scrollToNode(node);
        }
        return false;
      }
    };
    return KeyHandler;
  }();
  module.exports = KeyHandler;
}, {}], 4:[function(require, module, exports) {
  var $, MouseWidget, SimpleWidget, extend = function(child, parent) {
    for (var key in parent) {
      if (hasProp.call(parent, key)) {
        child[key] = parent[key];
      }
    }
    function ctor() {
      this.constructor = child;
    }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor;
    child.__super__ = parent.prototype;
    return child;
  }, hasProp = {}.hasOwnProperty;
  SimpleWidget = require("./simple.widget");
  $ = jQuery;
  MouseWidget = function(superClass) {
    extend(MouseWidget, superClass);
    function MouseWidget() {
      return MouseWidget.__super__.constructor.apply(this, arguments);
    }
    MouseWidget.is_mouse_handled = false;
    MouseWidget.prototype._init = function() {
      this.$el.bind("mousedown.mousewidget", $.proxy(this._mouseDown, this));
      this.$el.bind("touchstart.mousewidget", $.proxy(this._touchStart, this));
      this.is_mouse_started = false;
      this.mouse_delay = 0;
      this._mouse_delay_timer = null;
      this._is_mouse_delay_met = true;
      return this.mouse_down_info = null;
    };
    MouseWidget.prototype._deinit = function() {
      var $document;
      this.$el.unbind("mousedown.mousewidget");
      this.$el.unbind("touchstart.mousewidget");
      $document = $(document);
      $document.unbind("mousemove.mousewidget");
      return $document.unbind("mouseup.mousewidget");
    };
    MouseWidget.prototype._mouseDown = function(e) {
      var result;
      if (e.which !== 1) {
        return;
      }
      result = this._handleMouseDown(e, this._getPositionInfo(e));
      if (result) {
        e.preventDefault();
      }
      return result;
    };
    MouseWidget.prototype._handleMouseDown = function(e, position_info) {
      if (MouseWidget.is_mouse_handled) {
        return;
      }
      if (this.is_mouse_started) {
        this._handleMouseUp(position_info);
      }
      this.mouse_down_info = position_info;
      if (!this._mouseCapture(position_info)) {
        return;
      }
      this._handleStartMouse();
      this.is_mouse_handled = true;
      return true;
    };
    MouseWidget.prototype._handleStartMouse = function() {
      var $document;
      $document = $(document);
      $document.bind("mousemove.mousewidget", $.proxy(this._mouseMove, this));
      $document.bind("touchmove.mousewidget", $.proxy(this._touchMove, this));
      $document.bind("mouseup.mousewidget", $.proxy(this._mouseUp, this));
      $document.bind("touchend.mousewidget", $.proxy(this._touchEnd, this));
      if (this.mouse_delay) {
        return this._startMouseDelayTimer();
      }
    };
    MouseWidget.prototype._startMouseDelayTimer = function() {
      if (this._mouse_delay_timer) {
        clearTimeout(this._mouse_delay_timer);
      }
      this._mouse_delay_timer = setTimeout(function(_this) {
        return function() {
          return _this._is_mouse_delay_met = true;
        };
      }(this), this.mouse_delay);
      return this._is_mouse_delay_met = false;
    };
    MouseWidget.prototype._mouseMove = function(e) {
      return this._handleMouseMove(e, this._getPositionInfo(e));
    };
    MouseWidget.prototype._handleMouseMove = function(e, position_info) {
      if (this.is_mouse_started) {
        this._mouseDrag(position_info);
        return e.preventDefault();
      }
      if (this.mouse_delay && !this._is_mouse_delay_met) {
        return true;
      }
      this.is_mouse_started = this._mouseStart(this.mouse_down_info) !== false;
      if (this.is_mouse_started) {
        this._mouseDrag(position_info);
      } else {
        this._handleMouseUp(position_info);
      }
      return !this.is_mouse_started;
    };
    MouseWidget.prototype._getPositionInfo = function(e) {
      return {page_x:e.pageX, page_y:e.pageY, target:e.target, original_event:e};
    };
    MouseWidget.prototype._mouseUp = function(e) {
      return this._handleMouseUp(this._getPositionInfo(e));
    };
    MouseWidget.prototype._handleMouseUp = function(position_info) {
      var $document;
      $document = $(document);
      $document.unbind("mousemove.mousewidget");
      $document.unbind("touchmove.mousewidget");
      $document.unbind("mouseup.mousewidget");
      $document.unbind("touchend.mousewidget");
      if (this.is_mouse_started) {
        this.is_mouse_started = false;
        this._mouseStop(position_info);
      }
    };
    MouseWidget.prototype._mouseCapture = function(position_info) {
      return true;
    };
    MouseWidget.prototype._mouseStart = function(position_info) {
      return null;
    };
    MouseWidget.prototype._mouseDrag = function(position_info) {
      return null;
    };
    MouseWidget.prototype._mouseStop = function(position_info) {
      return null;
    };
    MouseWidget.prototype.setMouseDelay = function(mouse_delay) {
      return this.mouse_delay = mouse_delay;
    };
    MouseWidget.prototype._touchStart = function(e) {
      var touch;
      if (e.originalEvent.touches.length > 1) {
        return;
      }
      touch = e.originalEvent.changedTouches[0];
      return this._handleMouseDown(e, this._getPositionInfo(touch));
    };
    MouseWidget.prototype._touchMove = function(e) {
      var touch;
      if (e.originalEvent.touches.length > 1) {
        return;
      }
      touch = e.originalEvent.changedTouches[0];
      return this._handleMouseMove(e, this._getPositionInfo(touch));
    };
    MouseWidget.prototype._touchEnd = function(e) {
      var touch;
      if (e.originalEvent.touches.length > 1) {
        return;
      }
      touch = e.originalEvent.changedTouches[0];
      return this._handleMouseUp(this._getPositionInfo(touch));
    };
    return MouseWidget;
  }(SimpleWidget);
  module.exports = MouseWidget;
}, {"./simple.widget":10}], 5:[function(require, module, exports) {
  var $, Node, Position;
  $ = jQuery;
  Position = {getName:function(position) {
    return Position.strings[position - 1];
  }, nameToIndex:function(name) {
    var i, j, ref;
    for (i = j = 1, ref = Position.strings.length; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
      if (Position.strings[i - 1] === name) {
        return i;
      }
    }
    return 0;
  }};
  Position.BEFORE = 1;
  Position.AFTER = 2;
  Position.INSIDE = 3;
  Position.NONE = 4;
  Position.strings = ["before", "after", "inside", "none"];
  Node = function() {
    function Node(o, is_root, node_class) {
      if (is_root == null) {
        is_root = false;
      }
      if (node_class == null) {
        node_class = Node;
      }
      this.name = "";
      this.setData(o);
      this.children = [];
      this.parent = null;
      if (is_root) {
        this.id_mapping = {};
        this.tree = this;
        this.node_class = node_class;
      }
    }
    Node.prototype.setData = function(o) {
      var key, setName, value;
      setName = function(_this) {
        return function(name) {
          if (name !== null) {
            return _this.name = name;
          }
        };
      }(this);
      if (typeof o !== "object") {
        setName(o);
      } else {
        for (key in o) {
          value = o[key];
          if (key === "label") {
            setName(value);
          } else {
            if (key !== "children") {
              this[key] = value;
            }
          }
        }
      }
      return null;
    };
    Node.prototype.initFromData = function(data) {
      var addChildren, addNode;
      addNode = function(_this) {
        return function(node_data) {
          _this.setData(node_data);
          if (node_data.children) {
            return addChildren(node_data.children);
          }
        };
      }(this);
      addChildren = function(_this) {
        return function(children_data) {
          var child, j, len, node;
          for (j = 0, len = children_data.length; j < len; j++) {
            child = children_data[j];
            node = new _this.tree.node_class("");
            node.initFromData(child);
            _this.addChild(node);
          }
          return null;
        };
      }(this);
      addNode(data);
      return null;
    };
    Node.prototype.loadFromData = function(data) {
      var j, len, node, o;
      this.removeChildren();
      for (j = 0, len = data.length; j < len; j++) {
        o = data[j];
        node = new this.tree.node_class(o);
        this.addChild(node);
        if (typeof o === "object" && o.children) {
          node.loadFromData(o.children);
        }
      }
      return null;
    };
    Node.prototype.addChild = function(node) {
      this.children.push(node);
      return node._setParent(this);
    };
    Node.prototype.addChildAtPosition = function(node, index) {
      this.children.splice(index, 0, node);
      return node._setParent(this);
    };
    Node.prototype._setParent = function(parent) {
      this.parent = parent;
      this.tree = parent.tree;
      return this.tree.addNodeToIndex(this);
    };
    Node.prototype.removeChild = function(node) {
      node.removeChildren();
      return this._removeChild(node);
    };
    Node.prototype._removeChild = function(node) {
      this.children.splice(this.getChildIndex(node), 1);
      return this.tree.removeNodeFromIndex(node);
    };
    Node.prototype.getChildIndex = function(node) {
      return $.inArray(node, this.children);
    };
    Node.prototype.hasChildren = function() {
      return this.children.length !== 0;
    };
    Node.prototype.isFolder = function() {
      return this.hasChildren() || this.load_on_demand;
    };
    Node.prototype.iterate = function(callback) {
      var _iterate;
      _iterate = function(node, level) {
        var child, j, len, ref, result;
        if (node.children) {
          ref = node.children;
          for (j = 0, len = ref.length; j < len; j++) {
            child = ref[j];
            result = callback(child, level);
            if (result && child.hasChildren()) {
              _iterate(child, level + 1);
            }
          }
          return null;
        }
      };
      _iterate(this, 0);
      return null;
    };
    Node.prototype.moveNode = function(moved_node, target_node, position) {
      if (moved_node.isParentOf(target_node)) {
        return;
      }
      moved_node.parent._removeChild(moved_node);
      if (position === Position.AFTER) {
        return target_node.parent.addChildAtPosition(moved_node, target_node.parent.getChildIndex(target_node) + 1);
      } else {
        if (position === Position.BEFORE) {
          return target_node.parent.addChildAtPosition(moved_node, target_node.parent.getChildIndex(target_node));
        } else {
          if (position === Position.INSIDE) {
            return target_node.addChildAtPosition(moved_node, 0);
          }
        }
      }
    };
    Node.prototype.getData = function(include_parent) {
      var getDataFromNodes;
      if (include_parent == null) {
        include_parent = false;
      }
      getDataFromNodes = function(nodes) {
        var data, j, k, len, node, tmp_node, v;
        data = [];
        for (j = 0, len = nodes.length; j < len; j++) {
          node = nodes[j];
          tmp_node = {};
          for (k in node) {
            v = node[k];
            if (k !== "parent" && k !== "children" && k !== "element" && k !== "tree" && Object.prototype.hasOwnProperty.call(node, k)) {
              tmp_node[k] = v;
            }
          }
          if (node.hasChildren()) {
            tmp_node.children = getDataFromNodes(node.children);
          }
          data.push(tmp_node);
        }
        return data;
      };
      if (include_parent) {
        return getDataFromNodes([this]);
      } else {
        return getDataFromNodes(this.children);
      }
    };
    Node.prototype.getNodeByName = function(name) {
      return this.getNodeByCallback(function(node) {
        return node.name === name;
      });
    };
    Node.prototype.getNodeByCallback = function(callback) {
      var result;
      result = null;
      this.iterate(function(node) {
        if (callback(node)) {
          result = node;
          return false;
        } else {
          return true;
        }
      });
      return result;
    };
    Node.prototype.addAfter = function(node_info) {
      var child_index, node;
      if (!this.parent) {
        return null;
      } else {
        node = new this.tree.node_class(node_info);
        child_index = this.parent.getChildIndex(this);
        this.parent.addChildAtPosition(node, child_index + 1);
        if (typeof node_info === "object" && node_info.children && node_info.children.length) {
          node.loadFromData(node_info.children);
        }
        return node;
      }
    };
    Node.prototype.addBefore = function(node_info) {
      var child_index, node;
      if (!this.parent) {
        return null;
      } else {
        node = new this.tree.node_class(node_info);
        child_index = this.parent.getChildIndex(this);
        this.parent.addChildAtPosition(node, child_index);
        if (typeof node_info === "object" && node_info.children && node_info.children.length) {
          node.loadFromData(node_info.children);
        }
        return node;
      }
    };
    Node.prototype.addParent = function(node_info) {
      var child, j, len, new_parent, original_parent, ref;
      if (!this.parent) {
        return null;
      } else {
        new_parent = new this.tree.node_class(node_info);
        new_parent._setParent(this.tree);
        original_parent = this.parent;
        ref = original_parent.children;
        for (j = 0, len = ref.length; j < len; j++) {
          child = ref[j];
          new_parent.addChild(child);
        }
        original_parent.children = [];
        original_parent.addChild(new_parent);
        return new_parent;
      }
    };
    Node.prototype.remove = function() {
      if (this.parent) {
        this.parent.removeChild(this);
        return this.parent = null;
      }
    };
    Node.prototype.append = function(node_info) {
      var node;
      node = new this.tree.node_class(node_info);
      this.addChild(node);
      if (typeof node_info === "object" && node_info.children && node_info.children.length) {
        node.loadFromData(node_info.children);
      }
      return node;
    };
    Node.prototype.prepend = function(node_info) {
      var node;
      node = new this.tree.node_class(node_info);
      this.addChildAtPosition(node, 0);
      if (typeof node_info === "object" && node_info.children && node_info.children.length) {
        node.loadFromData(node_info.children);
      }
      return node;
    };
    Node.prototype.isParentOf = function(node) {
      var parent;
      parent = node.parent;
      while (parent) {
        if (parent === this) {
          return true;
        }
        parent = parent.parent;
      }
      return false;
    };
    Node.prototype.getLevel = function() {
      var level, node;
      level = 0;
      node = this;
      while (node.parent) {
        level += 1;
        node = node.parent;
      }
      return level;
    };
    Node.prototype.getNodeById = function(node_id) {
      return this.id_mapping[node_id];
    };
    Node.prototype.addNodeToIndex = function(node) {
      if (node.id != null) {
        return this.id_mapping[node.id] = node;
      }
    };
    Node.prototype.removeNodeFromIndex = function(node) {
      if (node.id != null) {
        return delete this.id_mapping[node.id];
      }
    };
    Node.prototype.removeChildren = function() {
      this.iterate(function(_this) {
        return function(child) {
          _this.tree.removeNodeFromIndex(child);
          return true;
        };
      }(this));
      return this.children = [];
    };
    Node.prototype.getPreviousSibling = function() {
      var previous_index;
      if (!this.parent) {
        return null;
      } else {
        previous_index = this.parent.getChildIndex(this) - 1;
        if (previous_index >= 0) {
          return this.parent.children[previous_index];
        } else {
          return null;
        }
      }
    };
    Node.prototype.getNextSibling = function() {
      var next_index;
      if (!this.parent) {
        return null;
      } else {
        next_index = this.parent.getChildIndex(this) + 1;
        if (next_index < this.parent.children.length) {
          return this.parent.children[next_index];
        } else {
          return null;
        }
      }
    };
    Node.prototype.getNodesByProperty = function(key, value) {
      return this.filter(function(node) {
        return node[key] === value;
      });
    };
    Node.prototype.filter = function(f) {
      var result;
      result = [];
      this.iterate(function(node) {
        if (f(node)) {
          result.push(node);
        }
        return true;
      });
      return result;
    };
    Node.prototype.getNextNode = function(include_children) {
      var next_sibling;
      if (include_children == null) {
        include_children = true;
      }
      if (include_children && this.hasChildren() && this.is_open) {
        return this.children[0];
      } else {
        if (!this.parent) {
          return null;
        } else {
          next_sibling = this.getNextSibling();
          if (next_sibling) {
            return next_sibling;
          } else {
            return this.parent.getNextNode(false);
          }
        }
      }
    };
    Node.prototype.getPreviousNode = function() {
      var previous_sibling;
      if (!this.parent) {
        return null;
      } else {
        previous_sibling = this.getPreviousSibling();
        if (previous_sibling) {
          if (!previous_sibling.hasChildren() || !previous_sibling.is_open) {
            return previous_sibling;
          } else {
            return previous_sibling.getLastChild();
          }
        } else {
          return this.getParent();
        }
      }
    };
    Node.prototype.getParent = function() {
      if (!this.parent) {
        return null;
      } else {
        if (!this.parent.parent) {
          return null;
        } else {
          return this.parent;
        }
      }
    };
    Node.prototype.getLastChild = function() {
      var last_child;
      if (!this.hasChildren()) {
        return null;
      } else {
        last_child = this.children[this.children.length - 1];
        if (!last_child.hasChildren() || !last_child.is_open) {
          return last_child;
        } else {
          return last_child.getLastChild();
        }
      }
    };
    return Node;
  }();
  module.exports = {Node:Node, Position:Position};
}, {}], 6:[function(require, module, exports) {
  var $, BorderDropHint, FolderElement, GhostDropHint, NodeElement, Position, node, extend = function(child, parent) {
    for (var key in parent) {
      if (hasProp.call(parent, key)) {
        child[key] = parent[key];
      }
    }
    function ctor() {
      this.constructor = child;
    }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor;
    child.__super__ = parent.prototype;
    return child;
  }, hasProp = {}.hasOwnProperty;
  node = require("./node");
  Position = node.Position;
  $ = jQuery;
  NodeElement = function() {
    function NodeElement(node, tree_widget) {
      this.init(node, tree_widget);
    }
    NodeElement.prototype.init = function(node, tree_widget) {
      this.node = node;
      this.tree_widget = tree_widget;
      if (!node.element) {
        node.element = this.tree_widget.element;
      }
      return this.$element = $(node.element);
    };
    NodeElement.prototype.getUl = function() {
      return this.$element.children("ul:first");
    };
    NodeElement.prototype.getSpan = function() {
      return this.$element.children(".jqtree-element").find("span.jqtree-title");
    };
    NodeElement.prototype.getLi = function() {
      return this.$element;
    };
    NodeElement.prototype.addDropHint = function(position) {
      if (position === Position.INSIDE) {
        return new BorderDropHint(this.$element);
      } else {
        return new GhostDropHint(this.node, this.$element, position);
      }
    };
    NodeElement.prototype.select = function() {
      var $li, $span;
      $li = this.getLi();
      $li.addClass("jqtree-selected");
      $li.attr("aria-selected", "true");
      $span = this.getSpan();
      return $span.attr("tabindex", 0);
    };
    NodeElement.prototype.deselect = function() {
      var $li, $span;
      $li = this.getLi();
      $li.removeClass("jqtree-selected");
      $li.attr("aria-selected", "false");
      $span = this.getSpan();
      return $span.attr("tabindex", -1);
    };
    return NodeElement;
  }();
  FolderElement = function(superClass) {
    extend(FolderElement, superClass);
    function FolderElement() {
      return FolderElement.__super__.constructor.apply(this, arguments);
    }
    FolderElement.prototype.open = function(on_finished, slide) {
      var $button, doOpen;
      if (slide == null) {
        slide = true;
      }
      if (!this.node.is_open) {
        this.node.is_open = true;
        $button = this.getButton();
        $button.removeClass("jqtree-closed");
        $button.html("");
        $button.append(this.tree_widget.renderer.opened_icon_element.cloneNode(false));
        doOpen = function(_this) {
          return function() {
            var $li, $span;
            $li = _this.getLi();
            $li.removeClass("jqtree-closed");
            $span = _this.getSpan();
            $span.attr("aria-expanded", "true");
            if (on_finished) {
              on_finished(_this.node);
            }
            return _this.tree_widget._triggerEvent("tree.open", {node:_this.node});
          };
        }(this);
        if (slide) {
          return this.getUl().slideDown("fast", doOpen);
        } else {
          this.getUl().show();
          return doOpen();
        }
      }
    };
    FolderElement.prototype.close = function(slide) {
      var $button, doClose;
      if (slide == null) {
        slide = true;
      }
      if (this.node.is_open) {
        this.node.is_open = false;
        $button = this.getButton();
        $button.addClass("jqtree-closed");
        $button.html("");
        $button.append(this.tree_widget.renderer.closed_icon_element.cloneNode(false));
        doClose = function(_this) {
          return function() {
            var $li, $span;
            $li = _this.getLi();
            $li.addClass("jqtree-closed");
            $span = _this.getSpan();
            $span.attr("aria-expanded", "false");
            return _this.tree_widget._triggerEvent("tree.close", {node:_this.node});
          };
        }(this);
        if (slide) {
          return this.getUl().slideUp("fast", doClose);
        } else {
          this.getUl().hide();
          return doClose();
        }
      }
    };
    FolderElement.prototype.getButton = function() {
      return this.$element.children(".jqtree-element").find("a.jqtree-toggler");
    };
    FolderElement.prototype.addDropHint = function(position) {
      if (!this.node.is_open && position === Position.INSIDE) {
        return new BorderDropHint(this.$element);
      } else {
        return new GhostDropHint(this.node, this.$element, position);
      }
    };
    return FolderElement;
  }(NodeElement);
  BorderDropHint = function() {
    function BorderDropHint($element) {
      var $div, width;
      $div = $element.children(".jqtree-element");
      width = $element.width() - 4;
      this.$hint = $('<span class="jqtree-border"></span>');
      $div.append(this.$hint);
      this.$hint.css({width:width, height:$div.outerHeight() - 4});
    }
    BorderDropHint.prototype.remove = function() {
      return this.$hint.remove();
    };
    return BorderDropHint;
  }();
  GhostDropHint = function() {
    function GhostDropHint(node, $element, position) {
      this.$element = $element;
      this.node = node;
      this.$ghost = $('<li class="jqtree_common jqtree-ghost"><span class="jqtree_common jqtree-circle"></span><span class="jqtree_common jqtree-line"></span></li>');
      if (position === Position.AFTER) {
        this.moveAfter();
      } else {
        if (position === Position.BEFORE) {
          this.moveBefore();
        } else {
          if (position === Position.INSIDE) {
            if (node.isFolder() && node.is_open) {
              this.moveInsideOpenFolder();
            } else {
              this.moveInside();
            }
          }
        }
      }
    }
    GhostDropHint.prototype.remove = function() {
      return this.$ghost.remove();
    };
    GhostDropHint.prototype.moveAfter = function() {
      return this.$element.after(this.$ghost);
    };
    GhostDropHint.prototype.moveBefore = function() {
      return this.$element.before(this.$ghost);
    };
    GhostDropHint.prototype.moveInsideOpenFolder = function() {
      return $(this.node.children[0].element).before(this.$ghost);
    };
    GhostDropHint.prototype.moveInside = function() {
      this.$element.after(this.$ghost);
      return this.$ghost.addClass("jqtree-inside");
    };
    return GhostDropHint;
  }();
  module.exports = {BorderDropHint:BorderDropHint, FolderElement:FolderElement, GhostDropHint:GhostDropHint, NodeElement:NodeElement};
}, {"./node":5}], 7:[function(require, module, exports) {
  var $, SaveStateHandler, indexOf, isInt, util;
  util = require("./util");
  indexOf = util.indexOf;
  isInt = util.isInt;
  $ = jQuery;
  SaveStateHandler = function() {
    function SaveStateHandler(tree_widget) {
      this.tree_widget = tree_widget;
    }
    SaveStateHandler.prototype.saveState = function() {
      var state;
      state = JSON.stringify(this.getState());
      if (this.tree_widget.options.onSetStateFromStorage) {
        return this.tree_widget.options.onSetStateFromStorage(state);
      } else {
        if (this.supportsLocalStorage()) {
          return localStorage.setItem(this.getCookieName(), state);
        } else {
          if ($.cookie) {
            $.cookie.raw = true;
            return $.cookie(this.getCookieName(), state, {path:"/"});
          }
        }
      }
    };
    SaveStateHandler.prototype.getStateFromStorage = function() {
      var json_data;
      json_data = this._loadFromStorage();
      if (json_data) {
        return this._parseState(json_data);
      } else {
        return null;
      }
    };
    SaveStateHandler.prototype._parseState = function(json_data) {
      var state;
      state = $.parseJSON(json_data);
      if (state && state.selected_node && isInt(state.selected_node)) {
        state.selected_node = [state.selected_node];
      }
      return state;
    };
    SaveStateHandler.prototype._loadFromStorage = function() {
      if (this.tree_widget.options.onGetStateFromStorage) {
        return this.tree_widget.options.onGetStateFromStorage();
      } else {
        if (this.supportsLocalStorage()) {
          return localStorage.getItem(this.getCookieName());
        } else {
          if ($.cookie) {
            $.cookie.raw = true;
            return $.cookie(this.getCookieName());
          } else {
            return null;
          }
        }
      }
    };
    SaveStateHandler.prototype.getState = function() {
      var getOpenNodeIds, getSelectedNodeIds;
      getOpenNodeIds = function(_this) {
        return function() {
          var open_nodes;
          open_nodes = [];
          _this.tree_widget.tree.iterate(function(node) {
            if (node.is_open && node.id && node.hasChildren()) {
              open_nodes.push(node.id);
            }
            return true;
          });
          return open_nodes;
        };
      }(this);
      getSelectedNodeIds = function(_this) {
        return function() {
          var n;
          return function() {
            var i, len, ref, results;
            ref = this.tree_widget.getSelectedNodes();
            results = [];
            for (i = 0, len = ref.length; i < len; i++) {
              n = ref[i];
              results.push(n.id);
            }
            return results;
          }.call(_this);
        };
      }(this);
      return {open_nodes:getOpenNodeIds(), selected_node:getSelectedNodeIds()};
    };
    SaveStateHandler.prototype.setInitialState = function(state) {
      var must_load_on_demand;
      if (!state) {
        return false;
      } else {
        must_load_on_demand = this._openInitialNodes(state.open_nodes);
        this._selectInitialNodes(state.selected_node);
        return must_load_on_demand;
      }
    };
    SaveStateHandler.prototype._openInitialNodes = function(node_ids) {
      var i, len, must_load_on_demand, node, node_id;
      must_load_on_demand = false;
      for (i = 0, len = node_ids.length; i < len; i++) {
        node_id = node_ids[i];
        node = this.tree_widget.getNodeById(node_id);
        if (node) {
          if (!node.load_on_demand) {
            node.is_open = true;
          } else {
            must_load_on_demand = true;
          }
        }
      }
      return must_load_on_demand;
    };
    SaveStateHandler.prototype._selectInitialNodes = function(node_ids) {
      var i, len, node, node_id, select_count;
      select_count = 0;
      for (i = 0, len = node_ids.length; i < len; i++) {
        node_id = node_ids[i];
        node = this.tree_widget.getNodeById(node_id);
        if (node) {
          select_count += 1;
          this.tree_widget.select_node_handler.addToSelection(node);
        }
      }
      return select_count !== 0;
    };
    SaveStateHandler.prototype.setInitialStateOnDemand = function(state, cb_finished) {
      if (state) {
        return this._setInitialStateOnDemand(state.open_nodes, state.selected_node, cb_finished);
      } else {
        return cb_finished();
      }
    };
    SaveStateHandler.prototype._setInitialStateOnDemand = function(node_ids, selected_nodes, cb_finished) {
      var loadAndOpenNode, loading_count, openNodes;
      loading_count = 0;
      openNodes = function(_this) {
        return function() {
          var i, len, new_nodes_ids, node, node_id;
          new_nodes_ids = [];
          for (i = 0, len = node_ids.length; i < len; i++) {
            node_id = node_ids[i];
            node = _this.tree_widget.getNodeById(node_id);
            if (!node) {
              new_nodes_ids.push(node_id);
            } else {
              if (!node.is_loading) {
                if (node.load_on_demand) {
                  loadAndOpenNode(node);
                } else {
                  _this.tree_widget._openNode(node, false);
                }
              }
            }
          }
          node_ids = new_nodes_ids;
          if (_this._selectInitialNodes(selected_nodes)) {
            _this.tree_widget._refreshElements();
          }
          if (loading_count === 0) {
            return cb_finished();
          }
        };
      }(this);
      loadAndOpenNode = function(_this) {
        return function(node) {
          loading_count += 1;
          return _this.tree_widget._openNode(node, false, function() {
            loading_count -= 1;
            return openNodes();
          });
        };
      }(this);
      return openNodes();
    };
    SaveStateHandler.prototype.getCookieName = function() {
      if (typeof this.tree_widget.options.saveState === "string") {
        return this.tree_widget.options.saveState;
      } else {
        return "tree";
      }
    };
    SaveStateHandler.prototype.supportsLocalStorage = function() {
      var testSupport;
      testSupport = function() {
        var error, key;
        if (typeof localStorage === "undefined" || localStorage === null) {
          return false;
        } else {
          try {
            key = "_storage_test";
            sessionStorage.setItem(key, true);
            sessionStorage.removeItem(key);
          } catch (error1) {
            error = error1;
            return false;
          }
          return true;
        }
      };
      if (this._supportsLocalStorage == null) {
        this._supportsLocalStorage = testSupport();
      }
      return this._supportsLocalStorage;
    };
    SaveStateHandler.prototype.getNodeIdToBeSelected = function() {
      var state;
      state = this.getStateFromStorage();
      if (state && state.selected_node) {
        return state.selected_node[0];
      } else {
        return null;
      }
    };
    return SaveStateHandler;
  }();
  module.exports = SaveStateHandler;
}, {"./util":12}], 8:[function(require, module, exports) {
  var $, ScrollHandler;
  $ = jQuery;
  ScrollHandler = function() {
    function ScrollHandler(tree_widget) {
      this.tree_widget = tree_widget;
      this.previous_top = -1;
      this.is_initialized = false;
    }
    ScrollHandler.prototype._initScrollParent = function() {
      var $scroll_parent, getParentWithOverflow, setDocumentAsScrollParent;
      getParentWithOverflow = function(_this) {
        return function() {
          var css_values, el, hasOverFlow, i, len, ref;
          css_values = ["overflow", "overflow-y"];
          hasOverFlow = function(el) {
            var css_value, i, len, ref;
            for (i = 0, len = css_values.length; i < len; i++) {
              css_value = css_values[i];
              if ((ref = $.css(el, css_value)) === "auto" || ref === "scroll") {
                return true;
              }
            }
            return false;
          };
          if (hasOverFlow(_this.tree_widget.$el[0])) {
            return _this.tree_widget.$el;
          }
          ref = _this.tree_widget.$el.parents();
          for (i = 0, len = ref.length; i < len; i++) {
            el = ref[i];
            if (hasOverFlow(el)) {
              return $(el);
            }
          }
          return null;
        };
      }(this);
      setDocumentAsScrollParent = function(_this) {
        return function() {
          _this.scroll_parent_top = 0;
          return _this.$scroll_parent = null;
        };
      }(this);
      if (this.tree_widget.$el.css("position") === "fixed") {
        setDocumentAsScrollParent();
      }
      $scroll_parent = getParentWithOverflow();
      if ($scroll_parent && $scroll_parent.length && $scroll_parent[0].tagName !== "HTML") {
        this.$scroll_parent = $scroll_parent;
        this.scroll_parent_top = this.$scroll_parent.offset().top;
      } else {
        setDocumentAsScrollParent();
      }
      return this.is_initialized = true;
    };
    ScrollHandler.prototype._ensureInit = function() {
      if (!this.is_initialized) {
        return this._initScrollParent();
      }
    };
    ScrollHandler.prototype.checkScrolling = function() {
      var hovered_area;
      this._ensureInit();
      hovered_area = this.tree_widget.dnd_handler.hovered_area;
      if (hovered_area && hovered_area.top !== this.previous_top) {
        this.previous_top = hovered_area.top;
        if (this.$scroll_parent) {
          return this._handleScrollingWithScrollParent(hovered_area);
        } else {
          return this._handleScrollingWithDocument(hovered_area);
        }
      }
    };
    ScrollHandler.prototype._handleScrollingWithScrollParent = function(area) {
      var distance_bottom;
      distance_bottom = this.scroll_parent_top + this.$scroll_parent[0].offsetHeight - area.bottom;
      if (distance_bottom < 20) {
        this.$scroll_parent[0].scrollTop += 20;
        this.tree_widget.refreshHitAreas();
        return this.previous_top = -1;
      } else {
        if (area.top - this.scroll_parent_top < 20) {
          this.$scroll_parent[0].scrollTop -= 20;
          this.tree_widget.refreshHitAreas();
          return this.previous_top = -1;
        }
      }
    };
    ScrollHandler.prototype._handleScrollingWithDocument = function(area) {
      var distance_top;
      distance_top = area.top - $(document).scrollTop();
      if (distance_top < 20) {
        return $(document).scrollTop($(document).scrollTop() - 20);
      } else {
        if ($(window).height() - (area.bottom - $(document).scrollTop()) < 20) {
          return $(document).scrollTop($(document).scrollTop() + 20);
        }
      }
    };
    ScrollHandler.prototype.scrollTo = function(top) {
      var tree_top;
      this._ensureInit();
      if (this.$scroll_parent) {
        return this.$scroll_parent[0].scrollTop = top;
      } else {
        tree_top = this.tree_widget.$el.offset().top;
        return $(document).scrollTop(top + tree_top);
      }
    };
    ScrollHandler.prototype.isScrolledIntoView = function(element) {
      var $element, element_bottom, element_top, view_bottom, view_top;
      this._ensureInit();
      $element = $(element);
      if (this.$scroll_parent) {
        view_top = 0;
        view_bottom = this.$scroll_parent.height();
        element_top = $element.offset().top - this.scroll_parent_top;
        element_bottom = element_top + $element.height();
      } else {
        view_top = $(window).scrollTop();
        view_bottom = view_top + $(window).height();
        element_top = $element.offset().top;
        element_bottom = element_top + $element.height();
      }
      return element_bottom <= view_bottom && element_top >= view_top;
    };
    return ScrollHandler;
  }();
  module.exports = ScrollHandler;
}, {}], 9:[function(require, module, exports) {
  var $, SelectNodeHandler;
  $ = jQuery;
  SelectNodeHandler = function() {
    function SelectNodeHandler(tree_widget) {
      this.tree_widget = tree_widget;
      this.clear();
    }
    SelectNodeHandler.prototype.getSelectedNode = function() {
      var selected_nodes;
      selected_nodes = this.getSelectedNodes();
      if (selected_nodes.length) {
        return selected_nodes[0];
      } else {
        return false;
      }
    };
    SelectNodeHandler.prototype.getSelectedNodes = function() {
      var id, node, selected_nodes;
      if (this.selected_single_node) {
        return [this.selected_single_node];
      } else {
        selected_nodes = [];
        for (id in this.selected_nodes) {
          node = this.tree_widget.getNodeById(id);
          if (node) {
            selected_nodes.push(node);
          }
        }
        return selected_nodes;
      }
    };
    SelectNodeHandler.prototype.getSelectedNodesUnder = function(parent) {
      var id, node, selected_nodes;
      if (this.selected_single_node) {
        if (parent.isParentOf(this.selected_single_node)) {
          return [this.selected_single_node];
        } else {
          return [];
        }
      } else {
        selected_nodes = [];
        for (id in this.selected_nodes) {
          node = this.tree_widget.getNodeById(id);
          if (node && parent.isParentOf(node)) {
            selected_nodes.push(node);
          }
        }
        return selected_nodes;
      }
    };
    SelectNodeHandler.prototype.isNodeSelected = function(node) {
      if (!node) {
        return false;
      } else {
        if (node.id) {
          if (this.selected_nodes[node.id]) {
            return true;
          } else {
            return false;
          }
        } else {
          if (this.selected_single_node) {
            return this.selected_single_node.element === node.element;
          } else {
            return false;
          }
        }
      }
    };
    SelectNodeHandler.prototype.clear = function() {
      this.selected_nodes = {};
      return this.selected_single_node = null;
    };
    SelectNodeHandler.prototype.removeFromSelection = function(node, include_children) {
      if (include_children == null) {
        include_children = false;
      }
      if (!node.id) {
        if (this.selected_single_node && node.element === this.selected_single_node.element) {
          return this.selected_single_node = null;
        }
      } else {
        delete this.selected_nodes[node.id];
        if (include_children) {
          return node.iterate(function(_this) {
            return function(n) {
              delete _this.selected_nodes[node.id];
              return true;
            };
          }(this));
        }
      }
    };
    SelectNodeHandler.prototype.addToSelection = function(node) {
      if (node.id) {
        return this.selected_nodes[node.id] = true;
      } else {
        return this.selected_single_node = node;
      }
    };
    return SelectNodeHandler;
  }();
  module.exports = SelectNodeHandler;
}, {}], 10:[function(require, module, exports) {
  var $, SimpleWidget, slice = [].slice;
  $ = jQuery;
  SimpleWidget = function() {
    SimpleWidget.prototype.defaults = {};
    function SimpleWidget(el, options) {
      this.$el = $(el);
      this.options = $.extend({}, this.defaults, options);
    }
    SimpleWidget.prototype.destroy = function() {
      return this._deinit();
    };
    SimpleWidget.prototype._init = function() {
      return null;
    };
    SimpleWidget.prototype._deinit = function() {
      return null;
    };
    SimpleWidget.register = function(widget_class, widget_name) {
      var callFunction, createWidget, destroyWidget, getDataKey, getWidgetData;
      getDataKey = function() {
        return "simple_widget_" + widget_name;
      };
      getWidgetData = function(el, data_key) {
        var widget;
        widget = $.data(el, data_key);
        if (widget && widget instanceof SimpleWidget) {
          return widget;
        } else {
          return null;
        }
      };
      createWidget = function($el, options) {
        var data_key, el, existing_widget, i, len, widget;
        data_key = getDataKey();
        for (i = 0, len = $el.length; i < len; i++) {
          el = $el[i];
          existing_widget = getWidgetData(el, data_key);
          if (!existing_widget) {
            widget = new widget_class(el, options);
            if (!$.data(el, data_key)) {
              $.data(el, data_key, widget);
            }
            widget._init();
          }
        }
        return $el;
      };
      destroyWidget = function($el) {
        var data_key, el, i, len, results, widget;
        data_key = getDataKey();
        results = [];
        for (i = 0, len = $el.length; i < len; i++) {
          el = $el[i];
          widget = getWidgetData(el, data_key);
          if (widget) {
            widget.destroy();
          }
          results.push($.removeData(el, data_key));
        }
        return results;
      };
      callFunction = function($el, function_name, args) {
        var el, i, len, result, widget, widget_function;
        result = null;
        for (i = 0, len = $el.length; i < len; i++) {
          el = $el[i];
          widget = $.data(el, getDataKey());
          if (widget && widget instanceof SimpleWidget) {
            widget_function = widget[function_name];
            if (widget_function && typeof widget_function === "function") {
              result = widget_function.apply(widget, args);
            }
          }
        }
        return result;
      };
      return $.fn[widget_name] = function() {
        var $el, args, argument1, function_name, options;
        argument1 = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
        $el = this;
        if (argument1 === void 0 || typeof argument1 === "object") {
          options = argument1;
          return createWidget($el, options);
        } else {
          if (typeof argument1 === "string" && argument1[0] !== "_") {
            function_name = argument1;
            if (function_name === "destroy") {
              return destroyWidget($el);
            } else {
              if (function_name === "get_widget_class") {
                return widget_class;
              } else {
                return callFunction($el, function_name, args);
              }
            }
          }
        }
      };
    };
    return SimpleWidget;
  }();
  module.exports = SimpleWidget;
}, {}], 11:[function(require, module, exports) {
  var $, BorderDropHint, DragAndDropHandler, DragElement, ElementsRenderer, FolderElement, GhostDropHint, HitAreasGenerator, JqTreeWidget, KeyHandler, MouseWidget, Node, NodeElement, Position, SaveStateHandler, ScrollHandler, SelectNodeHandler, SimpleWidget, __version__, drag_and_drop_handler, isFunction, node_module, ref, util_module, extend = function(child, parent) {
    for (var key in parent) {
      if (hasProp.call(parent, key)) {
        child[key] = parent[key];
      }
    }
    function ctor() {
      this.constructor = child;
    }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor;
    child.__super__ = parent.prototype;
    return child;
  }, hasProp = {}.hasOwnProperty;
  __version__ = require("./version");
  drag_and_drop_handler = require("./drag_and_drop_handler");
  ElementsRenderer = require("./elements_renderer");
  KeyHandler = require("./key_handler");
  MouseWidget = require("./mouse.widget");
  SaveStateHandler = require("./save_state_handler");
  ScrollHandler = require("./scroll_handler");
  SelectNodeHandler = require("./select_node_handler");
  SimpleWidget = require("./simple.widget");
  node_module = require("./node");
  Node = node_module.Node;
  Position = node_module.Position;
  util_module = require("./util");
  isFunction = util_module.isFunction;
  ref = require("./node_element"), BorderDropHint = ref.BorderDropHint, FolderElement = ref.FolderElement, GhostDropHint = ref.GhostDropHint, NodeElement = ref.NodeElement;
  DragAndDropHandler = drag_and_drop_handler.DragAndDropHandler, DragElement = drag_and_drop_handler.DragElement, HitAreasGenerator = drag_and_drop_handler.HitAreasGenerator;
  $ = jQuery;
  JqTreeWidget = function(superClass) {
    extend(JqTreeWidget, superClass);
    function JqTreeWidget() {
      return JqTreeWidget.__super__.constructor.apply(this, arguments);
    }
    JqTreeWidget.prototype.BorderDropHint = BorderDropHint;
    JqTreeWidget.prototype.DragElement = DragElement;
    JqTreeWidget.prototype.DragAndDropHandler = DragAndDropHandler;
    JqTreeWidget.prototype.ElementsRenderer = ElementsRenderer;
    JqTreeWidget.prototype.GhostDropHint = GhostDropHint;
    JqTreeWidget.prototype.HitAreasGenerator = HitAreasGenerator;
    JqTreeWidget.prototype.Node = Node;
    JqTreeWidget.prototype.SaveStateHandler = SaveStateHandler;
    JqTreeWidget.prototype.ScrollHandler = ScrollHandler;
    JqTreeWidget.prototype.SelectNodeHandler = SelectNodeHandler;
    JqTreeWidget.prototype.defaults = {autoOpen:false, saveState:false, dragAndDrop:false, selectable:true, useContextMenu:true, onCanSelectNode:null, onSetStateFromStorage:null, onGetStateFromStorage:null, onCreateLi:null, onIsMoveHandle:null, onCanMove:null, onCanMoveTo:null, onLoadFailed:null, autoEscape:true, dataUrl:null, closedIcon:null, openedIcon:"&#x25bc;", slide:true, nodeClass:Node, dataFilter:null, keyboardSupport:true, openFolderDelay:500, rtl:null, onDragMove:null, onDragStop:null, 
    buttonLeft:true, onLoading:null};
    JqTreeWidget.prototype.toggle = function(node, slide) {
      if (slide == null) {
        slide = null;
      }
      if (slide === null) {
        slide = this.options.slide;
      }
      if (node.is_open) {
        this.closeNode(node, slide);
      } else {
        this.openNode(node, slide);
      }
      return this.element;
    };
    JqTreeWidget.prototype.getTree = function() {
      return this.tree;
    };
    JqTreeWidget.prototype.selectNode = function(node) {
      this._selectNode(node, false);
      return this.element;
    };
    JqTreeWidget.prototype._selectNode = function(node, must_toggle) {
      var canSelect, deselected_node, openParents, saveState;
      if (must_toggle == null) {
        must_toggle = false;
      }
      if (!this.select_node_handler) {
        return;
      }
      canSelect = function(_this) {
        return function() {
          if (_this.options.onCanSelectNode) {
            return _this.options.selectable && _this.options.onCanSelectNode(node);
          } else {
            return _this.options.selectable;
          }
        };
      }(this);
      openParents = function(_this) {
        return function() {
          var parent;
          parent = node.parent;
          if (parent && parent.parent && !parent.is_open) {
            return _this.openNode(parent, false);
          }
        };
      }(this);
      saveState = function(_this) {
        return function() {
          if (_this.options.saveState) {
            return _this.save_state_handler.saveState();
          }
        };
      }(this);
      if (!node) {
        this._deselectCurrentNode();
        saveState();
        return;
      }
      if (!canSelect()) {
        return;
      }
      if (this.select_node_handler.isNodeSelected(node)) {
        if (must_toggle) {
          this._deselectCurrentNode();
          this._triggerEvent("tree.select", {node:null, previous_node:node});
        }
      } else {
        deselected_node = this.getSelectedNode();
        this._deselectCurrentNode();
        this.addToSelection(node);
        this._triggerEvent("tree.select", {node:node, deselected_node:deselected_node});
        openParents();
      }
      return saveState();
    };
    JqTreeWidget.prototype.getSelectedNode = function() {
      if (this.select_node_handler) {
        return this.select_node_handler.getSelectedNode();
      } else {
        return null;
      }
    };
    JqTreeWidget.prototype.toJson = function() {
      return JSON.stringify(this.tree.getData());
    };
    JqTreeWidget.prototype.loadData = function(data, parent_node) {
      this._loadData(data, parent_node);
      return this.element;
    };
    JqTreeWidget.prototype.loadDataFromUrl = function(param1, param2, param3) {
      if ($.type(param1) === "string") {
        this._loadDataFromUrl(param1, param2, param3);
      } else {
        this._loadDataFromUrl(null, param1, param2);
      }
      return this.element;
    };
    JqTreeWidget.prototype.reload = function(on_finished) {
      this._loadDataFromUrl(null, null, on_finished);
      return this.element;
    };
    JqTreeWidget.prototype._loadDataFromUrl = function(url_info, parent_node, on_finished) {
      var $el, addLoadingClass, handeLoadData, handleError, handleSuccess, loadDataFromUrlInfo, parseUrlInfo, removeLoadingClass;
      $el = null;
      addLoadingClass = function(_this) {
        return function() {
          if (parent_node) {
            $el = $(parent_node.element);
          } else {
            $el = _this.element;
          }
          $el.addClass("jqtree-loading");
          return _this._notifyLoading(true, parent_node, $el);
        };
      }(this);
      removeLoadingClass = function(_this) {
        return function() {
          if ($el) {
            $el.removeClass("jqtree-loading");
            return _this._notifyLoading(false, parent_node, $el);
          }
        };
      }(this);
      parseUrlInfo = function() {
        if ($.type(url_info) === "string") {
          return {url:url_info};
        }
        if (!url_info.method) {
          url_info.method = "get";
        }
        return url_info;
      };
      handeLoadData = function(_this) {
        return function(data) {
          removeLoadingClass();
          _this._loadData(data, parent_node);
          if (on_finished && $.isFunction(on_finished)) {
            return on_finished();
          }
        };
      }(this);
      handleSuccess = function(_this) {
        return function(response) {
          var data;
          if ($.isArray(response) || typeof response === "object") {
            data = response;
          } else {
            if (data != null) {
              data = $.parseJSON(response);
            } else {
              data = [];
            }
          }
          if (_this.options.dataFilter) {
            data = _this.options.dataFilter(data);
          }
          return handeLoadData(data);
        };
      }(this);
      handleError = function(_this) {
        return function(response) {
          removeLoadingClass();
          if (_this.options.onLoadFailed) {
            return _this.options.onLoadFailed(response);
          }
        };
      }(this);
      loadDataFromUrlInfo = function() {
        url_info = parseUrlInfo();
        return $.ajax($.extend({}, url_info, {method:url_info.method != null ? url_info.method.toUpperCase() : "GET", cache:false, dataType:"json", success:handleSuccess, error:handleError}));
      };
      if (!url_info) {
        url_info = this._getDataUrlInfo(parent_node);
      }
      addLoadingClass();
      if (!url_info) {
        removeLoadingClass();
      } else {
        if ($.isArray(url_info)) {
          handeLoadData(url_info);
        } else {
          loadDataFromUrlInfo();
        }
      }
    };
    JqTreeWidget.prototype._loadData = function(data, parent_node) {
      var deselectNodes, loadSubtree;
      if (parent_node == null) {
        parent_node = null;
      }
      deselectNodes = function(_this) {
        return function() {
          var i, len, n, selected_nodes_under_parent;
          if (_this.select_node_handler) {
            selected_nodes_under_parent = _this.select_node_handler.getSelectedNodesUnder(parent_node);
            for (i = 0, len = selected_nodes_under_parent.length; i < len; i++) {
              n = selected_nodes_under_parent[i];
              _this.select_node_handler.removeFromSelection(n);
            }
          }
          return null;
        };
      }(this);
      loadSubtree = function(_this) {
        return function() {
          parent_node.loadFromData(data);
          parent_node.load_on_demand = false;
          parent_node.is_loading = false;
          return _this._refreshElements(parent_node);
        };
      }(this);
      if (!data) {
        return;
      }
      this._triggerEvent("tree.load_data", {tree_data:data});
      if (!parent_node) {
        this._initTree(data);
      } else {
        deselectNodes();
        loadSubtree();
      }
      if (this.isDragging()) {
        return this.dnd_handler.refresh();
      }
    };
    JqTreeWidget.prototype.getNodeById = function(node_id) {
      return this.tree.getNodeById(node_id);
    };
    JqTreeWidget.prototype.getNodeByName = function(name) {
      return this.tree.getNodeByName(name);
    };
    JqTreeWidget.prototype.getNodesByProperty = function(key, value) {
      return this.tree.getNodesByProperty(key, value);
    };
    JqTreeWidget.prototype.getNodeByHtmlElement = function(element) {
      return this._getNode($(element));
    };
    JqTreeWidget.prototype.getNodeByCallback = function(callback) {
      return this.tree.getNodeByCallback(callback);
    };
    JqTreeWidget.prototype.openNode = function(node, slide_param, on_finished_param) {
      var on_finished, parseParams, ref1, slide;
      if (slide_param == null) {
        slide_param = null;
      }
      if (on_finished_param == null) {
        on_finished_param = null;
      }
      parseParams = function(_this) {
        return function() {
          var on_finished, slide;
          if (isFunction(slide_param)) {
            on_finished = slide_param;
            slide = null;
          } else {
            slide = slide_param;
            on_finished = on_finished_param;
          }
          if (slide === null) {
            slide = _this.options.slide;
          }
          return [slide, on_finished];
        };
      }(this);
      ref1 = parseParams(), slide = ref1[0], on_finished = ref1[1];
      if (node) {
        this._openNode(node, slide, on_finished);
      }
      return this.element;
    };
    JqTreeWidget.prototype._openNode = function(node, slide, on_finished) {
      var doOpenNode, parent;
      if (slide == null) {
        slide = true;
      }
      doOpenNode = function(_this) {
        return function(_node, _slide, _on_finished) {
          var folder_element;
          folder_element = new FolderElement(_node, _this);
          return folder_element.open(_on_finished, _slide);
        };
      }(this);
      if (node.isFolder()) {
        if (node.load_on_demand) {
          return this._loadFolderOnDemand(node, slide, on_finished);
        } else {
          parent = node.parent;
          while (parent) {
            if (parent.parent) {
              doOpenNode(parent, false, null);
            }
            parent = parent.parent;
          }
          doOpenNode(node, slide, on_finished);
          return this._saveState();
        }
      }
    };
    JqTreeWidget.prototype._loadFolderOnDemand = function(node, slide, on_finished) {
      if (slide == null) {
        slide = true;
      }
      node.is_loading = true;
      return this._loadDataFromUrl(null, node, function(_this) {
        return function() {
          return _this._openNode(node, slide, on_finished);
        };
      }(this));
    };
    JqTreeWidget.prototype.closeNode = function(node, slide) {
      if (slide == null) {
        slide = null;
      }
      if (slide === null) {
        slide = this.options.slide;
      }
      if (node.isFolder()) {
        (new FolderElement(node, this)).close(slide);
        this._saveState();
      }
      return this.element;
    };
    JqTreeWidget.prototype.isDragging = function() {
      if (this.dnd_handler) {
        return this.dnd_handler.is_dragging;
      } else {
        return false;
      }
    };
    JqTreeWidget.prototype.refreshHitAreas = function() {
      this.dnd_handler.refresh();
      return this.element;
    };
    JqTreeWidget.prototype.addNodeAfter = function(new_node_info, existing_node) {
      var new_node;
      new_node = existing_node.addAfter(new_node_info);
      this._refreshElements(existing_node.parent);
      return new_node;
    };
    JqTreeWidget.prototype.addNodeBefore = function(new_node_info, existing_node) {
      var new_node;
      new_node = existing_node.addBefore(new_node_info);
      this._refreshElements(existing_node.parent);
      return new_node;
    };
    JqTreeWidget.prototype.addParentNode = function(new_node_info, existing_node) {
      var new_node;
      new_node = existing_node.addParent(new_node_info);
      this._refreshElements(new_node.parent);
      return new_node;
    };
    JqTreeWidget.prototype.removeNode = function(node) {
      var parent;
      parent = node.parent;
      if (parent) {
        this.select_node_handler.removeFromSelection(node, true);
        node.remove();
        this._refreshElements(parent);
      }
      return this.element;
    };
    JqTreeWidget.prototype.appendNode = function(new_node_info, parent_node) {
      var node;
      parent_node = parent_node || this.tree;
      node = parent_node.append(new_node_info);
      this._refreshElements(parent_node);
      return node;
    };
    JqTreeWidget.prototype.prependNode = function(new_node_info, parent_node) {
      var node;
      if (!parent_node) {
        parent_node = this.tree;
      }
      node = parent_node.prepend(new_node_info);
      this._refreshElements(parent_node);
      return node;
    };
    JqTreeWidget.prototype.updateNode = function(node, data) {
      var id_is_changed;
      id_is_changed = data.id && data.id !== node.id;
      if (id_is_changed) {
        this.tree.removeNodeFromIndex(node);
      }
      node.setData(data);
      if (id_is_changed) {
        this.tree.addNodeToIndex(node);
      }
      if (typeof data === "object" && data.children) {
        node.removeChildren();
        if (data.children.length) {
          node.loadFromData(data.children);
        }
      }
      this.renderer.renderFromNode(node);
      this._selectCurrentNode();
      return this.element;
    };
    JqTreeWidget.prototype.moveNode = function(node, target_node, position) {
      var position_index;
      position_index = Position.nameToIndex(position);
      this.tree.moveNode(node, target_node, position_index);
      this._refreshElements();
      return this.element;
    };
    JqTreeWidget.prototype.getStateFromStorage = function() {
      return this.save_state_handler.getStateFromStorage();
    };
    JqTreeWidget.prototype.addToSelection = function(node) {
      if (node) {
        this.select_node_handler.addToSelection(node);
        this._getNodeElementForNode(node).select();
        this._saveState();
      }
      return this.element;
    };
    JqTreeWidget.prototype.getSelectedNodes = function() {
      return this.select_node_handler.getSelectedNodes();
    };
    JqTreeWidget.prototype.isNodeSelected = function(node) {
      return this.select_node_handler.isNodeSelected(node);
    };
    JqTreeWidget.prototype.removeFromSelection = function(node) {
      this.select_node_handler.removeFromSelection(node);
      this._getNodeElementForNode(node).deselect();
      this._saveState();
      return this.element;
    };
    JqTreeWidget.prototype.scrollToNode = function(node) {
      var $element, top;
      $element = $(node.element);
      top = $element.offset().top - this.$el.offset().top;
      this.scroll_handler.scrollTo(top);
      return this.element;
    };
    JqTreeWidget.prototype.getState = function() {
      return this.save_state_handler.getState();
    };
    JqTreeWidget.prototype.setState = function(state) {
      this.save_state_handler.setInitialState(state);
      this._refreshElements();
      return this.element;
    };
    JqTreeWidget.prototype.setOption = function(option, value) {
      this.options[option] = value;
      return this.element;
    };
    JqTreeWidget.prototype.moveDown = function() {
      if (this.key_handler) {
        this.key_handler.moveDown();
      }
      return this.element;
    };
    JqTreeWidget.prototype.moveUp = function() {
      if (this.key_handler) {
        this.key_handler.moveUp();
      }
      return this.element;
    };
    JqTreeWidget.prototype.getVersion = function() {
      return __version__;
    };
    JqTreeWidget.prototype._init = function() {
      JqTreeWidget.__super__._init.call(this);
      this.element = this.$el;
      this.mouse_delay = 300;
      this.is_initialized = false;
      this.options.rtl = this._getRtlOption();
      if (!this.options.closedIcon) {
        this.options.closedIcon = this._getDefaultClosedIcon();
      }
      this.renderer = new ElementsRenderer(this);
      if (SaveStateHandler != null) {
        this.save_state_handler = new SaveStateHandler(this);
      } else {
        this.options.saveState = false;
      }
      if (SelectNodeHandler != null) {
        this.select_node_handler = new SelectNodeHandler(this);
      }
      if (DragAndDropHandler != null) {
        this.dnd_handler = new DragAndDropHandler(this);
      } else {
        this.options.dragAndDrop = false;
      }
      if (ScrollHandler != null) {
        this.scroll_handler = new ScrollHandler(this);
      }
      if (KeyHandler != null && SelectNodeHandler != null) {
        this.key_handler = new KeyHandler(this);
      }
      this._initData();
      this.element.click($.proxy(this._click, this));
      this.element.dblclick($.proxy(this._dblclick, this));
      if (this.options.useContextMenu) {
        return this.element.bind("contextmenu", $.proxy(this._contextmenu, this));
      }
    };
    JqTreeWidget.prototype._deinit = function() {
      this.element.empty();
      this.element.unbind();
      if (this.key_handler) {
        this.key_handler.deinit();
      }
      this.tree = null;
      return JqTreeWidget.__super__._deinit.call(this);
    };
    JqTreeWidget.prototype._initData = function() {
      var data_url;
      if (this.options.data) {
        return this._loadData(this.options.data);
      } else {
        data_url = this._getDataUrlInfo();
        if (data_url) {
          return this._loadDataFromUrl();
        } else {
          return this._loadData([]);
        }
      }
    };
    JqTreeWidget.prototype._getDataUrlInfo = function(node) {
      var data_url, getUrlFromString;
      data_url = this.options.dataUrl || this.element.data("url");
      getUrlFromString = function(_this) {
        return function() {
          var data, selected_node_id, url_info;
          url_info = {url:data_url};
          if (node && node.id) {
            data = {node:node.id};
            url_info["data"] = data;
          } else {
            selected_node_id = _this._getNodeIdToBeSelected();
            if (selected_node_id) {
              data = {selected_node:selected_node_id};
              url_info["data"] = data;
            }
          }
          return url_info;
        };
      }(this);
      if ($.isFunction(data_url)) {
        return data_url(node);
      } else {
        if ($.type(data_url) === "string") {
          return getUrlFromString();
        } else {
          return data_url;
        }
      }
    };
    JqTreeWidget.prototype._getNodeIdToBeSelected = function() {
      if (this.options.saveState) {
        return this.save_state_handler.getNodeIdToBeSelected();
      } else {
        return null;
      }
    };
    JqTreeWidget.prototype._initTree = function(data) {
      var doInit, must_load_on_demand;
      doInit = function(_this) {
        return function() {
          if (!_this.is_initialized) {
            _this.is_initialized = true;
            return _this._triggerEvent("tree.init");
          }
        };
      }(this);
      this.tree = new this.options.nodeClass(null, true, this.options.nodeClass);
      if (this.select_node_handler) {
        this.select_node_handler.clear();
      }
      this.tree.loadFromData(data);
      must_load_on_demand = this._setInitialState();
      this._refreshElements();
      if (!must_load_on_demand) {
        return doInit();
      } else {
        return this._setInitialStateOnDemand(doInit);
      }
    };
    JqTreeWidget.prototype._setInitialState = function() {
      var autoOpenNodes, is_restored, must_load_on_demand, ref1, restoreState;
      restoreState = function(_this) {
        return function() {
          var must_load_on_demand, state;
          if (!(_this.options.saveState && _this.save_state_handler)) {
            return [false, false];
          } else {
            state = _this.save_state_handler.getStateFromStorage();
            if (!state) {
              return [false, false];
            } else {
              must_load_on_demand = _this.save_state_handler.setInitialState(state);
              return [true, must_load_on_demand];
            }
          }
        };
      }(this);
      autoOpenNodes = function(_this) {
        return function() {
          var max_level, must_load_on_demand;
          if (_this.options.autoOpen === false) {
            return false;
          }
          max_level = _this._getAutoOpenMaxLevel();
          must_load_on_demand = false;
          _this.tree.iterate(function(node, level) {
            if (node.load_on_demand) {
              must_load_on_demand = true;
              return false;
            } else {
              if (!node.hasChildren()) {
                return false;
              } else {
                node.is_open = true;
                return level !== max_level;
              }
            }
          });
          return must_load_on_demand;
        };
      }(this);
      ref1 = restoreState(), is_restored = ref1[0], must_load_on_demand = ref1[1];
      if (!is_restored) {
        must_load_on_demand = autoOpenNodes();
      }
      return must_load_on_demand;
    };
    JqTreeWidget.prototype._setInitialStateOnDemand = function(cb_finished) {
      var autoOpenNodes, restoreState;
      restoreState = function(_this) {
        return function() {
          var state;
          if (!(_this.options.saveState && _this.save_state_handler)) {
            return false;
          } else {
            state = _this.save_state_handler.getStateFromStorage();
            if (!state) {
              return false;
            } else {
              _this.save_state_handler.setInitialStateOnDemand(state, cb_finished);
              return true;
            }
          }
        };
      }(this);
      autoOpenNodes = function(_this) {
        return function() {
          var loadAndOpenNode, loading_count, max_level, openNodes;
          max_level = _this._getAutoOpenMaxLevel();
          loading_count = 0;
          loadAndOpenNode = function(node) {
            loading_count += 1;
            return _this._openNode(node, false, function() {
              loading_count -= 1;
              return openNodes();
            });
          };
          openNodes = function() {
            _this.tree.iterate(function(node, level) {
              if (node.load_on_demand) {
                if (!node.is_loading) {
                  loadAndOpenNode(node);
                }
                return false;
              } else {
                _this._openNode(node, false);
                return level !== max_level;
              }
            });
            if (loading_count === 0) {
              return cb_finished();
            }
          };
          return openNodes();
        };
      }(this);
      if (!restoreState()) {
        return autoOpenNodes();
      }
    };
    JqTreeWidget.prototype._getAutoOpenMaxLevel = function() {
      if (this.options.autoOpen === true) {
        return -1;
      } else {
        return parseInt(this.options.autoOpen);
      }
    };
    JqTreeWidget.prototype._refreshElements = function(from_node) {
      if (from_node == null) {
        from_node = null;
      }
      this.renderer.render(from_node);
      return this._triggerEvent("tree.refresh");
    };
    JqTreeWidget.prototype._click = function(e) {
      var click_target, event, node;
      click_target = this._getClickTarget(e.target);
      if (click_target) {
        if (click_target.type === "button") {
          this.toggle(click_target.node, this.options.slide);
          e.preventDefault();
          return e.stopPropagation();
        } else {
          if (click_target.type === "label") {
            node = click_target.node;
            event = this._triggerEvent("tree.click", {node:node, click_event:e});
            if (!event.isDefaultPrevented()) {
              return this._selectNode(node, true);
            }
          }
        }
      }
    };
    JqTreeWidget.prototype._dblclick = function(e) {
      var click_target;
      click_target = this._getClickTarget(e.target);
      if (click_target && click_target.type === "label") {
        return this._triggerEvent("tree.dblclick", {node:click_target.node, click_event:e});
      }
    };
    JqTreeWidget.prototype._getClickTarget = function(element) {
      var $button, $el, $target, node;
      $target = $(element);
      $button = $target.closest(".jqtree-toggler");
      if ($button.length) {
        node = this._getNode($button);
        if (node) {
          return {type:"button", node:node};
        }
      } else {
        $el = $target.closest(".jqtree-element");
        if ($el.length) {
          node = this._getNode($el);
          if (node) {
            return {type:"label", node:node};
          }
        }
      }
      return null;
    };
    JqTreeWidget.prototype._getNode = function($element) {
      var $li;
      $li = $element.closest("li.jqtree_common");
      if ($li.length === 0) {
        return null;
      } else {
        return $li.data("node");
      }
    };
    JqTreeWidget.prototype._getNodeElementForNode = function(node) {
      if (node.isFolder()) {
        return new FolderElement(node, this);
      } else {
        return new NodeElement(node, this);
      }
    };
    JqTreeWidget.prototype._getNodeElement = function($element) {
      var node;
      node = this._getNode($element);
      if (node) {
        return this._getNodeElementForNode(node);
      } else {
        return null;
      }
    };
    JqTreeWidget.prototype._contextmenu = function(e) {
      var $div, node;
      $div = $(e.target).closest("ul.jqtree-tree .jqtree-element");
      if ($div.length) {
        node = this._getNode($div);
        if (node) {
          e.preventDefault();
          e.stopPropagation();
          this._triggerEvent("tree.contextmenu", {node:node, click_event:e});
          return false;
        }
      }
    };
    JqTreeWidget.prototype._saveState = function() {
      if (this.options.saveState) {
        return this.save_state_handler.saveState();
      }
    };
    JqTreeWidget.prototype._mouseCapture = function(position_info) {
      if (this.options.dragAndDrop) {
        return this.dnd_handler.mouseCapture(position_info);
      } else {
        return false;
      }
    };
    JqTreeWidget.prototype._mouseStart = function(position_info) {
      if (this.options.dragAndDrop) {
        return this.dnd_handler.mouseStart(position_info);
      } else {
        return false;
      }
    };
    JqTreeWidget.prototype._mouseDrag = function(position_info) {
      var result;
      if (this.options.dragAndDrop) {
        result = this.dnd_handler.mouseDrag(position_info);
        if (this.scroll_handler) {
          this.scroll_handler.checkScrolling();
        }
        return result;
      } else {
        return false;
      }
    };
    JqTreeWidget.prototype._mouseStop = function(position_info) {
      if (this.options.dragAndDrop) {
        return this.dnd_handler.mouseStop(position_info);
      } else {
        return false;
      }
    };
    JqTreeWidget.prototype._triggerEvent = function(event_name, values) {
      var event;
      event = $.Event(event_name);
      $.extend(event, values);
      this.element.trigger(event);
      return event;
    };
    JqTreeWidget.prototype.testGenerateHitAreas = function(moving_node) {
      this.dnd_handler.current_item = this._getNodeElementForNode(moving_node);
      this.dnd_handler.generateHitAreas();
      return this.dnd_handler.hit_areas;
    };
    JqTreeWidget.prototype._selectCurrentNode = function() {
      var node, node_element;
      node = this.getSelectedNode();
      if (node) {
        node_element = this._getNodeElementForNode(node);
        if (node_element) {
          return node_element.select();
        }
      }
    };
    JqTreeWidget.prototype._deselectCurrentNode = function() {
      var node;
      node = this.getSelectedNode();
      if (node) {
        return this.removeFromSelection(node);
      }
    };
    JqTreeWidget.prototype._getDefaultClosedIcon = function() {
      if (this.options.rtl) {
        return "&#x25c0;";
      } else {
        return "&#x25ba;";
      }
    };
    JqTreeWidget.prototype._getRtlOption = function() {
      var data_rtl;
      if (this.options.rtl !== null) {
        return this.options.rtl;
      } else {
        data_rtl = this.element.data("rtl");
        if (data_rtl != null && data_rtl !== false) {
          return true;
        } else {
          return false;
        }
      }
    };
    JqTreeWidget.prototype._notifyLoading = function(is_loading, node, $el) {
      if (this.options.onLoading) {
        return this.options.onLoading(is_loading, node, $el);
      }
    };
    return JqTreeWidget;
  }(MouseWidget);
  JqTreeWidget.getModule = function(name) {
    var modules;
    modules = {"node":node_module, "util":util_module, "drag_and_drop_handler":drag_and_drop_handler};
    return modules[name];
  };
  SimpleWidget.register(JqTreeWidget, "tree");
}, {"./drag_and_drop_handler":1, "./elements_renderer":2, "./key_handler":3, "./mouse.widget":4, "./node":5, "./node_element":6, "./save_state_handler":7, "./scroll_handler":8, "./select_node_handler":9, "./simple.widget":10, "./util":12, "./version":13}], 12:[function(require, module, exports) {
  var _indexOf, getBoolString, html_escape, indexOf, isFunction, isInt;
  _indexOf = function(array, item) {
    var i, j, len, value;
    for (i = j = 0, len = array.length; j < len; i = ++j) {
      value = array[i];
      if (value === item) {
        return i;
      }
    }
    return -1;
  };
  indexOf = function(array, item) {
    if (array.indexOf) {
      return array.indexOf(item);
    } else {
      return _indexOf(array, item);
    }
  };
  isInt = function(n) {
    return typeof n === "number" && n % 1 === 0;
  };
  isFunction = function(v) {
    return typeof v === "function";
  };
  html_escape = function(string) {
    return ("" + string).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;").replace(/\//g, "&#x2F;");
  };
  getBoolString = function(value) {
    if (value) {
      return "true";
    } else {
      return "false";
    }
  };
  module.exports = {_indexOf:_indexOf, getBoolString:getBoolString, html_escape:html_escape, indexOf:indexOf, isInt:isInt, isFunction:isFunction};
}, {}], 13:[function(require, module, exports) {
  module.exports = "1.3.7";
}, {}]}, {}, [11]);
Polymer({is:"simpl-jqtree", properties:{multiselect:{type:Boolean, value:false}, selection:{type:Array, notify:true}, data:{observer:"dataChanged", type:Object}, selectedItem:{notify:true, type:Object}, jqtree:{notify:true, type:Object}, cmnode:{notify:true, type:Object}, contextmenu:{type:Array}, options:{type:String}}, observers:[], behaviors:[StyleScopeBehavior], ready:function() {
}, _createTree:function() {
  var o = clone(this._parseOptions(this.options));
  o.data = this.data;
  if (this.contextmenu) {
    o.useContextMenu = true;
  }
  this.jqtree = $(this.$.jqtree).tree(o);
  if (this.multiselect) {
    this.jqtree.bind("tree.click", this._multiSelection.bind(this));
  }
  this.jqtree.bind("tree.select", this._itemSelected.bind(this));
  if (this.contextmenu) {
    this.jqtree.bind("tree.contextmenu", this._contextMenu.bind(this));
    var cm = contextmenu(this.contextmenu);
    this._contextMenu = cm;
    contextmenu.attach($(this.$.contextmenuId), cm);
  }
}, dataChanged:function() {
  if (this.jqtree) {
    this.jqtree.tree("loadData", this.data);
  } else {
    this._createTree();
  }
}, _contextMenu:function(e) {
  this.cmnode = e.node;
  contextmenu.show(this._contextMenu, e.node.element);
}, _multiSelection:function(e) {
  e.preventDefault();
  var selected_node = e.node;
  if (selected_node.id == undefined) {
    console.log("The multiple selection functions require that nodes have an id");
  }
  if (this.jqtree.tree("isNodeSelected", selected_node)) {
    this.jqtree.tree("removeFromSelection", selected_node);
  } else {
    this.jqtree.tree("addToSelection", selected_node);
  }
}, _itemSelected:function(event) {
  if (event.node) {
    var node = event.node;
    this.selectedItem = {label:node.name, id:node.id};
    this.fire("iron-select", {item:this.selectedItem});
    this.prevSelectedItem = this.selectedItem;
  } else {
    this.selectedItem = null;
    this.fire("iron-deselect", {item:this.prevSelectedItem});
  }
}, _parseOptions:function(o) {
  if (o == null) {
    return {};
  }
  if (typeof o == "string") {
    o = JSON5.parse(o);
  }
  return o;
}});
Polymer({is:"simpl-jqtree-dropdown", properties:{selectedItem:{observer:"selectedItemChanged", notify:true, type:Object}}, observers:[], behaviors:[StyleScopeBehavior], ready:function() {
}, attached:function() {
}, selectedItemChanged:function(e) {
  console.log("jqtree.dropdown.selectedItemChanged:", this.selectedItem);
}});
(function(global, factory) {
  typeof exports === "object" && typeof module !== "undefined" ? factory(require("jquery")) : typeof define === "function" && define.amd ? define(["jquery"], factory) : factory(global.jQuery);
})(this, function($) {
  $ = "default" in $ ? $["default"] : $;
  var DEFAULTS = {viewMode:0, dragMode:"crop", aspectRatio:NaN, data:null, preview:"", responsive:true, restore:true, checkCrossOrigin:true, checkOrientation:true, modal:true, guides:true, center:true, highlight:true, background:true, autoCrop:true, autoCropArea:0.8, movable:true, rotatable:true, scalable:true, zoomable:true, zoomOnTouch:true, zoomOnWheel:true, wheelZoomRatio:0.1, cropBoxMovable:true, cropBoxResizable:true, toggleDragModeOnDblclick:true, minCanvasWidth:0, minCanvasHeight:0, minCropBoxWidth:0, 
  minCropBoxHeight:0, minContainerWidth:200, minContainerHeight:100, ready:null, cropstart:null, cropmove:null, cropend:null, crop:null, zoom:null};
  var TEMPLATE = '<div class="cropper-container">' + '<div class="cropper-wrap-box">' + '<div class="cropper-canvas"></div>' + "</div>" + '<div class="cropper-drag-box"></div>' + '<div class="cropper-crop-box">' + '<span class="cropper-view-box"></span>' + '<span class="cropper-dashed dashed-h"></span>' + '<span class="cropper-dashed dashed-v"></span>' + '<span class="cropper-center"></span>' + '<span class="cropper-face"></span>' + '<span class="cropper-line line-e" data-action="e"></span>' + '<span class="cropper-line line-n" data-action="n"></span>' + 
  '<span class="cropper-line line-w" data-action="w"></span>' + '<span class="cropper-line line-s" data-action="s"></span>' + '<span class="cropper-point point-e" data-action="e"></span>' + '<span class="cropper-point point-n" data-action="n"></span>' + '<span class="cropper-point point-w" data-action="w"></span>' + '<span class="cropper-point point-s" data-action="s"></span>' + '<span class="cropper-point point-ne" data-action="ne"></span>' + '<span class="cropper-point point-nw" data-action="nw"></span>' + 
  '<span class="cropper-point point-sw" data-action="sw"></span>' + '<span class="cropper-point point-se" data-action="se"></span>' + "</div>" + "</div>";
  var REGEXP_DATA_URL_HEAD = /^data:.*,/;
  var REGEXP_USERAGENT = /(Macintosh|iPhone|iPod|iPad).*AppleWebKit/i;
  var navigator = typeof window !== "undefined" ? window.navigator : null;
  var IS_SAFARI_OR_UIWEBVIEW = navigator && REGEXP_USERAGENT.test(navigator.userAgent);
  var fromCharCode = String.fromCharCode;
  function isNumber(n) {
    return typeof n === "number" && !isNaN(n);
  }
  function isUndefined(n) {
    return typeof n === "undefined";
  }
  function toArray(obj, offset) {
    var args = [];
    if (isNumber(offset)) {
      args.push(offset);
    }
    return args.slice.apply(obj, args);
  }
  function proxy(fn, context) {
    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }
    return function() {
      for (var _len2 = arguments.length, args2 = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args2[_key2] = arguments[_key2];
      }
      return fn.apply(context, args.concat(toArray(args2)));
    };
  }
  function objectKeys(obj) {
    var keys = [];
    $.each(obj, function(key) {
      keys.push(key);
    });
    return keys;
  }
  function isCrossOriginURL(url) {
    var parts = url.match(/^(https?:)\/\/([^:/?#]+):?(\d*)/i);
    return parts && (parts[1] !== location.protocol || parts[2] !== location.hostname || parts[3] !== location.port);
  }
  function addTimestamp(url) {
    var timestamp = "timestamp=" + (new Date).getTime();
    return url + (url.indexOf("?") === -1 ? "?" : "&") + timestamp;
  }
  function getImageSize(image, callback) {
    if (image.naturalWidth && !IS_SAFARI_OR_UIWEBVIEW) {
      callback(image.naturalWidth, image.naturalHeight);
      return;
    }
    var newImage = document.createElement("img");
    newImage.onload = function load() {
      callback(this.width, this.height);
    };
    newImage.src = image.src;
  }
  function getTransform(options) {
    var transforms = [];
    var translateX = options.translateX;
    var translateY = options.translateY;
    var rotate = options.rotate;
    var scaleX = options.scaleX;
    var scaleY = options.scaleY;
    if (isNumber(translateX) && translateX !== 0) {
      transforms.push("translateX(" + translateX + "px)");
    }
    if (isNumber(translateY) && translateY !== 0) {
      transforms.push("translateY(" + translateY + "px)");
    }
    if (isNumber(rotate) && rotate !== 0) {
      transforms.push("rotate(" + rotate + "deg)");
    }
    if (isNumber(scaleX) && scaleX !== 1) {
      transforms.push("scaleX(" + scaleX + ")");
    }
    if (isNumber(scaleY) && scaleY !== 1) {
      transforms.push("scaleY(" + scaleY + ")");
    }
    return transforms.length ? transforms.join(" ") : "none";
  }
  function getRotatedSizes(data, isReversed) {
    var deg = Math.abs(data.degree) % 180;
    var arc = (deg > 90 ? 180 - deg : deg) * Math.PI / 180;
    var sinArc = Math.sin(arc);
    var cosArc = Math.cos(arc);
    var width = data.width;
    var height = data.height;
    var aspectRatio = data.aspectRatio;
    var newWidth = void 0;
    var newHeight = void 0;
    if (!isReversed) {
      newWidth = width * cosArc + height * sinArc;
      newHeight = width * sinArc + height * cosArc;
    } else {
      newWidth = width / (cosArc + sinArc / aspectRatio);
      newHeight = newWidth / aspectRatio;
    }
    return {width:newWidth, height:newHeight};
  }
  function getSourceCanvas(image, data, options) {
    var canvas = $("<canvas>")[0];
    var context = canvas.getContext("2d");
    var dstX = 0;
    var dstY = 0;
    var dstWidth = data.naturalWidth;
    var dstHeight = data.naturalHeight;
    var rotate = data.rotate;
    var scaleX = data.scaleX;
    var scaleY = data.scaleY;
    var scalable = isNumber(scaleX) && isNumber(scaleY) && (scaleX !== 1 || scaleY !== 1);
    var rotatable = isNumber(rotate) && rotate !== 0;
    var advanced = rotatable || scalable;
    var canvasWidth = dstWidth * Math.abs(scaleX || 1);
    var canvasHeight = dstHeight * Math.abs(scaleY || 1);
    var translateX = void 0;
    var translateY = void 0;
    var rotated = void 0;
    if (scalable) {
      translateX = canvasWidth / 2;
      translateY = canvasHeight / 2;
    }
    if (rotatable) {
      rotated = getRotatedSizes({width:canvasWidth, height:canvasHeight, degree:rotate});
      canvasWidth = rotated.width;
      canvasHeight = rotated.height;
      translateX = canvasWidth / 2;
      translateY = canvasHeight / 2;
    }
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;
    if (options.fillColor) {
      context.fillStyle = options.fillColor;
      context.fillRect(0, 0, canvasWidth, canvasHeight);
    }
    if (advanced) {
      dstX = -dstWidth / 2;
      dstY = -dstHeight / 2;
      context.save();
      context.translate(translateX, translateY);
    }
    if (rotatable) {
      context.rotate(rotate * Math.PI / 180);
    }
    if (scalable) {
      context.scale(scaleX, scaleY);
    }
    context.imageSmoothingEnabled = !!options.imageSmoothingEnabled;
    if (options.imageSmoothingQuality) {
      context.imageSmoothingQuality = options.imageSmoothingQuality;
    }
    context.drawImage(image, Math.floor(dstX), Math.floor(dstY), Math.floor(dstWidth), Math.floor(dstHeight));
    if (advanced) {
      context.restore();
    }
    return canvas;
  }
  function getStringFromCharCode(dataView, start, length) {
    var str = "";
    var i = void 0;
    for (i = start, length += start; i < length; i++) {
      str += fromCharCode(dataView.getUint8(i));
    }
    return str;
  }
  function getOrientation(arrayBuffer) {
    var dataView = new DataView(arrayBuffer);
    var length = dataView.byteLength;
    var orientation = void 0;
    var exifIDCode = void 0;
    var tiffOffset = void 0;
    var firstIFDOffset = void 0;
    var littleEndian = void 0;
    var endianness = void 0;
    var app1Start = void 0;
    var ifdStart = void 0;
    var offset = void 0;
    var i = void 0;
    if (dataView.getUint8(0) === 255 && dataView.getUint8(1) === 216) {
      offset = 2;
      while (offset < length) {
        if (dataView.getUint8(offset) === 255 && dataView.getUint8(offset + 1) === 225) {
          app1Start = offset;
          break;
        }
        offset++;
      }
    }
    if (app1Start) {
      exifIDCode = app1Start + 4;
      tiffOffset = app1Start + 10;
      if (getStringFromCharCode(dataView, exifIDCode, 4) === "Exif") {
        endianness = dataView.getUint16(tiffOffset);
        littleEndian = endianness === 18761;
        if (littleEndian || endianness === 19789) {
          if (dataView.getUint16(tiffOffset + 2, littleEndian) === 42) {
            firstIFDOffset = dataView.getUint32(tiffOffset + 4, littleEndian);
            if (firstIFDOffset >= 8) {
              ifdStart = tiffOffset + firstIFDOffset;
            }
          }
        }
      }
    }
    if (ifdStart) {
      length = dataView.getUint16(ifdStart, littleEndian);
      for (i = 0; i < length; i++) {
        offset = ifdStart + i * 12 + 2;
        if (dataView.getUint16(offset, littleEndian) === 274) {
          offset += 8;
          orientation = dataView.getUint16(offset, littleEndian);
          if (IS_SAFARI_OR_UIWEBVIEW) {
            dataView.setUint16(offset, 1, littleEndian);
          }
          break;
        }
      }
    }
    return orientation;
  }
  function dataURLToArrayBuffer(dataURL) {
    var base64 = dataURL.replace(REGEXP_DATA_URL_HEAD, "");
    var binary = atob(base64);
    var length = binary.length;
    var arrayBuffer = new ArrayBuffer(length);
    var dataView = new Uint8Array(arrayBuffer);
    var i = void 0;
    for (i = 0; i < length; i++) {
      dataView[i] = binary.charCodeAt(i);
    }
    return arrayBuffer;
  }
  function arrayBufferToDataURL(arrayBuffer) {
    var dataView = new Uint8Array(arrayBuffer);
    var length = dataView.length;
    var base64 = "";
    var i = void 0;
    for (i = 0; i < length; i++) {
      base64 += fromCharCode(dataView[i]);
    }
    return "data:image/jpeg;base64," + btoa(base64);
  }
  var render$1 = {render:function render() {
    var self = this;
    self.initContainer();
    self.initCanvas();
    self.initCropBox();
    self.renderCanvas();
    if (self.cropped) {
      self.renderCropBox();
    }
  }, initContainer:function initContainer() {
    var self = this;
    var options = self.options;
    var $this = self.$element;
    var $container = self.$container;
    var $cropper = self.$cropper;
    var hidden = "cropper-hidden";
    $cropper.addClass(hidden);
    $this.removeClass(hidden);
    $cropper.css(self.container = {width:Math.max($container.width(), Number(options.minContainerWidth) || 200), height:Math.max($container.height(), Number(options.minContainerHeight) || 100)});
    $this.addClass(hidden);
    $cropper.removeClass(hidden);
  }, initCanvas:function initCanvas() {
    var self = this;
    var viewMode = self.options.viewMode;
    var container = self.container;
    var containerWidth = container.width;
    var containerHeight = container.height;
    var image = self.image;
    var imageNaturalWidth = image.naturalWidth;
    var imageNaturalHeight = image.naturalHeight;
    var is90Degree = Math.abs(image.rotate) % 180 === 90;
    var naturalWidth = is90Degree ? imageNaturalHeight : imageNaturalWidth;
    var naturalHeight = is90Degree ? imageNaturalWidth : imageNaturalHeight;
    var aspectRatio = naturalWidth / naturalHeight;
    var canvasWidth = containerWidth;
    var canvasHeight = containerHeight;
    if (containerHeight * aspectRatio > containerWidth) {
      if (viewMode === 3) {
        canvasWidth = containerHeight * aspectRatio;
      } else {
        canvasHeight = containerWidth / aspectRatio;
      }
    } else {
      if (viewMode === 3) {
        canvasHeight = containerWidth / aspectRatio;
      } else {
        canvasWidth = containerHeight * aspectRatio;
      }
    }
    var canvas = {naturalWidth:naturalWidth, naturalHeight:naturalHeight, aspectRatio:aspectRatio, width:canvasWidth, height:canvasHeight};
    canvas.oldLeft = canvas.left = (containerWidth - canvasWidth) / 2;
    canvas.oldTop = canvas.top = (containerHeight - canvasHeight) / 2;
    self.canvas = canvas;
    self.limited = viewMode === 1 || viewMode === 2;
    self.limitCanvas(true, true);
    self.initialImage = $.extend({}, image);
    self.initialCanvas = $.extend({}, canvas);
  }, limitCanvas:function limitCanvas(isSizeLimited, isPositionLimited) {
    var self = this;
    var options = self.options;
    var viewMode = options.viewMode;
    var container = self.container;
    var containerWidth = container.width;
    var containerHeight = container.height;
    var canvas = self.canvas;
    var aspectRatio = canvas.aspectRatio;
    var cropBox = self.cropBox;
    var cropped = self.cropped && cropBox;
    if (isSizeLimited) {
      var minCanvasWidth = Number(options.minCanvasWidth) || 0;
      var minCanvasHeight = Number(options.minCanvasHeight) || 0;
      if (viewMode) {
        if (viewMode > 1) {
          minCanvasWidth = Math.max(minCanvasWidth, containerWidth);
          minCanvasHeight = Math.max(minCanvasHeight, containerHeight);
          if (viewMode === 3) {
            if (minCanvasHeight * aspectRatio > minCanvasWidth) {
              minCanvasWidth = minCanvasHeight * aspectRatio;
            } else {
              minCanvasHeight = minCanvasWidth / aspectRatio;
            }
          }
        } else {
          if (minCanvasWidth) {
            minCanvasWidth = Math.max(minCanvasWidth, cropped ? cropBox.width : 0);
          } else {
            if (minCanvasHeight) {
              minCanvasHeight = Math.max(minCanvasHeight, cropped ? cropBox.height : 0);
            } else {
              if (cropped) {
                minCanvasWidth = cropBox.width;
                minCanvasHeight = cropBox.height;
                if (minCanvasHeight * aspectRatio > minCanvasWidth) {
                  minCanvasWidth = minCanvasHeight * aspectRatio;
                } else {
                  minCanvasHeight = minCanvasWidth / aspectRatio;
                }
              }
            }
          }
        }
      }
      if (minCanvasWidth && minCanvasHeight) {
        if (minCanvasHeight * aspectRatio > minCanvasWidth) {
          minCanvasHeight = minCanvasWidth / aspectRatio;
        } else {
          minCanvasWidth = minCanvasHeight * aspectRatio;
        }
      } else {
        if (minCanvasWidth) {
          minCanvasHeight = minCanvasWidth / aspectRatio;
        } else {
          if (minCanvasHeight) {
            minCanvasWidth = minCanvasHeight * aspectRatio;
          }
        }
      }
      canvas.minWidth = minCanvasWidth;
      canvas.minHeight = minCanvasHeight;
      canvas.maxWidth = Infinity;
      canvas.maxHeight = Infinity;
    }
    if (isPositionLimited) {
      if (viewMode) {
        var newCanvasLeft = containerWidth - canvas.width;
        var newCanvasTop = containerHeight - canvas.height;
        canvas.minLeft = Math.min(0, newCanvasLeft);
        canvas.minTop = Math.min(0, newCanvasTop);
        canvas.maxLeft = Math.max(0, newCanvasLeft);
        canvas.maxTop = Math.max(0, newCanvasTop);
        if (cropped && self.limited) {
          canvas.minLeft = Math.min(cropBox.left, cropBox.left + cropBox.width - canvas.width);
          canvas.minTop = Math.min(cropBox.top, cropBox.top + cropBox.height - canvas.height);
          canvas.maxLeft = cropBox.left;
          canvas.maxTop = cropBox.top;
          if (viewMode === 2) {
            if (canvas.width >= containerWidth) {
              canvas.minLeft = Math.min(0, newCanvasLeft);
              canvas.maxLeft = Math.max(0, newCanvasLeft);
            }
            if (canvas.height >= containerHeight) {
              canvas.minTop = Math.min(0, newCanvasTop);
              canvas.maxTop = Math.max(0, newCanvasTop);
            }
          }
        }
      } else {
        canvas.minLeft = -canvas.width;
        canvas.minTop = -canvas.height;
        canvas.maxLeft = containerWidth;
        canvas.maxTop = containerHeight;
      }
    }
  }, renderCanvas:function renderCanvas(isChanged) {
    var self = this;
    var canvas = self.canvas;
    var image = self.image;
    var rotate = image.rotate;
    var naturalWidth = image.naturalWidth;
    var naturalHeight = image.naturalHeight;
    if (self.rotated) {
      self.rotated = false;
      var rotated = getRotatedSizes({width:image.width, height:image.height, degree:rotate});
      var aspectRatio = rotated.width / rotated.height;
      var isSquareImage = image.aspectRatio === 1;
      if (isSquareImage || aspectRatio !== canvas.aspectRatio) {
        canvas.left -= (rotated.width - canvas.width) / 2;
        canvas.top -= (rotated.height - canvas.height) / 2;
        canvas.width = rotated.width;
        canvas.height = rotated.height;
        canvas.aspectRatio = aspectRatio;
        canvas.naturalWidth = naturalWidth;
        canvas.naturalHeight = naturalHeight;
        if (isSquareImage && rotate % 90 || rotate % 180) {
          var rotated2 = getRotatedSizes({width:naturalWidth, height:naturalHeight, degree:rotate});
          canvas.naturalWidth = rotated2.width;
          canvas.naturalHeight = rotated2.height;
        }
        self.limitCanvas(true, false);
      }
    }
    if (canvas.width > canvas.maxWidth || canvas.width < canvas.minWidth) {
      canvas.left = canvas.oldLeft;
    }
    if (canvas.height > canvas.maxHeight || canvas.height < canvas.minHeight) {
      canvas.top = canvas.oldTop;
    }
    canvas.width = Math.min(Math.max(canvas.width, canvas.minWidth), canvas.maxWidth);
    canvas.height = Math.min(Math.max(canvas.height, canvas.minHeight), canvas.maxHeight);
    self.limitCanvas(false, true);
    canvas.oldLeft = canvas.left = Math.min(Math.max(canvas.left, canvas.minLeft), canvas.maxLeft);
    canvas.oldTop = canvas.top = Math.min(Math.max(canvas.top, canvas.minTop), canvas.maxTop);
    self.$canvas.css({width:canvas.width, height:canvas.height, transform:getTransform({translateX:canvas.left, translateY:canvas.top})});
    self.renderImage();
    if (self.cropped && self.limited) {
      self.limitCropBox(true, true);
    }
    if (isChanged) {
      self.output();
    }
  }, renderImage:function renderImage(isChanged) {
    var self = this;
    var canvas = self.canvas;
    var image = self.image;
    var reversed = void 0;
    if (image.rotate) {
      reversed = getRotatedSizes({width:canvas.width, height:canvas.height, degree:image.rotate, aspectRatio:image.aspectRatio}, true);
    }
    $.extend(image, reversed ? {width:reversed.width, height:reversed.height, left:(canvas.width - reversed.width) / 2, top:(canvas.height - reversed.height) / 2} : {width:canvas.width, height:canvas.height, left:0, top:0});
    self.$clone.css({width:image.width, height:image.height, transform:getTransform($.extend({translateX:image.left, translateY:image.top}, image))});
    if (isChanged) {
      self.output();
    }
  }, initCropBox:function initCropBox() {
    var self = this;
    var options = self.options;
    var canvas = self.canvas;
    var aspectRatio = options.aspectRatio;
    var autoCropArea = Number(options.autoCropArea) || 0.8;
    var cropBox = {width:canvas.width, height:canvas.height};
    if (aspectRatio) {
      if (canvas.height * aspectRatio > canvas.width) {
        cropBox.height = cropBox.width / aspectRatio;
      } else {
        cropBox.width = cropBox.height * aspectRatio;
      }
    }
    self.cropBox = cropBox;
    self.limitCropBox(true, true);
    cropBox.width = Math.min(Math.max(cropBox.width, cropBox.minWidth), cropBox.maxWidth);
    cropBox.height = Math.min(Math.max(cropBox.height, cropBox.minHeight), cropBox.maxHeight);
    cropBox.width = Math.max(cropBox.minWidth, cropBox.width * autoCropArea);
    cropBox.height = Math.max(cropBox.minHeight, cropBox.height * autoCropArea);
    cropBox.oldLeft = cropBox.left = canvas.left + (canvas.width - cropBox.width) / 2;
    cropBox.oldTop = cropBox.top = canvas.top + (canvas.height - cropBox.height) / 2;
    self.initialCropBox = $.extend({}, cropBox);
  }, limitCropBox:function limitCropBox(isSizeLimited, isPositionLimited) {
    var self = this;
    var options = self.options;
    var aspectRatio = options.aspectRatio;
    var container = self.container;
    var containerWidth = container.width;
    var containerHeight = container.height;
    var canvas = self.canvas;
    var cropBox = self.cropBox;
    var limited = self.limited;
    if (isSizeLimited) {
      var minCropBoxWidth = Number(options.minCropBoxWidth) || 0;
      var minCropBoxHeight = Number(options.minCropBoxHeight) || 0;
      var maxCropBoxWidth = Math.min(containerWidth, limited ? canvas.width : containerWidth);
      var maxCropBoxHeight = Math.min(containerHeight, limited ? canvas.height : containerHeight);
      minCropBoxWidth = Math.min(minCropBoxWidth, containerWidth);
      minCropBoxHeight = Math.min(minCropBoxHeight, containerHeight);
      if (aspectRatio) {
        if (minCropBoxWidth && minCropBoxHeight) {
          if (minCropBoxHeight * aspectRatio > minCropBoxWidth) {
            minCropBoxHeight = minCropBoxWidth / aspectRatio;
          } else {
            minCropBoxWidth = minCropBoxHeight * aspectRatio;
          }
        } else {
          if (minCropBoxWidth) {
            minCropBoxHeight = minCropBoxWidth / aspectRatio;
          } else {
            if (minCropBoxHeight) {
              minCropBoxWidth = minCropBoxHeight * aspectRatio;
            }
          }
        }
        if (maxCropBoxHeight * aspectRatio > maxCropBoxWidth) {
          maxCropBoxHeight = maxCropBoxWidth / aspectRatio;
        } else {
          maxCropBoxWidth = maxCropBoxHeight * aspectRatio;
        }
      }
      cropBox.minWidth = Math.min(minCropBoxWidth, maxCropBoxWidth);
      cropBox.minHeight = Math.min(minCropBoxHeight, maxCropBoxHeight);
      cropBox.maxWidth = maxCropBoxWidth;
      cropBox.maxHeight = maxCropBoxHeight;
    }
    if (isPositionLimited) {
      if (limited) {
        cropBox.minLeft = Math.max(0, canvas.left);
        cropBox.minTop = Math.max(0, canvas.top);
        cropBox.maxLeft = Math.min(containerWidth, canvas.left + canvas.width) - cropBox.width;
        cropBox.maxTop = Math.min(containerHeight, canvas.top + canvas.height) - cropBox.height;
      } else {
        cropBox.minLeft = 0;
        cropBox.minTop = 0;
        cropBox.maxLeft = containerWidth - cropBox.width;
        cropBox.maxTop = containerHeight - cropBox.height;
      }
    }
  }, renderCropBox:function renderCropBox() {
    var self = this;
    var options = self.options;
    var container = self.container;
    var containerWidth = container.width;
    var containerHeight = container.height;
    var cropBox = self.cropBox;
    if (cropBox.width > cropBox.maxWidth || cropBox.width < cropBox.minWidth) {
      cropBox.left = cropBox.oldLeft;
    }
    if (cropBox.height > cropBox.maxHeight || cropBox.height < cropBox.minHeight) {
      cropBox.top = cropBox.oldTop;
    }
    cropBox.width = Math.min(Math.max(cropBox.width, cropBox.minWidth), cropBox.maxWidth);
    cropBox.height = Math.min(Math.max(cropBox.height, cropBox.minHeight), cropBox.maxHeight);
    self.limitCropBox(false, true);
    cropBox.oldLeft = cropBox.left = Math.min(Math.max(cropBox.left, cropBox.minLeft), cropBox.maxLeft);
    cropBox.oldTop = cropBox.top = Math.min(Math.max(cropBox.top, cropBox.minTop), cropBox.maxTop);
    if (options.movable && options.cropBoxMovable) {
      self.$face.data("action", cropBox.width === containerWidth && cropBox.height === containerHeight ? "move" : "all");
    }
    self.$cropBox.css({width:cropBox.width, height:cropBox.height, transform:getTransform({translateX:cropBox.left, translateY:cropBox.top})});
    if (self.cropped && self.limited) {
      self.limitCanvas(true, true);
    }
    if (!self.disabled) {
      self.output();
    }
  }, output:function output() {
    var self = this;
    self.preview();
    if (self.completed) {
      self.trigger("crop", self.getData());
    }
  }};
  var DATA_PREVIEW = "preview";
  var preview$1 = {initPreview:function initPreview() {
    var self = this;
    var crossOrigin = self.crossOrigin;
    var url = crossOrigin ? self.crossOriginUrl : self.url;
    var image = document.createElement("img");
    if (crossOrigin) {
      image.crossOrigin = crossOrigin;
    }
    image.src = url;
    var $clone2 = $(image);
    self.$preview = $(self.options.preview);
    self.$clone2 = $clone2;
    self.$viewBox.html($clone2);
    self.$preview.each(function(i, element) {
      var $this = $(element);
      var img = document.createElement("img");
      $this.data(DATA_PREVIEW, {width:$this.width(), height:$this.height(), html:$this.html()});
      if (crossOrigin) {
        img.crossOrigin = crossOrigin;
      }
      img.src = url;
      img.style.cssText = "display:block;" + "width:100%;" + "height:auto;" + "min-width:0!important;" + "min-height:0!important;" + "max-width:none!important;" + "max-height:none!important;" + 'image-orientation:0deg!important;"';
      $this.html(img);
    });
  }, resetPreview:function resetPreview() {
    this.$preview.each(function(i, element) {
      var $this = $(element);
      var data = $this.data(DATA_PREVIEW);
      $this.css({width:data.width, height:data.height}).html(data.html).removeData(DATA_PREVIEW);
    });
  }, preview:function preview() {
    var self = this;
    var image = self.image;
    var canvas = self.canvas;
    var cropBox = self.cropBox;
    var cropBoxWidth = cropBox.width;
    var cropBoxHeight = cropBox.height;
    var width = image.width;
    var height = image.height;
    var left = cropBox.left - canvas.left - image.left;
    var top = cropBox.top - canvas.top - image.top;
    if (!self.cropped || self.disabled) {
      return;
    }
    self.$clone2.css({width:width, height:height, transform:getTransform($.extend({translateX:-left, translateY:-top}, image))});
    self.$preview.each(function(i, element) {
      var $this = $(element);
      var data = $this.data(DATA_PREVIEW);
      var originalWidth = data.width;
      var originalHeight = data.height;
      var newWidth = originalWidth;
      var newHeight = originalHeight;
      var ratio = 1;
      if (cropBoxWidth) {
        ratio = originalWidth / cropBoxWidth;
        newHeight = cropBoxHeight * ratio;
      }
      if (cropBoxHeight && newHeight > originalHeight) {
        ratio = originalHeight / cropBoxHeight;
        newWidth = cropBoxWidth * ratio;
        newHeight = originalHeight;
      }
      $this.css({width:newWidth, height:newHeight}).find("img").css({width:width * ratio, height:height * ratio, transform:getTransform($.extend({translateX:-left * ratio, translateY:-top * ratio}, image))});
    });
  }};
  var PointerEvent = typeof window !== "undefined" ? window.PointerEvent : null;
  var EVENT_POINTER_DOWN = PointerEvent ? "pointerdown" : "touchstart mousedown";
  var EVENT_POINTER_MOVE = PointerEvent ? "pointermove" : "touchmove mousemove";
  var EVENT_POINTER_UP = PointerEvent ? " pointerup pointercancel" : "touchend touchcancel mouseup";
  var EVENT_WHEEL = "wheel mousewheel DOMMouseScroll";
  var EVENT_DBLCLICK = "dblclick";
  var EVENT_RESIZE = "resize";
  var EVENT_CROP_START = "cropstart";
  var EVENT_CROP_MOVE = "cropmove";
  var EVENT_CROP_END = "cropend";
  var EVENT_CROP = "crop";
  var EVENT_ZOOM = "zoom";
  var events = {bind:function bind() {
    var self = this;
    var options = self.options;
    var $this = self.$element;
    var $cropper = self.$cropper;
    if ($.isFunction(options.cropstart)) {
      $this.on(EVENT_CROP_START, options.cropstart);
    }
    if ($.isFunction(options.cropmove)) {
      $this.on(EVENT_CROP_MOVE, options.cropmove);
    }
    if ($.isFunction(options.cropend)) {
      $this.on(EVENT_CROP_END, options.cropend);
    }
    if ($.isFunction(options.crop)) {
      $this.on(EVENT_CROP, options.crop);
    }
    if ($.isFunction(options.zoom)) {
      $this.on(EVENT_ZOOM, options.zoom);
    }
    $cropper.on(EVENT_POINTER_DOWN, proxy(self.cropStart, this));
    if (options.zoomable && options.zoomOnWheel) {
      $cropper.on(EVENT_WHEEL, proxy(self.wheel, this));
    }
    if (options.toggleDragModeOnDblclick) {
      $cropper.on(EVENT_DBLCLICK, proxy(self.dblclick, this));
    }
    $(document).on(EVENT_POINTER_MOVE, self.onCropMove = proxy(self.cropMove, this)).on(EVENT_POINTER_UP, self.onCropEnd = proxy(self.cropEnd, this));
    if (options.responsive) {
      $(window).on(EVENT_RESIZE, self.onResize = proxy(self.resize, this));
    }
  }, unbind:function unbind() {
    var self = this;
    var options = self.options;
    var $this = self.$element;
    var $cropper = self.$cropper;
    if ($.isFunction(options.cropstart)) {
      $this.off(EVENT_CROP_START, options.cropstart);
    }
    if ($.isFunction(options.cropmove)) {
      $this.off(EVENT_CROP_MOVE, options.cropmove);
    }
    if ($.isFunction(options.cropend)) {
      $this.off(EVENT_CROP_END, options.cropend);
    }
    if ($.isFunction(options.crop)) {
      $this.off(EVENT_CROP, options.crop);
    }
    if ($.isFunction(options.zoom)) {
      $this.off(EVENT_ZOOM, options.zoom);
    }
    $cropper.off(EVENT_POINTER_DOWN, self.cropStart);
    if (options.zoomable && options.zoomOnWheel) {
      $cropper.off(EVENT_WHEEL, self.wheel);
    }
    if (options.toggleDragModeOnDblclick) {
      $cropper.off(EVENT_DBLCLICK, self.dblclick);
    }
    $(document).off(EVENT_POINTER_MOVE, self.onCropMove).off(EVENT_POINTER_UP, self.onCropEnd);
    if (options.responsive) {
      $(window).off(EVENT_RESIZE, self.onResize);
    }
  }};
  var REGEXP_ACTIONS = /^(e|w|s|n|se|sw|ne|nw|all|crop|move|zoom)$/;
  function getPointer(_ref, endOnly) {
    var pageX = _ref.pageX, pageY = _ref.pageY;
    var end = {endX:pageX, endY:pageY};
    if (endOnly) {
      return end;
    }
    return $.extend({startX:pageX, startY:pageY}, end);
  }
  var handlers = {resize:function resize() {
    var self = this;
    var options = self.options;
    var $container = self.$container;
    var container = self.container;
    var minContainerWidth = Number(options.minContainerWidth) || 200;
    var minContainerHeight = Number(options.minContainerHeight) || 100;
    if (self.disabled || container.width === minContainerWidth || container.height === minContainerHeight) {
      return;
    }
    var ratio = $container.width() / container.width;
    if (ratio !== 1 || $container.height() !== container.height) {
      (function() {
        var canvasData = void 0;
        var cropBoxData = void 0;
        if (options.restore) {
          canvasData = self.getCanvasData();
          cropBoxData = self.getCropBoxData();
        }
        self.render();
        if (options.restore) {
          self.setCanvasData($.each(canvasData, function(i, n) {
            canvasData[i] = n * ratio;
          }));
          self.setCropBoxData($.each(cropBoxData, function(i, n) {
            cropBoxData[i] = n * ratio;
          }));
        }
      })();
    }
  }, dblclick:function dblclick() {
    var self = this;
    if (self.disabled || self.options.dragMode === "none") {
      return;
    }
    self.setDragMode(self.$dragBox.hasClass("cropper-crop") ? "move" : "crop");
  }, wheel:function wheel(event) {
    var self = this;
    var e = event.originalEvent || event;
    var ratio = Number(self.options.wheelZoomRatio) || 0.1;
    if (self.disabled) {
      return;
    }
    event.preventDefault();
    if (self.wheeling) {
      return;
    }
    self.wheeling = true;
    setTimeout(function() {
      self.wheeling = false;
    }, 50);
    var delta = 1;
    if (e.deltaY) {
      delta = e.deltaY > 0 ? 1 : -1;
    } else {
      if (e.wheelDelta) {
        delta = -e.wheelDelta / 120;
      } else {
        if (e.detail) {
          delta = e.detail > 0 ? 1 : -1;
        }
      }
    }
    self.zoom(-delta * ratio, event);
  }, cropStart:function cropStart(e) {
    var self = this;
    if (self.disabled) {
      return;
    }
    var options = self.options;
    var pointers = self.pointers;
    var originalEvent = e.originalEvent;
    var action = void 0;
    if (originalEvent && originalEvent.changedTouches) {
      $.each(originalEvent.changedTouches, function(i, touch) {
        pointers[touch.identifier] = getPointer(touch);
      });
    } else {
      pointers[originalEvent && originalEvent.pointerId || 0] = getPointer(originalEvent || e);
    }
    if (objectKeys(pointers).length > 1 && options.zoomable && options.zoomOnTouch) {
      action = "zoom";
    } else {
      action = $(e.target).data("action");
    }
    if (!REGEXP_ACTIONS.test(action)) {
      return;
    }
    if (self.trigger("cropstart", {originalEvent:originalEvent, action:action}).isDefaultPrevented()) {
      return;
    }
    e.preventDefault();
    self.action = action;
    self.cropping = false;
    if (action === "crop") {
      self.cropping = true;
      self.$dragBox.addClass("cropper-modal");
    }
  }, cropMove:function cropMove(e) {
    var self = this;
    var action = self.action;
    if (self.disabled || !action) {
      return;
    }
    var pointers = self.pointers;
    var originalEvent = e.originalEvent;
    e.preventDefault();
    if (self.trigger("cropmove", {originalEvent:originalEvent, action:action}).isDefaultPrevented()) {
      return;
    }
    if (originalEvent && originalEvent.changedTouches) {
      $.each(originalEvent.changedTouches, function(i, touch) {
        $.extend(pointers[touch.identifier], getPointer(touch, true));
      });
    } else {
      $.extend(pointers[originalEvent && originalEvent.pointerId || 0], getPointer(originalEvent || e, true));
    }
    self.change(e);
  }, cropEnd:function cropEnd(e) {
    var self = this;
    if (self.disabled) {
      return;
    }
    var action = self.action;
    var pointers = self.pointers;
    var originalEvent = e.originalEvent;
    if (originalEvent && originalEvent.changedTouches) {
      $.each(originalEvent.changedTouches, function(i, touch) {
        delete pointers[touch.identifier];
      });
    } else {
      delete pointers[originalEvent && originalEvent.pointerId || 0];
    }
    if (!action) {
      return;
    }
    e.preventDefault();
    if (!objectKeys(pointers).length) {
      self.action = "";
    }
    if (self.cropping) {
      self.cropping = false;
      self.$dragBox.toggleClass("cropper-modal", self.cropped && self.options.modal);
    }
    self.trigger("cropend", {originalEvent:originalEvent, action:action});
  }};
  var ACTION_EAST = "e";
  var ACTION_WEST = "w";
  var ACTION_SOUTH = "s";
  var ACTION_NORTH = "n";
  var ACTION_SOUTH_EAST = "se";
  var ACTION_SOUTH_WEST = "sw";
  var ACTION_NORTH_EAST = "ne";
  var ACTION_NORTH_WEST = "nw";
  function getMaxZoomRatio(pointers) {
    var pointers2 = $.extend({}, pointers);
    var ratios = [];
    $.each(pointers, function(pointerId, pointer) {
      delete pointers2[pointerId];
      $.each(pointers2, function(pointerId2, pointer2) {
        var x1 = Math.abs(pointer.startX - pointer2.startX);
        var y1 = Math.abs(pointer.startY - pointer2.startY);
        var x2 = Math.abs(pointer.endX - pointer2.endX);
        var y2 = Math.abs(pointer.endY - pointer2.endY);
        var z1 = Math.sqrt(x1 * x1 + y1 * y1);
        var z2 = Math.sqrt(x2 * x2 + y2 * y2);
        var ratio = (z2 - z1) / z1;
        ratios.push(ratio);
      });
    });
    ratios.sort(function(a, b) {
      return Math.abs(a) < Math.abs(b);
    });
    return ratios[0];
  }
  var change$1 = {change:function change(e) {
    var self = this;
    var options = self.options;
    var pointers = self.pointers;
    var pointer = pointers[objectKeys(pointers)[0]];
    var container = self.container;
    var canvas = self.canvas;
    var cropBox = self.cropBox;
    var action = self.action;
    var aspectRatio = options.aspectRatio;
    var width = cropBox.width;
    var height = cropBox.height;
    var left = cropBox.left;
    var top = cropBox.top;
    var right = left + width;
    var bottom = top + height;
    var minLeft = 0;
    var minTop = 0;
    var maxWidth = container.width;
    var maxHeight = container.height;
    var renderable = true;
    var offset = void 0;
    if (!aspectRatio && e.shiftKey) {
      aspectRatio = width && height ? width / height : 1;
    }
    if (self.limited) {
      minLeft = cropBox.minLeft;
      minTop = cropBox.minTop;
      maxWidth = minLeft + Math.min(container.width, canvas.width, canvas.left + canvas.width);
      maxHeight = minTop + Math.min(container.height, canvas.height, canvas.top + canvas.height);
    }
    var range = {x:pointer.endX - pointer.startX, y:pointer.endY - pointer.startY};
    if (aspectRatio) {
      range.X = range.y * aspectRatio;
      range.Y = range.x / aspectRatio;
    }
    switch(action) {
      case "all":
        left += range.x;
        top += range.y;
        break;
      case ACTION_EAST:
        if (range.x >= 0 && (right >= maxWidth || aspectRatio && (top <= minTop || bottom >= maxHeight))) {
          renderable = false;
          break;
        }
        width += range.x;
        if (aspectRatio) {
          height = width / aspectRatio;
          top -= range.Y / 2;
        }
        if (width < 0) {
          action = ACTION_WEST;
          width = 0;
        }
        break;
      case ACTION_NORTH:
        if (range.y <= 0 && (top <= minTop || aspectRatio && (left <= minLeft || right >= maxWidth))) {
          renderable = false;
          break;
        }
        height -= range.y;
        top += range.y;
        if (aspectRatio) {
          width = height * aspectRatio;
          left += range.X / 2;
        }
        if (height < 0) {
          action = ACTION_SOUTH;
          height = 0;
        }
        break;
      case ACTION_WEST:
        if (range.x <= 0 && (left <= minLeft || aspectRatio && (top <= minTop || bottom >= maxHeight))) {
          renderable = false;
          break;
        }
        width -= range.x;
        left += range.x;
        if (aspectRatio) {
          height = width / aspectRatio;
          top += range.Y / 2;
        }
        if (width < 0) {
          action = ACTION_EAST;
          width = 0;
        }
        break;
      case ACTION_SOUTH:
        if (range.y >= 0 && (bottom >= maxHeight || aspectRatio && (left <= minLeft || right >= maxWidth))) {
          renderable = false;
          break;
        }
        height += range.y;
        if (aspectRatio) {
          width = height * aspectRatio;
          left -= range.X / 2;
        }
        if (height < 0) {
          action = ACTION_NORTH;
          height = 0;
        }
        break;
      case ACTION_NORTH_EAST:
        if (aspectRatio) {
          if (range.y <= 0 && (top <= minTop || right >= maxWidth)) {
            renderable = false;
            break;
          }
          height -= range.y;
          top += range.y;
          width = height * aspectRatio;
        } else {
          if (range.x >= 0) {
            if (right < maxWidth) {
              width += range.x;
            } else {
              if (range.y <= 0 && top <= minTop) {
                renderable = false;
              }
            }
          } else {
            width += range.x;
          }
          if (range.y <= 0) {
            if (top > minTop) {
              height -= range.y;
              top += range.y;
            }
          } else {
            height -= range.y;
            top += range.y;
          }
        }
        if (width < 0 && height < 0) {
          action = ACTION_SOUTH_WEST;
          height = 0;
          width = 0;
        } else {
          if (width < 0) {
            action = ACTION_NORTH_WEST;
            width = 0;
          } else {
            if (height < 0) {
              action = ACTION_SOUTH_EAST;
              height = 0;
            }
          }
        }
        break;
      case ACTION_NORTH_WEST:
        if (aspectRatio) {
          if (range.y <= 0 && (top <= minTop || left <= minLeft)) {
            renderable = false;
            break;
          }
          height -= range.y;
          top += range.y;
          width = height * aspectRatio;
          left += range.X;
        } else {
          if (range.x <= 0) {
            if (left > minLeft) {
              width -= range.x;
              left += range.x;
            } else {
              if (range.y <= 0 && top <= minTop) {
                renderable = false;
              }
            }
          } else {
            width -= range.x;
            left += range.x;
          }
          if (range.y <= 0) {
            if (top > minTop) {
              height -= range.y;
              top += range.y;
            }
          } else {
            height -= range.y;
            top += range.y;
          }
        }
        if (width < 0 && height < 0) {
          action = ACTION_SOUTH_EAST;
          height = 0;
          width = 0;
        } else {
          if (width < 0) {
            action = ACTION_NORTH_EAST;
            width = 0;
          } else {
            if (height < 0) {
              action = ACTION_SOUTH_WEST;
              height = 0;
            }
          }
        }
        break;
      case ACTION_SOUTH_WEST:
        if (aspectRatio) {
          if (range.x <= 0 && (left <= minLeft || bottom >= maxHeight)) {
            renderable = false;
            break;
          }
          width -= range.x;
          left += range.x;
          height = width / aspectRatio;
        } else {
          if (range.x <= 0) {
            if (left > minLeft) {
              width -= range.x;
              left += range.x;
            } else {
              if (range.y >= 0 && bottom >= maxHeight) {
                renderable = false;
              }
            }
          } else {
            width -= range.x;
            left += range.x;
          }
          if (range.y >= 0) {
            if (bottom < maxHeight) {
              height += range.y;
            }
          } else {
            height += range.y;
          }
        }
        if (width < 0 && height < 0) {
          action = ACTION_NORTH_EAST;
          height = 0;
          width = 0;
        } else {
          if (width < 0) {
            action = ACTION_SOUTH_EAST;
            width = 0;
          } else {
            if (height < 0) {
              action = ACTION_NORTH_WEST;
              height = 0;
            }
          }
        }
        break;
      case ACTION_SOUTH_EAST:
        if (aspectRatio) {
          if (range.x >= 0 && (right >= maxWidth || bottom >= maxHeight)) {
            renderable = false;
            break;
          }
          width += range.x;
          height = width / aspectRatio;
        } else {
          if (range.x >= 0) {
            if (right < maxWidth) {
              width += range.x;
            } else {
              if (range.y >= 0 && bottom >= maxHeight) {
                renderable = false;
              }
            }
          } else {
            width += range.x;
          }
          if (range.y >= 0) {
            if (bottom < maxHeight) {
              height += range.y;
            }
          } else {
            height += range.y;
          }
        }
        if (width < 0 && height < 0) {
          action = ACTION_NORTH_WEST;
          height = 0;
          width = 0;
        } else {
          if (width < 0) {
            action = ACTION_SOUTH_WEST;
            width = 0;
          } else {
            if (height < 0) {
              action = ACTION_NORTH_EAST;
              height = 0;
            }
          }
        }
        break;
      case "move":
        self.move(range.x, range.y);
        renderable = false;
        break;
      case "zoom":
        self.zoom(getMaxZoomRatio(pointers), e.originalEvent);
        renderable = false;
        break;
      case "crop":
        if (!range.x || !range.y) {
          renderable = false;
          break;
        }
        offset = self.$cropper.offset();
        left = pointer.startX - offset.left;
        top = pointer.startY - offset.top;
        width = cropBox.minWidth;
        height = cropBox.minHeight;
        if (range.x > 0) {
          action = range.y > 0 ? ACTION_SOUTH_EAST : ACTION_NORTH_EAST;
        } else {
          if (range.x < 0) {
            left -= width;
            action = range.y > 0 ? ACTION_SOUTH_WEST : ACTION_NORTH_WEST;
          }
        }
        if (range.y < 0) {
          top -= height;
        }
        if (!self.cropped) {
          self.$cropBox.removeClass("cropper-hidden");
          self.cropped = true;
          if (self.limited) {
            self.limitCropBox(true, true);
          }
        }
        break;
    }
    if (renderable) {
      cropBox.width = width;
      cropBox.height = height;
      cropBox.left = left;
      cropBox.top = top;
      self.action = action;
      self.renderCropBox();
    }
    $.each(pointers, function(i, p) {
      p.startX = p.endX;
      p.startY = p.endY;
    });
  }};
  var classCallCheck = function(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };
  var createClass = function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) {
          descriptor.writable = true;
        }
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps) {
        defineProperties(Constructor.prototype, protoProps);
      }
      if (staticProps) {
        defineProperties(Constructor, staticProps);
      }
      return Constructor;
    };
  }();
  var get = function get(object, property, receiver) {
    if (object === null) {
      object = Function.prototype;
    }
    var desc = Object.getOwnPropertyDescriptor(object, property);
    if (desc === undefined) {
      var parent = Object.getPrototypeOf(object);
      if (parent === null) {
        return undefined;
      } else {
        return get(parent, property, receiver);
      }
    } else {
      if ("value" in desc) {
        return desc.value;
      } else {
        var getter = desc.get;
        if (getter === undefined) {
          return undefined;
        }
        return getter.call(receiver);
      }
    }
  };
  var set = function set(object, property, value, receiver) {
    var desc = Object.getOwnPropertyDescriptor(object, property);
    if (desc === undefined) {
      var parent = Object.getPrototypeOf(object);
      if (parent !== null) {
        set(parent, property, value, receiver);
      }
    } else {
      if ("value" in desc && desc.writable) {
        desc.value = value;
      } else {
        var setter = desc.set;
        if (setter !== undefined) {
          setter.call(receiver, value);
        }
      }
    }
    return value;
  };
  var toConsumableArray = function(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    } else {
      return Array.from(arr);
    }
  };
  function getPointersCenter(pointers) {
    var pageX = 0;
    var pageY = 0;
    var count = 0;
    $.each(pointers, function(i, _ref) {
      var startX = _ref.startX, startY = _ref.startY;
      pageX += startX;
      pageY += startY;
      count += 1;
    });
    pageX /= count;
    pageY /= count;
    return {pageX:pageX, pageY:pageY};
  }
  var methods = {crop:function crop() {
    var self = this;
    if (!self.ready || self.disabled) {
      return;
    }
    if (!self.cropped) {
      self.cropped = true;
      self.limitCropBox(true, true);
      if (self.options.modal) {
        self.$dragBox.addClass("cropper-modal");
      }
      self.$cropBox.removeClass("cropper-hidden");
    }
    self.setCropBoxData(self.initialCropBox);
  }, reset:function reset() {
    var self = this;
    if (!self.ready || self.disabled) {
      return;
    }
    self.image = $.extend({}, self.initialImage);
    self.canvas = $.extend({}, self.initialCanvas);
    self.cropBox = $.extend({}, self.initialCropBox);
    self.renderCanvas();
    if (self.cropped) {
      self.renderCropBox();
    }
  }, clear:function clear() {
    var self = this;
    if (!self.cropped || self.disabled) {
      return;
    }
    $.extend(self.cropBox, {left:0, top:0, width:0, height:0});
    self.cropped = false;
    self.renderCropBox();
    self.limitCanvas(true, true);
    self.renderCanvas();
    self.$dragBox.removeClass("cropper-modal");
    self.$cropBox.addClass("cropper-hidden");
  }, replace:function replace(url, onlyColorChanged) {
    var self = this;
    if (!self.disabled && url) {
      if (self.isImg) {
        self.$element.attr("src", url);
      }
      if (onlyColorChanged) {
        self.url = url;
        self.$clone.attr("src", url);
        if (self.ready) {
          self.$preview.find("img").add(self.$clone2).attr("src", url);
        }
      } else {
        if (self.isImg) {
          self.replaced = true;
        }
        self.options.data = null;
        self.load(url);
      }
    }
  }, enable:function enable() {
    var self = this;
    if (self.ready) {
      self.disabled = false;
      self.$cropper.removeClass("cropper-disabled");
    }
  }, disable:function disable() {
    var self = this;
    if (self.ready) {
      self.disabled = true;
      self.$cropper.addClass("cropper-disabled");
    }
  }, destroy:function destroy() {
    var self = this;
    var $this = self.$element;
    if (self.loaded) {
      if (self.isImg && self.replaced) {
        $this.attr("src", self.originalUrl);
      }
      self.unbuild();
      $this.removeClass("cropper-hidden");
    } else {
      if (self.isImg) {
        $this.off("load", self.start);
      } else {
        if (self.$clone) {
          self.$clone.remove();
        }
      }
    }
    $this.removeData("cropper");
  }, move:function move(offsetX, offsetY) {
    var self = this;
    var canvas = self.canvas;
    self.moveTo(isUndefined(offsetX) ? offsetX : canvas.left + Number(offsetX), isUndefined(offsetY) ? offsetY : canvas.top + Number(offsetY));
  }, moveTo:function moveTo(x, y) {
    var self = this;
    var canvas = self.canvas;
    var changed = false;
    if (isUndefined(y)) {
      y = x;
    }
    x = Number(x);
    y = Number(y);
    if (self.ready && !self.disabled && self.options.movable) {
      if (isNumber(x)) {
        canvas.left = x;
        changed = true;
      }
      if (isNumber(y)) {
        canvas.top = y;
        changed = true;
      }
      if (changed) {
        self.renderCanvas(true);
      }
    }
  }, zoom:function zoom(ratio, _event) {
    var self = this;
    var canvas = self.canvas;
    ratio = Number(ratio);
    if (ratio < 0) {
      ratio = 1 / (1 - ratio);
    } else {
      ratio = 1 + ratio;
    }
    self.zoomTo(canvas.width * ratio / canvas.naturalWidth, _event);
  }, zoomTo:function zoomTo(ratio, _event) {
    var self = this;
    var options = self.options;
    var pointers = self.pointers;
    var canvas = self.canvas;
    var width = canvas.width;
    var height = canvas.height;
    var naturalWidth = canvas.naturalWidth;
    var naturalHeight = canvas.naturalHeight;
    ratio = Number(ratio);
    console.log("ratio:", ratio);
    if (ratio >= 0 && self.ready && !self.disabled && options.zoomable) {
      var newWidth = naturalWidth * ratio;
      var newHeight = naturalHeight * ratio;
      var originalEvent = void 0;
      if (_event) {
        originalEvent = _event.originalEvent;
      }
      if (self.trigger("zoom", {originalEvent:originalEvent, oldRatio:width / naturalWidth, ratio:newWidth / naturalWidth}).isDefaultPrevented()) {
        return;
      }
      if (originalEvent) {
        var offset = self.$cropper.offset();
        var center = pointers && objectKeys(pointers).length ? getPointersCenter(pointers) : {pageX:_event.pageX || originalEvent.pageX || 0, pageY:_event.pageY || originalEvent.pageY || 0};
        canvas.left -= (newWidth - width) * ((center.pageX - offset.left - canvas.left) / width);
        canvas.top -= (newHeight - height) * ((center.pageY - offset.top - canvas.top) / height);
      } else {
        canvas.left -= (newWidth - width) / 2;
        canvas.top -= (newHeight - height) / 2;
      }
      canvas.width = newWidth;
      canvas.height = newHeight;
      self.renderCanvas(true);
    }
  }, rotate:function rotate(degree) {
    var self = this;
    self.rotateTo((self.image.rotate || 0) + Number(degree));
  }, rotateTo:function rotateTo(degree) {
    var self = this;
    degree = Number(degree);
    if (isNumber(degree) && self.ready && !self.disabled && self.options.rotatable) {
      self.image.rotate = degree % 360;
      self.rotated = true;
      self.renderCanvas(true);
    }
  }, scale:function scale(scaleX, scaleY) {
    var self = this;
    var image = self.image;
    var changed = false;
    if (isUndefined(scaleY)) {
      scaleY = scaleX;
    }
    scaleX = Number(scaleX);
    scaleY = Number(scaleY);
    if (self.ready && !self.disabled && self.options.scalable) {
      if (isNumber(scaleX)) {
        image.scaleX = scaleX;
        changed = true;
      }
      if (isNumber(scaleY)) {
        image.scaleY = scaleY;
        changed = true;
      }
      if (changed) {
        self.renderImage(true);
      }
    }
  }, scaleX:function scaleX(_scaleX) {
    var self = this;
    var scaleY = self.image.scaleY;
    self.scale(_scaleX, isNumber(scaleY) ? scaleY : 1);
  }, scaleY:function scaleY(_scaleY) {
    var self = this;
    var scaleX = self.image.scaleX;
    self.scale(isNumber(scaleX) ? scaleX : 1, _scaleY);
  }, getData:function getData(isRounded) {
    var self = this;
    var options = self.options;
    var image = self.image;
    var canvas = self.canvas;
    var cropBox = self.cropBox;
    var ratio = void 0;
    var data = void 0;
    if (self.ready && self.cropped) {
      data = {x:cropBox.left - canvas.left, y:cropBox.top - canvas.top, width:cropBox.width, height:cropBox.height};
      ratio = image.width / image.naturalWidth;
      $.each(data, function(i, n) {
        n /= ratio;
        data[i] = isRounded ? Math.round(n) : n;
      });
    } else {
      data = {x:0, y:0, width:0, height:0};
    }
    if (options.rotatable) {
      data.rotate = image.rotate || 0;
    }
    if (options.scalable) {
      data.scaleX = image.scaleX || 1;
      data.scaleY = image.scaleY || 1;
    }
    return data;
  }, setData:function setData(data) {
    var self = this;
    var options = self.options;
    var image = self.image;
    var canvas = self.canvas;
    var cropBoxData = {};
    var rotated = void 0;
    var isScaled = void 0;
    var ratio = void 0;
    if ($.isFunction(data)) {
      data = data.call(self.element);
    }
    if (self.ready && !self.disabled && $.isPlainObject(data)) {
      if (options.rotatable) {
        if (isNumber(data.rotate) && data.rotate !== image.rotate) {
          image.rotate = data.rotate;
          self.rotated = rotated = true;
        }
      }
      if (options.scalable) {
        if (isNumber(data.scaleX) && data.scaleX !== image.scaleX) {
          image.scaleX = data.scaleX;
          isScaled = true;
        }
        if (isNumber(data.scaleY) && data.scaleY !== image.scaleY) {
          image.scaleY = data.scaleY;
          isScaled = true;
        }
      }
      if (rotated) {
        self.renderCanvas();
      } else {
        if (isScaled) {
          self.renderImage();
        }
      }
      ratio = image.width / image.naturalWidth;
      if (isNumber(data.x)) {
        cropBoxData.left = data.x * ratio + canvas.left;
      }
      if (isNumber(data.y)) {
        cropBoxData.top = data.y * ratio + canvas.top;
      }
      if (isNumber(data.width)) {
        cropBoxData.width = data.width * ratio;
      }
      if (isNumber(data.height)) {
        cropBoxData.height = data.height * ratio;
      }
      self.setCropBoxData(cropBoxData);
    }
  }, getContainerData:function getContainerData() {
    return this.ready ? this.container : {};
  }, getImageData:function getImageData() {
    return this.loaded ? this.image : {};
  }, getCanvasData:function getCanvasData() {
    var self = this;
    var canvas = self.canvas;
    var data = {};
    if (self.ready) {
      $.each(["left", "top", "width", "height", "naturalWidth", "naturalHeight"], function(i, n) {
        data[n] = canvas[n];
      });
    }
    return data;
  }, setCanvasData:function setCanvasData(data) {
    var self = this;
    var canvas = self.canvas;
    var aspectRatio = canvas.aspectRatio;
    if ($.isFunction(data)) {
      data = data.call(self.$element);
    }
    if (self.ready && !self.disabled && $.isPlainObject(data)) {
      if (isNumber(data.left)) {
        canvas.left = data.left;
      }
      if (isNumber(data.top)) {
        canvas.top = data.top;
      }
      if (isNumber(data.width)) {
        canvas.width = data.width;
        canvas.height = data.width / aspectRatio;
      } else {
        if (isNumber(data.height)) {
          canvas.height = data.height;
          canvas.width = data.height * aspectRatio;
        }
      }
      self.renderCanvas(true);
    }
  }, getCropBoxData:function getCropBoxData() {
    var self = this;
    var cropBox = self.cropBox;
    console.log("getCropBoxData(" + self.ready + "," + self.cropped + "):", cropBox);
    return self.ready && self.cropped ? {left:cropBox.left, top:cropBox.top, width:cropBox.width, height:cropBox.height} : {};
  }, setCropBoxData:function setCropBoxData(data) {
    var self = this;
    var cropBox = self.cropBox;
    var aspectRatio = self.options.aspectRatio;
    var widthChanged = void 0;
    var heightChanged = void 0;
    if ($.isFunction(data)) {
      data = data.call(self.$element);
    }
    if (self.ready && self.cropped && !self.disabled && $.isPlainObject(data)) {
      if (isNumber(data.left)) {
        cropBox.left = data.left;
      }
      if (isNumber(data.top)) {
        cropBox.top = data.top;
      }
      if (isNumber(data.width) && data.width !== cropBox.width) {
        widthChanged = true;
        cropBox.width = data.width;
      }
      if (isNumber(data.height) && data.height !== cropBox.height) {
        heightChanged = true;
        cropBox.height = data.height;
      }
      if (aspectRatio) {
        if (widthChanged) {
          cropBox.height = cropBox.width / aspectRatio;
        } else {
          if (heightChanged) {
            cropBox.width = cropBox.height * aspectRatio;
          }
        }
      }
      self.renderCropBox();
    }
  }, getCroppedCanvas:function getCroppedCanvas(options) {
    var self = this;
    if (!self.ready || !window.HTMLCanvasElement) {
      return null;
    }
    if (!$.isPlainObject(options)) {
      options = {};
    }
    if (!self.cropped) {
      return getSourceCanvas(self.$clone[0], self.image, options);
    }
    var data = self.getData();
    var originalWidth = data.width;
    var originalHeight = data.height;
    var aspectRatio = originalWidth / originalHeight;
    var scaledWidth = void 0;
    var scaledHeight = void 0;
    var scaledRatio = void 0;
    if ($.isPlainObject(options)) {
      scaledWidth = options.width;
      scaledHeight = options.height;
      if (scaledWidth) {
        scaledHeight = scaledWidth / aspectRatio;
        scaledRatio = scaledWidth / originalWidth;
      } else {
        if (scaledHeight) {
          scaledWidth = scaledHeight * aspectRatio;
          scaledRatio = scaledHeight / originalHeight;
        }
      }
    }
    var canvasWidth = Math.floor(scaledWidth || originalWidth);
    var canvasHeight = Math.floor(scaledHeight || originalHeight);
    var canvas = $("<canvas>")[0];
    var context = canvas.getContext("2d");
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;
    if (options.fillColor) {
      context.fillStyle = options.fillColor;
      context.fillRect(0, 0, canvasWidth, canvasHeight);
    }
    var parameters = function() {
      var source = getSourceCanvas(self.$clone[0], self.image, options);
      var sourceWidth = source.width;
      var sourceHeight = source.height;
      var canvasData = self.canvas;
      var params = [source];
      var srcX = data.x + canvasData.naturalWidth * (Math.abs(data.scaleX || 1) - 1) / 2;
      var srcY = data.y + canvasData.naturalHeight * (Math.abs(data.scaleY || 1) - 1) / 2;
      var srcWidth = void 0;
      var srcHeight = void 0;
      var dstX = void 0;
      var dstY = void 0;
      var dstWidth = void 0;
      var dstHeight = void 0;
      if (srcX <= -originalWidth || srcX > sourceWidth) {
        srcX = srcWidth = dstX = dstWidth = 0;
      } else {
        if (srcX <= 0) {
          dstX = -srcX;
          srcX = 0;
          srcWidth = dstWidth = Math.min(sourceWidth, originalWidth + srcX);
        } else {
          if (srcX <= sourceWidth) {
            dstX = 0;
            srcWidth = dstWidth = Math.min(originalWidth, sourceWidth - srcX);
          }
        }
      }
      if (srcWidth <= 0 || srcY <= -originalHeight || srcY > sourceHeight) {
        srcY = srcHeight = dstY = dstHeight = 0;
      } else {
        if (srcY <= 0) {
          dstY = -srcY;
          srcY = 0;
          srcHeight = dstHeight = Math.min(sourceHeight, originalHeight + srcY);
        } else {
          if (srcY <= sourceHeight) {
            dstY = 0;
            srcHeight = dstHeight = Math.min(originalHeight, sourceHeight - srcY);
          }
        }
      }
      params.push(Math.floor(srcX), Math.floor(srcY), Math.floor(srcWidth), Math.floor(srcHeight));
      if (scaledRatio) {
        dstX *= scaledRatio;
        dstY *= scaledRatio;
        dstWidth *= scaledRatio;
        dstHeight *= scaledRatio;
      }
      if (dstWidth > 0 && dstHeight > 0) {
        params.push(Math.floor(dstX), Math.floor(dstY), Math.floor(dstWidth), Math.floor(dstHeight));
      }
      return params;
    }();
    context.imageSmoothingEnabled = !!options.imageSmoothingEnabled;
    if (options.imageSmoothingQuality) {
      context.imageSmoothingQuality = options.imageSmoothingQuality;
    }
    context.drawImage.apply(context, toConsumableArray(parameters));
    return canvas;
  }, setAspectRatio:function setAspectRatio(aspectRatio) {
    var self = this;
    var options = self.options;
    if (!self.disabled && !isUndefined(aspectRatio)) {
      options.aspectRatio = Math.max(0, aspectRatio) || NaN;
      if (self.ready) {
        self.initCropBox();
        if (self.cropped) {
          self.renderCropBox();
        }
      }
    }
  }, setDragMode:function setDragMode(mode) {
    var self = this;
    var options = self.options;
    var croppable = void 0;
    var movable = void 0;
    if (self.loaded && !self.disabled) {
      croppable = mode === "crop";
      movable = options.movable && mode === "move";
      mode = croppable || movable ? mode : "none";
      self.$dragBox.data("action", mode).toggleClass("cropper-crop", croppable).toggleClass("cropper-move", movable);
      if (!options.cropBoxMovable) {
        self.$face.data("action", mode).toggleClass("cropper-crop", croppable).toggleClass("cropper-move", movable);
      }
    }
  }};
  var CLASS_HIDDEN = "cropper-hidden";
  var REGEXP_DATA_URL = /^data:/;
  var REGEXP_DATA_URL_JPEG = /^data:image\/jpeg;base64,/;
  var Cropper = function() {
    function Cropper(element, options) {
      classCallCheck(this, Cropper);
      var self = this;
      self.$element = $(element);
      self.options = $.extend({}, DEFAULTS, $.isPlainObject(options) && options);
      self.loaded = false;
      self.ready = false;
      self.completed = false;
      self.rotated = false;
      self.cropped = false;
      self.disabled = false;
      self.replaced = false;
      self.limited = false;
      self.wheeling = false;
      self.isImg = false;
      self.originalUrl = "";
      self.canvas = null;
      self.cropBox = null;
      self.pointers = {};
      self.init();
    }
    createClass(Cropper, [{key:"init", value:function init() {
      var self = this;
      var $this = self.$element;
      var url = void 0;
      if ($this.is("img")) {
        self.isImg = true;
        self.originalUrl = url = $this.attr("src");
        if (!url) {
          return;
        }
        url = $this.prop("src");
      } else {
        if ($this.is("canvas") && window.HTMLCanvasElement) {
          url = $this[0].toDataURL();
        }
      }
      self.load(url);
    }}, {key:"trigger", value:function trigger(type, data) {
      var e = $.Event(type, data);
      this.$element.trigger(e);
      return e;
    }}, {key:"load", value:function load(url) {
      var self = this;
      var options = self.options;
      var $this = self.$element;
      if (!url) {
        return;
      }
      self.url = url;
      self.image = {};
      if (!options.checkOrientation || !window.ArrayBuffer) {
        self.clone();
        return;
      }
      if (REGEXP_DATA_URL.test(url)) {
        if (REGEXP_DATA_URL_JPEG.test(url)) {
          self.read(dataURLToArrayBuffer(url));
        } else {
          self.clone();
        }
        return;
      }
      var xhr = new XMLHttpRequest;
      xhr.onerror = xhr.onabort = $.proxy(function() {
        self.clone();
      }, this);
      xhr.onload = function load() {
        self.read(this.response);
      };
      if (options.checkCrossOrigin && isCrossOriginURL(url) && $this.prop("crossOrigin")) {
        url = addTimestamp(url);
      }
      xhr.open("get", url);
      xhr.responseType = "arraybuffer";
      xhr.withCredentials = $this.prop("crossOrigin") === "use-credentials";
      xhr.send();
    }}, {key:"read", value:function read(arrayBuffer) {
      var self = this;
      var options = self.options;
      var orientation = getOrientation(arrayBuffer);
      var image = self.image;
      var rotate = 0;
      var scaleX = 1;
      var scaleY = 1;
      if (orientation > 1) {
        self.url = arrayBufferToDataURL(arrayBuffer);
        switch(orientation) {
          case 2:
            scaleX = -1;
            break;
          case 3:
            rotate = -180;
            break;
          case 4:
            scaleY = -1;
            break;
          case 5:
            rotate = 90;
            scaleY = -1;
            break;
          case 6:
            rotate = 90;
            break;
          case 7:
            rotate = 90;
            scaleX = -1;
            break;
          case 8:
            rotate = -90;
            break;
        }
      }
      if (options.rotatable) {
        image.rotate = rotate;
      }
      if (options.scalable) {
        image.scaleX = scaleX;
        image.scaleY = scaleY;
      }
      self.clone();
    }}, {key:"clone", value:function clone() {
      var self = this;
      var options = self.options;
      var $this = self.$element;
      var url = self.url;
      var crossOrigin = "";
      var crossOriginUrl = void 0;
      if (options.checkCrossOrigin && isCrossOriginURL(url)) {
        crossOrigin = $this.prop("crossOrigin");
        if (crossOrigin) {
          crossOriginUrl = url;
        } else {
          crossOrigin = "anonymous";
          crossOriginUrl = addTimestamp(url);
        }
      }
      self.crossOrigin = crossOrigin;
      self.crossOriginUrl = crossOriginUrl;
      var image = document.createElement("img");
      if (crossOrigin) {
        image.crossOrigin = crossOrigin;
      }
      image.src = crossOriginUrl || url;
      var $clone = $(image);
      self.$clone = $clone;
      if (self.isImg) {
        if ($this[0].complete) {
          self.start();
        } else {
          $this.one("load", $.proxy(self.start, this));
        }
      } else {
        $clone.one("load", $.proxy(self.start, this)).one("error", $.proxy(self.stop, this)).addClass("cropper-hide").insertAfter($this);
      }
    }}, {key:"start", value:function start() {
      var self = this;
      var $clone = self.$clone;
      var $image = self.$element;
      if (!self.isImg) {
        $clone.off("error", self.stop);
        $image = $clone;
      }
      getImageSize($image[0], function(naturalWidth, naturalHeight) {
        $.extend(self.image, {naturalWidth:naturalWidth, naturalHeight:naturalHeight, aspectRatio:naturalWidth / naturalHeight});
        self.loaded = true;
        self.build();
      });
    }}, {key:"stop", value:function stop() {
      var self = this;
      self.$clone.remove();
      self.$clone = null;
    }}, {key:"build", value:function build() {
      var self = this;
      var options = self.options;
      var $this = self.$element;
      var $clone = self.$clone;
      var $cropper = void 0;
      var $cropBox = void 0;
      var $face = void 0;
      if (!self.loaded) {
        return;
      }
      if (self.ready) {
        self.unbuild();
      }
      self.$container = $this.parent();
      self.$cropper = $cropper = $(TEMPLATE);
      self.$canvas = $cropper.find(".cropper-canvas").append($clone);
      self.$dragBox = $cropper.find(".cropper-drag-box");
      self.$cropBox = $cropBox = $cropper.find(".cropper-crop-box");
      self.$viewBox = $cropper.find(".cropper-view-box");
      self.$face = $face = $cropBox.find(".cropper-face");
      $this.addClass(CLASS_HIDDEN).after($cropper);
      if (!self.isImg) {
        $clone.removeClass("cropper-hide");
      }
      self.initPreview();
      self.bind();
      options.aspectRatio = Math.max(0, options.aspectRatio) || NaN;
      options.viewMode = Math.max(0, Math.min(3, Math.round(options.viewMode))) || 0;
      self.cropped = options.autoCrop;
      if (options.autoCrop) {
        if (options.modal) {
          self.$dragBox.addClass("cropper-modal");
        }
      } else {
        $cropBox.addClass(CLASS_HIDDEN);
      }
      if (!options.guides) {
        $cropBox.find(".cropper-dashed").addClass(CLASS_HIDDEN);
      }
      if (!options.center) {
        $cropBox.find(".cropper-center").addClass(CLASS_HIDDEN);
      }
      if (options.cropBoxMovable) {
        $face.addClass("cropper-move").data("action", "all");
      }
      if (!options.highlight) {
        $face.addClass("cropper-invisible");
      }
      if (options.background) {
        $cropper.addClass("cropper-bg");
      }
      if (!options.cropBoxResizable) {
        $cropBox.find(".cropper-line, .cropper-point").addClass(CLASS_HIDDEN);
      }
      self.setDragMode(options.dragMode);
      self.render();
      self.ready = true;
      self.setData(options.data);
      self.completing = setTimeout(function() {
        if ($.isFunction(options.ready)) {
          $this.one("ready", options.ready);
        }
        self.trigger("ready");
        self.trigger("crop", self.getData());
        self.completed = true;
      }, 0);
    }}, {key:"unbuild", value:function unbuild() {
      var self = this;
      if (!self.ready) {
        return;
      }
      if (!self.completed) {
        clearTimeout(self.completing);
      }
      self.ready = false;
      self.completed = false;
      self.initialImage = null;
      self.initialCanvas = null;
      self.initialCropBox = null;
      self.container = null;
      self.canvas = null;
      self.cropBox = null;
      self.unbind();
      self.resetPreview();
      self.$preview = null;
      self.$viewBox = null;
      self.$cropBox = null;
      self.$dragBox = null;
      self.$canvas = null;
      self.$container = null;
      self.$cropper.remove();
      self.$cropper = null;
    }}], [{key:"setDefaults", value:function setDefaults(options) {
      $.extend(DEFAULTS, $.isPlainObject(options) && options);
    }}]);
    return Cropper;
  }();
  $.extend(Cropper.prototype, render$1);
  $.extend(Cropper.prototype, preview$1);
  $.extend(Cropper.prototype, events);
  $.extend(Cropper.prototype, handlers);
  $.extend(Cropper.prototype, change$1);
  $.extend(Cropper.prototype, methods);
  var NAMESPACE = "cropper";
  var OtherCropper = $.fn.cropper;
  $.fn.cropper = function jQueryCropper(option) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    var result = void 0;
    this.each(function(i, element) {
      var $this = $(element);
      var data = $this.data(NAMESPACE);
      if (!data) {
        if (/destroy/.test(option)) {
          return;
        }
        var options = $.extend({}, $this.data(), $.isPlainObject(option) && option);
        $this.data(NAMESPACE, data = new Cropper(element, options));
      }
      if (typeof option === "string") {
        var fn = data[option];
        if ($.isFunction(fn)) {
          result = fn.apply(data, args);
        }
      }
    });
    return typeof result !== "undefined" ? result : this;
  };
  $.fn.cropper.Constructor = Cropper;
  $.fn.cropper.setDefaults = Cropper.setDefaults;
  $.fn.cropper.noConflict = function noConflict() {
    $.fn.cropper = OtherCropper;
    return this;
  };
});
Polymer({is:"simpl-cropper", properties:{mainTabId:{type:String, value:"0"}, options:{type:String}}, observers:[], behaviors:[TranslationsBehavior, StyleScopeBehavior], attached:function() {
  if (this.atta) {
    return;
  }
  this.atta = true;
  this.hasImage = false;
  this.dataHeight = 0;
  this.dataWidth = 0;
  this.formData = {};
  this.image = $(this.$.image);
  this.image.cropper({viewMode:0, movable:true, zoomable:true, rotatable:false, scalable:true, responsive:false, ready:function(e) {
    this.fire("cropper-ready", {event:e, fileId:this.currentFileId});
  }.bind(this), crop:function(e) {
    this.dataHeight = Math.round(e.height);
    this.dataWidth = Math.round(e.width);
  }.bind(this)});
}, reset:function() {
  this.image.cropper("destroy");
  this.mainTabId = "0";
  this.formData = {};
}, getImage:function() {
  return this.image;
}, setCurrentFileId:function(fid) {
  this.currentFileId = fid;
}, gotoEditTab:function() {
  if (this.currentFileId) {
    this.mainTabId = "1";
  }
}, replaceImage:function(fileId, file) {
  console.log("replaceImage:", fileId);
  this.mainTabId = "1";
  this.image.cropper("replace", file);
  this.currentFileId = fileId;
  this.hasImage = true;
}, getDimension:function() {
  return "h:" + this.dataHeight + " w:" + this.dataWidth;
}, onUploadValueChanged:function(e) {
  var data = this.$.uploadFormId.getData();
  console.log("onUploadValueChanged:", data.uploadId);
  this.mainTabId = "1";
  var key = Object.keys(data.uploadId)[0];
  this.image.cropper("replace", data.uploadId[key]);
  this.currentFileId = key;
  this.hasImage = true;
}, mainTabSelected:function() {
}, onTapReset:function() {
  var result = this.image.cropper("reset");
}, onTapZoomIn:function() {
  var result = this.image.cropper("zoom", "0.1");
}, onTapZoomOut:function() {
  var result = this.image.cropper("zoom", "-0.1");
}, onTapZoomTo:function() {
  var result = this.image.cropper("zoomTo", "0.01");
}, onTapMoveLeft:function() {
  var result = this.image.cropper("move", "-10", "0");
}, onTapMoveRight:function() {
  var result = this.image.cropper("move", "10", "0");
}, onTapMoveUp:function() {
  var result = this.image.cropper("move", "0", "-10");
}, onTapMoveDown:function() {
  var result = this.image.cropper("move", "0", "10");
}, onTapMoveTo0:function() {
  var result = this.image.cropper("moveTo", "0", "0");
}, onTapPreview:function() {
  this.mainTabId = "2";
  var result = this.image.cropper("getCroppedCanvas");
  $(this.$.preview).html(result);
}, ready:function() {
}});
Polymer({is:"simpl-dispatcher", properties:{selected:{observer:"selectedChanged", type:String}}, ready:function() {
  this.nodes = this._getMenuYaml();
}, getNodes:function() {
  return this.nodes;
}, attached:function() {
  this.async(function() {
    this.initListener();
  });
}, initListener:function() {
  var menuEntries = document.querySelectorAll("a.menuentry");
  for (var i = 0; i < menuEntries.length; i++) {
    var a = menuEntries[i];
    $(menuEntries[i]).tap(this.tapListener.bind(this), false);
  }
  if (this.selected) {
    var self = this;
    setTimeout(function() {
      self.selectMenuItem(self.selected);
    }, 300);
  }
}, tapListener:function(e) {
  var target = e.target;
  if (target.params) {
    $("#mainContainer").animate({scrollTop:$(target.params.id).offset().top}, 1000);
    return;
  }
  var page = e.target.page;
  if (!page) {
    return;
  }
  if (this._selectedPage) {
    this.fire("menu-selected", {isSelected:false, page:this._selectedPage});
  }
  var prevPage = this._selectedPage;
  this._selectedPage = page;
  this.fire("menu-selected", {isSelected:true, prevPage:prevPage, page:this._selectedPage});
  this.selected = page.hash;
}, getPageByHash:function(hash) {
  if (hash && hash.startsWith("!")) {
    return null;
  }
  var e = document.querySelector("#hash_" + hash);
  return e ? e.page : null;
}, getActivePage:function() {
  return this._selectedPage;
}, selectMenuItem:function(hash) {
  var page = this.getPageByHash(hash);
  if (page != null) {
    page.provider.setSelected(page);
  }
}, selectedChanged:function(e) {
  if (this._selectedPage == null || this.selected != this._selectedPage.hash) {
    var page = this.getPageByHash(this.selected);
    if (page) {
      var prevPage = this._selectedPage;
      this._selectedPage = page;
      this.fire("menu-selected", {isSelected:true, prevPage:prevPage, page:this._selectedPage});
    }
  }
  this.selectMenuItem(this.selected);
}, filterLocalLinks:function(e) {
  if (!e.querySelectorAll) {
    return;
  }
  var aList = e.querySelectorAll("a");
  for (var i = 0; i < aList.length; i++) {
    var a = aList[i];
    var href = a.getAttribute("href");
    if (href && href.match(/^local.*/)) {
      var page = this.getPageByHash(href.substring("local:".length));
      if (page) {
        a.removeAttribute("href");
        a.page = page;
        a.element = a;
        $(a).tap(this.tapListener.bind(this), false);
      }
    } else {
      if (href && href.startsWith("#_")) {
        a.removeAttribute("href");
        a.params = {id:href};
        $(a).tap(this.tapListener.bind(this), false);
      }
    }
  }
}, _traverse:function(parents, nodes, pages) {
  for (var i = 0; i < nodes.length; i++) {
    var node = nodes[i];
    if (node.uri && node.uri.startsWith("structure:")) {
      node.children = this._loadMenu(node.uri.substring(10));
      node.uri = null;
    }
    var name = node.name || node.title;
    if (name) {
      node.name = tr(name);
    }
    if (_.isEmpty(node.icon)) {
      node.icon = "av:web-asset";
    }
    if (_.isEmpty(node.hash)) {
      node.hash = node.id;
    }
    if (_.isEmpty(node.hash) && name) {
      node.hash = name.toLowerCase().replace(/[^a-z0-9_]/g, "-");
    }
    var hash = base = node.hash;
    var x = 0;
    while (this._hashExists(pages, hash)) {
      hash = base + x;
      x++;
    }
    if (x > 0 && node.uri) {
      node.hash = hash;
      var hasQuery = node.uri.indexOf("?") >= 0;
      node.uri += (hasQuery ? "&" : "?") + "dummy=" + i;
    }
    node.url = node.uri || node.url;
    if (node.url && node.url.indexOf("%l") != -1) {
      node.url = node.url.replace("%l", simpl4Globals.get("lang"));
    }
    node.disabled = node.disabled === true || node.enabled === false;
    if (!node.disabled) {
      var path = _.map(parents, function(e) {
        return tr(e.title);
      }).join("/");
      node.path = _.isEmpty(path) ? tr(node.name) : path + "/" + tr(node.name);
      if (node.children && node.children.length > 0) {
        pages.push(node);
        var n = clone(node);
        n.children = null;
        parents.push(n);
        this._traverse(parents, node.children, pages);
        parents.pop();
      } else {
        pages.push(node);
      }
    }
  }
}, _loadMenu:function(name) {
  var nodes = null;
  var url = name;
  var namespace = null;
  var base = null;
  if (name.indexOf(":") >= 0) {
    namespace = name.split(":")[0];
    simpl4.util.MessageManager.installMessages(namespace);
    name = name.split(":")[1];
    var loc = window.location;
    base = loc.origin + "/repo/" + namespace;
    url = base + "/" + name;
  }
  if (!name.endsWith(".json") && !name.endsWith(".yaml")) {
    url += ".json";
  }
  console.log("_loadMenu.url:", url);
  nodes = jQuery.ajax({url:url, async:false, error:function() {
    console.log(name + ".json not found.");
  }, dataType:"json"}).responseText;
  url = name;
  if (!name.endsWith(".json") && !name.endsWith(".yaml")) {
    url += ".yaml";
  }
  console.log("_loadMenu2:", url);
  if (_.isEmpty(nodes)) {
    nodes = jQuery.ajax({url:url, async:false, error:function() {
      console.log(name + ".yaml not found.");
    }, dataType:"json"}).responseText;
  }
  try {
    nodes = JSON.parse(nodes);
  } catch (e) {
    alert("Error.Read Menu:" + e);
    console.error("Error.Read Menu:", e);
    return;
  }
  if (base != null) {
    for (var i = 0; i < nodes.length; i++) {
      this._insertBase(nodes[i], base);
    }
  }
  return nodes;
}, _insertBase:function(node, base) {
  if (node.uri && node.uri != "") {
    node.uri = base + "/" + node.uri;
  }
  if (node.children) {
    for (var i = 0; i < node.children.length; i++) {
      this._insertBase(node.children[i], base);
    }
  }
}, _hashExists:function(pages, hash) {
  for (var p = 0; p < pages.length; p++) {
    if (pages[p].hash == hash) {
      return true;
    }
  }
  return false;
}, _getMenuYaml:function() {
  if (this.name == null) {
    return [];
  }
  var nodes = this._loadMenu(this.name);
  var pages = [];
  if (nodes.length > 0) {
    nodes[0].hash = "0";
  }
  this._traverse([], nodes, pages);
  return nodes;
}});
Polymer({is:"simpl-rpc", properties:{_allparams:{computed:"_collectAll(method,service,params)"}, service:{type:String, value:"simpl4"}, method:{type:String}, params:{type:Object, value:null}, noauto:{type:Boolean, value:false}, response:{type:Object, notify:true}}, _collectAll:function() {
  if (this.noauto === true) {
    return;
  }
  this.async(function() {
    this.go();
  }, null, 30);
}, ready:function() {
  this.request_id = 1;
  this.xhr = document.createElement("simpl-xhr");
}, _receive:function(response, xhr) {
  if (this._isSuccess(xhr)) {
    var resp = this._evalResponse(xhr);
    console.log("rpc.receive(" + this.method + "):", resp);
    if (resp.error) {
      this._error2(resp.error, xhr);
    } else {
      this._processResponse(resp.result, xhr);
    }
  } else {
    this._error(xhr);
  }
  this._complete(xhr);
}, _isSuccess:function(xhr) {
  var status = xhr.status || 0;
  return !status || status >= 200 && status < 300;
}, _processResponse:function(result, xhr) {
  this.response = result;
  this.fire("response", {response:result, xhr:xhr});
}, _error:function(xhr) {
  var response = xhr.status + ": " + xhr.responseText;
  this.fire("error", {response:response, xhr:xhr});
}, _error2:function(error, xhr) {
  this.fire("error", {error:error, xhr:xhr});
}, _complete:function(xhr) {
  this.fire("complete", {response:xhr.status, xhr:xhr});
}, _evalResponse:function(xhr) {
  var r = xhr.responseText;
  try {
    var response = JSON.parse(r);
    return response;
  } catch (x) {
    return r;
  }
}, _getId:function() {
  return this.request_id++;
}, go:function() {
  console.log("rpc.go:", this.method + "/", this.params);
  var params = simpl4.util.Merge.clone(this.params);
  var args = this.xhrArgs || {};
  args.headers = this.headers || {};
  if (args.headers && typeof args.headers == "string") {
    args.headers = JSON5.parse(args.headers);
  }
  args.headers["Content-Type"] = "application/json";
  var username = simpl4.util.Rpc._getUserName();
  var password = simpl4.util.Rpc._getPassword();
  args.headers["Authorization"] = "Basic " + simpl4.util.Base64.encode(username + ":" + password);
  args.callback = this._receive.bind(this);
  args.url = simpl4.util.BaseManager.getBaseUrl() + "/rpc/xyz";
  args.method = "POST";
  var body = {jsonrpc:"2.0", method:this.method, service:this.service, id:this._getId()};
  if (params && typeof params == "string") {
    body.params = JSON5.parse(params);
  } else {
    body.params = params || {};
  }
  if (body.params.namespace && body.params.namespace == "default" || this.service == "camelRoute" || this.service.startsWith("simpl4")) {
    body.params.namespace = simpl4.util.BaseManager.getNamespace();
  }
  args.body = JSON.stringify(body, null, 2);
  if (this.xhr == null) {
    this.xhr = document.createElement("simpl-xhr");
  }
  return this.xhr.request(args);
}});
Polymer({is:"font-awesome", properties:{icon:{type:String}}, observers:["iconChanged(icon)"], iconChanged:function() {
  Polymer.dom(this.$.fontId).classList.add("fa");
  Polymer.dom(this.$.fontId).classList.add("fa-" + this.icon);
}});
LobiboxBehavior = {notify:function(msg, type, delay) {
  var icon = "vaadin-icons:info-circle-o";
  if (type == "success") {
    icon = "vaadin-icons:check-circle-o";
  } else {
    if (type == "warning") {
      icon = "vaadin-icons:warning";
    } else {
      if (type == "error") {
        icon = "vaadin-icons:exclamation";
      }
    }
  }
  Lobibox.notify(type, {delay:delay, icon:icon, msg:msg});
}};
Polymer({is:"simpl-import", properties:{data:{type:Object}, type:{type:String}, method:{type:String}, url:{observer:"urlChanged", type:String}}, behaviors:[StyleScopeBehavior], observers:["dataChanged(data,method)"], urlChanged:function(name) {
  if (this.url == null) {
    return;
  }
  var appendChar = "?";
  if (this.url.indexOf("?") > 0) {
    appendChar = "&";
  }
  var url = this.url + appendChar + "time=" + (new Date).getTime();
  this.importHref(url, this.onResponse.bind(this));
}, dataChanged:function(name) {
  var params = this.data;
  if (typeof params == "string") {
    params = JSON5.parse(params);
  }
  var method = this.method;
  if (method.indexOf(".") == -1) {
    var namespace = simpl4.util.BaseManager.getNamespace();
    method = namespace + "." + method;
  }
  var rpc = {"service":"camel-routing", "method":method, params:params};
  var password = simpl4.util.BaseManager.getPassword();
  var username = simpl4.util.BaseManager.getUser();
  var credentials = simpl4.util.Base64.encode(username + ":" + password);
  var url = simpl4.util.BaseManager.getBaseUrl() + "/rpc/get?rpc=" + encodeURIComponent(JSON.stringify(rpc)) + "&credentials=" + credentials;
  this.importHref(url, this.onResponse.bind(this));
}, onResponse:function(e) {
  var body = e.target.import.body;
  var head = e.target.import.head;
  if (body.innerHTML && body.innerHTML.startsWith('{"error":')) {
    console.error("simpl-import.onResponse:", JSON5.parse(body.innerHTML).error.message);
    return;
  }
  var insertPoint = this.$.insertPoint;
  while (insertPoint.firstChild) {
    Polymer.dom(insertPoint).removeChild(insertPoint.firstChild);
  }
  if (body.firstElementChild) {
    if (body.childNodes.length > 1) {
      for (var i = 0; i < body.childNodes.length; i++) {
        var node = body.childNodes[i];
        Polymer.dom(insertPoint).appendChild(node);
      }
    } else {
      Polymer.dom(insertPoint).appendChild(body.firstElementChild);
    }
  }
  document.querySelector("#dispatcherId").filterLocalLinks(insertPoint.firstElementChild);
  this.async(function() {
    this.setScope(insertPoint);
  }, 50);
}, setScope:function(insertPoint) {
  var d = document.querySelector("simpl-dispatcher");
  var page = d.getActivePage();
  if (page == null) {
    return;
  }
  var scope = page.scope;
  if (this.isAsciidoc(this.url) && scope == null) {
    scope = "asciidoctor-default";
  }
  this.setStyleScope(insertPoint, scope);
}, isAsciidoc:function(url) {
  if (this.type == "adoc") {
    return true;
  }
  if (url == null) {
    return false;
  }
  return url.indexOf(".adoc") > 0;
}});
(function(exports) {
  var dloc = document.location;
  function dlocHashEmpty() {
    return dloc.hash === "" || dloc.hash === "#";
  }
  var listener = {mode:"modern", hash:dloc.hash, history:false, check:function() {
    var h = dloc.hash;
    if (h != this.hash) {
      this.hash = h;
      this.onHashChanged();
    }
  }, fire:function() {
    if (this.mode === "modern") {
      this.history === true ? window.onpopstate() : window.onhashchange();
    } else {
      this.onHashChanged();
    }
  }, init:function(fn, history) {
    var self = this;
    this.history = history;
    if (!Router.listeners) {
      Router.listeners = [];
    }
    function onchange(onChangeEvent) {
      for (var i = 0, l = Router.listeners.length; i < l; i++) {
        Router.listeners[i](onChangeEvent);
      }
    }
    if ("onhashchange" in window && (document.documentMode === undefined || document.documentMode > 7)) {
      if (this.history === true) {
        setTimeout(function() {
          window.onpopstate = onchange;
        }, 500);
      } else {
        window.onhashchange = onchange;
      }
      this.mode = "modern";
    } else {
      var frame = document.createElement("iframe");
      frame.id = "state-frame";
      frame.style.display = "none";
      document.body.appendChild(frame);
      this.writeFrame("");
      if ("onpropertychange" in document && "attachEvent" in document) {
        document.attachEvent("onpropertychange", function() {
          if (event.propertyName === "location") {
            self.check();
          }
        });
      }
      window.setInterval(function() {
        self.check();
      }, 50);
      this.onHashChanged = onchange;
      this.mode = "legacy";
    }
    Router.listeners.push(fn);
    return this.mode;
  }, destroy:function(fn) {
    if (!Router || !Router.listeners) {
      return;
    }
    var listeners = Router.listeners;
    for (var i = listeners.length - 1; i >= 0; i--) {
      if (listeners[i] === fn) {
        listeners.splice(i, 1);
      }
    }
  }, setHash:function(s) {
    if (this.mode === "legacy") {
      this.writeFrame(s);
    }
    if (this.history === true) {
      window.history.pushState({}, document.title, s);
      this.fire();
    } else {
      dloc.hash = s[0] === "/" ? s : "/" + s;
    }
    return this;
  }, writeFrame:function(s) {
    var f = document.getElementById("state-frame");
    var d = f.contentDocument || f.contentWindow.document;
    d.open();
    d.write("<script>_hash = '" + s + "'; onload = parent.listener.syncHash;<script>");
    d.close();
  }, syncHash:function() {
    var s = this._hash;
    if (s != dloc.hash) {
      dloc.hash = s;
    }
    return this;
  }, onHashChanged:function() {
  }};
  var Router = exports.Router = function(routes) {
    if (!(this instanceof Router)) {
      return new Router(routes);
    }
    this.params = {};
    this.routes = {};
    this.methods = ["on", "once", "after", "before"];
    this.scope = [];
    this._methods = {};
    this._insert = this.insert;
    this.insert = this.insertEx;
    this.historySupport = (window.history != null ? window.history.pushState : null) != null;
    this.configure();
    this.mount(routes || {});
  };
  Router.prototype.init = function(r) {
    var self = this, routeTo;
    this.handler = function(onChangeEvent) {
      var newURL = onChangeEvent && onChangeEvent.newURL || window.location.hash;
      var url = self.history === true ? self.getPath() : newURL.replace(/.*#/, "");
      self.dispatch("on", url.charAt(0) === "/" ? url : "/" + url);
    };
    listener.init(this.handler, this.history);
    if (this.history === false) {
      if (dlocHashEmpty() && r) {
        dloc.hash = r;
      } else {
        if (!dlocHashEmpty()) {
          self.dispatch("on", "/" + dloc.hash.replace(/^(#\/|#|\/)/, ""));
        }
      }
    } else {
      if (this.convert_hash_in_init) {
        routeTo = dlocHashEmpty() && r ? r : !dlocHashEmpty() ? dloc.hash.replace(/^#/, "") : null;
        if (routeTo) {
          window.history.replaceState({}, document.title, routeTo);
        }
      } else {
        routeTo = this.getPath();
      }
      if (routeTo || this.run_in_init === true) {
        this.handler();
      }
    }
    return this;
  };
  Router.prototype.explode = function() {
    var v = this.history === true ? this.getPath() : dloc.hash;
    if (v.charAt(1) === "/") {
      v = v.slice(1);
    }
    return v.slice(1, v.length).split("/");
  };
  Router.prototype.setRoute = function(i, v, val) {
    var url = this.explode();
    if (typeof i === "number" && typeof v === "string") {
      url[i] = v;
    } else {
      if (typeof val === "string") {
        url.splice(i, v, s);
      } else {
        url = [i];
      }
    }
    listener.setHash(url.join("/"));
    return url;
  };
  Router.prototype.insertEx = function(method, path, route, parent) {
    if (method === "once") {
      method = "on";
      route = function(route) {
        var once = false;
        return function() {
          if (once) {
            return;
          }
          once = true;
          return route.apply(this, arguments);
        };
      }(route);
    }
    return this._insert(method, path, route, parent);
  };
  Router.prototype.getRoute = function(v) {
    var ret = v;
    if (typeof v === "number") {
      ret = this.explode()[v];
    } else {
      if (typeof v === "string") {
        var h = this.explode();
        ret = h.indexOf(v);
      } else {
        ret = this.explode();
      }
    }
    return ret;
  };
  Router.prototype.destroy = function() {
    listener.destroy(this.handler);
    return this;
  };
  Router.prototype.getPath = function() {
    var path = window.location.pathname;
    if (path.substr(0, 1) !== "/") {
      path = "/" + path;
    }
    return path;
  };
  function _every(arr, iterator) {
    for (var i = 0; i < arr.length; i += 1) {
      if (iterator(arr[i], i, arr) === false) {
        return;
      }
    }
  }
  function _flatten(arr) {
    var flat = [];
    for (var i = 0, n = arr.length; i < n; i++) {
      flat = flat.concat(arr[i]);
    }
    return flat;
  }
  function _asyncEverySeries(arr, iterator, callback) {
    if (!arr.length) {
      return callback();
    }
    var completed = 0;
    (function iterate() {
      iterator(arr[completed], function(err) {
        if (err || err === false) {
          callback(err);
          callback = function() {
          };
        } else {
          completed += 1;
          if (completed === arr.length) {
            callback();
          } else {
            iterate();
          }
        }
      });
    })();
  }
  function paramifyString(str, params, mod) {
    mod = str;
    for (var param in params) {
      if (params.hasOwnProperty(param)) {
        mod = params[param](str);
        if (mod !== str) {
          break;
        }
      }
    }
    return mod === str ? "([._a-zA-Z0-9-%()]+)" : mod;
  }
  function regifyString(str, params) {
    var matches, last = 0, out = "";
    while (matches = str.substr(last).match(/[^\w\d\- %@&]*\*[^\w\d\- %@&]*/)) {
      last = matches.index + matches[0].length;
      matches[0] = matches[0].replace(/^\*/, "([_.()!\\ %@&a-zA-Z0-9-]+)");
      out += str.substr(0, matches.index) + matches[0];
    }
    str = out += str.substr(last);
    var captures = str.match(/:([^\/]+)/ig), capture, length;
    if (captures) {
      length = captures.length;
      for (var i = 0; i < length; i++) {
        capture = captures[i];
        if (capture.slice(0, 2) === "::") {
          str = capture.slice(1);
        } else {
          str = str.replace(capture, paramifyString(capture, params));
        }
      }
    }
    return str;
  }
  function terminator(routes, delimiter, start, stop) {
    var last = 0, left = 0, right = 0, start = (start || "(").toString(), stop = (stop || ")").toString(), i;
    for (i = 0; i < routes.length; i++) {
      var chunk = routes[i];
      if (chunk.indexOf(start, last) > chunk.indexOf(stop, last) || ~chunk.indexOf(start, last) && !~chunk.indexOf(stop, last) || !~chunk.indexOf(start, last) && ~chunk.indexOf(stop, last)) {
        left = chunk.indexOf(start, last);
        right = chunk.indexOf(stop, last);
        if (~left && !~right || !~left && ~right) {
          var tmp = routes.slice(0, (i || 1) + 1).join(delimiter);
          routes = [tmp].concat(routes.slice((i || 1) + 1));
        }
        last = (right > left ? right : left) + 1;
        i = 0;
      } else {
        last = 0;
      }
    }
    return routes;
  }
  var QUERY_SEPARATOR = /\?.*/;
  Router.prototype.configure = function(options) {
    options = options || {};
    for (var i = 0; i < this.methods.length; i++) {
      this._methods[this.methods[i]] = true;
    }
    this.recurse = options.recurse || this.recurse || false;
    this.async = options.async || false;
    this.delimiter = options.delimiter || "/";
    this.strict = typeof options.strict === "undefined" ? true : options.strict;
    this.notfound = options.notfound;
    this.resource = options.resource;
    this.history = options.html5history && this.historySupport || false;
    this.run_in_init = this.history === true && options.run_handler_in_init !== false;
    this.convert_hash_in_init = this.history === true && options.convert_hash_in_init !== false;
    this.every = {after:options.after || null, before:options.before || null, on:options.on || null};
    return this;
  };
  Router.prototype.param = function(token, matcher) {
    if (token[0] !== ":") {
      token = ":" + token;
    }
    var compiled = new RegExp(token, "g");
    this.params[token] = function(str) {
      return str.replace(compiled, matcher.source || matcher);
    };
    return this;
  };
  Router.prototype.on = Router.prototype.route = function(method, path, route) {
    var self = this;
    if (!route && typeof path == "function") {
      route = path;
      path = method;
      method = "on";
    }
    if (Array.isArray(path)) {
      return path.forEach(function(p) {
        self.on(method, p, route);
      });
    }
    if (path.source) {
      path = path.source.replace(/\\\//ig, "/");
    }
    if (Array.isArray(method)) {
      return method.forEach(function(m) {
        self.on(m.toLowerCase(), path, route);
      });
    }
    path = path.split(new RegExp(this.delimiter));
    path = terminator(path, this.delimiter);
    this.insert(method, this.scope.concat(path), route);
  };
  Router.prototype.path = function(path, routesFn) {
    var self = this, length = this.scope.length;
    if (path.source) {
      path = path.source.replace(/\\\//ig, "/");
    }
    path = path.split(new RegExp(this.delimiter));
    path = terminator(path, this.delimiter);
    this.scope = this.scope.concat(path);
    routesFn.call(this, this);
    this.scope.splice(length, path.length);
  };
  Router.prototype.dispatch = function(method, path, callback) {
    var self = this, fns = this.traverse(method, path.replace(QUERY_SEPARATOR, ""), this.routes, ""), invoked = this._invoked, after;
    this._invoked = true;
    if (!fns || fns.length === 0) {
      this.last = [];
      if (typeof this.notfound === "function") {
        this.invoke([this.notfound], {method:method, path:path}, callback);
      }
      return false;
    }
    if (this.recurse === "forward") {
      fns = fns.reverse();
    }
    function updateAndInvoke() {
      self.last = fns.after;
      self.invoke(self.runlist(fns), self, callback);
    }
    after = this.every && this.every.after ? [this.every.after].concat(this.last) : [this.last];
    if (after && after.length > 0 && invoked) {
      if (this.async) {
        this.invoke(after, this, updateAndInvoke);
      } else {
        this.invoke(after, this);
        updateAndInvoke();
      }
      return true;
    }
    updateAndInvoke();
    return true;
  };
  Router.prototype.invoke = function(fns, thisArg, callback) {
    var self = this;
    var apply;
    if (this.async) {
      apply = function(fn, next) {
        if (Array.isArray(fn)) {
          return _asyncEverySeries(fn, apply, next);
        } else {
          if (typeof fn == "function") {
            fn.apply(thisArg, (fns.captures || []).concat(next));
          }
        }
      };
      _asyncEverySeries(fns, apply, function() {
        if (callback) {
          callback.apply(thisArg, arguments);
        }
      });
    } else {
      apply = function(fn) {
        if (Array.isArray(fn)) {
          return _every(fn, apply);
        } else {
          if (typeof fn === "function") {
            return fn.apply(thisArg, fns.captures || []);
          } else {
            if (typeof fn === "string" && self.resource) {
              self.resource[fn].apply(thisArg, fns.captures || []);
            }
          }
        }
      };
      _every(fns, apply);
    }
  };
  Router.prototype.traverse = function(method, path, routes, regexp, filter) {
    var fns = [], current, exact, match, next, that;
    function filterRoutes(routes) {
      if (!filter) {
        return routes;
      }
      function deepCopy(source) {
        var result = [];
        for (var i = 0; i < source.length; i++) {
          result[i] = Array.isArray(source[i]) ? deepCopy(source[i]) : source[i];
        }
        return result;
      }
      function applyFilter(fns) {
        for (var i = fns.length - 1; i >= 0; i--) {
          if (Array.isArray(fns[i])) {
            applyFilter(fns[i]);
            if (fns[i].length === 0) {
              fns.splice(i, 1);
            }
          } else {
            if (!filter(fns[i])) {
              fns.splice(i, 1);
            }
          }
        }
      }
      var newRoutes = deepCopy(routes);
      newRoutes.matched = routes.matched;
      newRoutes.captures = routes.captures;
      newRoutes.after = routes.after.filter(filter);
      applyFilter(newRoutes);
      return newRoutes;
    }
    if (path === this.delimiter && routes[method]) {
      next = [[routes.before, routes[method]].filter(Boolean)];
      next.after = [routes.after].filter(Boolean);
      next.matched = true;
      next.captures = [];
      return filterRoutes(next);
    }
    for (var r in routes) {
      if (routes.hasOwnProperty(r) && (!this._methods[r] || this._methods[r] && typeof routes[r] === "object" && !Array.isArray(routes[r]))) {
        current = exact = regexp + this.delimiter + r;
        if (!this.strict) {
          exact += "[" + this.delimiter + "]?";
        }
        match = path.match(new RegExp("^" + exact));
        if (!match) {
          continue;
        }
        if (match[0] && match[0] == path && routes[r][method]) {
          next = [[routes[r].before, routes[r][method]].filter(Boolean)];
          next.after = [routes[r].after].filter(Boolean);
          next.matched = true;
          next.captures = match.slice(1);
          if (this.recurse && routes === this.routes) {
            next.push([routes.before, routes.on].filter(Boolean));
            next.after = next.after.concat([routes.after].filter(Boolean));
          }
          return filterRoutes(next);
        }
        next = this.traverse(method, path, routes[r], current);
        if (next.matched) {
          if (next.length > 0) {
            fns = fns.concat(next);
          }
          if (this.recurse) {
            fns.push([routes[r].before, routes[r].on].filter(Boolean));
            next.after = next.after.concat([routes[r].after].filter(Boolean));
            if (routes === this.routes) {
              fns.push([routes["before"], routes["on"]].filter(Boolean));
              next.after = next.after.concat([routes["after"]].filter(Boolean));
            }
          }
          fns.matched = true;
          fns.captures = next.captures;
          fns.after = next.after;
          return filterRoutes(fns);
        }
      }
    }
    return false;
  };
  Router.prototype.insert = function(method, path, route, parent) {
    var methodType, parentType, isArray, nested, part;
    path = path.filter(function(p) {
      return p && p.length > 0;
    });
    parent = parent || this.routes;
    part = path.shift();
    if (/\:|\*/.test(part) && !/\\d|\\w/.test(part)) {
      part = regifyString(part, this.params);
    }
    if (path.length > 0) {
      parent[part] = parent[part] || {};
      return this.insert(method, path, route, parent[part]);
    }
    if (!part && !path.length && parent === this.routes) {
      methodType = typeof parent[method];
      switch(methodType) {
        case "function":
          parent[method] = [parent[method], route];
          return;
        case "object":
          parent[method].push(route);
          return;
        case "undefined":
          parent[method] = route;
          return;
      }
      return;
    }
    parentType = typeof parent[part];
    isArray = Array.isArray(parent[part]);
    if (parent[part] && !isArray && parentType == "object") {
      methodType = typeof parent[part][method];
      switch(methodType) {
        case "function":
          parent[part][method] = [parent[part][method], route];
          return;
        case "object":
          parent[part][method].push(route);
          return;
        case "undefined":
          parent[part][method] = route;
          return;
      }
    } else {
      if (parentType == "undefined") {
        nested = {};
        nested[method] = route;
        parent[part] = nested;
        return;
      }
    }
    throw new Error("Invalid route context: " + parentType);
  };
  Router.prototype.extend = function(methods) {
    var self = this, len = methods.length, i;
    function extend(method) {
      self._methods[method] = true;
      self[method] = function() {
        var extra = arguments.length === 1 ? [method, ""] : [method];
        self.on.apply(self, extra.concat(Array.prototype.slice.call(arguments)));
      };
    }
    for (i = 0; i < len; i++) {
      extend(methods[i]);
    }
  };
  Router.prototype.runlist = function(fns) {
    var runlist = this.every && this.every.before ? [this.every.before].concat(_flatten(fns)) : _flatten(fns);
    if (this.every && this.every.on) {
      runlist.push(this.every.on);
    }
    runlist.captures = fns.captures;
    runlist.source = fns.source;
    return runlist;
  };
  Router.prototype.mount = function(routes, path) {
    if (!routes || typeof routes !== "object" || Array.isArray(routes)) {
      return;
    }
    var self = this;
    path = path || [];
    if (!Array.isArray(path)) {
      path = path.split(self.delimiter);
    }
    function insertOrMount(route, local) {
      var rename = route, parts = route.split(self.delimiter), routeType = typeof routes[route], isRoute = parts[0] === "" || !self._methods[parts[0]], event = isRoute ? "on" : rename;
      if (isRoute) {
        rename = rename.slice((rename.match(new RegExp("^" + self.delimiter)) || [""])[0].length);
        parts.shift();
      }
      if (isRoute && routeType === "object" && !Array.isArray(routes[route])) {
        local = local.concat(parts);
        self.mount(routes[route], local);
        return;
      }
      if (isRoute) {
        local = local.concat(rename.split(self.delimiter));
        local = terminator(local, self.delimiter);
      }
      self.insert(event, local, routes[route]);
    }
    for (var route in routes) {
      if (routes.hasOwnProperty(route)) {
        insertOrMount(route, path.slice(0));
      }
    }
  };
})(typeof exports === "object" ? exports : window);
(function() {
  var private_router;
  Polymer({is:"flatiron-director", properties:{autoHash:{value:false, type:Boolean}, route:{notify:true, type:String}}, observers:["routeChanged(route)"], attached:function() {
    this.router.on(/(.*)/, function(route) {
      this.route = route;
    }.bind(this));
    var r = this.router.getRoute();
    if (window.startPage) {
      r = [window.startPage];
      window.startPage = null;
    }
    this.route = r && r != "" ? r.join(this.router.delimiter) : "0";
  }, routeChanged:function() {
    if (this.autoHash) {
      window.location.hash = this.route;
    }
    this.fire("director-route", this.route);
  }, changeRoute:function(route) {
    this.route = route;
  }, get router() {
    if (!private_router) {
      private_router = new Router;
      private_router.init();
    }
    return private_router;
  }});
})();
Polymer({is:"simpl-asciidoctor", properties:{data:{observer:"dataChanged", type:String}, scope:{type:String}, css:{type:String}}, behaviors:[CSSImportBehavior, StyleScopeBehavior], attached:function(filter) {
}, dataChanged:function(filter) {
  var d = document.querySelector("simpl-dispatcher");
  var page = d.getActivePage();
  var scope = this.scope || page.scope || "asciidoctor-default";
  this.selectedPage = {scope:scope};
  if (this.css) {
    this.importSheet(this.css);
  }
  var template = this.textContent;
  var data = null;
  if (typeof this.data == "object" && !Array.isArray(this.data)) {
    data = this.data;
  } else {
    data = {data:this.data};
  }
  var html = simpl4.util.Rpc.rpcSync("camelRoute:asciidoctor", {namespace:"global", data:data, template:template});
  this.$.asciidoctorId.innerHTML = html;
  this.setStyleScope(this.$.asciidoctorId, scope);
}});
Polymer({is:"simpl-lightbox", behaviors:[Polymer.IronOverlayBehavior], properties:{withBackdrop:{type:Boolean, value:true}, items:{type:Array, value:function() {
  return [];
}, observer:"_updateItems"}, selectedItem:{type:Object, value:function() {
  return {};
}, notify:true, readOnly:true, observer:"_onSelect"}, selectedIndex:{type:Number, value:0, notify:true, observer:"_onIndexChanged"}, autoplayVideos:{type:Boolean, value:false}}, listeners:{"iron-overlay-opened":"_onOpen", "iron-overlay-closed":"_onClose", "iron-overlay-cancelled":"_onClose", "keyup":"_onKeyup"}, _currentMediaElement:null, selectPrevious:function() {
  if (this.selectedIndex === 0) {
    this.selectedIndex = this.items.length - 1;
  } else {
    this.selectedIndex--;
  }
}, selectNext:function() {
  if (this.selectedIndex === this.items.length - 1) {
    this.selectedIndex = 0;
  } else {
    this.selectedIndex++;
  }
}, useStrategy:function(name, strategy) {
  this._strategies[name] = strategy;
}, _strategies:{"pdf":"_displayPdf", "pdfRPC":"_displayPdfRPC", "image":"_displayImage", "html":"_displayHtml", "video":"_displayVideo"}, _replaceMedia:function(el) {
  this.$.viewer.innerHTML = "";
  Polymer.dom(this.$.viewer).appendChild(el);
  this._currentMediaElement = el;
}, _displayPdfRPC:function(it) {
  this.$.viewer.innerHTML = "";
  var self = this;
  var url = simpl4.util.BaseManager.getBaseUrl() + "/rpc/xyz";
  var xhr = new XMLHttpRequest;
  xhr.open("POST", url, true);
  xhr.responseType = "blob";
  var username = simpl4.util.Rpc._getUserName();
  var password = simpl4.util.Rpc._getPassword();
  xhr.setRequestHeader("Authorization", "Basic " + simpl4.util.Base64.encode(username + ":" + password));
  xhr.setRequestHeader("Content-type", "application/json; charset=utf-8");
  if (it.wait) {
    this.$.toastId.show(it.wait, "success", "100000");
  }
  xhr.onload = function(e) {
    if (this.status == 200) {
      var blob = new Blob([this.response], {type:"application/pdf"});
      if (window.navigator.msSaveBlob) {
        window.navigator.msSaveBlob(blob, "download.pdf");
        self.close();
      } else {
        var downloadUrl = URL.createObjectURL(blob);
        var pdf = document.createElement("simpl-pdfviewer");
        pdf.file = downloadUrl;
        pdf.height = "100%";
        pdf.style = "position:absolute;";
        self._replaceMedia(pdf);
      }
      self.$.toastId.close();
    } else {
      console.error("Error download:", this.status);
      this.$.toastId.show("Error download:" + this.status, "error", "100000");
    }
    xhr.onerror = function(e) {
      console.log("Failed:", e);
      this.$.toastId.show("Failed:" + e, "error", "100000");
    };
  };
  console.log("send:", it.rpc);
  xhr.send(JSON.stringify(it.rpc));
}, _displayPdf:function(it) {
  var pdf = document.createElement("simpl-pdfviewer");
  pdf.file = it.src;
  pdf.height = "100%";
  pdf.style = "position:absolute;";
  this._replaceMedia(pdf);
}, _displayImage:function(it) {
  var img = document.createElement("iron-image");
  img.src = it.src;
  img.sizing = "contain";
  img.preload = true;
  img.fade = true;
  this._replaceMedia(img);
}, _displayHtml:function(it) {
  var img = document.createElement("iframe");
  img.src = it.src;
  img.fade = true;
  this._replaceMedia(img);
}, _displayVideo:function(it) {
  var video = document.createElement("paper-video");
  video.poster = it.thumbnail;
  video.controls = true;
  video.src = it.src;
  this._replaceMedia(video);
  this._maybeAutoplayVideo(it);
}, _updateItems:function() {
  if (!this.items.length) {
    return;
  }
  var old = this.selectedIndex;
  this.selectedIndex = 0;
  if (old === 0) {
    this._setSelectedItem(this.items[0]);
  }
}, _onIndexChanged:function(i) {
  if (!this.items.length) {
    return;
  }
  this._setSelectedItem(this.items[i]);
}, _onSelect:function(it) {
  this.debounce("doSelect", function() {
    this.__onSelect(it);
  }, 300);
}, __onSelect:function(it) {
  console.log("_onSelect");
  if (!it) {
    return;
  }
  var strategy = this._strategies[it.type];
  if (!strategy) {
    return;
  }
  if (typeof strategy === "function") {
    strategy.call(this, it);
  } else {
    this[strategy](it);
  }
  this.$.viewer.setAttribute("media-type", it.type);
}, _maybeAutoplayVideo:function(it) {
  if (it.type === "video") {
    this._currentMediaElement.$.container.focus();
    if ((it.autoplay || this.autoplayVideos) && this._currentMediaElement !== null && this.opened) {
      this._currentMediaElement.play();
    }
  }
}, _toggleVideo:function() {
  if (this.selectedItem.type === "video") {
    this._currentMediaElement[this._currentMediaElement.paused ? "play" : "pause"]();
  }
}, _hideControls:function(xs) {
  return xs.length <= 1;
}, _onOpen:function() {
  var it = this.selectedItem;
  this._maybeAutoplayVideo(it);
}, _onClose:function() {
  if (this.selectedItem.type === "video") {
    this._currentMediaElement.pause();
  }
}, _onKeyup:function(e) {
  switch(e.which || e.keyCode) {
    case 39:
      this.selectNext();
      break;
    case 37:
      this.selectPrevious();
      break;
  }
}});
Polymer({is:"simpl-pdfviewer", properties:{file:{type:String, value:undefined, reflectToAttribute:true}, notSupportedMessage:{type:String, value:"It appears your Web browser is not configured to display PDF files. No worries, just"}, notSupportedLinkMessage:{type:String, value:"click here to download the PDF file."}, height:{type:String, value:"400px"}, width:{type:String, value:"100%"}, card:{type:Boolean, value:false}, downloadLabel:{type:String, value:"Download"}, elevation:{type:String, value:"1"}}, 
clear:function() {
  this.file = undefined;
}, _download:function() {
  window.location = this.file;
}});
Polymer({is:"simpl-elements-docviewer", properties:{}, observers:[], ready:function() {
}});
Polymer({is:"simpl-panel", properties:{heading:{type:String, value:""}, collapsable:{value:false, type:Boolean}, showHeader:{value:true, type:Boolean}, collapsed:{value:false, observer:"collapsedChanged", type:Boolean}, collapsecolor:{value:"white", type:String}, height:{value:null, observer:"heightChanged", type:String}}, getIconFill:function() {
  return "fill:" + this.collapsecolor;
}, attached:function() {
}, ready:function() {
  if (!this.height && !this.style.height) {
    this.$.panelContent.style["-ms-flex"] = "none";
  } else {
    if (this.style.height && !this.height) {
      this.height = parseInt(this.style.height, 10);
    }
    if (this.collapsable === true && this.collapsed === true) {
      this.style.height = parseInt(this.height, 10) + "px";
    } else {
      this.style.height = "30px";
    }
    this.$.panelContent.style["-ms-flex-preferred-size"] = parseInt(this.height, 10) - 50 + "px";
  }
  if (this.collapsable === true) {
    this.$.collapsable.style.display = "block";
    if (this.collapsed === true) {
      this.$.panelContent.style.display = "none";
    } else {
      this.$.panelContent.style.display = "block";
    }
    this.$.collapsable.icon = "custom-icons:" + (this.collapsed ? "icon-collapse" : "icon-expand");
  }
  if (this.showHeader === true) {
    this.$.heading.style.display = "block";
  } else {
    this.$.heading.style.display = "none";
  }
  var self = this;
  this.$.heading.addEventListener("click", function() {
    self.toggleCollapse();
  }, false);
}, heightChanged:function(oldValue, newValue) {
  if (!this.height && !this.style.height) {
    this.$.panelContent.style["-ms-flex"] = "none";
  } else {
    if (this.style.height && !this.height) {
      this.height = parseInt(this.style.height, 10);
    }
    if (this.collapsable === true && this.collapsed === true) {
      this.style.height = parseInt(this.height, 10) + "px";
    } else {
      this.style.height = "30px";
    }
    this.$.panelContent.style["-ms-flex-preferred-size"] = parseInt(this.height, 10) - 50 + "px";
  }
}, close:function() {
  this.collapsed = true;
  this.$.collapsable.icon = "custom-icons:" + (this.collapsed ? "icon-collapse" : "icon-expand");
}, open:function() {
  this.collapsed = false;
  this.$.collapsable.icon = "custom-icons:" + (this.collapsed ? "icon-collapse" : "icon-expand");
}, toggleCollapse:function() {
  this.collapsed = !this.collapsed;
  this.$.collapsable.icon = "custom-icons:" + (this.collapsed ? "icon-collapse" : "icon-expand");
}, collapsedChanged:function() {
  if (this.collapsable === true) {
    if (this.collapsed === true) {
      this.$.panelContent.style.display = "none";
      this.style.height = "30px";
      this.fire("close-action", {data:this.data});
    } else {
      if (this.height && this.height != 30) {
        this.style.height = parseInt(this.height, 10) + "px";
        this.$.panelContent.style.height = parseInt(this.height, 10) - 40 + "px";
        this.$.panelContent.style["-ms-flex"] = "none";
      } else {
        this.style.height = null;
        this.$.panelContent.style["-ms-flex"] = "none";
      }
      this.$.panelContent.style.display = "block";
      this.fire("open-action", {data:this.data});
    }
  }
}});
(function(root, factory) {
  if (typeof define === "function" && define.amd) {
    define(["jquery", "microevent"], factory);
  } else {
    factory(root.jQuery, root.MicroEvent);
  }
})(this, function($, MicroEvent) {
  var types = ["string", "integer", "double", "date", "time", "datetime"], internalTypes = ["string", "number", "datetime"], inputs = ["text", "radio", "checkbox", "select"];
  var QueryBuilder = function($el, options) {
    console.log("QueryBuilder.construct");
    this.$el = $el;
    this.init(options);
  };
  MicroEvent.mixin(QueryBuilder);
  QueryBuilder.DEFAULTS = {filters:[], plugins:null, onValidationError:null, onAfterAddGroup:null, onAfterAddRule:null, onAfterCreateRuleInput:null, onAfterChangeOperator:null, display_errors:true, allow_groups:-1, conditions:["AND", "OR"], default_condition:"AND", default_rule_flags:{filter_readonly:false, operator_readonly:false, value_readonly:false, no_delete:false}, template:{group:null, rule:null}, lang:{"add_rule":"Add rule", "add_group":"Add group", "delete_rule":"Delete", "delete_group":"Delete", 
  "condition_and":"AND", "condition_or":"OR", "filter_select_placeholder":"------", "operators":{"equal":"equal", "not_equal":"not equal", "in":"in", "not_in":"not in", "less":"less", "less_or_equal":"less or equal", "greater":"greater", "greater_or_equal":"greater or equal", "between":"between", "begins_with":"begins with", "not_begins_with":"doesn't begin with", "contains":"contains", "not_contains":"doesn't contain", "ends_with":"ends with", "not_ends_with":"doesn't end with", "is_empty":"is empty", 
  "is_not_empty":"is not empty", "is_null":"is null", "is_not_null":"is not null"}, "errors":{"no_filter":"No filter selected", "empty_group":"The group is empty", "radio_empty":"No value selected", "checkbox_empty":"No value selected", "select_empty":"No value selected", "string_empty":"Empty value", "string_exceed_min_length":"Must contain at least {0} characters", "string_exceed_max_length":"Must not contain more than {0} characters", "string_invalid_format":"Invalid format ({0})", "number_nan":"Not a number", 
  "number_not_integer":"Not an integer", "number_not_double":"Not a real number", "number_exceed_min":"Must be greater than {0}", "number_exceed_max":"Must be lower than {0}", "number_wrong_step":"Must be a multiple of {0}", "datetime_invalid":"Invalid date format ({0})", "datetime_exceed_min":"Must be after {0}", "datetime_exceed_max":"Must be before {0}"}}, operators:[{type:"equal", accept_values:1, apply_to:["string", "number", "datetime"]}, {type:"not_equal", accept_values:1, apply_to:["string", 
  "number", "datetime"]}, {type:"in", accept_values:1, apply_to:["string", "number", "datetime"]}, {type:"not_in", accept_values:1, apply_to:["string", "number", "datetime"]}, {type:"less", accept_values:1, apply_to:["number", "datetime"]}, {type:"less_or_equal", accept_values:1, apply_to:["number", "datetime"]}, {type:"greater", accept_values:1, apply_to:["number", "datetime"]}, {type:"greater_or_equal", accept_values:1, apply_to:["number", "datetime"]}, {type:"between", accept_values:2, apply_to:["number", 
  "datetime"]}, {type:"begins_with", accept_values:1, apply_to:["string"]}, {type:"not_begins_with", accept_values:1, apply_to:["string"]}, {type:"contains", accept_values:1, apply_to:["string"]}, {type:"not_contains", accept_values:1, apply_to:["string"]}, {type:"ends_with", accept_values:1, apply_to:["string"]}, {type:"not_ends_with", accept_values:1, apply_to:["string"]}, {type:"is_empty", accept_values:0, apply_to:["string"]}, {type:"is_not_empty", accept_values:0, apply_to:["string"]}, {type:"is_null", 
  accept_values:0, apply_to:["string", "number", "datetime"]}, {type:"is_not_null", accept_values:0, apply_to:["string", "number", "datetime"]}], icons:{add_group:"glyphicon glyphicon-plus-sign", add_rule:"glyphicon glyphicon-plus", remove_group:"glyphicon glyphicon-remove", remove_rule:"glyphicon glyphicon-remove", error:"glyphicon glyphicon-warning-sign"}};
  QueryBuilder.plugins = {};
  QueryBuilder.define = function(name, fct) {
    QueryBuilder.plugins[name] = fct;
  };
  QueryBuilder.extend = function(methods) {
    $.extend(QueryBuilder.prototype, methods);
  };
  QueryBuilder.prototype.initPlugins = function() {
    if (!this.settings.plugins) {
      return;
    }
    var that = this, queue = {};
    if ($.isArray(this.settings.plugins)) {
      $.each(this.settings.plugins, function(i, plugin) {
        queue[plugin] = {};
      });
    } else {
      $.each(this.settings.plugins, function(plugin, options) {
        queue[plugin] = options;
      });
    }
    $.each(queue, function(plugin, options) {
      if (plugin in QueryBuilder.plugins) {
        QueryBuilder.plugins[plugin].call(that, options);
      } else {
        $.error('Unable to find plugin "' + plugin + '"');
      }
    });
  };
  QueryBuilder.prototype.init = function(options) {
    this.settings = $.extendext(true, "replace", {}, QueryBuilder.DEFAULTS, options);
    this.status = {group_id:0, rule_id:0, generatedId:false, has_optgroup:false};
    if (this.settings.allow_groups === false) {
      this.settings.allow_groups = 0;
    } else {
      if (this.settings.allow_groups === true) {
        this.settings.allow_groups = -1;
      }
    }
    this.filters = this.settings.filters;
    this.lang = this.settings.lang;
    this.icons = this.settings.icons;
    this.operators = this.settings.operators;
    this.template = this.settings.template;
    if (this.template.group === null) {
      this.template.group = this.getGroupTemplate;
    }
    if (this.template.rule === null) {
      this.template.rule = this.getRuleTemplate;
    }
    if (!this.$el.attr("id")) {
      this.$el.attr("id", "qb_" + Math.floor(Math.random() * 99999));
      this.status.generatedId = true;
    }
    this.$el_id = this.$el.attr("id");
    this.$el.addClass("query-builder");
    if (!this.filters || this.filters.length < 1) {
      $.error("Missing filters list");
    }
    this.checkFilters();
    this.bindEvents();
    this.initPlugins();
    this.trigger("afterInit");
    if (options.rules) {
      this.setRules(options.rules);
    } else {
      this.addGroup(this.$el);
    }
  };
  QueryBuilder.prototype.destroy = function() {
    this.trigger("beforeDestroy");
    if (this.status.generatedId) {
      this.$el.removeAttr("id");
    }
    this.$el.empty().off("click.queryBuilder change.queryBuilder").removeClass("query-builder").removeData("queryBuilder");
  };
  QueryBuilder.prototype.reset = function() {
    this.status.group_id = 1;
    this.status.rule_id = 0;
    this.$el.find(">.rules-group-container>.rules-group-body>.rules-list").empty();
    this.addRule(this.$el.find(">.rules-group-container"));
    this.trigger("afterReset");
  };
  QueryBuilder.prototype.clear = function() {
    this.status.group_id = 0;
    this.status.rule_id = 0;
    this.$el.empty();
    this.trigger("afterClear");
  };
  QueryBuilder.prototype.getRules = function() {
    this.clearErrors();
    var $group = this.$el.find(">.rules-group-container"), that = this;
    var rules = function parse($group) {
      var out = {}, $elements = $group.find(">.rules-group-body>.rules-list>*");
      out.condition = that.getGroupCondition($group);
      out.rules = [];
      for (var i = 0, l = $elements.length; i < l; i++) {
        var $rule = $elements.eq(i), rule;
        if ($rule.hasClass("rule-container")) {
          var filterId = that.getRuleFilter($rule);
          if (filterId == "-1") {
            that.triggerValidationError(["no_filter"], $rule, null, null, null);
            return {};
          }
          var filter = that.getFilterById(filterId), operator = that.getOperatorByType(that.getRuleOperator($rule)), value = null;
          if (operator.accept_values !== 0) {
            value = that.getRuleValue($rule, filter, operator);
            var valid = that.validateValue($rule, value, filter, operator);
            if (valid !== true) {
              that.triggerValidationError(valid, $rule, value, filter, operator);
              return {};
            }
          }
          rule = {id:filter.id, field:filter.field, type:filter.type, input:filter.input, operator:operator.type, value:value};
          out.rules.push(rule);
        } else {
          rule = parse($rule);
          if (!$.isEmptyObject(rule)) {
            out.rules.push(rule);
          } else {
            return {};
          }
        }
      }
      if (out.rules.length === 0) {
        that.triggerValidationError(["empty_group"], $group, null, null, null);
        return {};
      }
      return out;
    }($group);
    return this.change("getRules", rules);
  };
  QueryBuilder.prototype.setRules = function(data) {
    this.clear();
    if (!data || !data.rules || data.rules.length === 0) {
      $.error("Incorrect data object passed");
    }
    data = this.change("setRules", data);
    var $container = this.$el, that = this;
    (function add(data, $container) {
      var $group = that.addGroup($container, false), $buttons = $group.find(">.rules-group-header input[name$=_cond]");
      if (data.condition === undefined) {
        data.condition = that.settings.default_condition;
      }
      for (var i = 0, l = that.settings.conditions.length; i < l; i++) {
        var cond = that.settings.conditions[i];
        $buttons.filter("[value=" + cond + "]").prop("checked", data.condition.toUpperCase() == cond.toUpperCase());
      }
      $buttons.trigger("change");
      $.each(data.rules, function(i, rule) {
        if (rule.rules && rule.rules.length > 0) {
          if (that.settings.allow_groups !== -1 && that.settings.allow_groups < $group.data("queryBuilder").level) {
            that.reset();
            $.error(fmt("No more than {0} groups are allowed", that.settings.allow_groups));
          } else {
            add(rule, $group);
          }
        } else {
          if (rule.id === undefined) {
            $.error("Missing rule field id");
          }
          if (rule.value === undefined) {
            rule.value = "";
          }
          if (rule.operator === undefined) {
            rule.operator = "equal";
          }
          var $rule = that.addRule($group), filter = that.getFilterById(rule.id), operator = that.getOperatorByType(rule.operator);
          $rule.find(".rule-filter-container select[name$=_filter]").val(rule.id).trigger("change");
          $rule.find(".rule-operator-container select[name$=_operator]").val(rule.operator).trigger("change");
          if (operator.accept_values !== 0) {
            that.setRuleValue($rule, rule.value, filter, operator);
          }
          that.applyRuleFlags($rule, rule);
          if (filter.onAfterSetValue) {
            filter.onAfterSetValue.call(that, $rule, rule.value, filter, operator);
          }
        }
      });
    })(data, $container);
  };
  QueryBuilder.prototype.checkFilters = function() {
    var definedFilters = [], that = this;
    $.each(this.filters, function(i, filter) {
      if (!filter.id) {
        $.error("Missing filter id: " + i);
      }
      if (definedFilters.indexOf(filter.id) != -1) {
        $.error("Filter already defined: " + filter.id);
      }
      definedFilters.push(filter.id);
      if (!filter.type) {
        $.error("Missing filter type: " + filter.id);
      }
      if (types.indexOf(filter.type) == -1) {
        $.error("Invalid type: " + filter.type);
      }
      if (!filter.input) {
        filter.input = "text";
      } else {
        if (typeof filter.input != "function" && inputs.indexOf(filter.input) == -1) {
          $.error("Invalid input: " + filter.input);
        }
      }
      if (!filter.field) {
        filter.field = filter.id;
      }
      if (!filter.label) {
        filter.label = filter.field;
      }
      that.status.has_optgroup |= !!filter.optgroup;
      if (!filter.optgroup) {
        filter.optgroup = null;
      }
      switch(filter.type) {
        case "string":
          filter.internalType = "string";
          break;
        case "integer":
        case "double":
          filter.internalType = "number";
          break;
        case "date":
        case "time":
        case "datetime":
          filter.internalType = "datetime";
          break;
      }
      switch(filter.input) {
        case "radio":
        case "checkbox":
          if (!filter.values || filter.values.length < 1) {
            $.error("Missing values for filter: " + filter.id);
          }
          break;
      }
    });
    if (this.status.has_optgroup) {
      var optgroups = [], filters = [];
      $.each(this.filters, function(i, filter) {
        var idx;
        if (filter.optgroup) {
          idx = optgroups.lastIndexOf(filter.optgroup);
          if (idx == -1) {
            idx = optgroups.length;
          }
        } else {
          idx = optgroups.length;
        }
        optgroups.splice(idx, 0, filter.optgroup);
        filters.splice(idx, 0, filter);
      });
      this.filters = filters;
    }
    this.trigger("afterCheckFilters");
  };
  QueryBuilder.prototype.bindEvents = function() {
    var that = this;
    this.$el.on("change.queryBuilder", ".rules-group-header input[name$=_cond]", function() {
      var $this = $(this);
      if ($this.is(":checked")) {
        $this.parent().addClass("active");
        $this.parent().siblings().removeClass("active");
      }
    });
    this.$el.on("change.queryBuilder", ".rule-filter-container select[name$=_filter]", function() {
      var $this = $(this), $rule = $this.closest(".rule-container");
      that.updateRuleFilter($rule, $this.val());
    });
    this.$el.on("change.queryBuilder", ".rule-operator-container select[name$=_operator]", function() {
      var $this = $(this), $rule = $this.closest(".rule-container");
      that.updateRuleOperator($rule, $this.val());
    });
    this.$el.on("click.queryBuilder", "[data-add=rule]", function() {
      var $this = $(this), $group = $this.closest(".rules-group-container");
      that.addRule($group);
    });
    if (this.settings.allow_groups !== 0) {
      this.$el.on("click.queryBuilder", "[data-add=group]", function() {
        var $this = $(this), $group = $this.closest(".rules-group-container");
        that.addGroup($group);
      });
    }
    this.$el.on("click.queryBuilder", "[data-delete=rule]", function() {
      var $this = $(this), $rule = $this.closest(".rule-container");
      $rule.remove();
    });
    this.$el.on("click.queryBuilder", "[data-delete=group]", function() {
      var $this = $(this), $group = $this.closest(".rules-group-container");
      that.deleteGroup($group);
    });
  };
  QueryBuilder.prototype.addGroup = function($parent, addRule) {
    var group_id = this.nextGroupId(), level = ($parent.data("queryBuilder") || {}).level || 0, $container = level === 0 ? $parent : $parent.find(">.rules-group-body>.rules-list"), $group = $(this.template.group.call(this, group_id, ++level));
    $group.data("queryBuilder", {level:level});
    $container.append($group);
    if (this.settings.onAfterAddGroup) {
      this.settings.onAfterAddGroup.call(this, $group);
    }
    this.trigger("afterAddGroup", $group);
    if (addRule === undefined || addRule === true) {
      this.addRule($group);
    }
    return $group;
  };
  QueryBuilder.prototype.deleteGroup = function($group) {
    if ($group[0].id == this.$el_id + "_group_0") {
      return;
    }
    this.trigger("beforeDeleteGroup", $group);
    var that = this, keepGroup = false;
    $group.find(">.rules-group-body>.rules-list>*").each(function() {
      var $element = $(this);
      if ($element.hasClass("rule-container")) {
        if ($element.data("queryBuilder").flags.no_delete) {
          keepGroup = true;
        } else {
          $element.remove();
        }
      } else {
        keepGroup |= that.deleteGroup($element);
      }
    });
    if (!keepGroup) {
      $group.remove();
    }
    return keepGroup;
  };
  QueryBuilder.prototype.addRule = function($parent) {
    var rule_id = this.nextRuleId(), $container = $parent.find(">.rules-group-body>.rules-list"), $rule = $(this.template.rule.call(this, rule_id)), $filterSelect = $(this.getRuleFilterSelect(rule_id));
    $rule.data("queryBuilder", {flags:{}});
    $container.append($rule);
    $rule.find(".rule-filter-container").append($filterSelect);
    if (this.settings.onAfterAddRule) {
      this.settings.onAfterAddRule.call(this, $rule);
    }
    this.trigger("afterAddRule", $rule);
    return $rule;
  };
  QueryBuilder.prototype.createRuleOperators = function($rule, filter) {
    var $operatorContainer = $rule.find(".rule-operator-container").empty();
    if (filter === null) {
      return;
    }
    var operators = this.getOperators(filter), $operatorSelect = $(this.getRuleOperatorSelect($rule.attr("id"), operators));
    $operatorContainer.html($operatorSelect);
    $rule.data("queryBuilder").operator = operators[0];
    this.trigger("afterCreateRuleOperators", $rule, filter, operators);
  };
  QueryBuilder.prototype.createRuleInput = function($rule, filter) {
    var $valueContainer = $rule.find(".rule-value-container").empty();
    if (filter === null) {
      return;
    }
    var operator = this.getOperatorByType(this.getRuleOperator($rule));
    if (operator.accept_values === 0) {
      return;
    }
    var $inputs = $();
    for (var i = 0; i < operator.accept_values; i++) {
      var $ruleInput = $(this.getRuleInput($rule.attr("id"), filter, i));
      if (i > 0) {
        $valueContainer.append(" , ");
      }
      $valueContainer.append($ruleInput);
      $inputs = $inputs.add($ruleInput);
    }
    showHide($valueContainer, true);
    if (filter.onAfterCreateRuleInput) {
      filter.onAfterCreateRuleInput.call(this, $rule, filter);
    }
    if (filter.plugin) {
      $inputs[filter.plugin](filter.plugin_config || {});
    }
    this.trigger("afterCreateRuleInput", $rule, filter, operator);
  };
  QueryBuilder.prototype.updateRuleFilter = function($rule, filterId) {
    var filter = filterId != "-1" ? this.getFilterById(filterId) : null;
    this.createRuleOperators($rule, filter);
    this.createRuleInput($rule, filter);
    $rule.data("queryBuilder").filter = filter;
  };
  QueryBuilder.prototype.updateRuleOperator = function($rule, operatorType) {
    var $valueContainer = $rule.find(".rule-value-container"), filter = this.getFilterById(this.getRuleFilter($rule)), operator = this.getOperatorByType(operatorType);
    if (operator.accept_values === 0) {
      showHide($valueContainer, false);
    } else {
      showHide($valueContainer, true);
      var previousOperator = $rule.data("queryBuilder").operator;
      if ($valueContainer.is(":empty") || operator.accept_values != previousOperator.accept_values) {
        this.createRuleInput($rule, filter);
      }
    }
    $rule.data("queryBuilder").operator = operator;
    if (filter.onAfterChangeOperator) {
      filter.onAfterChangeOperator.call(this, $rule, filter, operator);
    }
    this.trigger("afterChangeOperator", $rule, filter, operator);
  };
  QueryBuilder.prototype.validateValue = function($rule, value, filter, operator) {
    var validation = filter.validation || {}, result = true;
    if (operator.accept_values == 1) {
      value = [value];
    } else {
      value = value;
    }
    if (validation.callback) {
      result = validation.callback.call(this, value, filter, operator, $rule);
      return this.change("validateValue", result, $rule, value, filter, operator);
    }
    for (var i = 0; i < operator.accept_values; i++) {
      switch(filter.input) {
        case "radio":
          if (value[i] === undefined) {
            result = ["radio_empty"];
            break;
          }
          break;
        case "checkbox":
          if (value[i].length === 0) {
            result = ["checkbox_empty"];
            break;
          }
          break;
        case "select":
          if (filter.multiple) {
            if (value[i].length === 0) {
              result = ["select_empty"];
              break;
            }
          } else {
            if (value[i] === undefined) {
              result = ["select_empty"];
              break;
            }
          }
          break;
        case "text":
        default:
          switch(filter.internalType) {
            case "string":
              if (validation.min !== undefined) {
                if (value[i].length < validation.min) {
                  result = ["string_exceed_min_length", validation.min];
                  break;
                }
              } else {
                if (value[i].length === 1000) {
                  result = ["string_empty"];
                  break;
                }
              }
              if (validation.max !== undefined) {
                if (value[i].length > validation.max) {
                  result = ["string_exceed_max_length", validation.max];
                  break;
                }
              }
              if (validation.format) {
                if (!validation.format.test(value[i])) {
                  result = ["string_invalid_format", validation.format];
                  break;
                }
              }
              break;
            case "number":
              if (isNaN(value[i])) {
                result = ["number_nan"];
                break;
              }
              if (filter.type == "integer") {
                if (parseInt(value[i]) != value[i]) {
                  result = ["number_not_integer"];
                  break;
                }
              } else {
                if (parseFloat(value[i]) != value[i]) {
                  result = ["number_not_double"];
                  break;
                }
              }
              if (validation.min !== undefined) {
                if (value[i] < validation.min) {
                  result = ["number_exceed_min", validation.min];
                  break;
                }
              }
              if (validation.max !== undefined) {
                if (value[i] > validation.max) {
                  result = ["number_exceed_max", validation.max];
                  break;
                }
              }
              if (validation.step !== undefined) {
                var v = value[i] / validation.step;
                if (parseInt(v) != v) {
                  result = ["number_wrong_step", validation.step];
                  break;
                }
              }
              break;
            case "datetime":
              if (window.moment && validation.format) {
                var datetime = moment(value[i], validation.format);
                if (!datetime.isValid()) {
                  result = ["datetime_invalid"];
                  break;
                } else {
                  if (validation.min) {
                    if (datetime < moment(validation.min, validation.format)) {
                      result = ["datetime_exceed_min", validation.min];
                      break;
                    }
                  }
                  if (validation.max) {
                    if (datetime > moment(validation.max, validation.format)) {
                      result = ["datetime_exceed_max", validation.max];
                      break;
                    }
                  }
                }
              }
              break;
          }
      }
      if (result !== true) {
        break;
      }
    }
    return this.change("validateValue", result, $rule, value, filter, operator);
  };
  QueryBuilder.prototype.clearErrors = function() {
    this.$el.find(".has-error").removeClass("has-error");
  };
  QueryBuilder.prototype.triggerValidationError = function(error, $target, value, filter, operator) {
    if (!$.isArray(error)) {
      error = [error];
    }
    if (filter && filter.onValidationError) {
      filter.onValidationError.call(this, $target, error, value, filter, operator);
    }
    if (this.settings.onValidationError) {
      this.settings.onValidationError.call(this, $target, error, value, filter, operator);
    }
    var e = jQuery.Event("validationError.queryBuilder", {error:error, filter:filter, operator:operator, value:value, targetRule:$target[0], builder:this});
    this.$el.trigger(e);
    if (this.settings.display_errors && !e.isDefaultPrevented()) {
      var errorLoc = $.extend([], error, [this.lang.errors[error[0]] || error[0]]);
      $target.addClass("has-error");
      var $error = $target.find(".error-container").eq(0);
      $error.attr("title", fmt.apply(null, errorLoc));
    }
    this.trigger("validationError", $target, error);
  };
  QueryBuilder.prototype.nextGroupId = function() {
    return this.$el_id + "_group_" + this.status.group_id++;
  };
  QueryBuilder.prototype.nextRuleId = function() {
    return this.$el_id + "_rule_" + this.status.rule_id++;
  };
  QueryBuilder.prototype.getOperators = function(filter) {
    if (typeof filter === "string") {
      filter = this.getFilterById(filter);
    }
    var result = [];
    for (var i = 0, l = this.operators.length; i < l; i++) {
      if (filter.operators) {
        if (filter.operators.indexOf(this.operators[i].type) == -1) {
          continue;
        }
      } else {
        if (this.operators[i].apply_to.indexOf(filter.internalType) == -1) {
          continue;
        }
      }
      result.push(this.operators[i]);
    }
    if (filter.operators) {
      result.sort(function(a, b) {
        return filter.operators.indexOf(a.type) - filter.operators.indexOf(b.type);
      });
    }
    return this.change("getOperators", result, filter);
  };
  QueryBuilder.prototype.getFilterById = function(filterId) {
    for (var i = 0, l = this.filters.length; i < l; i++) {
      if (this.filters[i].id == filterId) {
        return this.filters[i];
      }
    }
    $.error("Undefined filter: " + filterId);
  };
  QueryBuilder.prototype.getOperatorByType = function(type) {
    for (var i = 0, l = this.operators.length; i < l; i++) {
      if (this.operators[i].type == type) {
        return this.operators[i];
      }
    }
    $.error("Undefined operator: " + type);
  };
  QueryBuilder.prototype.getGroupCondition = function($group) {
    return $group.find(">.rules-group-header input[name$=_cond]:checked").val();
  };
  QueryBuilder.prototype.getRuleFilter = function($rule) {
    return $rule.find(".rule-filter-container select[name$=_filter]").val();
  };
  QueryBuilder.prototype.getRuleOperator = function($rule) {
    return $rule.find(".rule-operator-container select[name$=_operator]").val();
  };
  QueryBuilder.prototype.getRuleValue = function($rule, filter, operator) {
    filter = filter || this.getFilterById(this.getRuleFilter($rule));
    operator = operator || this.getOperatorByType(this.getRuleOperator($rule));
    var value = [], tmp = [], $value = $rule.find(".rule-value-container");
    for (var i = 0; i < operator.accept_values; i++) {
      var name = $rule[0].id + "_value_" + i;
      switch(filter.input) {
        case "radio":
          value.push($value.find("input[name=" + name + "]:checked").val());
          break;
        case "checkbox":
          $value.find("input[name=" + name + "]:checked").each(function() {
            tmp.push($(this).val());
          });
          value.push(tmp);
          break;
        case "select":
          if (filter.multiple) {
            $value.find("select[name=" + name + "] option:selected").each(function() {
              tmp.push($(this).val());
            });
            value.push(tmp);
          } else {
            value.push($value.find("select[name=" + name + "] option:selected").val());
          }
          break;
        case "text":
        default:
          value.push($value.find("[name=" + name + "]").val());
      }
    }
    if (operator.accept_values == 1) {
      value = value[0];
    }
    if (filter.valueParser) {
      value = filter.valueParser.call(this, $rule, value, filter, operator);
    }
    return this.change("getRuleValue", value, $rule, filter, operator);
  };
  QueryBuilder.prototype.setRuleValue = function($rule, value, filter, operator) {
    filter = filter || this.getFilterById(this.getRuleFilter($rule));
    operator = operator || this.getOperatorByType(this.getRuleOperator($rule));
    this.trigger("beforeSetRuleValue", $rule, value, filter, operator);
    if (filter.valueSetter) {
      filter.valueSetter.call(this, $rule, value, filter, operator);
    } else {
      var $value = $rule.find(".rule-value-container");
      if (operator.accept_values == 1) {
        value = [value];
      } else {
        value = value;
      }
      for (var i = 0; i < operator.accept_values; i++) {
        var name = $rule[0].id + "_value_" + i;
        switch(filter.input) {
          case "radio":
            $value.find("input[name=" + name + '][value="' + value[i] + '"]').prop("checked", true).trigger("change");
            break;
          case "checkbox":
            if (!$.isArray(value[i])) {
              value[i] = [value[i]];
            }
            $.each(value[i], function(i, value) {
              $value.find("input[name=" + name + '][value="' + value + '"]').prop("checked", true).trigger("change");
            });
            break;
          case "select":
            $value.find("select[name=" + name + "]").val(value[i]).trigger("change");
            break;
          case "text":
          default:
            $value.find("input[name=" + name + "]").val(value[i]).trigger("change");
            break;
        }
      }
    }
    this.trigger("afterSetRuleValue", $rule, value, filter, operator);
  };
  QueryBuilder.prototype.applyRuleFlags = function($rule, rule) {
    var flags = this.getRuleFlags(rule);
    $rule.data("queryBuilder").flags = flags;
    if (flags.filter_readonly) {
      $rule.find("select[name$=_filter]").prop("disabled", true);
    }
    if (flags.operator_readonly) {
      $rule.find("select[name$=_operator]").prop("disabled", true);
    }
    if (flags.value_readonly) {
      $rule.find("input[name*=_value_], select[name*=_value_]").prop("disabled", true);
    }
    if (flags.no_delete) {
      $rule.find("[data-delete=rule]").remove();
    }
    this.trigger("afterApplyRuleFlags", $rule, rule, flags);
  };
  QueryBuilder.prototype.getGroupTemplate = function(group_id, level) {
    var h = '<dl id="' + group_id + '" class="style-scope simpl-filter rules-group-container">' + '<dt class="style-scope simpl-filter rules-group-header">' + '<div class="style-scope simpl-filter btn-group pull-right group-actions">' + '<paper-button type="button" class="style-scope simpl-filter button_secondary_raised" data-add="rule">' + '<i class="style-scope simpl-filter ' + this.icons.add_rule + '"></i> ' + this.lang.add_rule + "</paper-button>" + (this.settings.allow_groups === -1 || this.settings.allow_groups >= 
    level ? '<paper-button type="button" class="style-scope simpl-filter button_secondary_raised" data-add="group">' + '<i class="style-scope simpl-filter ' + this.icons.add_group + '"></i> ' + this.lang.add_group + "</paper-button>" : "") + (level > 1 ? '<paper-button type="button" class="style-scope simpl-filter small button_error_raised" data-delete="group">' + '<i class="' + this.icons.remove_group + '"></i> ' + this.lang.delete_group + "</paper-button>" : "") + "</div>" + '<div class="style-scope simpl-filter btn-group group-conditions">' + 
    this.getGroupConditions(group_id) + "</div>" + (this.settings.display_errors ? '<div class="style-scope simpl-filter error-container" data-toggle="tooltip" data-placement="right"><i class="style-scope simpl-filter ' + this.icons.error + '"></i></div>' : "") + "</dt>" + '<dd class="style-scope simpl-filter rules-group-body">' + '<ul class="style-scope simpl-filter rules-list"></ul>' + "</dd>" + "</dl>";
    return this.change("getGroupTemplate", h, level);
  };
  QueryBuilder.prototype.getGroupConditions = function(group_id) {
    var h = "";
    for (var i = 0, l = this.settings.conditions.length; i < l; i++) {
      var cond = this.settings.conditions[i], active = cond == this.settings.default_condition, label = this.lang["condition_" + cond.toLowerCase()] || cond;
      h += '<label class="btn btn-xs btn-primary ' + (active ? "active" : "") + '">' + '<input type="radio" name="' + group_id + '_cond" value="' + cond + '" ' + (active ? "checked" : "") + "> " + label + "</label>";
    }
    return this.change("getGroupConditions", h);
  };
  QueryBuilder.prototype.getRuleTemplate = function(rule_id) {
    var h = '<li id="' + rule_id + '" class="style-scope simpl-filter rule-container">' + '<div class="style-scope simpl-filter rule-header">' + '<div class="style-scope simpl-filter btn-group pull-right rule-actions">' + '<paper-button type="button" class="style-scope simpl-filter small button_error_raised" data-delete="rule">' + '<i class="style-scope simpl-filter ' + this.icons.remove_rule + '"></i> ' + this.lang.delete_rule + "</paper-button>" + "</div>" + "</div>" + (this.settings.display_errors ? 
    '<div class="style-scope simpl-filter error-container"><i class="' + this.icons.error + '"></i></div>' : "") + '<div class="style-scope simpl-filter rule-filter-container"></div>' + '<div class="style-scope simpl-filter rule-operator-container"></div>' + '<div class="style-scope simpl-filter rule-value-container"></div>' + "</li>";
    return this.change("getRuleTemplate", h);
  };
  QueryBuilder.prototype.getRuleFilterSelect = function(rule_id) {
    var optgroup = null;
    var h = '<select name="' + rule_id + '_filter">';
    h += '<option value="-1">' + this.lang.filter_select_placeholder + "</option>";
    $.each(this.filters, function(i, filter) {
      if (optgroup != filter.optgroup) {
        if (optgroup !== null) {
          h += "</optgroup>";
        }
        optgroup = filter.optgroup;
        if (optgroup !== null) {
          h += '<optgroup label="' + optgroup + '">';
        }
      }
      h += '<option value="' + filter.id + '">' + filter.label + "</option>";
    });
    if (optgroup !== null) {
      h += "</optgroup>";
    }
    h += "</select>";
    return this.change("getRuleFilterSelect", h);
  };
  QueryBuilder.prototype.getRuleOperatorSelect = function(rule_id, operators) {
    var h = '<select name="' + rule_id + '_operator">';
    for (var i = 0, l = operators.length; i < l; i++) {
      var label = this.lang.operators[operators[i].type] || operators[i].type;
      h += '<option value="' + operators[i].type + '">' + label + "</option>";
    }
    h += "</select>";
    return this.change("getRuleOperatorSelect", h);
  };
  QueryBuilder.prototype.getRuleInput = function(rule_id, filter, value_id) {
    var $rule = this.$el.find("#" + rule_id), validation = filter.validation || {}, name = rule_id + "_value_" + value_id, h = "", c;
    if (typeof filter.input === "function") {
      h = filter.input.call(this, $rule, filter, name);
    } else {
      switch(filter.input) {
        case "radio":
          c = filter.vertical ? " class=block" : "";
          iterateOptions(filter.values, function(key, val) {
            h += "<label" + c + '><input type="radio" name="' + name + '" value="' + key + '"> ' + val + "</label> ";
          });
          break;
        case "checkbox":
          c = filter.vertical ? " class=block" : "";
          iterateOptions(filter.values, function(key, val) {
            h += "<label" + c + '><input type="checkbox" name="' + name + '" value="' + key + '"> ' + val + "</label> ";
          });
          break;
        case "select":
          h += '<select name="' + name + '"' + (filter.multiple ? " multiple" : "") + ">";
          iterateOptions(filter.values, function(key, val) {
            h += '<option value="' + key + '"> ' + val + "</option> ";
          });
          h += "</select>";
          break;
        case "text":
        default:
          switch(filter.internalType) {
            case "number":
              h += '<input type="number" name="' + name + '"';
              if (validation.step !== undefined) {
                h += ' step="' + validation.step + '"';
              }
              if (validation.min !== undefined) {
                h += ' min="' + validation.min + '"';
              }
              if (validation.max !== undefined) {
                h += ' max="' + validation.max + '"';
              }
              if (filter.placeholder) {
                h += ' placeholder="' + filter.placeholder + '"';
              }
              h += ">";
              break;
            case "datetime":
            case "text":
            default:
              h += '<input type="text" name="' + name + '"';
              if (filter.placeholder) {
                h += ' placeholder="' + filter.placeholder + '"';
              }
              h += ">";
          }
      }
    }
    return this.change("getRuleInput", h, $rule, filter, name);
  };
  QueryBuilder.prototype.getRuleFlags = function(rule) {
    var flags = $.extend({}, this.settings.default_rule_flags);
    if (rule.readonly) {
      $.extend(flags, {filter_readonly:true, operator_readonly:true, value_readonly:true, no_delete:true});
    }
    if (rule.flags) {
      $.extend(flags, rule.flags);
    }
    return this.change("getRuleFlags", flags, rule);
  };
  $.fn.queryBuilder = function(option) {
    if (this.length > 1) {
      $.error("Unable to initialize on multiple target");
    }
    var data = this.data("queryBuilder"), options = typeof option == "object" && option || {};
    if (!data && option == "destroy") {
      return this;
    }
    if (!data) {
      this.data("queryBuilder", new QueryBuilder(this, options));
    }
    if (typeof option == "string") {
      return data[option].apply(data, Array.prototype.slice.call(arguments, 1));
    }
    return this;
  };
  $.fn.queryBuilder.defaults = {set:function(options) {
    $.extendext(true, "replace", QueryBuilder.DEFAULTS, options);
  }, get:function(key) {
    var options = QueryBuilder.DEFAULTS;
    if (key) {
      options = options[key];
    }
    return $.extend(true, {}, options);
  }};
  $.fn.queryBuilder.constructor = QueryBuilder;
  $.fn.queryBuilder.extend = QueryBuilder.extend;
  $.fn.queryBuilder.define = QueryBuilder.define;
  function iterateOptions(options, tpl) {
    if (options) {
      if ($.isArray(options)) {
        $.each(options, function(index, entry) {
          if ($.isPlainObject(entry)) {
            $.each(entry, function(key, val) {
              tpl(key, val);
              return false;
            });
          } else {
            tpl(index, entry);
          }
        });
      } else {
        $.each(options, function(key, val) {
          tpl(key, val);
        });
      }
    }
  }
  function fmt(str, args) {
    args = Array.prototype.slice.call(arguments);
    return str.replace(/{([0-9]+)}/g, function(m, i) {
      return args[parseInt(i) + 1];
    });
  }
  $.fn.queryBuilder.define("bt-selectpicker", function(options) {
    if (!$.fn.selectpicker || !$.fn.selectpicker.Constructor) {
      $.error('Bootstrap Select is required to use "bt-selectpicker" plugin. Get it here: http://silviomoreto.github.io/bootstrap-select');
    }
    options = $.extend({container:"body", style:"btn-inverse btn-xs", width:"auto", showIcon:false}, options || {});
    this.on("afterAddRule", function($rule) {
      $rule.find(".rule-filter-container select").selectpicker(options);
    });
    this.on("afterCreateRuleOperators", function($rule) {
      $rule.find(".rule-operator-container select").selectpicker(options);
    });
  });
  $.fn.queryBuilder.define("bt-tooltip-errors", function(options) {
    if (!$.fn.tooltip || !$.fn.tooltip.Constructor || !$.fn.tooltip.Constructor.prototype.fixTitle) {
      $.error('Bootstrap Tooltip is required to use "bt-tooltip-errors" plugin. Get it here: http://getbootstrap.com');
    }
    options = $.extend({placement:"right"}, options || {});
    this.on("ruleTemplate", function(h) {
      return h.replace('class="error-container"', 'class="error-container" data-toggle="tooltip"');
    });
    this.on("validationError", function($target) {
      $target.find(".error-container").eq(0).tooltip(options).tooltip("hide").tooltip("fixTitle");
    });
  });
  $.fn.queryBuilder.defaults.set({mongoOperators:{equal:function(v) {
    return v[0];
  }, not_equal:function(v) {
    return {"$ne":v[0]};
  }, in:function(v) {
    return {"$in":v};
  }, not_in:function(v) {
    return {"$nin":v};
  }, less:function(v) {
    return {"$lt":v[0]};
  }, less_or_equal:function(v) {
    return {"$lte":v[0]};
  }, greater:function(v) {
    return {"$gt":v[0]};
  }, greater_or_equal:function(v) {
    return {"$gte":v[0]};
  }, between:function(v) {
    return {"$gte":v[0], "$lte":v[1]};
  }, begins_with:function(v) {
    return {"$regex":"^" + escapeRegExp(v[0])};
  }, not_begins_with:function(v) {
    return {"$not":{"$regex":"^" + escapeRegExp(v[0])}};
  }, contains:function(v) {
    return {"$regex":escapeRegExp(v[0])};
  }, not_contains:function(v) {
    return {"$not":{"$regex":escapeRegExp(v[0])}};
  }, ends_with:function(v) {
    return {"$regex":escapeRegExp(v[0]) + "$"};
  }, not_ends_with:function(v) {
    return {"$not":{"$regex":escapeRegExp(v[0]) + "$"}};
  }, is_empty:function(v) {
    return "";
  }, is_not_empty:function(v) {
    return {"$ne":""};
  }, is_null:function(v) {
    return null;
  }, is_not_null:function(v) {
    return {"$ne":null};
  }}});
  $.fn.queryBuilder.extend({getMongo:function(data) {
    data = data === undefined ? this.getRules() : data;
    var that = this;
    return function parse(data) {
      if (!data.condition) {
        data.condition = that.settings.default_condition;
      }
      if (["AND", "OR"].indexOf(data.condition.toUpperCase()) === -1) {
        $.error("Unable to build MongoDB query with " + data.condition + " condition");
      }
      if (!data.rules) {
        return {};
      }
      var parts = [];
      $.each(data.rules, function(i, rule) {
        if (rule.rules && rule.rules.length > 0) {
          parts.push(parse(rule));
        } else {
          var mdb = that.settings.mongoOperators[rule.operator], ope = that.getOperatorByType(rule.operator), values = [];
          if (mdb === undefined) {
            $.error("MongoDB operation unknown for operator " + rule.operator);
          }
          if (ope.accept_values) {
            if (!(rule.value instanceof Array)) {
              rule.value = [rule.value];
            }
            rule.value.forEach(function(v, i) {
              values.push(changeType(v, rule.type));
            });
          }
          var part = {};
          part[rule.field] = mdb.call(that, values);
          parts.push(part);
        }
      });
      var res = {};
      res["$" + data.condition.toLowerCase()] = parts;
      return res;
    }(data);
  }});
  function changeType(value, type) {
    switch(type) {
      case "integer":
        return parseInt(value);
      case "double":
        return parseFloat(value);
      default:
        return value;
    }
  }
  function escapeRegExp(str) {
    return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
  }
  $.fn.queryBuilder.defaults.set({default_rule_flags:{no_sortable:false}, icons:{sort:"glyphicon glyphicon-sort"}});
  $.fn.queryBuilder.define("sortable", function(options) {
    this.on("afterInit", function() {
      $.event.props.push("dataTransfer");
      var placeholder, src, that = this;
      this.$el.on("mouseover", ".drag-handle", function() {
        that.$el.find(".rule-container, .rules-group-container").attr("draggable", true);
      });
      this.$el.on("mouseout", ".drag-handle", function() {
        that.$el.find(".rule-container, .rules-group-container").removeAttr("draggable");
      });
      this.$el.on("dragstart", "[draggable]", function(e) {
        e.stopPropagation();
        e.dataTransfer.setData("text", "drag");
        src = $(e.target);
        placeholder = $('<div class="rule-placeholder">&nbsp;</div>');
        placeholder.css("min-height", src.height());
        placeholder.insertAfter(src);
        setTimeout(function() {
          showHide(src, false);
        }, 0);
      });
      this.$el.on("dragenter", "[draggable]", function(e) {
        e.preventDefault();
        e.stopPropagation();
        moveSortableToTarget(placeholder, $(e.target));
      });
      this.$el.on("dragover", "[draggable]", function(e) {
        e.preventDefault();
        e.stopPropagation();
      });
      this.$el.on("drop", function(e) {
        e.preventDefault();
        e.stopPropagation();
        moveSortableToTarget(src, $(e.target));
      });
      this.$el.on("dragend", "[draggable]", function(e) {
        e.preventDefault();
        e.stopPropagation();
        showHide(src, true);
        placeholder.remove();
        src = placeholder = null;
        that.$el.find(".rule-container, .rules-group-container").removeAttr("draggable");
      });
    });
    this.on("afterApplyRuleFlags", function($rule, rule, flags) {
      if (flags.no_sortable) {
        $rule.find(".drag-handle").remove();
      }
    });
    this.on("getGroupTemplate", function(h, level) {
      if (level > 1) {
        var $h = $(h);
        $h.find(".group-conditions").after('<div class="drag-handle"><i class="' + this.icons.sort + '"></i></div>');
        h = $h.prop("outerHTML");
      }
      return h;
    });
    this.on("getRuleTemplate", function(h) {
      var $h = $(h);
      $h.find(".rule-header").after('<div class="drag-handle"><i class="' + this.icons.sort + '"></i></div>');
      return $h.prop("outerHTML");
    });
  });
  function moveSortableToTarget(element, target) {
    var parent;
    parent = target.closest(".rule-container");
    if (parent.length) {
      element.detach().insertAfter(parent);
      return;
    }
    parent = target.closest(".rules-group-header");
    if (parent.length) {
      parent = target.closest(".rules-group-container");
      element.detach().prependTo(parent.find(".rules-list").eq(0));
      return;
    }
    parent = target.closest(".rules-group-container");
    if (parent.length) {
      element.detach().appendTo(parent.find(".rules-list").eq(0));
      return;
    }
  }
  $.fn.queryBuilder.defaults.set({sqlOperators:{equal:"= ?", not_equal:"!= ?", in:{op:"IN(?)", list:true, sep:", "}, not_in:{op:"NOT IN(?)", list:true, sep:", "}, less:"< ?", less_or_equal:"<= ?", greater:"> ?", greater_or_equal:">= ?", between:{op:"BETWEEN ?", list:true, sep:" AND "}, begins_with:{op:"LIKE(?)", fn:function(v) {
    return v + "%";
  }}, not_begins_with:{op:"NOT LIKE(?)", fn:function(v) {
    return v + "%";
  }}, contains:{op:"LIKE(?)", fn:function(v) {
    return "%" + v + "%";
  }}, not_contains:{op:"NOT LIKE(?)", fn:function(v) {
    return "%" + v + "%";
  }}, ends_with:{op:"LIKE(?)", fn:function(v) {
    return "%" + v;
  }}, not_ends_with:{op:"NOT LIKE(?)", fn:function(v) {
    return "%" + v;
  }}, is_empty:'== ""', is_not_empty:'!= ""', is_null:"IS NULL", is_not_null:"IS NOT NULL"}});
  $.fn.queryBuilder.extend({getSQL:function(stmt, nl, data) {
    data = data === undefined ? this.getRules() : data;
    stmt = stmt === true || stmt === undefined ? "question_mark" : stmt;
    nl = nl || nl === undefined ? "\n" : " ";
    var that = this, bind_index = 1, bind_params = [];
    var sql = function parse(data) {
      if (!data.condition) {
        data.condition = that.settings.default_condition;
      }
      if (["AND", "OR"].indexOf(data.condition.toUpperCase()) === -1) {
        $.error("Unable to build SQL query with " + data.condition + " condition");
      }
      if (!data.rules) {
        return "";
      }
      var parts = [];
      $.each(data.rules, function(i, rule) {
        if (rule.rules && rule.rules.length > 0) {
          parts.push("(" + nl + parse(rule) + nl + ")" + nl);
        } else {
          var sql = that.getSqlOperator(rule.operator), ope = that.getOperatorByType(rule.operator), value = "";
          if (sql === false) {
            $.error("SQL operation unknown for operator " + rule.operator);
          }
          if (ope.accept_values) {
            if (!(rule.value instanceof Array)) {
              rule.value = [rule.value];
            } else {
              if (!sql.list && rule.value.length > 1) {
                $.error("Operator " + rule.operator + " cannot accept multiple values");
              }
            }
            rule.value.forEach(function(v, i) {
              if (i > 0) {
                value += sql.sep;
              }
              if (rule.type == "integer" || rule.type == "double") {
                v = changeType(v, rule.type);
              } else {
                if (!stmt) {
                  v = escapeString(v);
                }
              }
              if (sql.fn) {
                v = sql.fn(v);
              }
              if (stmt) {
                if (stmt == "question_mark") {
                  value += "?";
                } else {
                  value += "$" + bind_index;
                }
                bind_params.push(v);
                bind_index++;
              } else {
                if (typeof v === "string") {
                  v = "'" + v + "'";
                }
                value += v;
              }
            });
          }
          parts.push(rule.field + " " + sql.op.replace(/\?/, value));
        }
      });
      return parts.join(" " + data.condition + nl);
    }(data);
    if (stmt) {
      return {sql:sql, params:bind_params};
    } else {
      return {sql:sql};
    }
  }, getSqlOperator:function(type) {
    var sql = this.settings.sqlOperators[type];
    if (sql === undefined) {
      return false;
    }
    if (typeof sql === "string") {
      sql = {op:sql};
    }
    if (!sql.list) {
      sql.list = false;
    }
    if (sql.list && !sql.sep) {
      sql.sep = ", ";
    }
    return sql;
  }});
  function changeType(value, type) {
    switch(type) {
      case "integer":
        return parseInt(value);
      case "double":
        return parseFloat(value);
      default:
        return value;
    }
  }
  function escapeString(value) {
    if (typeof value !== "string") {
      return value;
    }
    return value.replace(/[\0\n\r\b\\\'\"]/g, function(s) {
      switch(s) {
        case "\x00":
          return "\\0";
        case "\n":
          return "\\n";
        case "\r":
          return "\\r";
        case "\b":
          return "\\b";
        default:
          return "\\" + s;
      }
    }).replace(/\t/g, "\\t").replace(/\x1a/g, "\\Z");
  }
  function showHide(elements, show) {
    if (show) {
      jQuery(elements).css("display", "");
    } else {
      jQuery(elements).css("display", "none");
    }
  }
});
Polymer({is:"simpl-filter", behaviors:[StyleScopeBehavior, TranslationsBehavior], searchMode:"simple", isBuilderInitialized:false, searchModeIcon:"expand-more", properties:{namespace:{observer:"namespaceChanged", type:String}, entity:{observer:"entityChanged", type:String}, withCancel:{type:Boolean, value:false}, isInited:{type:Boolean, value:false}, filter:{value:null, notify:true, type:String}}, getSearchModeIcon:function() {
  return this.searchModeIcon;
}, namespaceChanged:function() {
  console.log("filter.namespaceChanged:", this.namespace + "/" + this.entity);
  if (this.entity == null) {
    return;
  }
  this.init();
}, entityChanged:function() {
  console.log("filter.entityChanged:", this.namespace + "/" + this.entity);
  if (this.namespace == null) {
    return;
  }
  this.init();
}, ready:function() {
}, doSearch:function() {
  if (this.entity == null) {
    return;
  }
  this.search();
}, attached:function() {
  if (this.isInited !== true) {
    this.init();
  }
}, init:function() {
  console.debug("Filter.attached.Entity:", this.entity + "/namespace:" + this.namespace);
  if (this.entity == null || this.namespace == null) {
    return;
  }
  var filters = simpl4.util.SearchFilter.createSearchFilter(this.entity, {namespace:this.namespace});
  console.debug("Builder;", this.builder);
  $(this.$.builder).queryBuilder({icons:{add_group:"fa fa-plus-circle", add_rule:"fa fa-plus", remove_group:"fa fa-minus", remove_rule:"fa fa-minus", error:"fa fa-bug", sort:"fa fa-arrows-v"}, sortable:false, display_errors:true, filters:filters, lang:this.getLang()});
  $(this.$.builder).queryBuilder("setRules", {condition:"AND", rules:[{id:filters[0].id, operator:filters[0].operators[0], value:""}]});
  this.isBuilderInitialized = true;
  this.searchMode = "simple";
  this.setSearchMode(this.searchMode);
  this.async(function() {
    this.setStyleScope(this.$.builder, "style-scope", this.tagName.toLowerCase());
  });
  this.isInited = true;
}, renameOne:function(from, to, model) {
  model[to] = model[from];
  delete model[from];
}, deleteOne:function(from, model) {
  delete model[from];
}, connectorToLowerCase:function(model) {
  if (model.connector === undefined) {
    return;
  }
  model.connector = model.connector.toLowerCase();
}, opToSimpl4:function(model) {
  if (model.op === undefined) {
    return;
  }
  model.op = simpl4.util.SearchFilter.mapOpToSimpl4(model.op);
}, renameToSimpl4:function(model) {
  this.renameOne("condition", "connector", model);
  this.connectorToLowerCase(model);
  this.renameOne("value", "data", model);
  this.renameOne("operator", "op", model);
  this.deleteOne("input", model);
  this.deleteOne("type", model);
  this.deleteOne("id", model);
  this.opToSimpl4(model);
  var children = model.rules || [];
  model.children = children;
  delete model.rules;
  if (children.length > 0) {
    for (var i = 0; i < children.length; i++) {
      this.renameToSimpl4(children[i]);
    }
  }
  return model;
}, renameFromSimpl4:function(model, meta) {
  this.renameOne("connector", "condition", model);
  this.renameOne("data", "value", model);
  this.renameOne("op", "operator", model);
  model.input = meta.edittype;
  model.type = meta.datetype;
  model.id = model.field;
  var rules = model.children || [];
  model.rules = rules;
  delete model.children;
  if (rules.length > 0) {
    for (var i = 0; i < rules.length; i++) {
      this.renameFromSimpl4(rules[i], meta);
    }
  }
  return model;
}, getRules:function() {
  return this.renameToSimpl4($(this.$.builder).queryBuilder("getRules"));
}, setRules:function(rules) {
  $(this.$.builder).queryBuilder("setRules", rules);
}, reset:function(e) {
  $(this.$.builder).queryBuilder("reset");
}, loadSearch:function(e) {
}, saveSearch:function(e) {
}, toggleSearchMode:function() {
  this.searchMode = this.searchMode == "complex" ? "simple" : "complex";
  this.setSearchMode(this.searchMode);
  this.searchTooltip = this.searchMode == "complex" ? tr("button.complex-search") : tr("button.simple-search");
}, setSearchMode:function(mode) {
  console.log("setSearchMode:", mode);
  if (this.isBuilderInitialized == false) {
    return;
  }
  if (mode == "complex") {
    this.searchModeIcon = "expand-less";
    Polymer.dom(this.root).querySelector(".rules-group-header").removeAttribute("invisible");
    Polymer.dom(this.root).querySelector(".rule-header").removeAttribute("invisible");
    $(Polymer.dom(this.root).querySelectorAll(".rule-container")).removeAttr("simpleSearch");
    $(Polymer.dom(this.root).querySelectorAll(".rules-group-container")).removeAttr("simpleSearch");
  } else {
    this.searchModeIcon = "expand-more";
    Polymer.dom(this.root).querySelector(".rules-group-header").setAttribute("invisible", "");
    Polymer.dom(this.root).querySelector(".rule-header").setAttribute("invisible", "");
    $(Polymer.dom(this.root).querySelectorAll(".rule-container")).attr("simpleSearch", "");
    $(Polymer.dom(this.root).querySelectorAll(".rules-group-container")).attr("simpleSearch", "");
  }
}, cancel:function(e) {
  this.fire("cancel", {});
}, search:function(e) {
  var event = {name:"filter-changed", data:{entity:this.entity, filter:this.getRules()}};
  var rules = this.getRules();
  rules.entity = this.entity;
  console.log("Filter.namespace:", this.namespace);
  rules.namespace = this.namespace;
  this.set("filter", rules);
}, getLang:function() {
  return {"add_rule":tr("querybuilder.add_rule"), "add_group":tr("querybuilder.add_group"), "delete_rule":tr("querybuilder.delete_rule"), "delete_group":tr("querybuilder.delete_group"), "condition_and":tr("querybuilder.condition_and"), "condition_or":tr("querybuilder.condition_or"), "filter_select_placeholder":tr("querybuilder.filter_select_placeholder"), "operators":{"equal":tr("querybuilder.equal"), "not_equal":tr("querybuilder.not_equal"), "in":tr("querybuilder.in"), "not_in":tr("querybuilder.not_in"), 
  "less":tr("querybuilder.less"), "less_or_equal":tr("querybuilder.less_or_equal"), "greater":tr("querybuilder.greater"), "greater_or_equal":tr("querybuilder.greater_or_equal"), "begins_with":tr("querybuilder.begins_with"), "not_begins_with":tr("querybuilder.not_begins_with"), "contains":tr("querybuilder.contains"), "not_contains":tr("querybuilder.not_contains"), "ends_with":tr("querybuilder.ends_with"), "not_ends_with":tr("querybuilder.not_ends_with"), "is_empty":tr("querybuilder.is_empty"), "is_not_empty":tr("querybuilder.is_not_empty"), 
  "is_null":tr("querybuilder.is_null"), "is_not_null":tr("querybuilder.is_not_null")}};
}});
Polymer({is:"simpl-embeddedlist", behaviors:[Polymer.IronA11yKeysBehavior, DialogBehavior, TranslationsBehavior], properties:{namespace:{value:null, type:String}, entity:{value:null, type:String}, mode:{value:"add", type:String}, height:{value:"150", type:String}, buttons:{value:"save,add,del,edit,cancel", type:String}, buttonList:{type:String}}, observers:["buttonsChanged(buttons)", "heightChanged(height)", "entityChanged(entity,namespace)"], buttonsChanged:function() {
  var buttons = {add:{action:this.addAction, icon:"add", position:"global", text:tr("button.new"), disabled:false}, edit:{action:this.editAction, icon:"create", position:"global", text:tr("button.edit"), disabled:true}, del:{action:this.delAction, icon:"delete", position:"global", text:tr("button.del"), disabled:true}, save:{action:this.saveAction, icon:"undo", position:"form", text:tr("button.take_over"), disabled:false}, cancel:{action:this.cancelAction, icon:"cancel", position:"form", text:tr("button.cancel"), 
  disabled:false}};
  this.buttonDef = buttons;
  var bList = [];
  this.buttons.split(",").forEach(function(name) {
    var b = buttons[name];
    b.name = name;
    bList.push(b);
  }.bind(this));
  this.buttonList = bList;
}, heightChanged:function() {
  console.log("embeddedlist.height:" + this.height);
  this.dataTablesOptions = {paging:false, dom:"ft", scrollY:this.height + "px"};
  this.data = [];
}, getData:function() {
  return this.data;
}, setData:function(data) {
  this.data = data;
}, setButtonState:function(name, enabled) {
  if (this.buttonDef == null) {
    return;
  }
  this.buttonDef[name].disabled = !enabled;
  for (var i = 0; i < this.buttonList.length; i++) {
    if (this.buttonList[i].name == name) {
      this.set("buttonList." + i + ".disabled", !enabled);
    }
  }
}, isGlobalButton:function(b) {
  console.log("isGlobalButton:", b.position);
  return b.position == "global";
}, isFormButton:function(b) {
  console.log("isFormButton:", b.position);
  return b.position == "form";
}, onTap:function(e) {
  var src = e.srcElement || e.target;
  var name = null;
  while (src) {
    name = src.getAttribute("name");
    if (name) {
      break;
    }
    src = src.parentElement;
  }
  if (name == null) {
    return;
  }
  this.buttonDef[name].action.call(this);
}, onRowSelected:function(e) {
  this.currentData = e.detail.rows[0];
  this.setButtonState("edit", true);
  this.setButtonState("del", true);
  if (!e.detail.doubleTap) {
    return;
  }
  this.editAction();
}, addAction:function() {
  this.entityName = this.entity;
  console.log("embeddedlist.entity:", this.entity);
  this.mode = "add";
  this.$.formid.setData({});
  this.async(function() {
    this.openDialog(this.$.formDialog);
  }, 50);
}, editAction:function() {
  this.mode = "edit";
  this.$.formid.setData(this.currentData);
  this.async(function() {
    this.openDialog(this.$.formDialog);
  }, 50);
}, delAction:function() {
  this.setButtonState("del", false);
  this.mode = "del";
  this._saveAction();
}, onDeleteOk:function(e) {
  console.log("deleteok:", e);
  this._saveAction();
}, cancelAction:function(e) {
  this.closeDialog(this.$.formDialog);
}, saveAction:function() {
  var form = this.$.formid;
  if (!form.validate()) {
    return;
  }
  this._saveAction();
}, _saveAction:function() {
  this.setButtonState("edit", false);
  this.setButtonState("del", false);
  this.cancelAction();
  var form = this.$.formid;
  var chgData = form.getData();
  var oldData = clone(this.data) || [];
  this.data = [];
  if (this.mode == "add") {
    chgData._id = this.guid();
    oldData.push(chgData);
  } else {
    if (this.mode == "del") {
      chgData = this.currentData;
      var index = _.findIndex(oldData, function(o) {
        return o._id == chgData._id;
      });
      oldData.splice(index, 1);
    } else {
      var index = _.findIndex(oldData, function(o) {
        return o._id == chgData._id;
      });
      simpl4.util.Merge.merge(false, oldData[index], chgData);
    }
  }
  this.async(function() {
    this.data = oldData;
    this.fire("changed", {data:this.data});
  }, 150);
}, entityChanged:function() {
  this.getColumns(this.entity);
  this._pack = this.getPackFromEntity(this.entity);
  this.setFormSpec(this.namespace, this.entity);
}, setFormSpec:function(namespace, entity) {
  if (namespace === this.prevNamespace && entity === this.prevEntityName) {
    return;
  }
  this.currentNamespace = namespace;
  var formSpec = simpl4FormManager.getCrudForm(entity, namespace);
  this.prevEntityName = entity;
  this.prevNamespace = namespace;
  if (typeof formSpec === "string") {
    this.formName = formSpec;
  } else {
    this.formSpec = [formSpec];
  }
}, getColumns:function(entity) {
  console.log("getColumns:", entity + "/" + this.namespace);
  try {
    var em = simpl4.util.EntityManager;
    var data = em.getEntityViewFields(entity, this.namespace, "main-grid", false);
    var colModel = em.buildColModel(data, this.namespace, entity, "search");
    this._buildMeta(colModel, entity);
  } catch (e) {
    console.error("getSelectableFields:", e);
    return;
  }
  return colModel;
}, _buildMeta:function(colModel, entity) {
  simpl4.util.MessageManager.installMessages(this.namespace);
  this.fieldmap = {};
  var columns = new Array;
  for (var f = 0; f < colModel.length; f++) {
    var col = colModel[f];
    if (col.id != "id") {
      var fd = {};
      fd.label = tr(this.getPackFromEntity(entity) + "." + this.getSimpleEntityName(entity) + "." + col.id);
      fd.title = fd.label;
      fd["data"] = col.name;
      columns.push(fd);
    }
  }
  console.debug("embeddedlist.meta:", columns);
  this.meta = columns;
}, getPackFromEntity:function(entity) {
  if (entity.indexOf(":") >= 0) {
    return entity.split(":")[0];
  }
  return "data";
}, getSimpleEntityName:function(entity) {
  if (entity.indexOf(":") >= 0) {
    return entity.split(":")[1];
  }
  return entity;
}, guid:function() {
  var firstPart = Math.random() * 46656 | 0;
  var secondPart = Math.random() * 46656 | 0;
  firstPart = ("000" + firstPart.toString(36)).slice(-3);
  secondPart = ("000" + secondPart.toString(36)).slice(-3);
  return firstPart + secondPart;
}, getToast:function() {
  var t = document.querySelector("#toastGlobal");
  if (t == null) {
    t = this.querySelector("#toastId");
  }
  return t;
}});
Polymer({is:"simpl-linkedlist", behaviors:[Polymer.IronA11yKeysBehavior, DialogBehavior, TranslationsBehavior], properties:{namespace:{value:null, type:String}, entity:{value:null, type:String}, height:{value:"150", type:String}, buttons:{value:"select,del", type:String}, buttonList:{type:String}}, observers:["buttonsChanged(buttons)", "heightChanged(height)", "entityChanged(entity,namespace)"], buttonsChanged:function() {
  var buttons = {select:{action:this.openSelectDialog, icon:"add", text:tr("button.select"), disabled:false}, del:{action:this.delAction, icon:"delete", text:tr("button.del"), disabled:true}};
  this.buttonDef = buttons;
  var bList = [];
  this.buttons.split(",").forEach(function(name) {
    var b = buttons[name];
    b.name = name;
    bList.push(b);
  }.bind(this));
  this.buttonList = bList;
}, heightChanged:function() {
  console.log("linkedlist.height:" + this.height);
  this.dataTablesOptions = {paging:false, dom:"ft", scrollY:this.height + "px"};
  this.data = [];
}, getData:function() {
  return this.data;
}, setData:function(data) {
  this.data = data;
}, setButtonState:function(name, enabled) {
  if (this.buttonDef == null) {
    return;
  }
  this.buttonDef[name].disabled = !enabled;
  for (var i = 0; i < this.buttonList.length; i++) {
    if (this.buttonList[i].name == name) {
      this.set("buttonList." + i + ".disabled", !enabled);
    }
  }
}, onTap:function(e) {
  var src = e.srcElement || e.target;
  var name = null;
  while (src) {
    name = src.getAttribute("name");
    if (name) {
      break;
    }
    src = src.parentElement;
  }
  if (name == null) {
    return;
  }
  this.buttonDef[name].action.call(this);
}, onRowSelected:function(e) {
  this.currentData = e.detail.rows[0];
  this.setButtonState("del", true);
}, openSelectDialog:function() {
  this.entityName = this.entity;
  console.log("linkedlist.selectOpenAction:", this.entity);
  this.$.filterId.doSearch();
  this.async(function() {
    this.openDialog(this.$.selectDialog);
  }, 250);
}, rowsSelected:function(e) {
  if (!e.detail.doubleTap) {
    return;
  }
  this.setButtonState("del", false);
  console.log("linkedlist.selectAction:", e.detail);
  var data = e.detail.rows[0];
  this.changeData("select", data);
}, delAction:function() {
  this.setButtonState("del", false);
  this.changeData("del", this.currentData);
}, changeData:function(mode, chgData) {
  this.closeDialog(this.$.selectDialog);
  var oldData = clone(this.data) || [];
  this.data = [];
  if (mode == "select") {
    var index = _.findIndex(oldData, function(o) {
      return o._id == chgData._id;
    });
    if (index < 0) {
      oldData.push(chgData);
    }
  } else {
    if (mode == "del") {
      var index = _.findIndex(oldData, function(o) {
        return o._id == chgData._id;
      });
      oldData.splice(index, 1);
    }
  }
  this.async(function() {
    this.data = oldData;
    this.fire("changed", {data:this.data});
  }, 150);
}, selectCancelAction:function(e) {
  this.setButtonState("del", false);
  this.closeDialog(this.$.selectDialog);
}, entityChanged:function() {
  this.getColumns(this.entity);
  this._pack = this.getPackFromEntity(this.entity);
}, getColumns:function(entity) {
  console.log("getColumns:", entity + "/" + this.namespace);
  try {
    var em = simpl4.util.EntityManager;
    var data = em.getEntityViewFields(entity, this.namespace, "main-grid", false);
    colModel = em.buildColModel(data, this.namespace, entity, "search");
    this._buildMeta(colModel, entity);
  } catch (e) {
    console.error("getSelectableFields:", e);
    return;
  }
  return colModel;
}, _buildMeta:function(colMode, entity) {
  simpl4.util.MessageManager.installMessages(this.namespace);
  this.fieldmap = {};
  var columns = new Array;
  for (var f = 0; f < colModel.length; f++) {
    var col = colModel[f];
    if (col.id != "id") {
      var fd = {};
      fd.label = tr(this.getPackFromEntity(entity) + "." + this.getSimpleEntityName(entity) + "." + col.id);
      fd.title = fd.label;
      fd["data"] = col.name;
      columns.push(fd);
    }
  }
  console.debug("linkedlist.meta:", columns);
  this.meta = columns;
}, getHelp:function() {
  return tr("crud2.select_with");
}, getHeader:function(entityName) {
  return tr(this.getPackFromEntity(this.entity) + "." + this.getSimpleEntityName(entityName));
}, getPackFromEntity:function(entity) {
  if (entity.indexOf(":") >= 0) {
    return entity.split(":")[0];
  }
  return "data";
}, getSimpleEntityName:function(entity) {
  if (entity.indexOf(":") >= 0) {
    return entity.split(":")[1];
  }
  return entity;
}});
Polymer({is:"simpl-crud", behaviors:[Polymer.IronA11yKeysBehavior, LobiboxBehavior, TranslationsBehavior], properties:{namespace:{type:String}, filterName:{value:null, type:String}, autoSearch:{value:false, type:Boolean}, entity:{type:String}, withPanel:{type:Object, value:true}, saveDisabled:{type:Boolean, value:true}, buttonList:{type:String, value:"add,edit,copy,detail"}, buttonListDetail:{type:String, value:"add,edit,copy"}, pageSelected:{type:Number, value:0}, selectedDetailsTabId:{type:String, 
observer:"selectedDetailsTabIdChanged"}, pressed:{type:String, readOnly:true, value:""}, showHeader:{type:Boolean, value:false}, noCarriageReturn:{type:Boolean, value:false}, boundKeys:{type:Array, value:function() {
  return Object.keys(this.keyBindings).join(" ").split(" ");
}}, preventDefault:{type:Boolean, value:true, notify:true}, keyEventTarget:{type:Object, value:function() {
  return this;
}}}, keyBindings:{"enter":"_enterPressed"}, _enterPressed:function() {
  console.log("_enterPressedCrud:", this.saveDisabled);
  console.log("_pageSelected:", this.pageSelected);
  if (this.pageSelected == 0 || this.noCarriageReturn || this.saveDisabled === true) {
    return;
  }
  this.saveAction();
}, onError:function(e) {
  console.log("exceptionCrud:", e);
  this.fire("error", e.detail);
}, attached:function() {
  if (this.initialized != true) {
    this.init();
    if (this.autoSearch) {
      this.async(function() {
        this.querySelector("#filterId").doSearch();
      }, 200);
    }
  }
}, init:function() {
  this.selectedDetailsTabId = "detailsMainTabId";
  this.entryAnimation = "slide-from-left-animation";
  this.exitAnimation = "slide-left-animation";
  if (this.namespace && this.namespace != simpl4.util.BaseManager.getNamespace()) {
    simpl4MessageManager.installMessages(this.namespace);
  }
  this.mainEntityName = this.entity;
  var ep = this.getPack(this.mainEntityName);
  this._pack = ep.pack;
  this.panelHeaderCrudTable = tr(ep.pack + "." + ep.entityName + "_list");
  this.pageStack = new Array;
  this.pageSelected = 0;
  this.initialized = true;
}, setFormSpec:function(namespace, entity) {
  if (namespace === this.prevNamespace && entity === this.prevEntityName) {
    return;
  }
  this.currentNamespace = namespace;
  var formSpec = simpl4FormManager.getCrudForm(entity, namespace);
  console.debug("setFormSpec:", formSpec);
  this.prevEntityName = entity;
  this.prevNamespace = namespace;
  if (typeof formSpec === "string") {
    this.formName = formSpec;
  } else {
    this.formSpec = [formSpec];
  }
}, getFormSpec:function(item) {
  return [simpl4FormManager.getCrudForm(item.entity, item.namespace || this.namespace)];
}, getEditMode:function() {
  return "edit";
}, selectedDetailsTabIdChanged:function(e) {
  var ct = this.$.ironPages.querySelector("#" + this.selectedDetailsTabId);
  if (ct == null) {
    return;
  }
  var dataDesc = ct.dataDesc;
  dataDesc.namespace = this.namespace;
  if (dataDesc.type == "table") {
    ct.filter = dataDesc;
  } else {
    ct.setData(clone(this.getFormData(dataDesc)));
  }
}, cancelAction:function(e) {
  this.prevNextButtonsInvisible = true;
  var prevPage = this.pageStack.pop();
  console.log("CancelAction:" + prevPage);
  if (this.needRefresh) {
    this.needRefresh = false;
    setTimeout(function() {
      this.pageSelected = prevPage;
      if (this.currentTable) {
        this.currentTable.refresh();
      }
    }.bind(this), 100);
  } else {
    this.async(function() {
      this.pageSelected = prevPage;
    }, 100);
  }
}, copyAction:function(e) {
  this.prevNextButtonsInvisible = true;
  var detail = e.detail;
  this.mode = "add";
  this.pageStack.push(this.pageSelected);
  console.log("copyAction:", detail);
  this.setFormSpec(detail.namespace, detail.entity);
  this.currentEntityName = detail.entity;
  this.currentEntityChildName = detail.entityChild;
  if (this.loadBeforeEdit()) {
    this.currentRowData = this.getData(detail.data);
  } else {
    this.currentRowData = detail.data;
  }
  this.currentTable = detail.table;
  var ep = this.getPack(detail.entity);
  this.panelHeaderCrudForm = tr(ep.pack + "." + ep.entityName);
  this.whenElementsReady(function() {
    console.debug("Ready");
    this.$.formid.setData(clone(this.currentRowData));
    this.pageSelected = 1;
  }.bind(this));
}, prevAction:function(e) {
  if (this.currentRowIndex > 0) {
    this.currentRowIndex--;
    if (this.loadBeforeEdit()) {
      this.currentRowData = this.getData(this.currentDataSet[this.currentRowIndex]);
    } else {
      this.currentRowData = this.currentDataSet[this.currentRowIndex];
    }
    if (Detectizr.browser.name == "firefox") {
      this.$.formid.clearData();
      this.async(function() {
        this.$.formid.setData(clone(this.currentRowData));
      }, 10);
    } else {
      this.$.formid.setData(clone(this.currentRowData));
    }
  }
  this.handlePrevNextButtons();
}, nextAction:function(e) {
  if (this.currentRowIndex < this.currentDataSet.length - 1) {
    this.currentRowIndex++;
    if (this.loadBeforeEdit()) {
      this.currentRowData = this.getData(this.currentDataSet[this.currentRowIndex]);
    } else {
      this.currentRowData = this.currentDataSet[this.currentRowIndex];
    }
    if (Detectizr.browser.name == "firefox") {
      this.$.formid.clearData();
      this.async(function() {
        this.$.formid.setData(clone(this.currentRowData));
      }, 10);
    } else {
      this.$.formid.setData(clone(this.currentRowData));
    }
  }
  this.handlePrevNextButtons();
}, editAction:function(e) {
  var detail = e.detail;
  this.mode = "edit";
  this.pageStack.push(this.pageSelected);
  console.log("editAction:", detail);
  this.setFormSpec(detail.namespace, detail.entity);
  this.currentEntityName = detail.entity;
  this.currentEntityChildName = detail.entityChild;
  var props = simpl4.util.EntityManager.getEntityViewProperties(detail.entity, "main-form", {namespace:detail.namespace});
  if (props.loadBeforeEdit) {
    this.currentRowData = this.getData(detail.data);
  } else {
    this.currentRowData = detail.data;
  }
  this.currentTable = detail.table;
  this.currentDataSet = detail.dataSet;
  this.currentRowIndex = detail.rowIndex;
  console.log("currentRowData:", this.currentRowData);
  this.prevNextButtonsInvisible = null;
  this.handlePrevNextButtons();
  var ep = this.getPack(detail.entity);
  this.panelHeaderCrudForm = tr(ep.pack + "." + ep.entityName);
  this.$.formid.setData(clone(this.currentRowData));
  this.whenElementsReady(function() {
    this.pageSelected = 1;
  }.bind(this));
}, rowsSelected:function(e) {
  console.log("rowsSelected:", e.detail);
  if (!e.detail.doubleTap) {
    return;
  }
  var crud = this.querySelector("#crudTableId");
  var data = e.detail.rows[0];
  var detail = {data:data, dataSet:crud.dataSet, rowIndex:crud.currentRowIndex, table:crud, entity:this.entity, namespace:this.namespace};
  this.editAction({detail:detail});
}, refreshAction:function(e) {
  var detail = e.detail;
  console.log("refreshAction:", detail);
  detail.table.refresh();
}, delAction:function(e) {
  var detail = e.detail;
  console.log("delAction:", detail);
  this.currentTable = detail.table;
  Lobibox.confirm({msg:tr("entitytypes.confirm_delete"), title:"&nbsp;", callback:function($this, type) {
    if (type === "yes") {
      this.mode = "del";
      this.onDeleteOk(e);
    } else {
      if (type === "no") {
      }
    }
  }.bind(this)});
}, onDeleteOk:function(e) {
  console.log("deleteok:", e);
  try {
    this.deleteData(e.detail.data);
    this.async(function() {
      if (this.currentTable) {
        this.currentTable.refresh();
      }
    }, 100);
    this.notify(tr("entitytypes.deleted"), "success", "5000");
  } catch (e$6) {
    console.error("delAction:", e$6);
    var msg = null;
    if (e$6.message) {
      msg = e$6.message;
    } else {
      msg = e$6.toString();
    }
    this.notify(msg, "error", "10000");
    return;
  }
}, _addAction:function(e) {
  var e = {detail:{namespace:this.namespace, entityChild:"", entity:this.entity}};
  this.addAction(e);
}, addAction:function(e) {
  this.prevNextButtonsInvisible = true;
  var detail = e.detail;
  this.mode = "add";
  this.pageStack.push(this.pageSelected);
  console.log("addAction:", detail);
  this.setFormSpec(detail.namespace, detail.entity);
  this.currentEntityName = detail.entity;
  this.currentEntityChildName = detail.entityChild;
  this.currentTable = detail.table;
  var ep = this.getPack(detail.entity);
  this.panelHeaderCrudForm = tr(ep.pack + "." + ep.entityName);
  this.$.formid.setData({});
  this.whenElementsReady(function() {
    this.pageSelected = 1;
  }.bind(this));
}, detailAction:function(e) {
  console.log("detailAction:", e.detail);
  console.log("detailAction:", this.$.detailsOverviewId);
  var currentRowData = e.detail.data;
  this.$.detailsOverviewId.setData(e.detail.data);
  var props = simpl4EntityManager.getPropertiesForEntity(this.mainEntityName, {namespace:this.namespace});
  this.panelHeaderDetails = this._maskedEval(props.title_expression, currentRowData, "");
  var mainEntity = simpl4EntityManager.getEntity(this.mainEntityName, this.namespace);
  this.mainEntityId = this.getIdValue(this.mainEntityName, this.namespace, currentRowData);
  var entityChildList = [];
  for (var i = 0; i < mainEntity.childs.length; i++) {
    var c = mainEntity.childs[i];
    var cn = {};
    if (c.modulename == "team") {
      continue;
    }
    cn.entity = c.modulename;
    cn.namespace = c.namespace;
    cn.title = tr("data." + c.name);
    cn.id = c.name;
    cn.buttonListDetail = this.buttonListDetail;
    cn.rpc = {storeId:this.namespace + "_data", entity:this.mainEntityName, entityChild:c.name, id:currentRowData.id, pageSize:0};
    var datatype = c.datatype.split("/");
    cn.type = datatype[0] == "list" ? "table" : "form";
    cn.dependent = c.dependent;
    entityChildList.push(cn);
  }
  this.entityChildList = entityChildList;
  this.pageStack.push(this.pageSelected);
  this.async(function() {
    this.pageSelected = 2;
  }, 100);
}, storeData:function(data) {
  var props = simpl4.util.EntityManager.getPropertiesForEntity(this.entity, {namespace:this.namespace});
  var customServiceUpdate = props.customServiceUpdate;
  var customServiceInsert = props.customServiceInsert;
  var mode = this.mode;
  if (mode == "add" && customServiceInsert) {
    return this._storeDataCustom(data, customServiceInsert);
  } else {
    if (mode == "edit" && customServiceUpdate) {
      return this._storeDataCustom(data, customServiceUpdate);
    } else {
      return this._storeData(data);
    }
  }
}, _storeData:function(data) {
  var rpc = null;
  var ep = this.getPack(this.mainEntityName);
  if (this.mainEntityName != this.currentEntityName) {
    rpc = {storeId:(this.namespace || simpl4.util.BaseManager.getNamespace()) + "_" + ep.pack, entity:ep.entityName, entityChild:this.currentEntityChildName, id:this.mainEntityId, idChild:this.getIdValue(this.mainEntityName, this.namespace, data), data:data};
  } else {
    var idValue = this.getIdValue(this.mainEntityName, this.namespace, data);
    console.log("storeData.idValue:", idValue);
    rpc = {storeId:(this.namespace || simpl4.util.BaseManager.getNamespace()) + "_" + ep.pack, entity:ep.entityName, id:idValue, data:data};
  }
  console.log("rpc:", rpc);
  var ret = simpl4.util.Rpc.rpcSync("data:" + (this.mode == "add" ? "insert" : "update"), rpc);
  return ret;
}, _storeDataCustom:function(data, customService) {
  if (customService.indexOf(":") == -1) {
    customService = "camelRoute:" + customService;
  }
  if (customService.indexOf(".") == -1) {
    var x = customService.split(":");
    customService = x[0] + ":" + this.namespace + "." + x[1];
  }
  var rpc = null;
  var ep = this.getPack(this.mainEntityName);
  if (this.mainEntityName != this.currentEntityName) {
    rpc = {storeId:(this.namespace || simpl4.util.BaseManager.getNamespace()) + "_" + ep.pack, entity:ep.entityName, entityChild:this.currentEntityChildName, id:this.mainEntityId, idChild:this.getIdValue(this.mainEntityName, this.namespace, data), data:data};
  } else {
    var idValue = this.getIdValue(this.mainEntityName, this.namespace, data);
    console.log("idValue:", idValue);
    rpc = {storeId:(this.namespace || simpl4.util.BaseManager.getNamespace()) + "_" + ep.pack, entity:ep.entityName, id:idValue, data:data};
  }
  if (window.uuid) {
    rpc.uuid = window.uuid;
  }
  var ret = simpl4.util.Rpc.rpcSync(customService, rpc);
  return ret;
}, deleteData:function(data) {
  var ep = this.getPack(this.mainEntityName);
  var rpc = {storeId:(this.namespace || simpl4.util.BaseManager.getNamespace()) + "_" + ep.pack, entity:ep.entityName, id:this.getIdValue(this.mainEntityName, this.namespace, data)};
  console.log("rpc.delete:", rpc);
  var ret = simpl4.util.Rpc.rpcSync("data:delete", rpc);
  return ret;
}, getData:function(data) {
  var ep = this.getPack(this.currentEntityName);
  var idValue = this.getIdValue(this.currentEntityName, this.namespace, data);
  var rpc = {storeId:(this.namespace || simpl4.util.BaseManager.getNamespace()) + "_" + ep.pack, entity:ep.entityName, id:idValue};
  var ret = simpl4.util.Rpc.rpcSync("data:queryOne", rpc);
  return ret;
}, getPack:function(en) {
  var p = "data";
  var e = en;
  if (en && en.indexOf(":") > 0) {
    p = en.split(":")[0];
    e = en.split(":")[1];
  }
  return {entityName:e, pack:p};
}, getIdValue:function(entityName, namespace, data) {
  console.log("getIdValue:", entityName + "/", data);
  var pkList = simpl4.util.EntityManager.getEntity(entityName, namespace).primaryKeys;
  if (pkList == null || pkList.length === 0) {
    if (data["_id"] != null) {
      pkList = ["_id"];
    } else {
      pkList = ["id"];
    }
  }
  var idValue = "";
  var colon = "";
  for (var i = 0; i < pkList.length; i++) {
    var val = data[pkList[i]] || "";
    idValue += colon + val;
    colon = ":";
  }
  return idValue;
}, saveAction:function() {
  var postServiceData = this.$.formid._postProcessService();
  var data = this.$.formid.getData();
  if (postServiceData != null) {
    this.$.formid._setFieldData(postServiceData);
    data = simpl4.util.Merge.merge(true, data, postServiceData);
  }
  var postLocalService = this.$.formid._postProcessLocal();
  if (postLocalService != null) {
    this.$.formid._setFieldData(postLocalService);
    data = simpl4.util.Merge.merge(true, data, postLocalService);
  }
  var valid = this.$.formid.validate();
  console.log("saveAction.valid(" + valid + "):", data);
  if (!valid) {
    var msg = tr("widgets.table.form_incomplete");
    this.notify(msg, "error", "10000");
    return;
  } else {
    try {
      if (this.mode == "edit") {
        data = simpl4.util.Merge.merge(true, this.currentRowData, data);
      }
      console.log("saveAction.storeData:", data);
      var ret = this.storeData(data);
      var content = ret;
      var cv = ret["constraintViolations"];
      if (cv) {
        var message = "";
        for (var i = 0; i < cv.length; i++) {
          var c = cv[i];
          var msg = c.message;
          if (msg && msg.match(/^[@%].*/)) {
            msg = tr(msg.substring(1));
          }
          message += this.$.formid._getLabel(c.path) + " : " + msg + "<br />";
        }
        this.alert(message);
      } else {
        var msg = "";
        if (this.mode == "add") {
          msg = tr("data.form.created");
        } else {
          msg = tr("data.form.saved");
        }
        this.notify(msg, "success", "10000");
        this.needRefresh = true;
        if (this.mode == "add") {
          this.cancelAction();
        }
        if (this.mode == "edit" && this.loadBeforeEdit() == false) {
          simpl4.util.Merge.merge(false, this.currentRowData, data);
          console.log("merged:", JSON.stringify(this.currentRowData, null, 2));
        }
      }
    } catch (e) {
      console.error("saveAction:", e);
      var msg = null;
      if (e.message) {
        msg = e.message;
      } else {
        var m = e.toString();
        msg = m.substring(m.indexOf("entityName:") + 11);
        msg = tr("data.form.save") + ": (" + msg + ")";
      }
      this.notify(msg, "error", "10000");
      return;
    }
  }
}, handlePrevNextButtons:function() {
  if (!this.prevNextButtonsInvisible) {
    this.$.nextButton.disabled = this.currentRowIndex < this.currentDataSet.length - 1 ? false : true;
    this.$.prevButton.disabled = this.currentRowIndex > 0 ? false : true;
  }
}, isForm:function(item) {
  return item.type == "form";
}, isTable:function(item) {
  return item.type == "table";
}, loadBeforeEdit:function() {
  var props = simpl4.util.EntityManager.getEntityViewProperties(this.entity, "main-form", {namespace:this.namespace});
  return props.loadBeforeEdit === true;
}, getFormData:function(dataDesc) {
  var props = simpl4.util.EntityManager.getEntityViewProperties(dataDesc.entity, "main-form", {namespace:dataDesc.namespace});
  var data = simpl4.util.Rpc.rpcSync("data:query", dataDesc.rpc);
  return data.rows.length > 0 ? data.rows[0] : {};
}, _maskedEval:function(scr, env, def) {
  try {
    return (new Function("with(this) { return " + scr + "}")).call(env);
  } catch (e) {
    console.log("Crud._maskedEval:" + scr);
    console.error("error:" + e);
  }
  return def;
}, whenElementsReady:function(done) {
  this.async(function() {
    done();
  }, 50);
}, getHelp:function() {
  return tr("crud2.select_with");
}, alert:function(message) {
  this.querySelector("#error p").innerHTML = message;
  this.querySelector("#error").open();
}});
Polymer({is:"simpl-crud2", behaviors:[Polymer.IronA11yKeysBehavior, LobiboxBehavior, DialogBehavior, TranslationsBehavior], properties:{namespace:{type:String}, mode:{value:"add", type:String}, buttons:{value:"save,add,del,search", type:String}, entity:{type:String}, buttonList:{value:null, type:Array}}, observers:["buttonsChanged(isAttached)", "entityChanged(entity)"], attached:function() {
  this.isAttached = true;
}, buttonsChanged:function() {
  var buttons = {add:{action:this.addAction, icon:"add", text:tr("button.new"), disabled:false}, del:{action:this.delAction, icon:"delete", text:tr("button.del"), disabled:true}, save:{action:this.saveAction, icon:"save", text:tr("button.save"), disabled:false}, search:{action:this.searchAction, icon:"search", text:tr("button.select"), disabled:false}};
  this.buttonDef = buttons;
  var bList = [];
  this.buttons.split(",").forEach(function(name) {
    var b = buttons[name];
    b.name = name;
    bList.push(b);
  }.bind(this));
  this.set("buttonList", bList);
}, setButtonState:function(name, enabled) {
  if (this.buttonDef == null) {
    return;
  }
  this.buttonDef[name].disabled = !enabled;
  for (var i = 0; i < this.buttonList.length; i++) {
    if (this.buttonList[i].name == name) {
      this.set("buttonList." + i + ".disabled", !enabled);
    }
  }
}, onTap:function(e) {
  var src = e.srcElement || e.target;
  var name = null;
  while (src) {
    name = src.getAttribute("name");
    if (name) {
      break;
    }
    src = src.parentElement;
  }
  if (name == null) {
    return;
  }
  this.buttonDef[name].action.call(this);
}, addAction:function(noEvent) {
  this.mode = "add";
  this.setButtonState("save", true);
  this.setButtonState("del", false);
  this.$.formid.setData({});
  if (noEvent !== true) {
    this.fire("add-action", {entity:this.entity, namespace:this.namespace});
  }
}, searchAction:function() {
  this.entityName = this.entity;
  this.$.filterId.doSearch();
  this.async(function() {
    this.openDialog(this.$.searchDialog);
  }, 200);
  this.fire("search-action", {entity:this.entity, namespace:this.namespace});
}, delAction:function() {
  Lobibox.confirm({msg:tr("entitytypes.confirm_delete"), title:"&nbsp;", callback:function($this, type) {
    if (type === "yes") {
      this.mode = "del";
      this.setButtonState("del", false);
      this.onDeleteOk({detail:this.currentData});
      this.fire("del-action", {entity:this.entity, namespace:this.namespace});
    } else {
      if (type === "no") {
      }
    }
  }.bind(this)});
}, onDeleteOk:function(e) {
  console.log("deleteok:", e);
  try {
    this.deleteData(e.detail);
    this.notify(tr("entitytypes.deleted"), "success", "5000");
    this.addAction(true);
  } catch (e$7) {
    console.error("delAction:", e$7);
    var msg = null;
    if (e$7.message) {
      msg = e$7.message;
    } else {
      msg = e$7.toString();
    }
    this.notify(msg, "error", "10000");
    return;
  }
}, selectCancelAction:function() {
  this.async(function() {
    this.closeDialog(this.$.searchDialog);
  }, 50);
}, selectAction:function(e) {
  this.setButtonState("del", true);
  this.mode = "edit";
  var data = e.detail.data;
  console.log("selectAction:", e);
  this.closeDialog(this.$.searchDialog);
  this.currentData = clone(data);
  this.$.formid.setData(this.currentData);
}, rowsSelected:function(e) {
  console.log("rowsSelected:", e.detail);
  if (!e.detail.doubleTap) {
    return;
  }
  this.setButtonState("del", true);
  this.mode = "edit";
  var data = e.detail.rows[0];
  this.closeDialog(this.$.searchDialog);
  this.currentData = clone(data);
  this.$.formid.setData(this.currentData);
}, saveAction:function() {
  if (this._saveAction()) {
    this.addAction(true);
  }
}, _saveAction:function() {
  var postServiceData = this.$.formid._postProcessService();
  var data = this.$.formid.getData();
  if (postServiceData != null) {
    this.$.formid._setFieldData(postServiceData);
    data = simpl4.util.Merge.merge(true, data, postServiceData);
  }
  var postLocalService = this.$.formid._postProcessLocal();
  if (postLocalService != null) {
    this.$.formid._setFieldData(postLocalService);
    data = simpl4.util.Merge.merge(true, data, postLocalService);
  }
  var valid = this.$.formid.validate();
  console.log("saveAction.valid(" + valid + "):", data);
  if (!valid) {
    var msg = tr("widgets.table.form_incomplete");
    this.notify(msg, "error", "10000");
    return false;
  } else {
    try {
      if (this.mode == "edit") {
      }
      console.log("saveAction.storeData:", data);
      var ret = this.storeData(data);
      console.log("ret:", ret);
      var cv = ret["constraintViolations"];
      if (cv) {
        var message = "";
        for (var i = 0; i < cv.length; i++) {
          var c = cv[i];
          var msg = c.message;
          if (msg && msg.match(/^[@%].*/)) {
            msg = tr(msg.substring(1));
          }
          message += this.$.formid._getLabel(c.path) + " : " + msg + "<br />";
        }
        this.alert(message);
      } else {
        var msg = "";
        if (this.mode == "add") {
          msg = tr("data.form.created");
        } else {
          msg = tr("data.form.saved");
        }
        data.id = ret.id;
        this.$.formid.updateData(data);
        this.notify(msg, "success", "10000");
      }
    } catch (e) {
      console.error("saveAction:", e.stack);
      var msg = null;
      if (e.message) {
        msg = e.message;
      } else {
        var m = e.toString();
        msg = m.substring(m.indexOf("entityName:") + 11);
        msg = tr("data.form.save") + ": (" + msg + ")";
      }
      this.notify(msg, "error", "10000");
      return false;
    }
  }
  return true;
  this.fire("save-action", {entity:this.entity, namespace:this.namespace});
}, storeData:function(data) {
  var props = simpl4.util.EntityManager.getPropertiesForEntity(this.entity, {namespace:this.namespace});
  var customServiceUpdate = props.customServiceUpdate;
  var customServiceInsert = props.customServiceInsert;
  var mode = this.mode;
  if (mode == "add" && customServiceInsert) {
    return this._storeDataCustom(data, customServiceInsert);
  } else {
    if (mode == "edit" && customServiceUpdate) {
      return this._storeDataCustom(data, customServiceUpdate);
    } else {
      return this._storeData(data);
    }
  }
}, _storeData:function(data) {
  var idValue = this.getIdValue(this.entity, this.namespace, data);
  console.log("storeData.idValue:", idValue);
  var rpc = {storeId:(this.namespace || simpl4.util.BaseManager.getNamespace()) + "_" + this.getPackFromEntity(this.entity), entity:this.entity, id:idValue, data:data};
  console.log("rpc:", rpc);
  console.log("mode:", this.mode);
  var ret = simpl4.util.Rpc.rpcSync("data:" + (this.mode == "add" ? "insert" : "update"), rpc);
  return ret;
}, deleteData:function(data) {
  var rpc = {storeId:(this.namespace || simpl4.util.BaseManager.getNamespace()) + "_" + this.getPackFromEntity(this.entity), entity:this.entity, id:this.getIdValue(this.entity, this.namespace, data)};
  console.log("rpc.delete:", rpc);
  var ret = simpl4.util.Rpc.rpcSync("data:delete", rpc);
  return ret;
}, getIdValue:function(entityName, namespace, data) {
  if (this.mode == "add") {
    return null;
  }
  console.log("getIdValue:", entityName + "/", data);
  var pkList = simpl4.util.EntityManager.getEntity(entityName, namespace).primaryKeys;
  if (pkList == null || pkList.length === 0) {
    if (data["_id"] != null) {
      pkList = ["_id"];
    } else {
      pkList = ["id"];
    }
  }
  var idValue = "";
  var colon = "";
  for (var i = 0; i < pkList.length; i++) {
    var val = data[pkList[i]] || "";
    idValue += colon + val;
    colon = ":";
  }
  return idValue;
}, entityChanged:function() {
  this.getColumns(this.entity);
  this._pack = this.getPackFromEntity(this.entity);
  this.setFormSpec(this.namespace, this.entity);
}, setFormSpec:function(namespace, entity) {
  if (namespace === this.prevNamespace && entity === this.prevEntityName) {
    return;
  }
  this.currentNamespace = namespace;
  var formSpec = simpl4FormManager.getCrudForm(entity, namespace);
  console.debug("setFormSpec:", formSpec);
  this.prevEntityName = entity;
  this.prevNamespace = namespace;
  if (typeof formSpec === "string") {
    this.formName = formSpec;
  } else {
    this.formSpec = [formSpec];
  }
  this.async(function() {
    this.$.formid.setData({});
  }, 5);
}, getFormSpec:function(item) {
  return [simpl4FormManager.getCrudForm(item.entity, item.namespace || this.namespace)];
}, getEditMode:function() {
  return "edit";
}, getColumns:function(entity) {
  try {
    var em = simpl4.util.EntityManager;
    var data = em.getEntityViewFields(entity, this.namespace, "report", false);
    colModel = em.buildColModel(data, this.namespace, entity, "search");
    this._buildMeta(colModel, entity);
  } catch (e) {
    console.error("getSelectableFields:", e);
    return;
  }
  return colModel;
}, _buildMeta:function(colMode, entity) {
  simpl4.util.MessageManager.installMessages(this.namespace);
  this.fieldmap = {};
  var columns = new Array;
  for (var f = 0; f < colModel.length; f++) {
    var col = colModel[f];
    if (true || col.display === true) {
      var fd = {};
      fd.label = tr(this.getPackFromEntity(entity) + "." + this.getSimpleEntityName(entity) + "." + col.id);
      fd.title = fd.label;
      fd["data"] = col.name;
      columns.push(fd);
    }
  }
  console.debug("meta:", columns);
  this.meta = columns;
  this.data = [{articleId:"ABC"}];
}, getHelp:function() {
  return tr("crud2.select_with");
}, getHeader:function(entityName) {
  return tr(this.getPackFromEntity(this.entity) + "." + this.getSimpleEntityName(entityName));
}, getPackFromEntity:function(entity) {
  if (entity.indexOf(":") >= 0) {
    return entity.split(":")[0];
  }
  return "data";
}, getSimpleEntityName:function(entity) {
  if (entity.indexOf(":") >= 0) {
    return entity.split(":")[1];
  }
  return entity;
}});
Polymer({is:"simpl-details", properties:{namespace:{type:String}, entity:{observer:"entityChanged", type:String}}, attached:function(item) {
}, getCellData:function(item) {
  return this.data[item.data];
}, entityChanged:function(e) {
  this.namespace = this.namespace || simpl4.util.BaseManager.getNamespace();
  this.meta = this.preProcessMeta(simpl4EntityManager.getEntityViewFields(this.entity, "main-form", true, {namespace:this.namespace}));
}, preProcessData:function(rows) {
  var selKeys = Object.keys(this.selectableList);
  var dateKeys = Object.keys(this.dateList);
  var datetimeKeys = Object.keys(this.datetimeList);
  rows.forEach(function(r) {
    selKeys.forEach(function(key) {
      var val = r[key];
      r[key + "_display"] = this.selectableList[key][val];
    }, this);
    dateKeys.forEach(function(key) {
      var val = r[key];
      r[key + "_display"] = this.getDate(val);
    }, this);
  }, this);
  return rows;
}, preProcessMeta:function(fields) {
  this.selectableList = {};
  this.dateList = {};
  this.datetimeList = {};
  this.columns = [];
  var ret = [];
  if (fields == null) {
    fields = [];
  }
  fields.forEach(function(f) {
    var dtName = f.name;
    if (f.hidden) {
      return;
    }
    if (f.selectable_items && Array.isArray(f.selectable_items.getItems())) {
      this.selectableList[f.name] = this.toMap(f.selectable_items.getItems());
      dtName = f.name + "_display";
    }
    if (f.datatype == "date") {
      this.dateList[f.name] = true;
      dtName = f.name + "_display";
    }
    if (f.datatype == "datetime") {
      this.datetimeList[f.name] = true;
      dtName = f.name + "_display";
    }
    var col = {title:tr("data." + this.entity + "." + f.name), data:dtName};
    ret.push(col);
    this.columns.push(f.name);
  }, this);
  return ret;
}, toMap:function(sel) {
  var map = {};
  sel.forEach(function(elem) {
    map[elem.value] = elem.label;
  }, this);
  return map;
}, getDate:function(val) {
  if (val == null) {
    return "--";
  }
  return moment(parseInt(val)).format("L");
}, setData:function(data) {
  this.data = null;
  this.async(function() {
    this.data = this.preProcessData([data])[0];
  }, 100);
}});
Polymer({is:"delete-dialog", behaviors:[TranslationsBehavior], onTap:function() {
  this.fire("delete-ok", this.data);
  this.$.dialogId.close();
}, close:function(msg) {
  this.$.dialogId.close();
}, open:function(data) {
  this.data = data;
  this.$.dialogId.open();
}});
(function(factory) {
  if (typeof define === "function" && define.amd) {
    define(["jquery"], function($) {
      return factory($, window, document);
    });
  } else {
    if (typeof exports === "object") {
      module.exports = function(root, $) {
        if (!root) {
          root = window;
        }
        if (!$) {
          $ = typeof window !== "undefined" ? require("jquery") : require("jquery")(root);
        }
        return factory($, root, root.document);
      };
    } else {
      factory(jQuery, window, document);
    }
  }
})(function($, window, document, undefined) {
  var DataTable = function(options) {
    this.$ = function(sSelector, oOpts) {
      return this.api(true).$(sSelector, oOpts);
    };
    this._ = function(sSelector, oOpts) {
      return this.api(true).rows(sSelector, oOpts).data();
    };
    this.api = function(traditional) {
      return traditional ? new _Api(_fnSettingsFromNode(this[_ext.iApiIndex])) : new _Api(this);
    };
    this.fnAddData = function(data, redraw) {
      var api = this.api(true);
      var rows = $.isArray(data) && ($.isArray(data[0]) || $.isPlainObject(data[0])) ? api.rows.add(data) : api.row.add(data);
      if (redraw === undefined || redraw) {
        api.draw();
      }
      return rows.flatten().toArray();
    };
    this.fnAdjustColumnSizing = function(bRedraw) {
      var api = this.api(true).columns.adjust();
      var settings = api.settings()[0];
      var scroll = settings.oScroll;
      if (bRedraw === undefined || bRedraw) {
        api.draw(false);
      } else {
        if (scroll.sX !== "" || scroll.sY !== "") {
          _fnScrollDraw(settings);
        }
      }
    };
    this.fnClearTable = function(bRedraw) {
      var api = this.api(true).clear();
      if (bRedraw === undefined || bRedraw) {
        api.draw();
      }
    };
    this.fnClose = function(nTr) {
      this.api(true).row(nTr).child.hide();
    };
    this.fnDeleteRow = function(target, callback, redraw) {
      var api = this.api(true);
      var rows = api.rows(target);
      var settings = rows.settings()[0];
      var data = settings.aoData[rows[0][0]];
      rows.remove();
      if (callback) {
        callback.call(this, settings, data);
      }
      if (redraw === undefined || redraw) {
        api.draw();
      }
      return data;
    };
    this.fnDestroy = function(remove) {
      this.api(true).destroy(remove);
    };
    this.fnDraw = function(complete) {
      this.api(true).draw(complete);
    };
    this.fnFilter = function(sInput, iColumn, bRegex, bSmart, bShowGlobal, bCaseInsensitive) {
      var api = this.api(true);
      if (iColumn === null || iColumn === undefined) {
        api.search(sInput, bRegex, bSmart, bCaseInsensitive);
      } else {
        api.column(iColumn).search(sInput, bRegex, bSmart, bCaseInsensitive);
      }
      api.draw();
    };
    this.fnGetData = function(src, col) {
      var api = this.api(true);
      if (src !== undefined) {
        var type = src.nodeName ? src.nodeName.toLowerCase() : "";
        return col !== undefined || type == "td" || type == "th" ? api.cell(src, col).data() : api.row(src).data() || null;
      }
      return api.data().toArray();
    };
    this.fnGetNodes = function(iRow) {
      var api = this.api(true);
      return iRow !== undefined ? api.row(iRow).node() : api.rows().nodes().flatten().toArray();
    };
    this.fnGetPosition = function(node) {
      var api = this.api(true);
      var nodeName = node.nodeName.toUpperCase();
      if (nodeName == "TR") {
        return api.row(node).index();
      } else {
        if (nodeName == "TD" || nodeName == "TH") {
          var cell = api.cell(node).index();
          return [cell.row, cell.columnVisible, cell.column];
        }
      }
      return null;
    };
    this.fnIsOpen = function(nTr) {
      return this.api(true).row(nTr).child.isShown();
    };
    this.fnOpen = function(nTr, mHtml, sClass) {
      return this.api(true).row(nTr).child(mHtml, sClass).show().child()[0];
    };
    this.fnPageChange = function(mAction, bRedraw) {
      var api = this.api(true).page(mAction);
      if (bRedraw === undefined || bRedraw) {
        api.draw(false);
      }
    };
    this.fnSetColumnVis = function(iCol, bShow, bRedraw) {
      var api = this.api(true).column(iCol).visible(bShow);
      if (bRedraw === undefined || bRedraw) {
        api.columns.adjust().draw();
      }
    };
    this.fnSettings = function() {
      return _fnSettingsFromNode(this[_ext.iApiIndex]);
    };
    this.fnSort = function(aaSort) {
      this.api(true).order(aaSort).draw();
    };
    this.fnSortListener = function(nNode, iColumn, fnCallback) {
      this.api(true).order.listener(nNode, iColumn, fnCallback);
    };
    this.fnUpdate = function(mData, mRow, iColumn, bRedraw, bAction) {
      var api = this.api(true);
      if (iColumn === undefined || iColumn === null) {
        api.row(mRow).data(mData);
      } else {
        api.cell(mRow, iColumn).data(mData);
      }
      if (bAction === undefined || bAction) {
        api.columns.adjust();
      }
      if (bRedraw === undefined || bRedraw) {
        api.draw();
      }
      return 0;
    };
    this.fnVersionCheck = _ext.fnVersionCheck;
    var _that = this;
    var emptyInit = options === undefined;
    var len = this.length;
    if (emptyInit) {
      options = {};
    }
    this.oApi = this.internal = _ext.internal;
    for (var fn in DataTable.ext.internal) {
      if (fn) {
        this[fn] = _fnExternApiFunc(fn);
      }
    }
    this.each(function() {
      var o = {};
      var oInit = len > 1 ? _fnExtend(o, options, true) : options;
      var i = 0, iLen, j, jLen, k, kLen;
      var sId = this.getAttribute("id");
      var bInitHandedOff = false;
      var defaults = DataTable.defaults;
      var $this = $(this);
      if (this.nodeName.toLowerCase() != "table") {
        _fnLog(null, 0, "Non-table node initialisation (" + this.nodeName + ")", 2);
        return;
      }
      _fnCompatOpts(defaults);
      _fnCompatCols(defaults.column);
      _fnCamelToHungarian(defaults, defaults, true);
      _fnCamelToHungarian(defaults.column, defaults.column, true);
      _fnCamelToHungarian(defaults, $.extend(oInit, $this.data()));
      var allSettings = DataTable.settings;
      for (i = 0, iLen = allSettings.length; i < iLen; i++) {
        var s = allSettings[i];
        if (s.nTable == this || s.nTHead.parentNode == this || s.nTFoot && s.nTFoot.parentNode == this) {
          var bRetrieve = oInit.bRetrieve !== undefined ? oInit.bRetrieve : defaults.bRetrieve;
          var bDestroy = oInit.bDestroy !== undefined ? oInit.bDestroy : defaults.bDestroy;
          if (emptyInit || bRetrieve) {
            return s.oInstance;
          } else {
            if (bDestroy) {
              s.oInstance.fnDestroy();
              break;
            } else {
              _fnLog(s, 0, "Cannot reinitialise DataTable", 3);
              return;
            }
          }
        }
        if (s.sTableId == this.id) {
          allSettings.splice(i, 1);
          break;
        }
      }
      if (sId === null || sId === "") {
        sId = "DataTables_Table_" + DataTable.ext._unique++;
        this.id = sId;
      }
      var oSettings = $.extend(true, {}, DataTable.models.oSettings, {"sDestroyWidth":$this[0].style.width, "sInstance":sId, "sTableId":sId});
      oSettings.nTable = this;
      oSettings.oApi = _that.internal;
      oSettings.oInit = oInit;
      allSettings.push(oSettings);
      oSettings.oInstance = _that.length === 1 ? _that : $this.dataTable();
      _fnCompatOpts(oInit);
      if (oInit.oLanguage) {
        _fnLanguageCompat(oInit.oLanguage);
      }
      if (oInit.aLengthMenu && !oInit.iDisplayLength) {
        oInit.iDisplayLength = $.isArray(oInit.aLengthMenu[0]) ? oInit.aLengthMenu[0][0] : oInit.aLengthMenu[0];
      }
      oInit = _fnExtend($.extend(true, {}, defaults), oInit);
      _fnMap(oSettings.oFeatures, oInit, ["bPaginate", "bLengthChange", "bFilter", "bSort", "bSortMulti", "bInfo", "bProcessing", "bAutoWidth", "bSortClasses", "bServerSide", "bDeferRender"]);
      _fnMap(oSettings, oInit, ["asStripeClasses", "ajax", "fnServerData", "fnFormatNumber", "sServerMethod", "aaSorting", "aaSortingFixed", "aLengthMenu", "sPaginationType", "sAjaxSource", "sAjaxDataProp", "iStateDuration", "sDom", "bSortCellsTop", "iTabIndex", "fnStateLoadCallback", "fnStateSaveCallback", "renderer", "searchDelay", "rowId", ["iCookieDuration", "iStateDuration"], ["oSearch", "oPreviousSearch"], ["aoSearchCols", "aoPreSearchCols"], ["iDisplayLength", "_iDisplayLength"], ["bJQueryUI", 
      "bJUI"]]);
      _fnMap(oSettings.oScroll, oInit, [["sScrollX", "sX"], ["sScrollXInner", "sXInner"], ["sScrollY", "sY"], ["bScrollCollapse", "bCollapse"]]);
      _fnMap(oSettings.oLanguage, oInit, "fnInfoCallback");
      _fnCallbackReg(oSettings, "aoDrawCallback", oInit.fnDrawCallback, "user");
      _fnCallbackReg(oSettings, "aoServerParams", oInit.fnServerParams, "user");
      _fnCallbackReg(oSettings, "aoStateSaveParams", oInit.fnStateSaveParams, "user");
      _fnCallbackReg(oSettings, "aoStateLoadParams", oInit.fnStateLoadParams, "user");
      _fnCallbackReg(oSettings, "aoStateLoaded", oInit.fnStateLoaded, "user");
      _fnCallbackReg(oSettings, "aoRowCallback", oInit.fnRowCallback, "user");
      _fnCallbackReg(oSettings, "aoRowCreatedCallback", oInit.fnCreatedRow, "user");
      _fnCallbackReg(oSettings, "aoHeaderCallback", oInit.fnHeaderCallback, "user");
      _fnCallbackReg(oSettings, "aoFooterCallback", oInit.fnFooterCallback, "user");
      _fnCallbackReg(oSettings, "aoInitComplete", oInit.fnInitComplete, "user");
      _fnCallbackReg(oSettings, "aoPreDrawCallback", oInit.fnPreDrawCallback, "user");
      oSettings.rowIdFn = _fnGetObjectDataFn(oInit.rowId);
      _fnBrowserDetect(oSettings);
      var oClasses = oSettings.oClasses;
      if (oInit.bJQueryUI) {
        $.extend(oClasses, DataTable.ext.oJUIClasses, oInit.oClasses);
        if (oInit.sDom === defaults.sDom && defaults.sDom === "lfrtip") {
          oSettings.sDom = '<"H"lfr>t<"F"ip>';
        }
        if (!oSettings.renderer) {
          oSettings.renderer = "jqueryui";
        } else {
          if ($.isPlainObject(oSettings.renderer) && !oSettings.renderer.header) {
            oSettings.renderer.header = "jqueryui";
          }
        }
      } else {
        $.extend(oClasses, DataTable.ext.classes, oInit.oClasses);
      }
      $this.addClass(oClasses.sTable);
      if (oSettings.iInitDisplayStart === undefined) {
        oSettings.iInitDisplayStart = oInit.iDisplayStart;
        oSettings._iDisplayStart = oInit.iDisplayStart;
      }
      if (oInit.iDeferLoading !== null) {
        oSettings.bDeferLoading = true;
        var tmp = $.isArray(oInit.iDeferLoading);
        oSettings._iRecordsDisplay = tmp ? oInit.iDeferLoading[0] : oInit.iDeferLoading;
        oSettings._iRecordsTotal = tmp ? oInit.iDeferLoading[1] : oInit.iDeferLoading;
      }
      var oLanguage = oSettings.oLanguage;
      $.extend(true, oLanguage, oInit.oLanguage);
      if (oLanguage.sUrl !== "") {
        $.ajax({dataType:"json", url:oLanguage.sUrl, success:function(json) {
          _fnLanguageCompat(json);
          _fnCamelToHungarian(defaults.oLanguage, json);
          $.extend(true, oLanguage, json);
          _fnInitialise(oSettings);
        }, error:function() {
          _fnInitialise(oSettings);
        }});
        bInitHandedOff = true;
      }
      if (oInit.asStripeClasses === null) {
        oSettings.asStripeClasses = [oClasses.sStripeOdd, oClasses.sStripeEven];
      }
      var stripeClasses = oSettings.asStripeClasses;
      var rowOne = $this.children("tbody").find("tr").eq(0);
      if ($.inArray(true, $.map(stripeClasses, function(el, i) {
        return rowOne.hasClass(el);
      })) !== -1) {
        $("tbody tr", this).removeClass(stripeClasses.join(" "));
        oSettings.asDestroyStripes = stripeClasses.slice();
      }
      var anThs = [];
      var aoColumnsInit;
      var nThead = this.getElementsByTagName("thead");
      if (nThead.length !== 0) {
        _fnDetectHeader(oSettings.aoHeader, nThead[0]);
        anThs = _fnGetUniqueThs(oSettings);
      }
      if (oInit.aoColumns === null) {
        aoColumnsInit = [];
        for (i = 0, iLen = anThs.length; i < iLen; i++) {
          aoColumnsInit.push(null);
        }
      } else {
        aoColumnsInit = oInit.aoColumns;
      }
      for (i = 0, iLen = aoColumnsInit.length; i < iLen; i++) {
        _fnAddColumn(oSettings, anThs ? anThs[i] : null);
      }
      _fnApplyColumnDefs(oSettings, oInit.aoColumnDefs, aoColumnsInit, function(iCol, oDef) {
        _fnColumnOptions(oSettings, iCol, oDef);
      });
      if (rowOne.length) {
        var a = function(cell, name) {
          return cell.getAttribute("data-" + name) !== null ? name : null;
        };
        $(rowOne[0]).children("th, td").each(function(i, cell) {
          var col = oSettings.aoColumns[i];
          if (col.mData === i) {
            var sort = a(cell, "sort") || a(cell, "order");
            var filter = a(cell, "filter") || a(cell, "search");
            if (sort !== null || filter !== null) {
              col.mData = {_:i + ".display", sort:sort !== null ? i + ".@data-" + sort : undefined, type:sort !== null ? i + ".@data-" + sort : undefined, filter:filter !== null ? i + ".@data-" + filter : undefined};
              _fnColumnOptions(oSettings, i);
            }
          }
        });
      }
      var features = oSettings.oFeatures;
      if (oInit.bStateSave) {
        features.bStateSave = true;
        _fnLoadState(oSettings, oInit);
        _fnCallbackReg(oSettings, "aoDrawCallback", _fnSaveState, "state_save");
      }
      if (oInit.aaSorting === undefined) {
        var sorting = oSettings.aaSorting;
        for (i = 0, iLen = sorting.length; i < iLen; i++) {
          sorting[i][1] = oSettings.aoColumns[i].asSorting[0];
        }
      }
      _fnSortingClasses(oSettings);
      if (features.bSort) {
        _fnCallbackReg(oSettings, "aoDrawCallback", function() {
          if (oSettings.bSorted) {
            var aSort = _fnSortFlatten(oSettings);
            var sortedColumns = {};
            $.each(aSort, function(i, val) {
              sortedColumns[val.src] = val.dir;
            });
            _fnCallbackFire(oSettings, null, "order", [oSettings, aSort, sortedColumns]);
            _fnSortAria(oSettings);
          }
        });
      }
      _fnCallbackReg(oSettings, "aoDrawCallback", function() {
        if (oSettings.bSorted || _fnDataSource(oSettings) === "ssp" || features.bDeferRender) {
          _fnSortingClasses(oSettings);
        }
      }, "sc");
      var captions = $this.children("caption").each(function() {
        this._captionSide = $this.css("caption-side");
      });
      var thead = $this.children("thead");
      if (thead.length === 0) {
        thead = $("<thead/>").appendTo(this);
      }
      oSettings.nTHead = thead[0];
      var tbody = $this.children("tbody");
      if (tbody.length === 0) {
        tbody = $("<tbody/>").appendTo(this);
      }
      oSettings.nTBody = tbody[0];
      var tfoot = $this.children("tfoot");
      if (tfoot.length === 0 && captions.length > 0 && (oSettings.oScroll.sX !== "" || oSettings.oScroll.sY !== "")) {
        tfoot = $("<tfoot/>").appendTo(this);
      }
      if (tfoot.length === 0 || tfoot.children().length === 0) {
        $this.addClass(oClasses.sNoFooter);
      } else {
        if (tfoot.length > 0) {
          oSettings.nTFoot = tfoot[0];
          _fnDetectHeader(oSettings.aoFooter, oSettings.nTFoot);
        }
      }
      if (oInit.aaData) {
        for (i = 0; i < oInit.aaData.length; i++) {
          _fnAddData(oSettings, oInit.aaData[i]);
        }
      } else {
        if (oSettings.bDeferLoading || _fnDataSource(oSettings) == "dom") {
          _fnAddTr(oSettings, $(oSettings.nTBody).children("tr"));
        }
      }
      oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
      oSettings.bInitialised = true;
      if (bInitHandedOff === false) {
        _fnInitialise(oSettings);
      }
    });
    _that = null;
    return this;
  };
  var _ext;
  var _Api;
  var _api_register;
  var _api_registerPlural;
  var _re_dic = {};
  var _re_new_lines = /[\r\n]/g;
  var _re_html = /<.*?>/g;
  var _re_date_start = /^[\w\+\-]/;
  var _re_date_end = /[\w\+\-]$/;
  var _re_escape_regex = new RegExp("(\\" + ["/", ".", "*", "+", "?", "|", "(", ")", "[", "]", "{", "}", "\\", "$", "^", "-"].join("|\\") + ")", "g");
  var _re_formatted_numeric = /[',$£€¥%\u2009\u202F\u20BD\u20a9\u20BArfk]/gi;
  var _empty = function(d) {
    return !d || d === true || d === "-" ? true : false;
  };
  var _intVal = function(s) {
    var integer = parseInt(s, 10);
    return !isNaN(integer) && isFinite(s) ? integer : null;
  };
  var _numToDecimal = function(num, decimalPoint) {
    if (!_re_dic[decimalPoint]) {
      _re_dic[decimalPoint] = new RegExp(_fnEscapeRegex(decimalPoint), "g");
    }
    return typeof num === "string" && decimalPoint !== "." ? num.replace(/\./g, "").replace(_re_dic[decimalPoint], ".") : num;
  };
  var _isNumber = function(d, decimalPoint, formatted) {
    var strType = typeof d === "string";
    if (_empty(d)) {
      return true;
    }
    if (decimalPoint && strType) {
      d = _numToDecimal(d, decimalPoint);
    }
    if (formatted && strType) {
      d = d.replace(_re_formatted_numeric, "");
    }
    return !isNaN(parseFloat(d)) && isFinite(d);
  };
  var _isHtml = function(d) {
    return _empty(d) || typeof d === "string";
  };
  var _htmlNumeric = function(d, decimalPoint, formatted) {
    if (_empty(d)) {
      return true;
    }
    var html = _isHtml(d);
    return !html ? null : _isNumber(_stripHtml(d), decimalPoint, formatted) ? true : null;
  };
  var _pluck = function(a, prop, prop2) {
    var out = [];
    var i = 0, ien = a.length;
    if (prop2 !== undefined) {
      for (; i < ien; i++) {
        if (a[i] && a[i][prop]) {
          out.push(a[i][prop][prop2]);
        }
      }
    } else {
      for (; i < ien; i++) {
        if (a[i]) {
          out.push(a[i][prop]);
        }
      }
    }
    return out;
  };
  var _pluck_order = function(a, order, prop, prop2) {
    var out = [];
    var i = 0, ien = order.length;
    if (prop2 !== undefined) {
      for (; i < ien; i++) {
        if (a[order[i]][prop]) {
          out.push(a[order[i]][prop][prop2]);
        }
      }
    } else {
      for (; i < ien; i++) {
        out.push(a[order[i]][prop]);
      }
    }
    return out;
  };
  var _range = function(len, start) {
    var out = [];
    var end;
    if (start === undefined) {
      start = 0;
      end = len;
    } else {
      end = start;
      start = len;
    }
    for (var i = start; i < end; i++) {
      out.push(i);
    }
    return out;
  };
  var _removeEmpty = function(a) {
    var out = [];
    for (var i = 0, ien = a.length; i < ien; i++) {
      if (a[i]) {
        out.push(a[i]);
      }
    }
    return out;
  };
  var _stripHtml = function(d) {
    return d.replace(_re_html, "");
  };
  var _unique = function(src) {
    var out = [], val, i, ien = src.length, j, k = 0;
    again: for (i = 0; i < ien; i++) {
      val = src[i];
      for (j = 0; j < k; j++) {
        if (out[j] === val) {
          continue again;
        }
      }
      out.push(val);
      k++;
    }
    return out;
  };
  DataTable.util = {throttle:function(fn, freq) {
    var frequency = freq !== undefined ? freq : 200, last, timer;
    return function() {
      var that = this, now = +new Date, args = arguments;
      if (last && now < last + frequency) {
        clearTimeout(timer);
        timer = setTimeout(function() {
          last = undefined;
          fn.apply(that, args);
        }, frequency);
      } else {
        last = now;
        fn.apply(that, args);
      }
    };
  }, escapeRegex:function(val) {
    return val.replace(_re_escape_regex, "\\$1");
  }};
  function _fnHungarianMap(o) {
    var hungarian = "a aa ai ao as b fn i m o s ", match, newKey, map = {};
    $.each(o, function(key, val) {
      match = key.match(/^([^A-Z]+?)([A-Z])/);
      if (match && hungarian.indexOf(match[1] + " ") !== -1) {
        newKey = key.replace(match[0], match[2].toLowerCase());
        map[newKey] = key;
        if (match[1] === "o") {
          _fnHungarianMap(o[key]);
        }
      }
    });
    o._hungarianMap = map;
  }
  function _fnCamelToHungarian(src, user, force) {
    if (!src._hungarianMap) {
      _fnHungarianMap(src);
    }
    var hungarianKey;
    $.each(user, function(key, val) {
      hungarianKey = src._hungarianMap[key];
      if (hungarianKey !== undefined && (force || user[hungarianKey] === undefined)) {
        if (hungarianKey.charAt(0) === "o") {
          if (!user[hungarianKey]) {
            user[hungarianKey] = {};
          }
          $.extend(true, user[hungarianKey], user[key]);
          _fnCamelToHungarian(src[hungarianKey], user[hungarianKey], force);
        } else {
          user[hungarianKey] = user[key];
        }
      }
    });
  }
  function _fnLanguageCompat(lang) {
    var defaults = DataTable.defaults.oLanguage;
    var zeroRecords = lang.sZeroRecords;
    if (!lang.sEmptyTable && zeroRecords && defaults.sEmptyTable === "No data available in table") {
      _fnMap(lang, lang, "sZeroRecords", "sEmptyTable");
    }
    if (!lang.sLoadingRecords && zeroRecords && defaults.sLoadingRecords === "Loading...") {
      _fnMap(lang, lang, "sZeroRecords", "sLoadingRecords");
    }
    if (lang.sInfoThousands) {
      lang.sThousands = lang.sInfoThousands;
    }
    var decimal = lang.sDecimal;
    if (decimal) {
      _addNumericSort(decimal);
    }
  }
  var _fnCompatMap = function(o, knew, old) {
    if (o[knew] !== undefined) {
      o[old] = o[knew];
    }
  };
  function _fnCompatOpts(init) {
    _fnCompatMap(init, "ordering", "bSort");
    _fnCompatMap(init, "orderMulti", "bSortMulti");
    _fnCompatMap(init, "orderClasses", "bSortClasses");
    _fnCompatMap(init, "orderCellsTop", "bSortCellsTop");
    _fnCompatMap(init, "order", "aaSorting");
    _fnCompatMap(init, "orderFixed", "aaSortingFixed");
    _fnCompatMap(init, "paging", "bPaginate");
    _fnCompatMap(init, "pagingType", "sPaginationType");
    _fnCompatMap(init, "pageLength", "iDisplayLength");
    _fnCompatMap(init, "searching", "bFilter");
    if (typeof init.sScrollX === "boolean") {
      init.sScrollX = init.sScrollX ? "100%" : "";
    }
    if (typeof init.scrollX === "boolean") {
      init.scrollX = init.scrollX ? "100%" : "";
    }
    var searchCols = init.aoSearchCols;
    if (searchCols) {
      for (var i = 0, ien = searchCols.length; i < ien; i++) {
        if (searchCols[i]) {
          _fnCamelToHungarian(DataTable.models.oSearch, searchCols[i]);
        }
      }
    }
  }
  function _fnCompatCols(init) {
    _fnCompatMap(init, "orderable", "bSortable");
    _fnCompatMap(init, "orderData", "aDataSort");
    _fnCompatMap(init, "orderSequence", "asSorting");
    _fnCompatMap(init, "orderDataType", "sortDataType");
    var dataSort = init.aDataSort;
    if (dataSort && !$.isArray(dataSort)) {
      init.aDataSort = [dataSort];
    }
  }
  function _fnBrowserDetect(settings) {
    if (!DataTable.__browser) {
      var browser = {};
      DataTable.__browser = browser;
      var n = $("<div/>").css({position:"fixed", top:0, left:0, height:1, width:1, overflow:"hidden"}).append($("<div/>").css({position:"absolute", top:1, left:1, width:100, overflow:"scroll"}).append($("<div/>").css({width:"100%", height:10}))).appendTo("body");
      var outer = n.children();
      var inner = outer.children();
      browser.barWidth = outer[0].offsetWidth - outer[0].clientWidth;
      browser.bScrollOversize = inner[0].offsetWidth === 100 && outer[0].clientWidth !== 100;
      browser.bScrollbarLeft = Math.round(inner.offset().left) !== 1;
      browser.bBounding = n[0].getBoundingClientRect().width ? true : false;
      n.remove();
    }
    $.extend(settings.oBrowser, DataTable.__browser);
    settings.oScroll.iBarWidth = DataTable.__browser.barWidth;
  }
  function _fnReduce(that, fn, init, start, end, inc) {
    var i = start, value, isSet = false;
    if (init !== undefined) {
      value = init;
      isSet = true;
    }
    while (i !== end) {
      if (!that.hasOwnProperty(i)) {
        continue;
      }
      value = isSet ? fn(value, that[i], i, that) : that[i];
      isSet = true;
      i += inc;
    }
    return value;
  }
  function _fnAddColumn(oSettings, nTh) {
    var oDefaults = DataTable.defaults.column;
    var iCol = oSettings.aoColumns.length;
    var oCol = $.extend({}, DataTable.models.oColumn, oDefaults, {"nTh":nTh ? nTh : document.createElement("th"), "sTitle":oDefaults.sTitle ? oDefaults.sTitle : nTh ? nTh.innerHTML : "", "aDataSort":oDefaults.aDataSort ? oDefaults.aDataSort : [iCol], "mData":oDefaults.mData ? oDefaults.mData : iCol, idx:iCol});
    oSettings.aoColumns.push(oCol);
    var searchCols = oSettings.aoPreSearchCols;
    searchCols[iCol] = $.extend({}, DataTable.models.oSearch, searchCols[iCol]);
    _fnColumnOptions(oSettings, iCol, $(nTh).data());
  }
  function _fnColumnOptions(oSettings, iCol, oOptions) {
    var oCol = oSettings.aoColumns[iCol];
    var oClasses = oSettings.oClasses;
    var th = $(oCol.nTh);
    if (!oCol.sWidthOrig) {
      oCol.sWidthOrig = th.attr("width") || null;
      var t = (th.attr("style") || "").match(/width:\s*(\d+[pxem%]+)/);
      if (t) {
        oCol.sWidthOrig = t[1];
      }
    }
    if (oOptions !== undefined && oOptions !== null) {
      _fnCompatCols(oOptions);
      _fnCamelToHungarian(DataTable.defaults.column, oOptions);
      if (oOptions.mDataProp !== undefined && !oOptions.mData) {
        oOptions.mData = oOptions.mDataProp;
      }
      if (oOptions.sType) {
        oCol._sManualType = oOptions.sType;
      }
      if (oOptions.className && !oOptions.sClass) {
        oOptions.sClass = oOptions.className;
      }
      $.extend(oCol, oOptions);
      _fnMap(oCol, oOptions, "sWidth", "sWidthOrig");
      if (oOptions.iDataSort !== undefined) {
        oCol.aDataSort = [oOptions.iDataSort];
      }
      _fnMap(oCol, oOptions, "aDataSort");
    }
    var mDataSrc = oCol.mData;
    var mData = _fnGetObjectDataFn(mDataSrc);
    var mRender = oCol.mRender ? _fnGetObjectDataFn(oCol.mRender) : null;
    var attrTest = function(src) {
      return typeof src === "string" && src.indexOf("@") !== -1;
    };
    oCol._bAttrSrc = $.isPlainObject(mDataSrc) && (attrTest(mDataSrc.sort) || attrTest(mDataSrc.type) || attrTest(mDataSrc.filter));
    oCol._setter = null;
    oCol.fnGetData = function(rowData, type, meta) {
      var innerData = mData(rowData, type, undefined, meta);
      return mRender && type ? mRender(innerData, type, rowData, meta) : innerData;
    };
    oCol.fnSetData = function(rowData, val, meta) {
      return _fnSetObjectDataFn(mDataSrc)(rowData, val, meta);
    };
    if (typeof mDataSrc !== "number") {
      oSettings._rowReadObject = true;
    }
    if (!oSettings.oFeatures.bSort) {
      oCol.bSortable = false;
      th.addClass(oClasses.sSortableNone);
    }
    var bAsc = $.inArray("asc", oCol.asSorting) !== -1;
    var bDesc = $.inArray("desc", oCol.asSorting) !== -1;
    if (!oCol.bSortable || !bAsc && !bDesc) {
      oCol.sSortingClass = oClasses.sSortableNone;
      oCol.sSortingClassJUI = "";
    } else {
      if (bAsc && !bDesc) {
        oCol.sSortingClass = oClasses.sSortableAsc;
        oCol.sSortingClassJUI = oClasses.sSortJUIAscAllowed;
      } else {
        if (!bAsc && bDesc) {
          oCol.sSortingClass = oClasses.sSortableDesc;
          oCol.sSortingClassJUI = oClasses.sSortJUIDescAllowed;
        } else {
          oCol.sSortingClass = oClasses.sSortable;
          oCol.sSortingClassJUI = oClasses.sSortJUI;
        }
      }
    }
  }
  function _fnAdjustColumnSizing(settings) {
    if (settings.oFeatures.bAutoWidth !== false) {
      var columns = settings.aoColumns;
      _fnCalculateColumnWidths(settings);
      for (var i = 0, iLen = columns.length; i < iLen; i++) {
        columns[i].nTh.style.width = columns[i].sWidth;
      }
    }
    var scroll = settings.oScroll;
    if (scroll.sY !== "" || scroll.sX !== "") {
      _fnScrollDraw(settings);
    }
    _fnCallbackFire(settings, null, "column-sizing", [settings]);
  }
  function _fnVisibleToColumnIndex(oSettings, iMatch) {
    var aiVis = _fnGetColumns(oSettings, "bVisible");
    return typeof aiVis[iMatch] === "number" ? aiVis[iMatch] : null;
  }
  function _fnColumnIndexToVisible(oSettings, iMatch) {
    var aiVis = _fnGetColumns(oSettings, "bVisible");
    var iPos = $.inArray(iMatch, aiVis);
    return iPos !== -1 ? iPos : null;
  }
  function _fnVisbleColumns(oSettings) {
    var vis = 0;
    $.each(oSettings.aoColumns, function(i, col) {
      if (col.bVisible && $(col.nTh).css("display") !== "none") {
        vis++;
      }
    });
    return vis;
  }
  function _fnGetColumns(oSettings, sParam) {
    var a = [];
    $.map(oSettings.aoColumns, function(val, i) {
      if (val[sParam]) {
        a.push(i);
      }
    });
    return a;
  }
  function _fnColumnTypes(settings) {
    var columns = settings.aoColumns;
    var data = settings.aoData;
    var types = DataTable.ext.type.detect;
    var i, ien, j, jen, k, ken;
    var col, cell, detectedType, cache;
    for (i = 0, ien = columns.length; i < ien; i++) {
      col = columns[i];
      cache = [];
      if (!col.sType && col._sManualType) {
        col.sType = col._sManualType;
      } else {
        if (!col.sType) {
          for (j = 0, jen = types.length; j < jen; j++) {
            for (k = 0, ken = data.length; k < ken; k++) {
              if (cache[k] === undefined) {
                cache[k] = _fnGetCellData(settings, k, i, "type");
              }
              detectedType = types[j](cache[k], settings);
              if (!detectedType && j !== types.length - 1) {
                break;
              }
              if (detectedType === "html") {
                break;
              }
            }
            if (detectedType) {
              col.sType = detectedType;
              break;
            }
          }
          if (!col.sType) {
            col.sType = "string";
          }
        }
      }
    }
  }
  function _fnApplyColumnDefs(oSettings, aoColDefs, aoCols, fn) {
    var i, iLen, j, jLen, k, kLen, def;
    var columns = oSettings.aoColumns;
    if (aoColDefs) {
      for (i = aoColDefs.length - 1; i >= 0; i--) {
        def = aoColDefs[i];
        var aTargets = def.targets !== undefined ? def.targets : def.aTargets;
        if (!$.isArray(aTargets)) {
          aTargets = [aTargets];
        }
        for (j = 0, jLen = aTargets.length; j < jLen; j++) {
          if (typeof aTargets[j] === "number" && aTargets[j] >= 0) {
            while (columns.length <= aTargets[j]) {
              _fnAddColumn(oSettings);
            }
            fn(aTargets[j], def);
          } else {
            if (typeof aTargets[j] === "number" && aTargets[j] < 0) {
              fn(columns.length + aTargets[j], def);
            } else {
              if (typeof aTargets[j] === "string") {
                for (k = 0, kLen = columns.length; k < kLen; k++) {
                  if (aTargets[j] == "_all" || $(columns[k].nTh).hasClass(aTargets[j])) {
                    fn(k, def);
                  }
                }
              }
            }
          }
        }
      }
    }
    if (aoCols) {
      for (i = 0, iLen = aoCols.length; i < iLen; i++) {
        fn(i, aoCols[i]);
      }
    }
  }
  function _fnAddData(oSettings, aDataIn, nTr, anTds) {
    var iRow = oSettings.aoData.length;
    var oData = $.extend(true, {}, DataTable.models.oRow, {src:nTr ? "dom" : "data", idx:iRow});
    oData._aData = aDataIn;
    oSettings.aoData.push(oData);
    var nTd, sThisType;
    var columns = oSettings.aoColumns;
    for (var i = 0, iLen = columns.length; i < iLen; i++) {
      columns[i].sType = null;
    }
    oSettings.aiDisplayMaster.push(iRow);
    var id = oSettings.rowIdFn(aDataIn);
    if (id !== undefined) {
      oSettings.aIds[id] = oData;
    }
    if (nTr || !oSettings.oFeatures.bDeferRender) {
      _fnCreateTr(oSettings, iRow, nTr, anTds);
    }
    return iRow;
  }
  function _fnAddTr(settings, trs) {
    var row;
    if (!(trs instanceof $)) {
      trs = $(trs);
    }
    return trs.map(function(i, el) {
      row = _fnGetRowElements(settings, el);
      return _fnAddData(settings, row.data, el, row.cells);
    });
  }
  function _fnNodeToDataIndex(oSettings, n) {
    return n._DT_RowIndex !== undefined ? n._DT_RowIndex : null;
  }
  function _fnNodeToColumnIndex(oSettings, iRow, n) {
    return $.inArray(n, oSettings.aoData[iRow].anCells);
  }
  function _fnGetCellData(settings, rowIdx, colIdx, type) {
    var draw = settings.iDraw;
    var col = settings.aoColumns[colIdx];
    var rowData = settings.aoData[rowIdx]._aData;
    var defaultContent = col.sDefaultContent;
    var cellData = col.fnGetData(rowData, type, {settings:settings, row:rowIdx, col:colIdx});
    if (cellData === undefined) {
      if (settings.iDrawError != draw && defaultContent === null) {
        _fnLog(settings, 0, "Requested unknown parameter " + (typeof col.mData == "function" ? "{function}" : "'" + col.mData + "'") + " for row " + rowIdx + ", column " + colIdx, 4);
        settings.iDrawError = draw;
      }
      return defaultContent;
    }
    if ((cellData === rowData || cellData === null) && defaultContent !== null && type !== undefined) {
      cellData = defaultContent;
    } else {
      if (typeof cellData === "function") {
        return cellData.call(rowData);
      }
    }
    if (cellData === null && type == "display") {
      return "";
    }
    return cellData;
  }
  function _fnSetCellData(settings, rowIdx, colIdx, val) {
    var col = settings.aoColumns[colIdx];
    var rowData = settings.aoData[rowIdx]._aData;
    col.fnSetData(rowData, val, {settings:settings, row:rowIdx, col:colIdx});
  }
  var __reArray = /\[.*?\]$/;
  var __reFn = /\(\)$/;
  function _fnSplitObjNotation(str) {
    return $.map(str.match(/(\\.|[^\.])+/g) || [""], function(s) {
      return s.replace(/\\./g, ".");
    });
  }
  function _fnGetObjectDataFn(mSource) {
    if ($.isPlainObject(mSource)) {
      var o = {};
      $.each(mSource, function(key, val) {
        if (val) {
          o[key] = _fnGetObjectDataFn(val);
        }
      });
      return function(data, type, row, meta) {
        var t = o[type] || o._;
        return t !== undefined ? t(data, type, row, meta) : data;
      };
    } else {
      if (mSource === null) {
        return function(data) {
          return data;
        };
      } else {
        if (typeof mSource === "function") {
          return function(data, type, row, meta) {
            return mSource(data, type, row, meta);
          };
        } else {
          if (typeof mSource === "string" && (mSource.indexOf(".") !== -1 || mSource.indexOf("[") !== -1 || mSource.indexOf("(") !== -1)) {
            var fetchData = function(data, type, src) {
              var arrayNotation, funcNotation, out, innerSrc;
              if (src !== "") {
                var a = _fnSplitObjNotation(src);
                for (var i = 0, iLen = a.length; i < iLen; i++) {
                  arrayNotation = a[i].match(__reArray);
                  funcNotation = a[i].match(__reFn);
                  if (arrayNotation) {
                    a[i] = a[i].replace(__reArray, "");
                    if (a[i] !== "") {
                      data = data[a[i]];
                    }
                    out = [];
                    a.splice(0, i + 1);
                    innerSrc = a.join(".");
                    if ($.isArray(data)) {
                      for (var j = 0, jLen = data.length; j < jLen; j++) {
                        out.push(fetchData(data[j], type, innerSrc));
                      }
                    }
                    var join = arrayNotation[0].substring(1, arrayNotation[0].length - 1);
                    data = join === "" ? out : out.join(join);
                    break;
                  } else {
                    if (funcNotation) {
                      a[i] = a[i].replace(__reFn, "");
                      data = data[a[i]]();
                      continue;
                    }
                  }
                  if (data === null || data[a[i]] === undefined) {
                    return undefined;
                  }
                  data = data[a[i]];
                }
              }
              return data;
            };
            return function(data, type) {
              return fetchData(data, type, mSource);
            };
          } else {
            return function(data, type) {
              return data[mSource];
            };
          }
        }
      }
    }
  }
  function _fnSetObjectDataFn(mSource) {
    if ($.isPlainObject(mSource)) {
      return _fnSetObjectDataFn(mSource._);
    } else {
      if (mSource === null) {
        return function() {
        };
      } else {
        if (typeof mSource === "function") {
          return function(data, val, meta) {
            mSource(data, "set", val, meta);
          };
        } else {
          if (typeof mSource === "string" && (mSource.indexOf(".") !== -1 || mSource.indexOf("[") !== -1 || mSource.indexOf("(") !== -1)) {
            var setData = function(data, val, src) {
              var a = _fnSplitObjNotation(src), b;
              var aLast = a[a.length - 1];
              var arrayNotation, funcNotation, o, innerSrc;
              for (var i = 0, iLen = a.length - 1; i < iLen; i++) {
                arrayNotation = a[i].match(__reArray);
                funcNotation = a[i].match(__reFn);
                if (arrayNotation) {
                  a[i] = a[i].replace(__reArray, "");
                  data[a[i]] = [];
                  b = a.slice();
                  b.splice(0, i + 1);
                  innerSrc = b.join(".");
                  if ($.isArray(val)) {
                    for (var j = 0, jLen = val.length; j < jLen; j++) {
                      o = {};
                      setData(o, val[j], innerSrc);
                      data[a[i]].push(o);
                    }
                  } else {
                    data[a[i]] = val;
                  }
                  return;
                } else {
                  if (funcNotation) {
                    a[i] = a[i].replace(__reFn, "");
                    data = data[a[i]](val);
                  }
                }
                if (data[a[i]] === null || data[a[i]] === undefined) {
                  data[a[i]] = {};
                }
                data = data[a[i]];
              }
              if (aLast.match(__reFn)) {
                data = data[aLast.replace(__reFn, "")](val);
              } else {
                data[aLast.replace(__reArray, "")] = val;
              }
            };
            return function(data, val) {
              return setData(data, val, mSource);
            };
          } else {
            return function(data, val) {
              data[mSource] = val;
            };
          }
        }
      }
    }
  }
  function _fnGetDataMaster(settings) {
    return _pluck(settings.aoData, "_aData");
  }
  function _fnClearTable(settings) {
    settings.aoData.length = 0;
    settings.aiDisplayMaster.length = 0;
    settings.aiDisplay.length = 0;
    settings.aIds = {};
  }
  function _fnDeleteIndex(a, iTarget, splice) {
    var iTargetIndex = -1;
    for (var i = 0, iLen = a.length; i < iLen; i++) {
      if (a[i] == iTarget) {
        iTargetIndex = i;
      } else {
        if (a[i] > iTarget) {
          a[i]--;
        }
      }
    }
    if (iTargetIndex != -1 && splice === undefined) {
      a.splice(iTargetIndex, 1);
    }
  }
  function _fnInvalidate(settings, rowIdx, src, colIdx) {
    var row = settings.aoData[rowIdx];
    var i, ien;
    var cellWrite = function(cell, col) {
      while (cell.childNodes.length) {
        cell.removeChild(cell.firstChild);
      }
      cell.innerHTML = _fnGetCellData(settings, rowIdx, col, "display");
    };
    if (src === "dom" || (!src || src === "auto") && row.src === "dom") {
      row._aData = _fnGetRowElements(settings, row, colIdx, colIdx === undefined ? undefined : row._aData).data;
    } else {
      var cells = row.anCells;
      if (cells) {
        if (colIdx !== undefined) {
          cellWrite(cells[colIdx], colIdx);
        } else {
          for (i = 0, ien = cells.length; i < ien; i++) {
            cellWrite(cells[i], i);
          }
        }
      }
    }
    row._aSortData = null;
    row._aFilterData = null;
    var cols = settings.aoColumns;
    if (colIdx !== undefined) {
      cols[colIdx].sType = null;
    } else {
      for (i = 0, ien = cols.length; i < ien; i++) {
        cols[i].sType = null;
      }
      _fnRowAttributes(settings, row);
    }
  }
  function _fnGetRowElements(settings, row, colIdx, d) {
    var tds = [], td = row.firstChild, name, col, o, i = 0, contents, columns = settings.aoColumns, objectRead = settings._rowReadObject;
    d = d !== undefined ? d : objectRead ? {} : [];
    var attr = function(str, td) {
      if (typeof str === "string") {
        var idx = str.indexOf("@");
        if (idx !== -1) {
          var attr = str.substring(idx + 1);
          var setter = _fnSetObjectDataFn(str);
          setter(d, td.getAttribute(attr));
        }
      }
    };
    var cellProcess = function(cell) {
      if (colIdx === undefined || colIdx === i) {
        col = columns[i];
        contents = $.trim(cell.innerHTML);
        if (col && col._bAttrSrc) {
          var setter = _fnSetObjectDataFn(col.mData._);
          setter(d, contents);
          attr(col.mData.sort, cell);
          attr(col.mData.type, cell);
          attr(col.mData.filter, cell);
        } else {
          if (objectRead) {
            if (!col._setter) {
              col._setter = _fnSetObjectDataFn(col.mData);
            }
            col._setter(d, contents);
          } else {
            d[i] = contents;
          }
        }
      }
      i++;
    };
    if (td) {
      while (td) {
        name = td.nodeName.toUpperCase();
        if (name == "TD" || name == "TH") {
          cellProcess(td);
          tds.push(td);
        }
        td = td.nextSibling;
      }
    } else {
      tds = row.anCells;
      for (var j = 0, jen = tds.length; j < jen; j++) {
        cellProcess(tds[j]);
      }
    }
    var rowNode = row.firstChild ? row : row.nTr;
    if (rowNode) {
      var id = rowNode.getAttribute("id");
      if (id) {
        _fnSetObjectDataFn(settings.rowId)(d, id);
      }
    }
    return {data:d, cells:tds};
  }
  function _fnCreateTr(oSettings, iRow, nTrIn, anTds) {
    var row = oSettings.aoData[iRow], rowData = row._aData, cells = [], nTr, nTd, oCol, i, iLen;
    if (row.nTr === null) {
      nTr = nTrIn || document.createElement("tr");
      row.nTr = nTr;
      row.anCells = cells;
      nTr._DT_RowIndex = iRow;
      _fnRowAttributes(oSettings, row);
      for (i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {
        oCol = oSettings.aoColumns[i];
        nTd = nTrIn ? anTds[i] : document.createElement(oCol.sCellType);
        nTd._DT_CellIndex = {row:iRow, column:i};
        cells.push(nTd);
        if ((!nTrIn || oCol.mRender || oCol.mData !== i) && (!$.isPlainObject(oCol.mData) || oCol.mData._ !== i + ".display")) {
          nTd.innerHTML = _fnGetCellData(oSettings, iRow, i, "display");
        }
        if (oCol.sClass) {
          nTd.className += " " + oCol.sClass;
        }
        if (oCol.bVisible && !nTrIn) {
          nTr.appendChild(nTd);
        } else {
          if (!oCol.bVisible && nTrIn) {
            nTd.parentNode.removeChild(nTd);
          }
        }
        if (oCol.fnCreatedCell) {
          oCol.fnCreatedCell.call(oSettings.oInstance, nTd, _fnGetCellData(oSettings, iRow, i), rowData, iRow, i);
        }
      }
      _fnCallbackFire(oSettings, "aoRowCreatedCallback", null, [nTr, rowData, iRow]);
    }
    row.nTr.setAttribute("role", "row");
  }
  function _fnRowAttributes(settings, row) {
    var tr = row.nTr;
    var data = row._aData;
    if (tr) {
      var id = settings.rowIdFn(data);
      if (id) {
        tr.id = id;
      }
      if (data.DT_RowClass) {
        var a = data.DT_RowClass.split(" ");
        row.__rowc = row.__rowc ? _unique(row.__rowc.concat(a)) : a;
        $(tr).removeClass(row.__rowc.join(" ")).addClass(data.DT_RowClass);
      }
      if (data.DT_RowAttr) {
        $(tr).attr(data.DT_RowAttr);
      }
      if (data.DT_RowData) {
        $(tr).data(data.DT_RowData);
      }
    }
  }
  function _fnBuildHead(oSettings) {
    var i, ien, cell, row, column;
    var thead = oSettings.nTHead;
    var tfoot = oSettings.nTFoot;
    var createHeader = $("th, td", thead).length === 0;
    var classes = oSettings.oClasses;
    var columns = oSettings.aoColumns;
    if (createHeader) {
      row = $("<tr/>").appendTo(thead);
    }
    for (i = 0, ien = columns.length; i < ien; i++) {
      column = columns[i];
      cell = $(column.nTh).addClass(column.sClass);
      if (createHeader) {
        cell.appendTo(row);
      }
      if (oSettings.oFeatures.bSort) {
        cell.addClass(column.sSortingClass);
        if (column.bSortable !== false) {
          cell.attr("tabindex", oSettings.iTabIndex).attr("aria-controls", oSettings.sTableId);
          _fnSortAttachListener(oSettings, column.nTh, i);
        }
      }
      if (column.sTitle != cell[0].innerHTML) {
        cell.html(column.sTitle);
      }
      _fnRenderer(oSettings, "header")(oSettings, cell, column, classes);
    }
    if (createHeader) {
      _fnDetectHeader(oSettings.aoHeader, thead);
    }
    $(thead).find(">tr").attr("role", "row");
    $(thead).find(">tr>th, >tr>td").addClass(classes.sHeaderTH);
    $(tfoot).find(">tr>th, >tr>td").addClass(classes.sFooterTH);
    if (tfoot !== null) {
      var cells = oSettings.aoFooter[0];
      for (i = 0, ien = cells.length; i < ien; i++) {
        column = columns[i];
        column.nTf = cells[i].cell;
        if (column.sClass) {
          $(column.nTf).addClass(column.sClass);
        }
      }
    }
  }
  function _fnDrawHead(oSettings, aoSource, bIncludeHidden) {
    var i, iLen, j, jLen, k, kLen, n, nLocalTr;
    var aoLocal = [];
    var aApplied = [];
    var iColumns = oSettings.aoColumns.length;
    var iRowspan, iColspan;
    if (!aoSource) {
      return;
    }
    if (bIncludeHidden === undefined) {
      bIncludeHidden = false;
    }
    for (i = 0, iLen = aoSource.length; i < iLen; i++) {
      aoLocal[i] = aoSource[i].slice();
      aoLocal[i].nTr = aoSource[i].nTr;
      for (j = iColumns - 1; j >= 0; j--) {
        if (!oSettings.aoColumns[j].bVisible && !bIncludeHidden) {
          aoLocal[i].splice(j, 1);
        }
      }
      aApplied.push([]);
    }
    for (i = 0, iLen = aoLocal.length; i < iLen; i++) {
      nLocalTr = aoLocal[i].nTr;
      if (nLocalTr) {
        while (n = nLocalTr.firstChild) {
          nLocalTr.removeChild(n);
        }
      }
      for (j = 0, jLen = aoLocal[i].length; j < jLen; j++) {
        iRowspan = 1;
        iColspan = 1;
        if (aApplied[i][j] === undefined) {
          nLocalTr.appendChild(aoLocal[i][j].cell);
          aApplied[i][j] = 1;
          while (aoLocal[i + iRowspan] !== undefined && aoLocal[i][j].cell == aoLocal[i + iRowspan][j].cell) {
            aApplied[i + iRowspan][j] = 1;
            iRowspan++;
          }
          while (aoLocal[i][j + iColspan] !== undefined && aoLocal[i][j].cell == aoLocal[i][j + iColspan].cell) {
            for (k = 0; k < iRowspan; k++) {
              aApplied[i + k][j + iColspan] = 1;
            }
            iColspan++;
          }
          $(aoLocal[i][j].cell).attr("rowspan", iRowspan).attr("colspan", iColspan);
        }
      }
    }
  }
  function _fnDraw(oSettings) {
    var aPreDraw = _fnCallbackFire(oSettings, "aoPreDrawCallback", "preDraw", [oSettings]);
    if ($.inArray(false, aPreDraw) !== -1) {
      _fnProcessingDisplay(oSettings, false);
      return;
    }
    var i, iLen, n;
    var anRows = [];
    var iRowCount = 0;
    var asStripeClasses = oSettings.asStripeClasses;
    var iStripes = asStripeClasses.length;
    var iOpenRows = oSettings.aoOpenRows.length;
    var oLang = oSettings.oLanguage;
    var iInitDisplayStart = oSettings.iInitDisplayStart;
    var bServerSide = _fnDataSource(oSettings) == "ssp";
    var aiDisplay = oSettings.aiDisplay;
    oSettings.bDrawing = true;
    if (iInitDisplayStart !== undefined && iInitDisplayStart !== -1) {
      oSettings._iDisplayStart = bServerSide ? iInitDisplayStart : iInitDisplayStart >= oSettings.fnRecordsDisplay() ? 0 : iInitDisplayStart;
      oSettings.iInitDisplayStart = -1;
    }
    var iDisplayStart = oSettings._iDisplayStart;
    var iDisplayEnd = oSettings.fnDisplayEnd();
    if (oSettings.bDeferLoading) {
      oSettings.bDeferLoading = false;
      oSettings.iDraw++;
      _fnProcessingDisplay(oSettings, false);
    } else {
      if (!bServerSide) {
        oSettings.iDraw++;
      } else {
        if (!oSettings.bDestroying && !_fnAjaxUpdate(oSettings)) {
          return;
        }
      }
    }
    if (aiDisplay.length !== 0) {
      var iStart = bServerSide ? 0 : iDisplayStart;
      var iEnd = bServerSide ? oSettings.aoData.length : iDisplayEnd;
      for (var j = iStart; j < iEnd; j++) {
        var iDataIndex = aiDisplay[j];
        var aoData = oSettings.aoData[iDataIndex];
        if (aoData.nTr === null) {
          _fnCreateTr(oSettings, iDataIndex);
        }
        var nRow = aoData.nTr;
        if (iStripes !== 0) {
          var sStripe = asStripeClasses[iRowCount % iStripes];
          if (aoData._sRowStripe != sStripe) {
            $(nRow).removeClass(aoData._sRowStripe).addClass(sStripe);
            aoData._sRowStripe = sStripe;
          }
        }
        _fnCallbackFire(oSettings, "aoRowCallback", null, [nRow, aoData._aData, iRowCount, j]);
        anRows.push(nRow);
        iRowCount++;
      }
    } else {
      var sZero = oLang.sZeroRecords;
      if (oSettings.iDraw == 1 && _fnDataSource(oSettings) == "ajax") {
        sZero = oLang.sLoadingRecords;
      } else {
        if (oLang.sEmptyTable && oSettings.fnRecordsTotal() === 0) {
          sZero = oLang.sEmptyTable;
        }
      }
      anRows[0] = $("<tr/>", {"class":iStripes ? asStripeClasses[0] : ""}).append($("<td />", {"valign":"top", "colSpan":_fnVisbleColumns(oSettings), "class":oSettings.oClasses.sRowEmpty}).html(sZero))[0];
    }
    _fnCallbackFire(oSettings, "aoHeaderCallback", "header", [$(oSettings.nTHead).children("tr")[0], _fnGetDataMaster(oSettings), iDisplayStart, iDisplayEnd, aiDisplay]);
    _fnCallbackFire(oSettings, "aoFooterCallback", "footer", [$(oSettings.nTFoot).children("tr")[0], _fnGetDataMaster(oSettings), iDisplayStart, iDisplayEnd, aiDisplay]);
    var body = $(oSettings.nTBody);
    body.children().detach();
    body.append($(anRows));
    _fnCallbackFire(oSettings, "aoDrawCallback", "draw", [oSettings]);
    oSettings.bSorted = false;
    oSettings.bFiltered = false;
    oSettings.bDrawing = false;
  }
  function _fnReDraw(settings, holdPosition) {
    var features = settings.oFeatures, sort = features.bSort, filter = features.bFilter;
    if (sort) {
      _fnSort(settings);
    }
    if (filter) {
      _fnFilterComplete(settings, settings.oPreviousSearch);
    } else {
      settings.aiDisplay = settings.aiDisplayMaster.slice();
    }
    if (holdPosition !== true) {
      settings._iDisplayStart = 0;
    }
    settings._drawHold = holdPosition;
    _fnDraw(settings);
    settings._drawHold = false;
  }
  function _fnAddOptionsHtml(oSettings) {
    var classes = oSettings.oClasses;
    var table = $(oSettings.nTable);
    var holding = $("<div/>").insertBefore(table);
    var features = oSettings.oFeatures;
    var insert = $("<div/>", {id:oSettings.sTableId + "_wrapper", "class":classes.sWrapper + (oSettings.nTFoot ? "" : " " + classes.sNoFooter)});
    oSettings.nHolding = holding[0];
    oSettings.nTableWrapper = insert[0];
    oSettings.nTableReinsertBefore = oSettings.nTable.nextSibling;
    var aDom = oSettings.sDom.split("");
    var featureNode, cOption, nNewNode, cNext, sAttr, j;
    for (var i = 0; i < aDom.length; i++) {
      featureNode = null;
      cOption = aDom[i];
      if (cOption == "<") {
        nNewNode = $("<div/>")[0];
        cNext = aDom[i + 1];
        if (cNext == "'" || cNext == '"') {
          sAttr = "";
          j = 2;
          while (aDom[i + j] != cNext) {
            sAttr += aDom[i + j];
            j++;
          }
          if (sAttr == "H") {
            sAttr = classes.sJUIHeader;
          } else {
            if (sAttr == "F") {
              sAttr = classes.sJUIFooter;
            }
          }
          if (sAttr.indexOf(".") != -1) {
            var aSplit = sAttr.split(".");
            nNewNode.id = aSplit[0].substr(1, aSplit[0].length - 1);
            nNewNode.className = aSplit[1];
          } else {
            if (sAttr.charAt(0) == "#") {
              nNewNode.id = sAttr.substr(1, sAttr.length - 1);
            } else {
              nNewNode.className = sAttr;
            }
          }
          i += j;
        }
        insert.append(nNewNode);
        insert = $(nNewNode);
      } else {
        if (cOption == ">") {
          insert = insert.parent();
        } else {
          if (cOption == "l" && features.bPaginate && features.bLengthChange) {
            featureNode = _fnFeatureHtmlLength(oSettings);
          } else {
            if (cOption == "f" && features.bFilter) {
              featureNode = _fnFeatureHtmlFilter(oSettings);
            } else {
              if (cOption == "r" && features.bProcessing) {
                featureNode = _fnFeatureHtmlProcessing(oSettings);
              } else {
                if (cOption == "t") {
                  featureNode = _fnFeatureHtmlTable(oSettings);
                } else {
                  if (cOption == "i" && features.bInfo) {
                    featureNode = _fnFeatureHtmlInfo(oSettings);
                  } else {
                    if (cOption == "p" && features.bPaginate) {
                      featureNode = _fnFeatureHtmlPaginate(oSettings);
                    } else {
                      if (DataTable.ext.feature.length !== 0) {
                        var aoFeatures = DataTable.ext.feature;
                        for (var k = 0, kLen = aoFeatures.length; k < kLen; k++) {
                          if (cOption == aoFeatures[k].cFeature) {
                            featureNode = aoFeatures[k].fnInit(oSettings);
                            break;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      if (featureNode) {
        var aanFeatures = oSettings.aanFeatures;
        if (!aanFeatures[cOption]) {
          aanFeatures[cOption] = [];
        }
        aanFeatures[cOption].push(featureNode);
        insert.append(featureNode);
      }
    }
    holding.replaceWith(insert);
    oSettings.nHolding = null;
  }
  function _fnDetectHeader(aLayout, nThead) {
    var nTrs = $(nThead).children("tr");
    var nTr, nCell;
    var i, k, l, iLen, jLen, iColShifted, iColumn, iColspan, iRowspan;
    var bUnique;
    var fnShiftCol = function(a, i, j) {
      var k = a[i];
      while (k[j]) {
        j++;
      }
      return j;
    };
    aLayout.splice(0, aLayout.length);
    for (i = 0, iLen = nTrs.length; i < iLen; i++) {
      aLayout.push([]);
    }
    for (i = 0, iLen = nTrs.length; i < iLen; i++) {
      nTr = nTrs[i];
      iColumn = 0;
      nCell = nTr.firstChild;
      while (nCell) {
        if (nCell.nodeName.toUpperCase() == "TD" || nCell.nodeName.toUpperCase() == "TH") {
          iColspan = nCell.getAttribute("colspan") * 1;
          iRowspan = nCell.getAttribute("rowspan") * 1;
          iColspan = !iColspan || iColspan === 0 || iColspan === 1 ? 1 : iColspan;
          iRowspan = !iRowspan || iRowspan === 0 || iRowspan === 1 ? 1 : iRowspan;
          iColShifted = fnShiftCol(aLayout, i, iColumn);
          bUnique = iColspan === 1 ? true : false;
          for (l = 0; l < iColspan; l++) {
            for (k = 0; k < iRowspan; k++) {
              aLayout[i + k][iColShifted + l] = {"cell":nCell, "unique":bUnique};
              aLayout[i + k].nTr = nTr;
            }
          }
        }
        nCell = nCell.nextSibling;
      }
    }
  }
  function _fnGetUniqueThs(oSettings, nHeader, aLayout) {
    var aReturn = [];
    if (!aLayout) {
      aLayout = oSettings.aoHeader;
      if (nHeader) {
        aLayout = [];
        _fnDetectHeader(aLayout, nHeader);
      }
    }
    for (var i = 0, iLen = aLayout.length; i < iLen; i++) {
      for (var j = 0, jLen = aLayout[i].length; j < jLen; j++) {
        if (aLayout[i][j].unique && (!aReturn[j] || !oSettings.bSortCellsTop)) {
          aReturn[j] = aLayout[i][j].cell;
        }
      }
    }
    return aReturn;
  }
  function _fnBuildAjax(oSettings, data, fn) {
    _fnCallbackFire(oSettings, "aoServerParams", "serverParams", [data]);
    if (data && $.isArray(data)) {
      var tmp = {};
      var rbracket = /(.*?)\[\]$/;
      $.each(data, function(key, val) {
        var match = val.name.match(rbracket);
        if (match) {
          var name = match[0];
          if (!tmp[name]) {
            tmp[name] = [];
          }
          tmp[name].push(val.value);
        } else {
          tmp[val.name] = val.value;
        }
      });
      data = tmp;
    }
    var ajaxData;
    var ajax = oSettings.ajax;
    var instance = oSettings.oInstance;
    var callback = function(json) {
      _fnCallbackFire(oSettings, null, "xhr", [oSettings, json, oSettings.jqXHR]);
      fn(json);
    };
    if ($.isPlainObject(ajax) && ajax.data) {
      ajaxData = ajax.data;
      var newData = $.isFunction(ajaxData) ? ajaxData(data, oSettings) : ajaxData;
      data = $.isFunction(ajaxData) && newData ? newData : $.extend(true, data, newData);
      delete ajax.data;
    }
    var baseAjax = {"data":data, "success":function(json) {
      var error = json.error || json.sError;
      if (error) {
        _fnLog(oSettings, 0, error);
      }
      oSettings.json = json;
      callback(json);
    }, "dataType":"json", "cache":false, "type":oSettings.sServerMethod, "error":function(xhr, error, thrown) {
      var ret = _fnCallbackFire(oSettings, null, "xhr", [oSettings, null, oSettings.jqXHR]);
      if ($.inArray(true, ret) === -1) {
        if (error == "parsererror") {
          _fnLog(oSettings, 0, "Invalid JSON response", 1);
        } else {
          if (xhr.readyState === 4) {
            _fnLog(oSettings, 0, "Ajax error", 7);
          }
        }
      }
      _fnProcessingDisplay(oSettings, false);
    }};
    oSettings.oAjaxData = data;
    _fnCallbackFire(oSettings, null, "preXhr", [oSettings, data]);
    if (oSettings.fnServerData) {
      oSettings.fnServerData.call(instance, oSettings.sAjaxSource, $.map(data, function(val, key) {
        return {name:key, value:val};
      }), callback, oSettings);
    } else {
      if (oSettings.sAjaxSource || typeof ajax === "string") {
        oSettings.jqXHR = $.ajax($.extend(baseAjax, {url:ajax || oSettings.sAjaxSource}));
      } else {
        if ($.isFunction(ajax)) {
          oSettings.jqXHR = ajax.call(instance, data, callback, oSettings);
        } else {
          oSettings.jqXHR = $.ajax($.extend(baseAjax, ajax));
          ajax.data = ajaxData;
        }
      }
    }
  }
  function _fnAjaxUpdate(settings) {
    if (settings.bAjaxDataGet) {
      settings.iDraw++;
      _fnProcessingDisplay(settings, true);
      _fnBuildAjax(settings, _fnAjaxParameters(settings), function(json) {
        _fnAjaxUpdateDraw(settings, json);
      });
      return false;
    }
    return true;
  }
  function _fnAjaxParameters(settings) {
    var columns = settings.aoColumns, columnCount = columns.length, features = settings.oFeatures, preSearch = settings.oPreviousSearch, preColSearch = settings.aoPreSearchCols, i, data = [], dataProp, column, columnSearch, sort = _fnSortFlatten(settings), displayStart = settings._iDisplayStart, displayLength = features.bPaginate !== false ? settings._iDisplayLength : -1;
    var param = function(name, value) {
      data.push({"name":name, "value":value});
    };
    param("sEcho", settings.iDraw);
    param("iColumns", columnCount);
    param("sColumns", _pluck(columns, "sName").join(","));
    param("iDisplayStart", displayStart);
    param("iDisplayLength", displayLength);
    var d = {draw:settings.iDraw, columns:[], order:[], start:displayStart, length:displayLength, search:{value:preSearch.sSearch, regex:preSearch.bRegex}};
    for (i = 0; i < columnCount; i++) {
      column = columns[i];
      columnSearch = preColSearch[i];
      dataProp = typeof column.mData == "function" ? "function" : column.mData;
      d.columns.push({data:dataProp, name:column.sName, searchable:column.bSearchable, orderable:column.bSortable, search:{value:columnSearch.sSearch, regex:columnSearch.bRegex}});
      param("mDataProp_" + i, dataProp);
      if (features.bFilter) {
        param("sSearch_" + i, columnSearch.sSearch);
        param("bRegex_" + i, columnSearch.bRegex);
        param("bSearchable_" + i, column.bSearchable);
      }
      if (features.bSort) {
        param("bSortable_" + i, column.bSortable);
      }
    }
    if (features.bFilter) {
      param("sSearch", preSearch.sSearch);
      param("bRegex", preSearch.bRegex);
    }
    if (features.bSort) {
      $.each(sort, function(i, val) {
        d.order.push({column:val.col, dir:val.dir});
        param("iSortCol_" + i, val.col);
        param("sSortDir_" + i, val.dir);
      });
      param("iSortingCols", sort.length);
    }
    var legacy = DataTable.ext.legacy.ajax;
    if (legacy === null) {
      return settings.sAjaxSource ? data : d;
    }
    return legacy ? data : d;
  }
  function _fnAjaxUpdateDraw(settings, json) {
    var compat = function(old, modern) {
      return json[old] !== undefined ? json[old] : json[modern];
    };
    var data = _fnAjaxDataSrc(settings, json);
    var draw = compat("sEcho", "draw");
    var recordsTotal = compat("iTotalRecords", "recordsTotal");
    var recordsFiltered = compat("iTotalDisplayRecords", "recordsFiltered");
    if (draw) {
      if (draw * 1 < settings.iDraw) {
        return;
      }
      settings.iDraw = draw * 1;
    }
    _fnClearTable(settings);
    settings._iRecordsTotal = parseInt(recordsTotal, 10);
    settings._iRecordsDisplay = parseInt(recordsFiltered, 10);
    for (var i = 0, ien = data.length; i < ien; i++) {
      _fnAddData(settings, data[i]);
    }
    settings.aiDisplay = settings.aiDisplayMaster.slice();
    settings.bAjaxDataGet = false;
    _fnDraw(settings);
    if (!settings._bInitComplete) {
      _fnInitComplete(settings, json);
    }
    settings.bAjaxDataGet = true;
    _fnProcessingDisplay(settings, false);
  }
  function _fnAjaxDataSrc(oSettings, json) {
    var dataSrc = $.isPlainObject(oSettings.ajax) && oSettings.ajax.dataSrc !== undefined ? oSettings.ajax.dataSrc : oSettings.sAjaxDataProp;
    if (dataSrc === "data") {
      return json.aaData || json[dataSrc];
    }
    return dataSrc !== "" ? _fnGetObjectDataFn(dataSrc)(json) : json;
  }
  function _fnFeatureHtmlFilter(settings) {
    var classes = settings.oClasses;
    var tableId = settings.sTableId;
    var language = settings.oLanguage;
    var previousSearch = settings.oPreviousSearch;
    var features = settings.aanFeatures;
    var input = '<input type="search" class="' + classes.sFilterInput + '"/>';
    var str = language.sSearch;
    str = str.match(/_INPUT_/) ? str.replace("_INPUT_", input) : str + input;
    var filter = $("<div/>", {"id":!features.f ? tableId + "_filter" : null, "class":classes.sFilter}).append($("<label/>").append(str));
    var searchFn = function() {
      var n = features.f;
      var val = !this.value ? "" : this.value;
      if (val != previousSearch.sSearch) {
        _fnFilterComplete(settings, {"sSearch":val, "bRegex":previousSearch.bRegex, "bSmart":previousSearch.bSmart, "bCaseInsensitive":previousSearch.bCaseInsensitive});
        settings._iDisplayStart = 0;
        _fnDraw(settings);
      }
    };
    var searchDelay = settings.searchDelay !== null ? settings.searchDelay : _fnDataSource(settings) === "ssp" ? 400 : 0;
    var jqFilter = $("input", filter).val(previousSearch.sSearch).attr("placeholder", language.sSearchPlaceholder).bind("keyup.DT search.DT input.DT paste.DT cut.DT", searchDelay ? _fnThrottle(searchFn, searchDelay) : searchFn).bind("keypress.DT", function(e) {
      if (e.keyCode == 13) {
        return false;
      }
    }).attr("aria-controls", tableId);
    $(settings.nTable).on("search.dt.DT", function(ev, s) {
      if (settings === s) {
        try {
          if (jqFilter[0] !== document.activeElement) {
            jqFilter.val(previousSearch.sSearch);
          }
        } catch (e) {
        }
      }
    });
    return filter[0];
  }
  function _fnFilterComplete(oSettings, oInput, iForce) {
    var oPrevSearch = oSettings.oPreviousSearch;
    var aoPrevSearch = oSettings.aoPreSearchCols;
    var fnSaveFilter = function(oFilter) {
      oPrevSearch.sSearch = oFilter.sSearch;
      oPrevSearch.bRegex = oFilter.bRegex;
      oPrevSearch.bSmart = oFilter.bSmart;
      oPrevSearch.bCaseInsensitive = oFilter.bCaseInsensitive;
    };
    var fnRegex = function(o) {
      return o.bEscapeRegex !== undefined ? !o.bEscapeRegex : o.bRegex;
    };
    _fnColumnTypes(oSettings);
    if (_fnDataSource(oSettings) != "ssp") {
      _fnFilter(oSettings, oInput.sSearch, iForce, fnRegex(oInput), oInput.bSmart, oInput.bCaseInsensitive);
      fnSaveFilter(oInput);
      for (var i = 0; i < aoPrevSearch.length; i++) {
        _fnFilterColumn(oSettings, aoPrevSearch[i].sSearch, i, fnRegex(aoPrevSearch[i]), aoPrevSearch[i].bSmart, aoPrevSearch[i].bCaseInsensitive);
      }
      _fnFilterCustom(oSettings);
    } else {
      fnSaveFilter(oInput);
    }
    oSettings.bFiltered = true;
    _fnCallbackFire(oSettings, null, "search", [oSettings]);
  }
  function _fnFilterCustom(settings) {
    var filters = DataTable.ext.search;
    var displayRows = settings.aiDisplay;
    var row, rowIdx;
    for (var i = 0, ien = filters.length; i < ien; i++) {
      var rows = [];
      for (var j = 0, jen = displayRows.length; j < jen; j++) {
        rowIdx = displayRows[j];
        row = settings.aoData[rowIdx];
        if (filters[i](settings, row._aFilterData, rowIdx, row._aData, j)) {
          rows.push(rowIdx);
        }
      }
      displayRows.length = 0;
      $.merge(displayRows, rows);
    }
  }
  function _fnFilterColumn(settings, searchStr, colIdx, regex, smart, caseInsensitive) {
    if (searchStr === "") {
      return;
    }
    var data;
    var display = settings.aiDisplay;
    var rpSearch = _fnFilterCreateSearch(searchStr, regex, smart, caseInsensitive);
    for (var i = display.length - 1; i >= 0; i--) {
      data = settings.aoData[display[i]]._aFilterData[colIdx];
      if (!rpSearch.test(data)) {
        display.splice(i, 1);
      }
    }
  }
  function _fnFilter(settings, input, force, regex, smart, caseInsensitive) {
    var rpSearch = _fnFilterCreateSearch(input, regex, smart, caseInsensitive);
    var prevSearch = settings.oPreviousSearch.sSearch;
    var displayMaster = settings.aiDisplayMaster;
    var display, invalidated, i;
    if (DataTable.ext.search.length !== 0) {
      force = true;
    }
    invalidated = _fnFilterData(settings);
    if (input.length <= 0) {
      settings.aiDisplay = displayMaster.slice();
    } else {
      if (invalidated || force || prevSearch.length > input.length || input.indexOf(prevSearch) !== 0 || settings.bSorted) {
        settings.aiDisplay = displayMaster.slice();
      }
      display = settings.aiDisplay;
      for (i = display.length - 1; i >= 0; i--) {
        if (!rpSearch.test(settings.aoData[display[i]]._sFilterRow)) {
          display.splice(i, 1);
        }
      }
    }
  }
  function _fnFilterCreateSearch(search, regex, smart, caseInsensitive) {
    search = regex ? search : _fnEscapeRegex(search);
    if (smart) {
      var a = $.map(search.match(/"[^"]+"|[^ ]+/g) || [""], function(word) {
        if (word.charAt(0) === '"') {
          var m = word.match(/^"(.*)"$/);
          word = m ? m[1] : word;
        }
        return word.replace('"', "");
      });
      search = "^(?=.*?" + a.join(")(?=.*?") + ").*$";
    }
    return new RegExp(search, caseInsensitive ? "i" : "");
  }
  var _fnEscapeRegex = DataTable.util.escapeRegex;
  var __filter_div = $("<div>")[0];
  var __filter_div_textContent = __filter_div.textContent !== undefined;
  function _fnFilterData(settings) {
    var columns = settings.aoColumns;
    var column;
    var i, j, ien, jen, filterData, cellData, row;
    var fomatters = DataTable.ext.type.search;
    var wasInvalidated = false;
    for (i = 0, ien = settings.aoData.length; i < ien; i++) {
      row = settings.aoData[i];
      if (!row._aFilterData) {
        filterData = [];
        for (j = 0, jen = columns.length; j < jen; j++) {
          column = columns[j];
          if (column.bSearchable) {
            cellData = _fnGetCellData(settings, i, j, "filter");
            if (fomatters[column.sType]) {
              cellData = fomatters[column.sType](cellData);
            }
            if (cellData === null) {
              cellData = "";
            }
            if (typeof cellData !== "string" && cellData.toString) {
              cellData = cellData.toString();
            }
          } else {
            cellData = "";
          }
          if (cellData.indexOf && cellData.indexOf("&") !== -1) {
            __filter_div.innerHTML = cellData;
            cellData = __filter_div_textContent ? __filter_div.textContent : __filter_div.innerText;
          }
          if (cellData.replace) {
            cellData = cellData.replace(/[\r\n]/g, "");
          }
          filterData.push(cellData);
        }
        row._aFilterData = filterData;
        row._sFilterRow = filterData.join("  ");
        wasInvalidated = true;
      }
    }
    return wasInvalidated;
  }
  function _fnSearchToCamel(obj) {
    return {search:obj.sSearch, smart:obj.bSmart, regex:obj.bRegex, caseInsensitive:obj.bCaseInsensitive};
  }
  function _fnSearchToHung(obj) {
    return {sSearch:obj.search, bSmart:obj.smart, bRegex:obj.regex, bCaseInsensitive:obj.caseInsensitive};
  }
  function _fnFeatureHtmlInfo(settings) {
    var tid = settings.sTableId, nodes = settings.aanFeatures.i, n = $("<div/>", {"class":settings.oClasses.sInfo, "id":!nodes ? tid + "_info" : null});
    if (!nodes) {
      settings.aoDrawCallback.push({"fn":_fnUpdateInfo, "sName":"information"});
      n.attr("role", "status").attr("aria-live", "polite");
      $(settings.nTable).attr("aria-describedby", tid + "_info");
    }
    return n[0];
  }
  function _fnUpdateInfo(settings) {
    var nodes = settings.aanFeatures.i;
    if (nodes.length === 0) {
      return;
    }
    var lang = settings.oLanguage, start = settings._iDisplayStart + 1, end = settings.fnDisplayEnd(), max = settings.fnRecordsTotal(), total = settings.fnRecordsDisplay(), out = total ? lang.sInfo : lang.sInfoEmpty;
    if (total !== max) {
      out += " " + lang.sInfoFiltered;
    }
    out += lang.sInfoPostFix;
    out = _fnInfoMacros(settings, out);
    var callback = lang.fnInfoCallback;
    if (callback !== null) {
      out = callback.call(settings.oInstance, settings, start, end, max, total, out);
    }
    $(nodes).html(out);
  }
  function _fnInfoMacros(settings, str) {
    var formatter = settings.fnFormatNumber, start = settings._iDisplayStart + 1, len = settings._iDisplayLength, vis = settings.fnRecordsDisplay(), all = len === -1;
    return str.replace(/_START_/g, formatter.call(settings, start)).replace(/_END_/g, formatter.call(settings, settings.fnDisplayEnd())).replace(/_MAX_/g, formatter.call(settings, settings.fnRecordsTotal())).replace(/_TOTAL_/g, formatter.call(settings, vis)).replace(/_PAGE_/g, formatter.call(settings, all ? 1 : Math.ceil(start / len))).replace(/_PAGES_/g, formatter.call(settings, all ? 1 : Math.ceil(vis / len)));
  }
  function _fnInitialise(settings) {
    var i, iLen, iAjaxStart = settings.iInitDisplayStart;
    var columns = settings.aoColumns, column;
    var features = settings.oFeatures;
    var deferLoading = settings.bDeferLoading;
    if (!settings.bInitialised) {
      setTimeout(function() {
        _fnInitialise(settings);
      }, 200);
      return;
    }
    _fnAddOptionsHtml(settings);
    _fnBuildHead(settings);
    _fnDrawHead(settings, settings.aoHeader);
    _fnDrawHead(settings, settings.aoFooter);
    _fnProcessingDisplay(settings, true);
    if (features.bAutoWidth) {
      _fnCalculateColumnWidths(settings);
    }
    for (i = 0, iLen = columns.length; i < iLen; i++) {
      column = columns[i];
      if (column.sWidth) {
        column.nTh.style.width = _fnStringToCss(column.sWidth);
      }
    }
    _fnCallbackFire(settings, null, "preInit", [settings]);
    _fnReDraw(settings);
    var dataSrc = _fnDataSource(settings);
    if (dataSrc != "ssp" || deferLoading) {
      if (dataSrc == "ajax") {
        _fnBuildAjax(settings, [], function(json) {
          var aData = _fnAjaxDataSrc(settings, json);
          for (i = 0; i < aData.length; i++) {
            _fnAddData(settings, aData[i]);
          }
          settings.iInitDisplayStart = iAjaxStart;
          _fnReDraw(settings);
          _fnProcessingDisplay(settings, false);
          _fnInitComplete(settings, json);
        }, settings);
      } else {
        _fnProcessingDisplay(settings, false);
        _fnInitComplete(settings);
      }
    }
  }
  function _fnInitComplete(settings, json) {
    settings._bInitComplete = true;
    if (json || settings.oInit.aaData) {
      _fnAdjustColumnSizing(settings);
    }
    _fnCallbackFire(settings, null, "plugin-init", [settings, json]);
    _fnCallbackFire(settings, "aoInitComplete", "init", [settings, json]);
  }
  function _fnLengthChange(settings, val) {
    var len = parseInt(val, 10);
    settings._iDisplayLength = len;
    _fnLengthOverflow(settings);
    _fnCallbackFire(settings, null, "length", [settings, len]);
  }
  function _fnFeatureHtmlLength(settings) {
    var classes = settings.oClasses, tableId = settings.sTableId, menu = settings.aLengthMenu, d2 = $.isArray(menu[0]), lengths = d2 ? menu[0] : menu, language = d2 ? menu[1] : menu;
    var select = $("<select/>", {"name":tableId + "_length", "aria-controls":tableId, "class":classes.sLengthSelect});
    for (var i = 0, ien = lengths.length; i < ien; i++) {
      select[0][i] = new Option(language[i], lengths[i]);
    }
    var div = $("<div><label/></div>").addClass(classes.sLength);
    if (!settings.aanFeatures.l) {
      div[0].id = tableId + "_length";
    }
    div.children().append(settings.oLanguage.sLengthMenu.replace("_MENU_", select[0].outerHTML));
    $("select", div).val(settings._iDisplayLength).bind("change.DT", function(e) {
      _fnLengthChange(settings, $(this).val());
      _fnDraw(settings);
    });
    $(settings.nTable).bind("length.dt.DT", function(e, s, len) {
      if (settings === s) {
        $("select", div).val(len);
      }
    });
    return div[0];
  }
  function _fnFeatureHtmlPaginate(settings) {
    var type = settings.sPaginationType, plugin = DataTable.ext.pager[type], modern = typeof plugin === "function", redraw = function(settings) {
      _fnDraw(settings);
    }, node = $("<div/>").addClass(settings.oClasses.sPaging + type)[0], features = settings.aanFeatures;
    if (!modern) {
      plugin.fnInit(settings, node, redraw);
    }
    if (!features.p) {
      node.id = settings.sTableId + "_paginate";
      settings.aoDrawCallback.push({"fn":function(settings) {
        if (modern) {
          var start = settings._iDisplayStart, len = settings._iDisplayLength, visRecords = settings.fnRecordsDisplay(), all = len === -1, page = all ? 0 : Math.ceil(start / len), pages = all ? 1 : Math.ceil(visRecords / len), buttons = plugin(page, pages), i, ien;
          for (i = 0, ien = features.p.length; i < ien; i++) {
            _fnRenderer(settings, "pageButton")(settings, features.p[i], i, buttons, page, pages);
          }
        } else {
          plugin.fnUpdate(settings, redraw);
        }
      }, "sName":"pagination"});
    }
    return node;
  }
  function _fnPageChange(settings, action, redraw) {
    var start = settings._iDisplayStart, len = settings._iDisplayLength, records = settings.fnRecordsDisplay();
    if (records === 0 || len === -1) {
      start = 0;
    } else {
      if (typeof action === "number") {
        start = action * len;
        if (start > records) {
          start = 0;
        }
      } else {
        if (action == "first") {
          start = 0;
        } else {
          if (action == "previous") {
            start = len >= 0 ? start - len : 0;
            if (start < 0) {
              start = 0;
            }
          } else {
            if (action == "next") {
              if (start + len < records) {
                start += len;
              }
            } else {
              if (action == "last") {
                start = Math.floor((records - 1) / len) * len;
              } else {
                _fnLog(settings, 0, "Unknown paging action: " + action, 5);
              }
            }
          }
        }
      }
    }
    var changed = settings._iDisplayStart !== start;
    settings._iDisplayStart = start;
    if (changed) {
      _fnCallbackFire(settings, null, "page", [settings]);
      if (redraw) {
        _fnDraw(settings);
      }
    }
    return changed;
  }
  function _fnFeatureHtmlProcessing(settings) {
    return $("<div/>", {"id":!settings.aanFeatures.r ? settings.sTableId + "_processing" : null, "class":settings.oClasses.sProcessing}).html(settings.oLanguage.sProcessing).insertBefore(settings.nTable)[0];
  }
  function _fnProcessingDisplay(settings, show) {
    if (settings.oFeatures.bProcessing) {
      $(settings.aanFeatures.r).css("display", show ? "block" : "none");
    }
    _fnCallbackFire(settings, null, "processing", [settings, show]);
  }
  function _fnFeatureHtmlTable(settings) {
    var table = $(settings.nTable);
    table.attr("role", "grid");
    var scroll = settings.oScroll;
    if (scroll.sX === "" && scroll.sY === "") {
      return settings.nTable;
    }
    var scrollX = scroll.sX;
    var scrollY = scroll.sY;
    var classes = settings.oClasses;
    var caption = table.children("caption");
    var captionSide = caption.length ? caption[0]._captionSide : null;
    var headerClone = $(table[0].cloneNode(false));
    var footerClone = $(table[0].cloneNode(false));
    var footer = table.children("tfoot");
    var _div = "<div/>";
    var size = function(s) {
      return !s ? null : _fnStringToCss(s);
    };
    if (!footer.length) {
      footer = null;
    }
    var scroller = $(_div, {"class":classes.sScrollWrapper}).append($(_div, {"class":classes.sScrollHead}).css({overflow:"hidden", position:"relative", border:0, width:scrollX ? size(scrollX) : "100%"}).append($(_div, {"class":classes.sScrollHeadInner}).css({"box-sizing":"content-box", width:scroll.sXInner || "100%"}).append(headerClone.removeAttr("id").css("margin-left", 0).append(captionSide === "top" ? caption : null).append(table.children("thead"))))).append($(_div, {"class":classes.sScrollBody}).css({position:"relative", 
    overflow:"auto", width:size(scrollX)}).append(table));
    if (footer) {
      scroller.append($(_div, {"class":classes.sScrollFoot}).css({overflow:"hidden", border:0, width:scrollX ? size(scrollX) : "100%"}).append($(_div, {"class":classes.sScrollFootInner}).append(footerClone.removeAttr("id").css("margin-left", 0).append(captionSide === "bottom" ? caption : null).append(table.children("tfoot")))));
    }
    var children = scroller.children();
    var scrollHead = children[0];
    var scrollBody = children[1];
    var scrollFoot = footer ? children[2] : null;
    if (scrollX) {
      $(scrollBody).on("scroll.DT", function(e) {
        var scrollLeft = this.scrollLeft;
        scrollHead.scrollLeft = scrollLeft;
        if (footer) {
          scrollFoot.scrollLeft = scrollLeft;
        }
      });
    }
    $(scrollBody).css(scrollY && scroll.bCollapse ? "max-height" : "height", scrollY);
    settings.nScrollHead = scrollHead;
    settings.nScrollBody = scrollBody;
    settings.nScrollFoot = scrollFoot;
    settings.aoDrawCallback.push({"fn":_fnScrollDraw, "sName":"scrolling"});
    return scroller[0];
  }
  function _fnScrollDraw(settings) {
    var scroll = settings.oScroll, scrollX = scroll.sX, scrollXInner = scroll.sXInner, scrollY = scroll.sY, barWidth = scroll.iBarWidth, divHeader = $(settings.nScrollHead), divHeaderStyle = divHeader[0].style, divHeaderInner = divHeader.children("div"), divHeaderInnerStyle = divHeaderInner[0].style, divHeaderTable = divHeaderInner.children("table"), divBodyEl = settings.nScrollBody, divBody = $(divBodyEl), divBodyStyle = divBodyEl.style, divFooter = $(settings.nScrollFoot), divFooterInner = divFooter.children("div"), 
    divFooterTable = divFooterInner.children("table"), header = $(settings.nTHead), table = $(settings.nTable), tableEl = table[0], tableStyle = tableEl.style, footer = settings.nTFoot ? $(settings.nTFoot) : null, browser = settings.oBrowser, ie67 = browser.bScrollOversize, dtHeaderCells = _pluck(settings.aoColumns, "nTh"), headerTrgEls, footerTrgEls, headerSrcEls, footerSrcEls, headerCopy, footerCopy, headerWidths = [], footerWidths = [], headerContent = [], footerContent = [], idx, correction, 
    sanityWidth, zeroOut = function(nSizer) {
      var style = nSizer.style;
      style.paddingTop = "0";
      style.paddingBottom = "0";
      style.borderTopWidth = "0";
      style.borderBottomWidth = "0";
      style.height = 0;
    };
    var scrollBarVis = divBodyEl.scrollHeight > divBodyEl.clientHeight;
    if (settings.scrollBarVis !== scrollBarVis && settings.scrollBarVis !== undefined) {
      settings.scrollBarVis = scrollBarVis;
      _fnAdjustColumnSizing(settings);
      return;
    } else {
      settings.scrollBarVis = scrollBarVis;
    }
    table.children("thead, tfoot").remove();
    if (footer) {
      footerCopy = footer.clone().prependTo(table);
      footerTrgEls = footer.find("tr");
      footerSrcEls = footerCopy.find("tr");
    }
    headerCopy = header.clone().prependTo(table);
    headerTrgEls = header.find("tr");
    headerSrcEls = headerCopy.find("tr");
    headerCopy.find("th, td").removeAttr("tabindex");
    if (!scrollX) {
      divBodyStyle.width = "100%";
      divHeader[0].style.width = "100%";
    }
    $.each(_fnGetUniqueThs(settings, headerCopy), function(i, el) {
      idx = _fnVisibleToColumnIndex(settings, i);
      el.style.width = settings.aoColumns[idx].sWidth;
    });
    if (footer) {
      _fnApplyToChildren(function(n) {
        n.style.width = "";
      }, footerSrcEls);
    }
    sanityWidth = table.outerWidth();
    if (scrollX === "") {
      tableStyle.width = "100%";
      if (ie67 && (table.find("tbody").height() > divBodyEl.offsetHeight || divBody.css("overflow-y") == "scroll")) {
        tableStyle.width = _fnStringToCss(table.outerWidth() - barWidth);
      }
      sanityWidth = table.outerWidth();
    } else {
      if (scrollXInner !== "") {
        tableStyle.width = _fnStringToCss(scrollXInner);
        sanityWidth = table.outerWidth();
      }
    }
    _fnApplyToChildren(zeroOut, headerSrcEls);
    _fnApplyToChildren(function(nSizer) {
      headerContent.push(nSizer.innerHTML);
      headerWidths.push(_fnStringToCss($(nSizer).css("width")));
    }, headerSrcEls);
    _fnApplyToChildren(function(nToSize, i) {
      if ($.inArray(nToSize, dtHeaderCells) !== -1) {
        nToSize.style.width = headerWidths[i];
      }
    }, headerTrgEls);
    $(headerSrcEls).height(0);
    if (footer) {
      _fnApplyToChildren(zeroOut, footerSrcEls);
      _fnApplyToChildren(function(nSizer) {
        footerContent.push(nSizer.innerHTML);
        footerWidths.push(_fnStringToCss($(nSizer).css("width")));
      }, footerSrcEls);
      _fnApplyToChildren(function(nToSize, i) {
        nToSize.style.width = footerWidths[i];
      }, footerTrgEls);
      $(footerSrcEls).height(0);
    }
    _fnApplyToChildren(function(nSizer, i) {
      nSizer.innerHTML = '<div class="dataTables_sizing" style="height:0;overflow:hidden;">' + headerContent[i] + "</div>";
      nSizer.style.width = headerWidths[i];
    }, headerSrcEls);
    if (footer) {
      _fnApplyToChildren(function(nSizer, i) {
        nSizer.innerHTML = '<div class="dataTables_sizing" style="height:0;overflow:hidden;">' + footerContent[i] + "</div>";
        nSizer.style.width = footerWidths[i];
      }, footerSrcEls);
    }
    if (table.outerWidth() < sanityWidth) {
      correction = divBodyEl.scrollHeight > divBodyEl.offsetHeight || divBody.css("overflow-y") == "scroll" ? sanityWidth + barWidth : sanityWidth;
      if (ie67 && (divBodyEl.scrollHeight > divBodyEl.offsetHeight || divBody.css("overflow-y") == "scroll")) {
        tableStyle.width = _fnStringToCss(correction - barWidth);
      }
      if (scrollX === "" || scrollXInner !== "") {
        _fnLog(settings, 1, "Possible column misalignment", 6);
      }
    } else {
      correction = "100%";
    }
    divBodyStyle.width = _fnStringToCss(correction);
    divHeaderStyle.width = _fnStringToCss(correction);
    if (footer) {
      settings.nScrollFoot.style.width = _fnStringToCss(correction);
    }
    if (!scrollY) {
      if (ie67) {
        divBodyStyle.height = _fnStringToCss(tableEl.offsetHeight + barWidth);
      }
    }
    var iOuterWidth = table.outerWidth();
    divHeaderTable[0].style.width = _fnStringToCss(iOuterWidth);
    divHeaderInnerStyle.width = _fnStringToCss(iOuterWidth);
    var bScrolling = table.height() > divBodyEl.clientHeight || divBody.css("overflow-y") == "scroll";
    var padding = "padding" + (browser.bScrollbarLeft ? "Left" : "Right");
    divHeaderInnerStyle[padding] = bScrolling ? barWidth + "px" : "0px";
    if (footer) {
      divFooterTable[0].style.width = _fnStringToCss(iOuterWidth);
      divFooterInner[0].style.width = _fnStringToCss(iOuterWidth);
      divFooterInner[0].style[padding] = bScrolling ? barWidth + "px" : "0px";
    }
    table.children("colgroup").insertBefore(table.children("thead"));
    divBody.scroll();
    if ((settings.bSorted || settings.bFiltered) && !settings._drawHold) {
      divBodyEl.scrollTop = 0;
    }
  }
  function _fnApplyToChildren(fn, an1, an2) {
    var index = 0, i = 0, iLen = an1.length;
    var nNode1, nNode2;
    while (i < iLen) {
      nNode1 = an1[i].firstChild;
      nNode2 = an2 ? an2[i].firstChild : null;
      while (nNode1) {
        if (nNode1.nodeType === 1) {
          if (an2) {
            fn(nNode1, nNode2, index);
          } else {
            fn(nNode1, index);
          }
          index++;
        }
        nNode1 = nNode1.nextSibling;
        nNode2 = an2 ? nNode2.nextSibling : null;
      }
      i++;
    }
  }
  var __re_html_remove = /<.*?>/g;
  function _fnCalculateColumnWidths(oSettings) {
    var table = oSettings.nTable, columns = oSettings.aoColumns, scroll = oSettings.oScroll, scrollY = scroll.sY, scrollX = scroll.sX, scrollXInner = scroll.sXInner, columnCount = columns.length, visibleColumns = _fnGetColumns(oSettings, "bVisible"), headerCells = $("th", oSettings.nTHead), tableWidthAttr = table.getAttribute("width"), tableContainer = table.parentNode, userInputs = false, i, column, columnIdx, width, outerWidth, browser = oSettings.oBrowser, ie67 = browser.bScrollOversize;
    var styleWidth = table.style.width;
    if (styleWidth && styleWidth.indexOf("%") !== -1) {
      tableWidthAttr = styleWidth;
    }
    for (i = 0; i < visibleColumns.length; i++) {
      column = columns[visibleColumns[i]];
      if (column.sWidth !== null) {
        column.sWidth = _fnConvertToWidth(column.sWidthOrig, tableContainer);
        userInputs = true;
      }
    }
    if (ie67 || !userInputs && !scrollX && !scrollY && columnCount == _fnVisbleColumns(oSettings) && columnCount == headerCells.length) {
      for (i = 0; i < columnCount; i++) {
        var colIdx = _fnVisibleToColumnIndex(oSettings, i);
        if (colIdx !== null) {
          columns[colIdx].sWidth = _fnStringToCss(headerCells.eq(i).width());
        }
      }
    } else {
      var tmpTable = $(table).clone().css("visibility", "hidden").removeAttr("id");
      tmpTable.find("tbody tr").remove();
      var tr = $("<tr/>").appendTo(tmpTable.find("tbody"));
      tmpTable.find("thead, tfoot").remove();
      tmpTable.append($(oSettings.nTHead).clone()).append($(oSettings.nTFoot).clone());
      tmpTable.find("tfoot th, tfoot td").css("width", "");
      headerCells = _fnGetUniqueThs(oSettings, tmpTable.find("thead")[0]);
      for (i = 0; i < visibleColumns.length; i++) {
        column = columns[visibleColumns[i]];
        headerCells[i].style.width = column.sWidthOrig !== null && column.sWidthOrig !== "" ? _fnStringToCss(column.sWidthOrig) : "";
        if (column.sWidthOrig && scrollX) {
          $(headerCells[i]).append($("<div/>").css({width:column.sWidthOrig, margin:0, padding:0, border:0, height:1}));
        }
      }
      if (oSettings.aoData.length) {
        for (i = 0; i < visibleColumns.length; i++) {
          columnIdx = visibleColumns[i];
          column = columns[columnIdx];
          $(_fnGetWidestNode(oSettings, columnIdx)).clone(false).append(column.sContentPadding).appendTo(tr);
        }
      }
      $("[name]", tmpTable).removeAttr("name");
      var holder = $("<div/>").css(scrollX || scrollY ? {position:"absolute", top:0, left:0, height:1, right:0, overflow:"hidden"} : {}).append(tmpTable).appendTo(tableContainer);
      if (scrollX && scrollXInner) {
        tmpTable.width(scrollXInner);
      } else {
        if (scrollX) {
          tmpTable.css("width", "auto");
          tmpTable.removeAttr("width");
          if (tmpTable.width() < tableContainer.clientWidth && tableWidthAttr) {
            tmpTable.width(tableContainer.clientWidth);
          }
        } else {
          if (scrollY) {
            tmpTable.width(tableContainer.clientWidth);
          } else {
            if (tableWidthAttr) {
              tmpTable.width(tableWidthAttr);
            }
          }
        }
      }
      var total = 0;
      for (i = 0; i < visibleColumns.length; i++) {
        var cell = $(headerCells[i]);
        var border = cell.outerWidth() - cell.width();
        var bounding = browser.bBounding ? Math.ceil(headerCells[i].getBoundingClientRect().width) : cell.outerWidth();
        total += bounding;
        columns[visibleColumns[i]].sWidth = _fnStringToCss(bounding - border);
      }
      table.style.width = _fnStringToCss(total);
      holder.remove();
    }
    if (tableWidthAttr) {
      table.style.width = _fnStringToCss(tableWidthAttr);
    }
    if ((tableWidthAttr || scrollX) && !oSettings._reszEvt) {
      var bindResize = function() {
        $(window).bind("resize.DT-" + oSettings.sInstance, _fnThrottle(function() {
          _fnAdjustColumnSizing(oSettings);
        }));
      };
      if (ie67) {
        setTimeout(bindResize, 1000);
      } else {
        bindResize();
      }
      oSettings._reszEvt = true;
    }
  }
  var _fnThrottle = DataTable.util.throttle;
  function _fnConvertToWidth(width, parent) {
    if (!width) {
      return 0;
    }
    var n = $("<div/>").css("width", _fnStringToCss(width)).appendTo(parent || document.body);
    var val = n[0].offsetWidth;
    n.remove();
    return val;
  }
  function _fnGetWidestNode(settings, colIdx) {
    var idx = _fnGetMaxLenString(settings, colIdx);
    if (idx < 0) {
      return null;
    }
    var data = settings.aoData[idx];
    return !data.nTr ? $("<td/>").html(_fnGetCellData(settings, idx, colIdx, "display"))[0] : data.anCells[colIdx];
  }
  function _fnGetMaxLenString(settings, colIdx) {
    var s, max = -1, maxIdx = -1;
    for (var i = 0, ien = settings.aoData.length; i < ien; i++) {
      s = _fnGetCellData(settings, i, colIdx, "display") + "";
      s = s.replace(__re_html_remove, "");
      s = s.replace(/&nbsp;/g, " ");
      if (s.length > max) {
        max = s.length;
        maxIdx = i;
      }
    }
    return maxIdx;
  }
  function _fnStringToCss(s) {
    if (s === null) {
      return "0px";
    }
    if (typeof s == "number") {
      return s < 0 ? "0px" : s + "px";
    }
    return s.match(/\d$/) ? s + "px" : s;
  }
  function _fnSortFlatten(settings) {
    var i, iLen, k, kLen, aSort = [], aiOrig = [], aoColumns = settings.aoColumns, aDataSort, iCol, sType, srcCol, fixed = settings.aaSortingFixed, fixedObj = $.isPlainObject(fixed), nestedSort = [], add = function(a) {
      if (a.length && !$.isArray(a[0])) {
        nestedSort.push(a);
      } else {
        $.merge(nestedSort, a);
      }
    };
    if ($.isArray(fixed)) {
      add(fixed);
    }
    if (fixedObj && fixed.pre) {
      add(fixed.pre);
    }
    add(settings.aaSorting);
    if (fixedObj && fixed.post) {
      add(fixed.post);
    }
    for (i = 0; i < nestedSort.length; i++) {
      srcCol = nestedSort[i][0];
      aDataSort = aoColumns[srcCol].aDataSort;
      for (k = 0, kLen = aDataSort.length; k < kLen; k++) {
        iCol = aDataSort[k];
        sType = aoColumns[iCol].sType || "string";
        if (nestedSort[i]._idx === undefined) {
          nestedSort[i]._idx = $.inArray(nestedSort[i][1], aoColumns[iCol].asSorting);
        }
        aSort.push({src:srcCol, col:iCol, dir:nestedSort[i][1], index:nestedSort[i]._idx, type:sType, formatter:DataTable.ext.type.order[sType + "-pre"]});
      }
    }
    return aSort;
  }
  function _fnSort(oSettings) {
    var i, ien, iLen, j, jLen, k, kLen, sDataType, nTh, aiOrig = [], oExtSort = DataTable.ext.type.order, aoData = oSettings.aoData, aoColumns = oSettings.aoColumns, aDataSort, data, iCol, sType, oSort, formatters = 0, sortCol, displayMaster = oSettings.aiDisplayMaster, aSort;
    _fnColumnTypes(oSettings);
    aSort = _fnSortFlatten(oSettings);
    for (i = 0, ien = aSort.length; i < ien; i++) {
      sortCol = aSort[i];
      if (sortCol.formatter) {
        formatters++;
      }
      _fnSortData(oSettings, sortCol.col);
    }
    if (_fnDataSource(oSettings) != "ssp" && aSort.length !== 0) {
      for (i = 0, iLen = displayMaster.length; i < iLen; i++) {
        aiOrig[displayMaster[i]] = i;
      }
      if (formatters === aSort.length) {
        displayMaster.sort(function(a, b) {
          var x, y, k, test, sort, len = aSort.length, dataA = aoData[a]._aSortData, dataB = aoData[b]._aSortData;
          for (k = 0; k < len; k++) {
            sort = aSort[k];
            x = dataA[sort.col];
            y = dataB[sort.col];
            test = x < y ? -1 : x > y ? 1 : 0;
            if (test !== 0) {
              return sort.dir === "asc" ? test : -test;
            }
          }
          x = aiOrig[a];
          y = aiOrig[b];
          return x < y ? -1 : x > y ? 1 : 0;
        });
      } else {
        displayMaster.sort(function(a, b) {
          var x, y, k, l, test, sort, fn, len = aSort.length, dataA = aoData[a]._aSortData, dataB = aoData[b]._aSortData;
          for (k = 0; k < len; k++) {
            sort = aSort[k];
            x = dataA[sort.col];
            y = dataB[sort.col];
            fn = oExtSort[sort.type + "-" + sort.dir] || oExtSort["string-" + sort.dir];
            test = fn(x, y);
            if (test !== 0) {
              return test;
            }
          }
          x = aiOrig[a];
          y = aiOrig[b];
          return x < y ? -1 : x > y ? 1 : 0;
        });
      }
    }
    oSettings.bSorted = true;
  }
  function _fnSortAria(settings) {
    var label;
    var nextSort;
    var columns = settings.aoColumns;
    var aSort = _fnSortFlatten(settings);
    var oAria = settings.oLanguage.oAria;
    for (var i = 0, iLen = columns.length; i < iLen; i++) {
      var col = columns[i];
      var asSorting = col.asSorting;
      var sTitle = col.sTitle.replace(/<.*?>/g, "");
      var th = col.nTh;
      th.removeAttribute("aria-sort");
      if (col.bSortable) {
        if (aSort.length > 0 && aSort[0].col == i) {
          th.setAttribute("aria-sort", aSort[0].dir == "asc" ? "ascending" : "descending");
          nextSort = asSorting[aSort[0].index + 1] || asSorting[0];
        } else {
          nextSort = asSorting[0];
        }
        label = sTitle + (nextSort === "asc" ? oAria.sSortAscending : oAria.sSortDescending);
      } else {
        label = sTitle;
      }
      th.setAttribute("aria-label", label);
    }
  }
  function _fnSortListener(settings, colIdx, append, callback) {
    var col = settings.aoColumns[colIdx];
    var sorting = settings.aaSorting;
    var asSorting = col.asSorting;
    var nextSortIdx;
    var next = function(a, overflow) {
      var idx = a._idx;
      if (idx === undefined) {
        idx = $.inArray(a[1], asSorting);
      }
      return idx + 1 < asSorting.length ? idx + 1 : overflow ? null : 0;
    };
    if (typeof sorting[0] === "number") {
      sorting = settings.aaSorting = [sorting];
    }
    if (append && settings.oFeatures.bSortMulti) {
      var sortIdx = $.inArray(colIdx, _pluck(sorting, "0"));
      if (sortIdx !== -1) {
        nextSortIdx = next(sorting[sortIdx], true);
        if (nextSortIdx === null && sorting.length === 1) {
          nextSortIdx = 0;
        }
        if (nextSortIdx === null) {
          sorting.splice(sortIdx, 1);
        } else {
          sorting[sortIdx][1] = asSorting[nextSortIdx];
          sorting[sortIdx]._idx = nextSortIdx;
        }
      } else {
        sorting.push([colIdx, asSorting[0], 0]);
        sorting[sorting.length - 1]._idx = 0;
      }
    } else {
      if (sorting.length && sorting[0][0] == colIdx) {
        nextSortIdx = next(sorting[0]);
        sorting.length = 1;
        sorting[0][1] = asSorting[nextSortIdx];
        sorting[0]._idx = nextSortIdx;
      } else {
        sorting.length = 0;
        sorting.push([colIdx, asSorting[0]]);
        sorting[0]._idx = 0;
      }
    }
    _fnReDraw(settings);
    if (typeof callback == "function") {
      callback(settings);
    }
  }
  function _fnSortAttachListener(settings, attachTo, colIdx, callback) {
    var col = settings.aoColumns[colIdx];
    _fnBindAction(attachTo, {}, function(e) {
      if (col.bSortable === false) {
        return;
      }
      if (settings.oFeatures.bProcessing) {
        _fnProcessingDisplay(settings, true);
        setTimeout(function() {
          _fnSortListener(settings, colIdx, e.shiftKey, callback);
          if (_fnDataSource(settings) !== "ssp") {
            _fnProcessingDisplay(settings, false);
          }
        }, 0);
      } else {
        _fnSortListener(settings, colIdx, e.shiftKey, callback);
      }
    });
  }
  function _fnSortingClasses(settings) {
    var oldSort = settings.aLastSort;
    var sortClass = settings.oClasses.sSortColumn;
    var sort = _fnSortFlatten(settings);
    var features = settings.oFeatures;
    var i, ien, colIdx;
    if (features.bSort && features.bSortClasses) {
      for (i = 0, ien = oldSort.length; i < ien; i++) {
        colIdx = oldSort[i].src;
        $(_pluck(settings.aoData, "anCells", colIdx)).removeClass(sortClass + (i < 2 ? i + 1 : 3));
      }
      for (i = 0, ien = sort.length; i < ien; i++) {
        colIdx = sort[i].src;
        $(_pluck(settings.aoData, "anCells", colIdx)).addClass(sortClass + (i < 2 ? i + 1 : 3));
      }
    }
    settings.aLastSort = sort;
  }
  function _fnSortData(settings, idx) {
    var column = settings.aoColumns[idx];
    var customSort = DataTable.ext.order[column.sSortDataType];
    var customData;
    if (customSort) {
      customData = customSort.call(settings.oInstance, settings, idx, _fnColumnIndexToVisible(settings, idx));
    }
    var row, cellData;
    var formatter = DataTable.ext.type.order[column.sType + "-pre"];
    for (var i = 0, ien = settings.aoData.length; i < ien; i++) {
      row = settings.aoData[i];
      if (!row._aSortData) {
        row._aSortData = [];
      }
      if (!row._aSortData[idx] || customSort) {
        cellData = customSort ? customData[i] : _fnGetCellData(settings, i, idx, "sort");
        row._aSortData[idx] = formatter ? formatter(cellData) : cellData;
      }
    }
  }
  function _fnSaveState(settings) {
    if (!settings.oFeatures.bStateSave || settings.bDestroying) {
      return;
    }
    var state = {time:+new Date, start:settings._iDisplayStart, length:settings._iDisplayLength, order:$.extend(true, [], settings.aaSorting), search:_fnSearchToCamel(settings.oPreviousSearch), columns:$.map(settings.aoColumns, function(col, i) {
      return {visible:col.bVisible, search:_fnSearchToCamel(settings.aoPreSearchCols[i])};
    })};
    _fnCallbackFire(settings, "aoStateSaveParams", "stateSaveParams", [settings, state]);
    settings.oSavedState = state;
    settings.fnStateSaveCallback.call(settings.oInstance, settings, state);
  }
  function _fnLoadState(settings, oInit) {
    var i, ien;
    var columns = settings.aoColumns;
    if (!settings.oFeatures.bStateSave) {
      return;
    }
    var state = settings.fnStateLoadCallback.call(settings.oInstance, settings);
    if (!state || !state.time) {
      return;
    }
    var abStateLoad = _fnCallbackFire(settings, "aoStateLoadParams", "stateLoadParams", [settings, state]);
    if ($.inArray(false, abStateLoad) !== -1) {
      return;
    }
    var duration = settings.iStateDuration;
    if (duration > 0 && state.time < +new Date - duration * 1000) {
      return;
    }
    if (columns.length !== state.columns.length) {
      return;
    }
    settings.oLoadedState = $.extend(true, {}, state);
    if (state.start !== undefined) {
      settings._iDisplayStart = state.start;
      settings.iInitDisplayStart = state.start;
    }
    if (state.length !== undefined) {
      settings._iDisplayLength = state.length;
    }
    if (state.order !== undefined) {
      settings.aaSorting = [];
      $.each(state.order, function(i, col) {
        settings.aaSorting.push(col[0] >= columns.length ? [0, col[1]] : col);
      });
    }
    if (state.search !== undefined) {
      $.extend(settings.oPreviousSearch, _fnSearchToHung(state.search));
    }
    for (i = 0, ien = state.columns.length; i < ien; i++) {
      var col = state.columns[i];
      if (col.visible !== undefined) {
        columns[i].bVisible = col.visible;
      }
      if (col.search !== undefined) {
        $.extend(settings.aoPreSearchCols[i], _fnSearchToHung(col.search));
      }
    }
    _fnCallbackFire(settings, "aoStateLoaded", "stateLoaded", [settings, state]);
  }
  function _fnSettingsFromNode(table) {
    var settings = DataTable.settings;
    var idx = $.inArray(table, _pluck(settings, "nTable"));
    return idx !== -1 ? settings[idx] : null;
  }
  function _fnLog(settings, level, msg, tn) {
    msg = "DataTables warning: " + (settings ? "table id=" + settings.sTableId + " - " : "") + msg;
    if (tn) {
      msg += ". For more information about this error, please see " + "http://datatables.net/tn/" + tn;
    }
    if (!level) {
      var ext = DataTable.ext;
      var type = ext.sErrMode || ext.errMode;
      if (settings) {
        _fnCallbackFire(settings, null, "error", [settings, tn, msg]);
      }
      if (type == "alert") {
        alert(msg);
      } else {
        if (type == "throw") {
          throw new Error(msg);
        } else {
          if (typeof type == "function") {
            type(settings, tn, msg);
          }
        }
      }
    } else {
      if (window.console && console.log) {
        console.log(msg);
      }
    }
  }
  function _fnMap(ret, src, name, mappedName) {
    if ($.isArray(name)) {
      $.each(name, function(i, val) {
        if ($.isArray(val)) {
          _fnMap(ret, src, val[0], val[1]);
        } else {
          _fnMap(ret, src, val);
        }
      });
      return;
    }
    if (mappedName === undefined) {
      mappedName = name;
    }
    if (src[name] !== undefined) {
      ret[mappedName] = src[name];
    }
  }
  function _fnExtend(out, extender, breakRefs) {
    var val;
    for (var prop in extender) {
      if (extender.hasOwnProperty(prop)) {
        val = extender[prop];
        if ($.isPlainObject(val)) {
          if (!$.isPlainObject(out[prop])) {
            out[prop] = {};
          }
          $.extend(true, out[prop], val);
        } else {
          if (breakRefs && prop !== "data" && prop !== "aaData" && $.isArray(val)) {
            out[prop] = val.slice();
          } else {
            out[prop] = val;
          }
        }
      }
    }
    return out;
  }
  function _fnBindAction(n, oData, fn) {
    $(n).bind("click.DT", oData, function(e) {
      n.blur();
      fn(e);
    }).bind("keypress.DT", oData, function(e) {
      if (e.which === 13) {
        e.preventDefault();
        fn(e);
      }
    }).bind("selectstart.DT", function() {
      return false;
    });
  }
  function _fnCallbackReg(oSettings, sStore, fn, sName) {
    if (fn) {
      oSettings[sStore].push({"fn":fn, "sName":sName});
    }
  }
  function _fnCallbackFire(settings, callbackArr, eventName, args) {
    var ret = [];
    if (callbackArr) {
      ret = $.map(settings[callbackArr].slice().reverse(), function(val, i) {
        return val.fn.apply(settings.oInstance, args);
      });
    }
    if (eventName !== null) {
      var e = $.Event(eventName + ".dt");
      $(settings.nTable).trigger(e, args);
      ret.push(e.result);
    }
    return ret;
  }
  function _fnLengthOverflow(settings) {
    var start = settings._iDisplayStart, end = settings.fnDisplayEnd(), len = settings._iDisplayLength;
    if (start >= end) {
      start = end - len;
    }
    start -= start % len;
    if (len === -1 || start < 0) {
      start = 0;
    }
    settings._iDisplayStart = start;
  }
  function _fnRenderer(settings, type) {
    var renderer = settings.renderer;
    var host = DataTable.ext.renderer[type];
    if ($.isPlainObject(renderer) && renderer[type]) {
      return host[renderer[type]] || host._;
    } else {
      if (typeof renderer === "string") {
        return host[renderer] || host._;
      }
    }
    return host._;
  }
  function _fnDataSource(settings) {
    if (settings.oFeatures.bServerSide) {
      return "ssp";
    } else {
      if (settings.ajax || settings.sAjaxSource) {
        return "ajax";
      }
    }
    return "dom";
  }
  var __apiStruct = [];
  var __arrayProto = Array.prototype;
  var _toSettings = function(mixed) {
    var idx, jq;
    var settings = DataTable.settings;
    var tables = $.map(settings, function(el, i) {
      return el.nTable;
    });
    if (!mixed) {
      return [];
    } else {
      if (mixed.nTable && mixed.oApi) {
        return [mixed];
      } else {
        if (mixed.nodeName && mixed.nodeName.toLowerCase() === "table") {
          idx = $.inArray(mixed, tables);
          return idx !== -1 ? [settings[idx]] : null;
        } else {
          if (mixed && typeof mixed.settings === "function") {
            return mixed.settings().toArray();
          } else {
            if (typeof mixed === "string") {
              jq = $(mixed);
            } else {
              if (mixed instanceof $) {
                jq = mixed;
              }
            }
          }
        }
      }
    }
    if (jq) {
      return jq.map(function(i) {
        idx = $.inArray(this, tables);
        return idx !== -1 ? settings[idx] : null;
      }).toArray();
    }
  };
  _Api = function(context, data) {
    if (!(this instanceof _Api)) {
      return new _Api(context, data);
    }
    var settings = [];
    var ctxSettings = function(o) {
      var a = _toSettings(o);
      if (a) {
        settings = settings.concat(a);
      }
    };
    if ($.isArray(context)) {
      for (var i = 0, ien = context.length; i < ien; i++) {
        ctxSettings(context[i]);
      }
    } else {
      ctxSettings(context);
    }
    this.context = _unique(settings);
    if (data) {
      $.merge(this, data);
    }
    this.selector = {rows:null, cols:null, opts:null};
    _Api.extend(this, this, __apiStruct);
  };
  DataTable.Api = _Api;
  $.extend(_Api.prototype, {any:function() {
    return this.count() !== 0;
  }, concat:__arrayProto.concat, context:[], count:function() {
    return this.flatten().length;
  }, each:function(fn) {
    for (var i = 0, ien = this.length; i < ien; i++) {
      fn.call(this, this[i], i, this);
    }
    return this;
  }, eq:function(idx) {
    var ctx = this.context;
    return ctx.length > idx ? new _Api(ctx[idx], this[idx]) : null;
  }, filter:function(fn) {
    var a = [];
    if (__arrayProto.filter) {
      a = __arrayProto.filter.call(this, fn, this);
    } else {
      for (var i = 0, ien = this.length; i < ien; i++) {
        if (fn.call(this, this[i], i, this)) {
          a.push(this[i]);
        }
      }
    }
    return new _Api(this.context, a);
  }, flatten:function() {
    var a = [];
    return new _Api(this.context, a.concat.apply(a, this.toArray()));
  }, join:__arrayProto.join, indexOf:__arrayProto.indexOf || function(obj, start) {
    for (var i = start || 0, ien = this.length; i < ien; i++) {
      if (this[i] === obj) {
        return i;
      }
    }
    return -1;
  }, iterator:function(flatten, type, fn, alwaysNew) {
    var a = [], ret, i, ien, j, jen, context = this.context, rows, items, item, selector = this.selector;
    if (typeof flatten === "string") {
      alwaysNew = fn;
      fn = type;
      type = flatten;
      flatten = false;
    }
    for (i = 0, ien = context.length; i < ien; i++) {
      var apiInst = new _Api(context[i]);
      if (type === "table") {
        ret = fn.call(apiInst, context[i], i);
        if (ret !== undefined) {
          a.push(ret);
        }
      } else {
        if (type === "columns" || type === "rows") {
          ret = fn.call(apiInst, context[i], this[i], i);
          if (ret !== undefined) {
            a.push(ret);
          }
        } else {
          if (type === "column" || type === "column-rows" || type === "row" || type === "cell") {
            items = this[i];
            if (type === "column-rows") {
              rows = _selector_row_indexes(context[i], selector.opts);
            }
            for (j = 0, jen = items.length; j < jen; j++) {
              item = items[j];
              if (type === "cell") {
                ret = fn.call(apiInst, context[i], item.row, item.column, i, j);
              } else {
                ret = fn.call(apiInst, context[i], item, i, j, rows);
              }
              if (ret !== undefined) {
                a.push(ret);
              }
            }
          }
        }
      }
    }
    if (a.length || alwaysNew) {
      var api = new _Api(context, flatten ? a.concat.apply([], a) : a);
      var apiSelector = api.selector;
      apiSelector.rows = selector.rows;
      apiSelector.cols = selector.cols;
      apiSelector.opts = selector.opts;
      return api;
    }
    return this;
  }, lastIndexOf:__arrayProto.lastIndexOf || function(obj, start) {
    return this.indexOf.apply(this.toArray.reverse(), arguments);
  }, length:0, map:function(fn) {
    var a = [];
    if (__arrayProto.map) {
      a = __arrayProto.map.call(this, fn, this);
    } else {
      for (var i = 0, ien = this.length; i < ien; i++) {
        a.push(fn.call(this, this[i], i));
      }
    }
    return new _Api(this.context, a);
  }, pluck:function(prop) {
    return this.map(function(el) {
      return el[prop];
    });
  }, pop:__arrayProto.pop, push:__arrayProto.push, reduce:__arrayProto.reduce || function(fn, init) {
    return _fnReduce(this, fn, init, 0, this.length, 1);
  }, reduceRight:__arrayProto.reduceRight || function(fn, init) {
    return _fnReduce(this, fn, init, this.length - 1, -1, -1);
  }, reverse:__arrayProto.reverse, selector:null, shift:__arrayProto.shift, sort:__arrayProto.sort, splice:__arrayProto.splice, toArray:function() {
    return __arrayProto.slice.call(this);
  }, to$:function() {
    return $(this);
  }, toJQuery:function() {
    return $(this);
  }, unique:function() {
    return new _Api(this.context, _unique(this));
  }, unshift:__arrayProto.unshift});
  _Api.extend = function(scope, obj, ext) {
    if (!ext.length || !obj || !(obj instanceof _Api) && !obj.__dt_wrapper) {
      return;
    }
    var i, ien, j, jen, struct, inner, methodScoping = function(scope, fn, struc) {
      return function() {
        var ret = fn.apply(scope, arguments);
        _Api.extend(ret, ret, struc.methodExt);
        return ret;
      };
    };
    for (i = 0, ien = ext.length; i < ien; i++) {
      struct = ext[i];
      obj[struct.name] = typeof struct.val === "function" ? methodScoping(scope, struct.val, struct) : $.isPlainObject(struct.val) ? {} : struct.val;
      obj[struct.name].__dt_wrapper = true;
      _Api.extend(scope, obj[struct.name], struct.propExt);
    }
  };
  _Api.register = _api_register = function(name, val) {
    if ($.isArray(name)) {
      for (var j = 0, jen = name.length; j < jen; j++) {
        _Api.register(name[j], val);
      }
      return;
    }
    var i, ien, heir = name.split("."), struct = __apiStruct, key, method;
    var find = function(src, name) {
      for (var i = 0, ien = src.length; i < ien; i++) {
        if (src[i].name === name) {
          return src[i];
        }
      }
      return null;
    };
    for (i = 0, ien = heir.length; i < ien; i++) {
      method = heir[i].indexOf("()") !== -1;
      key = method ? heir[i].replace("()", "") : heir[i];
      var src = find(struct, key);
      if (!src) {
        src = {name:key, val:{}, methodExt:[], propExt:[]};
        struct.push(src);
      }
      if (i === ien - 1) {
        src.val = val;
      } else {
        struct = method ? src.methodExt : src.propExt;
      }
    }
  };
  _Api.registerPlural = _api_registerPlural = function(pluralName, singularName, val) {
    _Api.register(pluralName, val);
    _Api.register(singularName, function() {
      var ret = val.apply(this, arguments);
      if (ret === this) {
        return this;
      } else {
        if (ret instanceof _Api) {
          return ret.length ? $.isArray(ret[0]) ? new _Api(ret.context, ret[0]) : ret[0] : undefined;
        }
      }
      return ret;
    });
  };
  var __table_selector = function(selector, a) {
    if (typeof selector === "number") {
      return [a[selector]];
    }
    var nodes = $.map(a, function(el, i) {
      return el.nTable;
    });
    return $(nodes).filter(selector).map(function(i) {
      var idx = $.inArray(this, nodes);
      return a[idx];
    }).toArray();
  };
  _api_register("tables()", function(selector) {
    return selector ? new _Api(__table_selector(selector, this.context)) : this;
  });
  _api_register("table()", function(selector) {
    var tables = this.tables(selector);
    var ctx = tables.context;
    return ctx.length ? new _Api(ctx[0]) : tables;
  });
  _api_registerPlural("tables().nodes()", "table().node()", function() {
    return this.iterator("table", function(ctx) {
      return ctx.nTable;
    }, 1);
  });
  _api_registerPlural("tables().body()", "table().body()", function() {
    return this.iterator("table", function(ctx) {
      return ctx.nTBody;
    }, 1);
  });
  _api_registerPlural("tables().header()", "table().header()", function() {
    return this.iterator("table", function(ctx) {
      return ctx.nTHead;
    }, 1);
  });
  _api_registerPlural("tables().footer()", "table().footer()", function() {
    return this.iterator("table", function(ctx) {
      return ctx.nTFoot;
    }, 1);
  });
  _api_registerPlural("tables().containers()", "table().container()", function() {
    return this.iterator("table", function(ctx) {
      return ctx.nTableWrapper;
    }, 1);
  });
  _api_register("draw()", function(paging) {
    return this.iterator("table", function(settings) {
      if (paging === "page") {
        _fnDraw(settings);
      } else {
        if (typeof paging === "string") {
          paging = paging === "full-hold" ? false : true;
        }
        _fnReDraw(settings, paging === false);
      }
    });
  });
  _api_register("page()", function(action) {
    if (action === undefined) {
      return this.page.info().page;
    }
    return this.iterator("table", function(settings) {
      _fnPageChange(settings, action);
    });
  });
  _api_register("page.info()", function(action) {
    if (this.context.length === 0) {
      return undefined;
    }
    var settings = this.context[0], start = settings._iDisplayStart, len = settings.oFeatures.bPaginate ? settings._iDisplayLength : -1, visRecords = settings.fnRecordsDisplay(), all = len === -1;
    return {"page":all ? 0 : Math.floor(start / len), "pages":all ? 1 : Math.ceil(visRecords / len), "start":start, "end":settings.fnDisplayEnd(), "length":len, "recordsTotal":settings.fnRecordsTotal(), "recordsDisplay":visRecords, "serverSide":_fnDataSource(settings) === "ssp"};
  });
  _api_register("page.len()", function(len) {
    if (len === undefined) {
      return this.context.length !== 0 ? this.context[0]._iDisplayLength : undefined;
    }
    return this.iterator("table", function(settings) {
      _fnLengthChange(settings, len);
    });
  });
  var __reload = function(settings, holdPosition, callback) {
    if (callback) {
      var api = new _Api(settings);
      api.one("draw", function() {
        callback(api.ajax.json());
      });
    }
    if (_fnDataSource(settings) == "ssp") {
      _fnReDraw(settings, holdPosition);
    } else {
      _fnProcessingDisplay(settings, true);
      var xhr = settings.jqXHR;
      if (xhr && xhr.readyState !== 4) {
        xhr.abort();
      }
      _fnBuildAjax(settings, [], function(json) {
        _fnClearTable(settings);
        var data = _fnAjaxDataSrc(settings, json);
        for (var i = 0, ien = data.length; i < ien; i++) {
          _fnAddData(settings, data[i]);
        }
        _fnReDraw(settings, holdPosition);
        _fnProcessingDisplay(settings, false);
      });
    }
  };
  _api_register("ajax.json()", function() {
    var ctx = this.context;
    if (ctx.length > 0) {
      return ctx[0].json;
    }
  });
  _api_register("ajax.params()", function() {
    var ctx = this.context;
    if (ctx.length > 0) {
      return ctx[0].oAjaxData;
    }
  });
  _api_register("ajax.reload()", function(callback, resetPaging) {
    return this.iterator("table", function(settings) {
      __reload(settings, resetPaging === false, callback);
    });
  });
  _api_register("ajax.url()", function(url) {
    var ctx = this.context;
    if (url === undefined) {
      if (ctx.length === 0) {
        return undefined;
      }
      ctx = ctx[0];
      return ctx.ajax ? $.isPlainObject(ctx.ajax) ? ctx.ajax.url : ctx.ajax : ctx.sAjaxSource;
    }
    return this.iterator("table", function(settings) {
      if ($.isPlainObject(settings.ajax)) {
        settings.ajax.url = url;
      } else {
        settings.ajax = url;
      }
    });
  });
  _api_register("ajax.url().load()", function(callback, resetPaging) {
    return this.iterator("table", function(ctx) {
      __reload(ctx, resetPaging === false, callback);
    });
  });
  var _selector_run = function(type, selector, selectFn, settings, opts) {
    var out = [], res, a, i, ien, j, jen, selectorType = typeof selector;
    if (!selector || selectorType === "string" || selectorType === "function" || selector.length === undefined) {
      selector = [selector];
    }
    for (i = 0, ien = selector.length; i < ien; i++) {
      a = selector[i] && selector[i].split ? selector[i].split(",") : [selector[i]];
      for (j = 0, jen = a.length; j < jen; j++) {
        res = selectFn(typeof a[j] === "string" ? $.trim(a[j]) : a[j]);
        if (res && res.length) {
          out = out.concat(res);
        }
      }
    }
    var ext = _ext.selector[type];
    if (ext.length) {
      for (i = 0, ien = ext.length; i < ien; i++) {
        out = ext[i](settings, opts, out);
      }
    }
    return _unique(out);
  };
  var _selector_opts = function(opts) {
    if (!opts) {
      opts = {};
    }
    if (opts.filter && opts.search === undefined) {
      opts.search = opts.filter;
    }
    return $.extend({search:"none", order:"current", page:"all"}, opts);
  };
  var _selector_first = function(inst) {
    for (var i = 0, ien = inst.length; i < ien; i++) {
      if (inst[i].length > 0) {
        inst[0] = inst[i];
        inst[0].length = 1;
        inst.length = 1;
        inst.context = [inst.context[i]];
        return inst;
      }
    }
    inst.length = 0;
    return inst;
  };
  var _selector_row_indexes = function(settings, opts) {
    var i, ien, tmp, a = [], displayFiltered = settings.aiDisplay, displayMaster = settings.aiDisplayMaster;
    var search = opts.search, order = opts.order, page = opts.page;
    if (_fnDataSource(settings) == "ssp") {
      return search === "removed" ? [] : _range(0, displayMaster.length);
    } else {
      if (page == "current") {
        for (i = settings._iDisplayStart, ien = settings.fnDisplayEnd(); i < ien; i++) {
          a.push(displayFiltered[i]);
        }
      } else {
        if (order == "current" || order == "applied") {
          a = search == "none" ? displayMaster.slice() : search == "applied" ? displayFiltered.slice() : $.map(displayMaster, function(el, i) {
            return $.inArray(el, displayFiltered) === -1 ? el : null;
          });
        } else {
          if (order == "index" || order == "original") {
            for (i = 0, ien = settings.aoData.length; i < ien; i++) {
              if (search == "none") {
                a.push(i);
              } else {
                tmp = $.inArray(i, displayFiltered);
                if (tmp === -1 && search == "removed" || tmp >= 0 && search == "applied") {
                  a.push(i);
                }
              }
            }
          }
        }
      }
    }
    return a;
  };
  var __row_selector = function(settings, selector, opts) {
    var run = function(sel) {
      var selInt = _intVal(sel);
      var i, ien;
      if (selInt !== null && !opts) {
        return [selInt];
      }
      var rows = _selector_row_indexes(settings, opts);
      if (selInt !== null && $.inArray(selInt, rows) !== -1) {
        return [selInt];
      } else {
        if (!sel) {
          return rows;
        }
      }
      if (typeof sel === "function") {
        return $.map(rows, function(idx) {
          var row = settings.aoData[idx];
          return sel(idx, row._aData, row.nTr) ? idx : null;
        });
      }
      var nodes = _removeEmpty(_pluck_order(settings.aoData, rows, "nTr"));
      if (sel.nodeName) {
        if (sel._DT_RowIndex !== undefined) {
          return [sel._DT_RowIndex];
        } else {
          if (sel._DT_CellIndex) {
            return [sel._DT_CellIndex.row];
          } else {
            var host = $(sel).closest("*[data-dt-row]");
            return host.length ? [host.data("dt-row")] : [];
          }
        }
      }
      if (typeof sel === "string" && sel.charAt(0) === "#") {
        var rowObj = settings.aIds[sel.replace(/^#/, "")];
        if (rowObj !== undefined) {
          return [rowObj.idx];
        }
      }
      return $(nodes).filter(sel).map(function() {
        return this._DT_RowIndex;
      }).toArray();
    };
    return _selector_run("row", selector, run, settings, opts);
  };
  _api_register("rows()", function(selector, opts) {
    if (selector === undefined) {
      selector = "";
    } else {
      if ($.isPlainObject(selector)) {
        opts = selector;
        selector = "";
      }
    }
    opts = _selector_opts(opts);
    var inst = this.iterator("table", function(settings) {
      return __row_selector(settings, selector, opts);
    }, 1);
    inst.selector.rows = selector;
    inst.selector.opts = opts;
    return inst;
  });
  _api_register("rows().nodes()", function() {
    return this.iterator("row", function(settings, row) {
      return settings.aoData[row].nTr || undefined;
    }, 1);
  });
  _api_register("rows().data()", function() {
    return this.iterator(true, "rows", function(settings, rows) {
      return _pluck_order(settings.aoData, rows, "_aData");
    }, 1);
  });
  _api_registerPlural("rows().cache()", "row().cache()", function(type) {
    return this.iterator("row", function(settings, row) {
      var r = settings.aoData[row];
      return type === "search" ? r._aFilterData : r._aSortData;
    }, 1);
  });
  _api_registerPlural("rows().invalidate()", "row().invalidate()", function(src) {
    return this.iterator("row", function(settings, row) {
      _fnInvalidate(settings, row, src);
    });
  });
  _api_registerPlural("rows().indexes()", "row().index()", function() {
    return this.iterator("row", function(settings, row) {
      return row;
    }, 1);
  });
  _api_registerPlural("rows().ids()", "row().id()", function(hash) {
    var a = [];
    var context = this.context;
    for (var i = 0, ien = context.length; i < ien; i++) {
      for (var j = 0, jen = this[i].length; j < jen; j++) {
        var id = context[i].rowIdFn(context[i].aoData[this[i][j]]._aData);
        a.push((hash === true ? "#" : "") + id);
      }
    }
    return new _Api(context, a);
  });
  _api_registerPlural("rows().remove()", "row().remove()", function() {
    var that = this;
    this.iterator("row", function(settings, row, thatIdx) {
      var data = settings.aoData;
      var rowData = data[row];
      var i, ien, j, jen;
      var loopRow, loopCells;
      data.splice(row, 1);
      for (i = 0, ien = data.length; i < ien; i++) {
        loopRow = data[i];
        loopCells = loopRow.anCells;
        if (loopRow.nTr !== null) {
          loopRow.nTr._DT_RowIndex = i;
        }
        if (loopCells !== null) {
          for (j = 0, jen = loopCells.length; j < jen; j++) {
            loopCells[j]._DT_CellIndex.row = i;
          }
        }
      }
      _fnDeleteIndex(settings.aiDisplayMaster, row);
      _fnDeleteIndex(settings.aiDisplay, row);
      _fnDeleteIndex(that[thatIdx], row, false);
      _fnLengthOverflow(settings);
      var id = settings.rowIdFn(rowData._aData);
      if (id !== undefined) {
        delete settings.aIds[id];
      }
    });
    this.iterator("table", function(settings) {
      for (var i = 0, ien = settings.aoData.length; i < ien; i++) {
        settings.aoData[i].idx = i;
      }
    });
    return this;
  });
  _api_register("rows.add()", function(rows) {
    var newRows = this.iterator("table", function(settings) {
      var row, i, ien;
      var out = [];
      for (i = 0, ien = rows.length; i < ien; i++) {
        row = rows[i];
        if (row.nodeName && row.nodeName.toUpperCase() === "TR") {
          out.push(_fnAddTr(settings, row)[0]);
        } else {
          out.push(_fnAddData(settings, row));
        }
      }
      return out;
    }, 1);
    var modRows = this.rows(-1);
    modRows.pop();
    $.merge(modRows, newRows);
    return modRows;
  });
  _api_register("row()", function(selector, opts) {
    return _selector_first(this.rows(selector, opts));
  });
  _api_register("row().data()", function(data) {
    var ctx = this.context;
    if (data === undefined) {
      return ctx.length && this.length ? ctx[0].aoData[this[0]]._aData : undefined;
    }
    ctx[0].aoData[this[0]]._aData = data;
    _fnInvalidate(ctx[0], this[0], "data");
    return this;
  });
  _api_register("row().node()", function() {
    var ctx = this.context;
    return ctx.length && this.length ? ctx[0].aoData[this[0]].nTr || null : null;
  });
  _api_register("row.add()", function(row) {
    if (row instanceof $ && row.length) {
      row = row[0];
    }
    var rows = this.iterator("table", function(settings) {
      if (row.nodeName && row.nodeName.toUpperCase() === "TR") {
        return _fnAddTr(settings, row)[0];
      }
      return _fnAddData(settings, row);
    });
    return this.row(rows[0]);
  });
  var __details_add = function(ctx, row, data, klass) {
    var rows = [];
    var addRow = function(r, k) {
      if ($.isArray(r) || r instanceof $) {
        for (var i = 0, ien = r.length; i < ien; i++) {
          addRow(r[i], k);
        }
        return;
      }
      if (r.nodeName && r.nodeName.toLowerCase() === "tr") {
        rows.push(r);
      } else {
        var created = $("<tr><td/></tr>").addClass(k);
        $("td", created).addClass(k).html(r)[0].colSpan = _fnVisbleColumns(ctx);
        rows.push(created[0]);
      }
    };
    addRow(data, klass);
    if (row._details) {
      row._details.remove();
    }
    row._details = $(rows);
    if (row._detailsShow) {
      row._details.insertAfter(row.nTr);
    }
  };
  var __details_remove = function(api, idx) {
    var ctx = api.context;
    if (ctx.length) {
      var row = ctx[0].aoData[idx !== undefined ? idx : api[0]];
      if (row && row._details) {
        row._details.remove();
        row._detailsShow = undefined;
        row._details = undefined;
      }
    }
  };
  var __details_display = function(api, show) {
    var ctx = api.context;
    if (ctx.length && api.length) {
      var row = ctx[0].aoData[api[0]];
      if (row._details) {
        row._detailsShow = show;
        if (show) {
          row._details.insertAfter(row.nTr);
        } else {
          row._details.detach();
        }
        __details_events(ctx[0]);
      }
    }
  };
  var __details_events = function(settings) {
    var api = new _Api(settings);
    var namespace = ".dt.DT_details";
    var drawEvent = "draw" + namespace;
    var colvisEvent = "column-visibility" + namespace;
    var destroyEvent = "destroy" + namespace;
    var data = settings.aoData;
    api.off(drawEvent + " " + colvisEvent + " " + destroyEvent);
    if (_pluck(data, "_details").length > 0) {
      api.on(drawEvent, function(e, ctx) {
        if (settings !== ctx) {
          return;
        }
        api.rows({page:"current"}).eq(0).each(function(idx) {
          var row = data[idx];
          if (row._detailsShow) {
            row._details.insertAfter(row.nTr);
          }
        });
      });
      api.on(colvisEvent, function(e, ctx, idx, vis) {
        if (settings !== ctx) {
          return;
        }
        var row, visible = _fnVisbleColumns(ctx);
        for (var i = 0, ien = data.length; i < ien; i++) {
          row = data[i];
          if (row._details) {
            row._details.children("td[colspan]").attr("colspan", visible);
          }
        }
      });
      api.on(destroyEvent, function(e, ctx) {
        if (settings !== ctx) {
          return;
        }
        for (var i = 0, ien = data.length; i < ien; i++) {
          if (data[i]._details) {
            __details_remove(api, i);
          }
        }
      });
    }
  };
  var _emp = "";
  var _child_obj = _emp + "row().child";
  var _child_mth = _child_obj + "()";
  _api_register(_child_mth, function(data, klass) {
    var ctx = this.context;
    if (data === undefined) {
      return ctx.length && this.length ? ctx[0].aoData[this[0]]._details : undefined;
    } else {
      if (data === true) {
        this.child.show();
      } else {
        if (data === false) {
          __details_remove(this);
        } else {
          if (ctx.length && this.length) {
            __details_add(ctx[0], ctx[0].aoData[this[0]], data, klass);
          }
        }
      }
    }
    return this;
  });
  _api_register([_child_obj + ".show()", _child_mth + ".show()"], function(show) {
    __details_display(this, true);
    return this;
  });
  _api_register([_child_obj + ".hide()", _child_mth + ".hide()"], function() {
    __details_display(this, false);
    return this;
  });
  _api_register([_child_obj + ".remove()", _child_mth + ".remove()"], function() {
    __details_remove(this);
    return this;
  });
  _api_register(_child_obj + ".isShown()", function() {
    var ctx = this.context;
    if (ctx.length && this.length) {
      return ctx[0].aoData[this[0]]._detailsShow || false;
    }
    return false;
  });
  var __re_column_selector = /^(.+):(name|visIdx|visible)$/;
  var __columnData = function(settings, column, r1, r2, rows) {
    var a = [];
    for (var row = 0, ien = rows.length; row < ien; row++) {
      a.push(_fnGetCellData(settings, rows[row], column));
    }
    return a;
  };
  var __column_selector = function(settings, selector, opts) {
    var columns = settings.aoColumns, names = _pluck(columns, "sName"), nodes = _pluck(columns, "nTh");
    var run = function(s) {
      var selInt = _intVal(s);
      if (s === "") {
        return _range(columns.length);
      }
      if (selInt !== null) {
        return [selInt >= 0 ? selInt : columns.length + selInt];
      }
      if (typeof s === "function") {
        var rows = _selector_row_indexes(settings, opts);
        return $.map(columns, function(col, idx) {
          return s(idx, __columnData(settings, idx, 0, 0, rows), nodes[idx]) ? idx : null;
        });
      }
      var match = typeof s === "string" ? s.match(__re_column_selector) : "";
      if (match) {
        switch(match[2]) {
          case "visIdx":
          case "visible":
            var idx = parseInt(match[1], 10);
            if (idx < 0) {
              var visColumns = $.map(columns, function(col, i) {
                return col.bVisible ? i : null;
              });
              return [visColumns[visColumns.length + idx]];
            }
            return [_fnVisibleToColumnIndex(settings, idx)];
          case "name":
            return $.map(names, function(name, i) {
              return name === match[1] ? i : null;
            });
          default:
            return [];
        }
      }
      if (s.nodeName && s._DT_CellIndex) {
        return [s._DT_CellIndex.column];
      }
      var jqResult = $(nodes).filter(s).map(function() {
        return $.inArray(this, nodes);
      }).toArray();
      if (jqResult.length || !s.nodeName) {
        return jqResult;
      }
      var host = $(s).closest("*[data-dt-column]");
      return host.length ? [host.data("dt-column")] : [];
    };
    return _selector_run("column", selector, run, settings, opts);
  };
  var __setColumnVis = function(settings, column, vis) {
    var cols = settings.aoColumns, col = cols[column], data = settings.aoData, row, cells, i, ien, tr;
    if (vis === undefined) {
      return col.bVisible;
    }
    if (col.bVisible === vis) {
      return;
    }
    if (vis) {
      var insertBefore = $.inArray(true, _pluck(cols, "bVisible"), column + 1);
      for (i = 0, ien = data.length; i < ien; i++) {
        tr = data[i].nTr;
        cells = data[i].anCells;
        if (tr) {
          tr.insertBefore(cells[column], cells[insertBefore] || null);
        }
      }
    } else {
      $(_pluck(settings.aoData, "anCells", column)).detach();
    }
    col.bVisible = vis;
    _fnDrawHead(settings, settings.aoHeader);
    _fnDrawHead(settings, settings.aoFooter);
    _fnSaveState(settings);
  };
  _api_register("columns()", function(selector, opts) {
    if (selector === undefined) {
      selector = "";
    } else {
      if ($.isPlainObject(selector)) {
        opts = selector;
        selector = "";
      }
    }
    opts = _selector_opts(opts);
    var inst = this.iterator("table", function(settings) {
      return __column_selector(settings, selector, opts);
    }, 1);
    inst.selector.cols = selector;
    inst.selector.opts = opts;
    return inst;
  });
  _api_registerPlural("columns().header()", "column().header()", function(selector, opts) {
    return this.iterator("column", function(settings, column) {
      return settings.aoColumns[column].nTh;
    }, 1);
  });
  _api_registerPlural("columns().footer()", "column().footer()", function(selector, opts) {
    return this.iterator("column", function(settings, column) {
      return settings.aoColumns[column].nTf;
    }, 1);
  });
  _api_registerPlural("columns().data()", "column().data()", function() {
    return this.iterator("column-rows", __columnData, 1);
  });
  _api_registerPlural("columns().dataSrc()", "column().dataSrc()", function() {
    return this.iterator("column", function(settings, column) {
      return settings.aoColumns[column].mData;
    }, 1);
  });
  _api_registerPlural("columns().cache()", "column().cache()", function(type) {
    return this.iterator("column-rows", function(settings, column, i, j, rows) {
      return _pluck_order(settings.aoData, rows, type === "search" ? "_aFilterData" : "_aSortData", column);
    }, 1);
  });
  _api_registerPlural("columns().nodes()", "column().nodes()", function() {
    return this.iterator("column-rows", function(settings, column, i, j, rows) {
      return _pluck_order(settings.aoData, rows, "anCells", column);
    }, 1);
  });
  _api_registerPlural("columns().visible()", "column().visible()", function(vis, calc) {
    var ret = this.iterator("column", function(settings, column) {
      if (vis === undefined) {
        return settings.aoColumns[column].bVisible;
      }
      __setColumnVis(settings, column, vis);
    });
    if (vis !== undefined) {
      this.iterator("column", function(settings, column) {
        _fnCallbackFire(settings, null, "column-visibility", [settings, column, vis, calc]);
      });
      if (calc === undefined || calc) {
        this.columns.adjust();
      }
    }
    return ret;
  });
  _api_registerPlural("columns().indexes()", "column().index()", function(type) {
    return this.iterator("column", function(settings, column) {
      return type === "visible" ? _fnColumnIndexToVisible(settings, column) : column;
    }, 1);
  });
  _api_register("columns.adjust()", function() {
    return this.iterator("table", function(settings) {
      _fnAdjustColumnSizing(settings);
    }, 1);
  });
  _api_register("column.index()", function(type, idx) {
    if (this.context.length !== 0) {
      var ctx = this.context[0];
      if (type === "fromVisible" || type === "toData") {
        return _fnVisibleToColumnIndex(ctx, idx);
      } else {
        if (type === "fromData" || type === "toVisible") {
          return _fnColumnIndexToVisible(ctx, idx);
        }
      }
    }
  });
  _api_register("column()", function(selector, opts) {
    return _selector_first(this.columns(selector, opts));
  });
  var __cell_selector = function(settings, selector, opts) {
    var data = settings.aoData;
    var rows = _selector_row_indexes(settings, opts);
    var cells = _removeEmpty(_pluck_order(data, rows, "anCells"));
    var allCells = $([].concat.apply([], cells));
    var row;
    var columns = settings.aoColumns.length;
    var a, i, ien, j, o, host;
    var run = function(s) {
      var fnSelector = typeof s === "function";
      if (s === null || s === undefined || fnSelector) {
        a = [];
        for (i = 0, ien = rows.length; i < ien; i++) {
          row = rows[i];
          for (j = 0; j < columns; j++) {
            o = {row:row, column:j};
            if (fnSelector) {
              host = data[row];
              if (s(o, _fnGetCellData(settings, row, j), host.anCells ? host.anCells[j] : null)) {
                a.push(o);
              }
            } else {
              a.push(o);
            }
          }
        }
        return a;
      }
      if ($.isPlainObject(s)) {
        return [s];
      }
      var jqResult = allCells.filter(s).map(function(i, el) {
        return {row:el._DT_CellIndex.row, column:el._DT_CellIndex.column};
      }).toArray();
      if (jqResult.length || !s.nodeName) {
        return jqResult;
      }
      host = $(s).closest("*[data-dt-row]");
      return host.length ? [{row:host.data("dt-row"), column:host.data("dt-column")}] : [];
    };
    return _selector_run("cell", selector, run, settings, opts);
  };
  _api_register("cells()", function(rowSelector, columnSelector, opts) {
    if ($.isPlainObject(rowSelector)) {
      if (rowSelector.row === undefined) {
        opts = rowSelector;
        rowSelector = null;
      } else {
        opts = columnSelector;
        columnSelector = null;
      }
    }
    if ($.isPlainObject(columnSelector)) {
      opts = columnSelector;
      columnSelector = null;
    }
    if (columnSelector === null || columnSelector === undefined) {
      return this.iterator("table", function(settings) {
        return __cell_selector(settings, rowSelector, _selector_opts(opts));
      });
    }
    var columns = this.columns(columnSelector, opts);
    var rows = this.rows(rowSelector, opts);
    var a, i, ien, j, jen;
    var cells = this.iterator("table", function(settings, idx) {
      a = [];
      for (i = 0, ien = rows[idx].length; i < ien; i++) {
        for (j = 0, jen = columns[idx].length; j < jen; j++) {
          a.push({row:rows[idx][i], column:columns[idx][j]});
        }
      }
      return a;
    }, 1);
    $.extend(cells.selector, {cols:columnSelector, rows:rowSelector, opts:opts});
    return cells;
  });
  _api_registerPlural("cells().nodes()", "cell().node()", function() {
    return this.iterator("cell", function(settings, row, column) {
      var data = settings.aoData[row];
      return data && data.anCells ? data.anCells[column] : undefined;
    }, 1);
  });
  _api_register("cells().data()", function() {
    return this.iterator("cell", function(settings, row, column) {
      return _fnGetCellData(settings, row, column);
    }, 1);
  });
  _api_registerPlural("cells().cache()", "cell().cache()", function(type) {
    type = type === "search" ? "_aFilterData" : "_aSortData";
    return this.iterator("cell", function(settings, row, column) {
      return settings.aoData[row][type][column];
    }, 1);
  });
  _api_registerPlural("cells().render()", "cell().render()", function(type) {
    return this.iterator("cell", function(settings, row, column) {
      return _fnGetCellData(settings, row, column, type);
    }, 1);
  });
  _api_registerPlural("cells().indexes()", "cell().index()", function() {
    return this.iterator("cell", function(settings, row, column) {
      return {row:row, column:column, columnVisible:_fnColumnIndexToVisible(settings, column)};
    }, 1);
  });
  _api_registerPlural("cells().invalidate()", "cell().invalidate()", function(src) {
    return this.iterator("cell", function(settings, row, column) {
      _fnInvalidate(settings, row, src, column);
    });
  });
  _api_register("cell()", function(rowSelector, columnSelector, opts) {
    return _selector_first(this.cells(rowSelector, columnSelector, opts));
  });
  _api_register("cell().data()", function(data) {
    var ctx = this.context;
    var cell = this[0];
    if (data === undefined) {
      return ctx.length && cell.length ? _fnGetCellData(ctx[0], cell[0].row, cell[0].column) : undefined;
    }
    _fnSetCellData(ctx[0], cell[0].row, cell[0].column, data);
    _fnInvalidate(ctx[0], cell[0].row, "data", cell[0].column);
    return this;
  });
  _api_register("order()", function(order, dir) {
    var ctx = this.context;
    if (order === undefined) {
      return ctx.length !== 0 ? ctx[0].aaSorting : undefined;
    }
    if (typeof order === "number") {
      order = [[order, dir]];
    } else {
      if (order.length && !$.isArray(order[0])) {
        order = Array.prototype.slice.call(arguments);
      }
    }
    return this.iterator("table", function(settings) {
      settings.aaSorting = order.slice();
    });
  });
  _api_register("order.listener()", function(node, column, callback) {
    return this.iterator("table", function(settings) {
      _fnSortAttachListener(settings, node, column, callback);
    });
  });
  _api_register("order.fixed()", function(set) {
    if (!set) {
      var ctx = this.context;
      var fixed = ctx.length ? ctx[0].aaSortingFixed : undefined;
      return $.isArray(fixed) ? {pre:fixed} : fixed;
    }
    return this.iterator("table", function(settings) {
      settings.aaSortingFixed = $.extend(true, {}, set);
    });
  });
  _api_register(["columns().order()", "column().order()"], function(dir) {
    var that = this;
    return this.iterator("table", function(settings, i) {
      var sort = [];
      $.each(that[i], function(j, col) {
        sort.push([col, dir]);
      });
      settings.aaSorting = sort;
    });
  });
  _api_register("search()", function(input, regex, smart, caseInsen) {
    var ctx = this.context;
    if (input === undefined) {
      return ctx.length !== 0 ? ctx[0].oPreviousSearch.sSearch : undefined;
    }
    return this.iterator("table", function(settings) {
      if (!settings.oFeatures.bFilter) {
        return;
      }
      _fnFilterComplete(settings, $.extend({}, settings.oPreviousSearch, {"sSearch":input + "", "bRegex":regex === null ? false : regex, "bSmart":smart === null ? true : smart, "bCaseInsensitive":caseInsen === null ? true : caseInsen}), 1);
    });
  });
  _api_registerPlural("columns().search()", "column().search()", function(input, regex, smart, caseInsen) {
    return this.iterator("column", function(settings, column) {
      var preSearch = settings.aoPreSearchCols;
      if (input === undefined) {
        return preSearch[column].sSearch;
      }
      if (!settings.oFeatures.bFilter) {
        return;
      }
      $.extend(preSearch[column], {"sSearch":input + "", "bRegex":regex === null ? false : regex, "bSmart":smart === null ? true : smart, "bCaseInsensitive":caseInsen === null ? true : caseInsen});
      _fnFilterComplete(settings, settings.oPreviousSearch, 1);
    });
  });
  _api_register("state()", function() {
    return this.context.length ? this.context[0].oSavedState : null;
  });
  _api_register("state.clear()", function() {
    return this.iterator("table", function(settings) {
      settings.fnStateSaveCallback.call(settings.oInstance, settings, {});
    });
  });
  _api_register("state.loaded()", function() {
    return this.context.length ? this.context[0].oLoadedState : null;
  });
  _api_register("state.save()", function() {
    return this.iterator("table", function(settings) {
      _fnSaveState(settings);
    });
  });
  DataTable.versionCheck = DataTable.fnVersionCheck = function(version) {
    var aThis = DataTable.version.split(".");
    var aThat = version.split(".");
    var iThis, iThat;
    for (var i = 0, iLen = aThat.length; i < iLen; i++) {
      iThis = parseInt(aThis[i], 10) || 0;
      iThat = parseInt(aThat[i], 10) || 0;
      if (iThis === iThat) {
        continue;
      }
      return iThis > iThat;
    }
    return true;
  };
  DataTable.isDataTable = DataTable.fnIsDataTable = function(table) {
    var t = $(table).get(0);
    var is = false;
    $.each(DataTable.settings, function(i, o) {
      var head = o.nScrollHead ? $("table", o.nScrollHead)[0] : null;
      var foot = o.nScrollFoot ? $("table", o.nScrollFoot)[0] : null;
      if (o.nTable === t || head === t || foot === t) {
        is = true;
      }
    });
    return is;
  };
  DataTable.tables = DataTable.fnTables = function(visible) {
    var api = false;
    if ($.isPlainObject(visible)) {
      api = visible.api;
      visible = visible.visible;
    }
    var a = $.map(DataTable.settings, function(o) {
      if (!visible || visible && $(o.nTable).is(":visible")) {
        return o.nTable;
      }
    });
    return api ? new _Api(a) : a;
  };
  DataTable.camelToHungarian = _fnCamelToHungarian;
  _api_register("$()", function(selector, opts) {
    var rows = this.rows(opts).nodes(), jqRows = $(rows);
    return $([].concat(jqRows.filter(selector).toArray(), jqRows.find(selector).toArray()));
  });
  $.each(["on", "one", "off"], function(i, key) {
    _api_register(key + "()", function() {
      var args = Array.prototype.slice.call(arguments);
      if (!args[0].match(/\.dt\b/)) {
        args[0] += ".dt";
      }
      var inst = $(this.tables().nodes());
      inst[key].apply(inst, args);
      return this;
    });
  });
  _api_register("clear()", function() {
    return this.iterator("table", function(settings) {
      _fnClearTable(settings);
    });
  });
  _api_register("settings()", function() {
    return new _Api(this.context, this.context);
  });
  _api_register("init()", function() {
    var ctx = this.context;
    return ctx.length ? ctx[0].oInit : null;
  });
  _api_register("data()", function() {
    return this.iterator("table", function(settings) {
      return _pluck(settings.aoData, "_aData");
    }).flatten();
  });
  _api_register("destroy()", function(remove) {
    remove = remove || false;
    return this.iterator("table", function(settings) {
      var orig = settings.nTableWrapper.parentNode;
      var classes = settings.oClasses;
      var table = settings.nTable;
      var tbody = settings.nTBody;
      var thead = settings.nTHead;
      var tfoot = settings.nTFoot;
      var jqTable = $(table);
      var jqTbody = $(tbody);
      var jqWrapper = $(settings.nTableWrapper);
      var rows = $.map(settings.aoData, function(r) {
        return r.nTr;
      });
      var i, ien;
      settings.bDestroying = true;
      _fnCallbackFire(settings, "aoDestroyCallback", "destroy", [settings]);
      if (!remove) {
        (new _Api(settings)).columns().visible(true);
      }
      jqWrapper.unbind(".DT").find(":not(tbody *)").unbind(".DT");
      $(window).unbind(".DT-" + settings.sInstance);
      if (table != thead.parentNode) {
        jqTable.children("thead").detach();
        jqTable.append(thead);
      }
      if (tfoot && table != tfoot.parentNode) {
        jqTable.children("tfoot").detach();
        jqTable.append(tfoot);
      }
      settings.aaSorting = [];
      settings.aaSortingFixed = [];
      _fnSortingClasses(settings);
      $(rows).removeClass(settings.asStripeClasses.join(" "));
      $("th, td", thead).removeClass(classes.sSortable + " " + classes.sSortableAsc + " " + classes.sSortableDesc + " " + classes.sSortableNone);
      if (settings.bJUI) {
        $("th span." + classes.sSortIcon + ", td span." + classes.sSortIcon, thead).detach();
        $("th, td", thead).each(function() {
          var wrapper = $("div." + classes.sSortJUIWrapper, this);
          $(this).append(wrapper.contents());
          wrapper.detach();
        });
      }
      jqTbody.children().detach();
      jqTbody.append(rows);
      var removedMethod = remove ? "remove" : "detach";
      jqTable[removedMethod]();
      jqWrapper[removedMethod]();
      if (!remove && orig) {
        orig.insertBefore(table, settings.nTableReinsertBefore);
        jqTable.css("width", settings.sDestroyWidth).removeClass(classes.sTable);
        ien = settings.asDestroyStripes.length;
        if (ien) {
          jqTbody.children().each(function(i) {
            $(this).addClass(settings.asDestroyStripes[i % ien]);
          });
        }
      }
      var idx = $.inArray(settings, DataTable.settings);
      if (idx !== -1) {
        DataTable.settings.splice(idx, 1);
      }
    });
  });
  $.each(["column", "row", "cell"], function(i, type) {
    _api_register(type + "s().every()", function(fn) {
      var opts = this.selector.opts;
      var api = this;
      return this.iterator(type, function(settings, arg1, arg2, arg3, arg4) {
        fn.call(api[type](arg1, type === "cell" ? arg2 : opts, type === "cell" ? opts : undefined), arg1, arg2, arg3, arg4);
      });
    });
  });
  _api_register("i18n()", function(token, def, plural) {
    var ctx = this.context[0];
    var resolved = _fnGetObjectDataFn(token)(ctx.oLanguage);
    if (resolved === undefined) {
      resolved = def;
    }
    if (plural !== undefined && $.isPlainObject(resolved)) {
      resolved = resolved[plural] !== undefined ? resolved[plural] : resolved._;
    }
    return resolved.replace("%d", plural);
  });
  DataTable.version = "1.10.12";
  DataTable.settings = [];
  DataTable.models = {};
  DataTable.models.oSearch = {"bCaseInsensitive":true, "sSearch":"", "bRegex":false, "bSmart":true};
  DataTable.models.oRow = {"nTr":null, "anCells":null, "_aData":[], "_aSortData":null, "_aFilterData":null, "_sFilterRow":null, "_sRowStripe":"", "src":null, "idx":-1};
  DataTable.models.oColumn = {"idx":null, "aDataSort":null, "asSorting":null, "bSearchable":null, "bSortable":null, "bVisible":null, "_sManualType":null, "_bAttrSrc":false, "fnCreatedCell":null, "fnGetData":null, "fnSetData":null, "mData":null, "mRender":null, "nTh":null, "nTf":null, "sClass":null, "sContentPadding":null, "sDefaultContent":null, "sName":null, "sSortDataType":"std", "sSortingClass":null, "sSortingClassJUI":null, "sTitle":null, "sType":null, "sWidth":null, "sWidthOrig":null};
  DataTable.defaults = {"aaData":null, "aaSorting":[[0, "asc"]], "aaSortingFixed":[], "ajax":null, "aLengthMenu":[10, 25, 50, 100], "aoColumns":null, "aoColumnDefs":null, "aoSearchCols":[], "asStripeClasses":null, "bAutoWidth":true, "bDeferRender":false, "bDestroy":false, "bFilter":true, "bInfo":true, "bJQueryUI":false, "bLengthChange":true, "bPaginate":true, "bProcessing":false, "bRetrieve":false, "bScrollCollapse":false, "bServerSide":false, "bSort":true, "bSortMulti":true, "bSortCellsTop":false, 
  "bSortClasses":true, "bStateSave":false, "fnCreatedRow":null, "fnDrawCallback":null, "fnFooterCallback":null, "fnFormatNumber":function(toFormat) {
    return toFormat.toString().replace(/\B(?=(\d{3})+(?!\d))/g, this.oLanguage.sThousands);
  }, "fnHeaderCallback":null, "fnInfoCallback":null, "fnInitComplete":null, "fnPreDrawCallback":null, "fnRowCallback":null, "fnServerData":null, "fnServerParams":null, "fnStateLoadCallback":function(settings) {
    try {
      return JSON.parse((settings.iStateDuration === -1 ? sessionStorage : localStorage).getItem("DataTables_" + settings.sInstance + "_" + location.pathname));
    } catch (e) {
    }
  }, "fnStateLoadParams":null, "fnStateLoaded":null, "fnStateSaveCallback":function(settings, data) {
    try {
      (settings.iStateDuration === -1 ? sessionStorage : localStorage).setItem("DataTables_" + settings.sInstance + "_" + location.pathname, JSON.stringify(data));
    } catch (e) {
    }
  }, "fnStateSaveParams":null, "iStateDuration":7200, "iDeferLoading":null, "iDisplayLength":10, "iDisplayStart":0, "iTabIndex":0, "oClasses":{}, "oLanguage":{"oAria":{"sSortAscending":": activate to sort column ascending", "sSortDescending":": activate to sort column descending"}, "oPaginate":{"sFirst":"First", "sLast":"Last", "sNext":"Next", "sPrevious":"Previous"}, "sEmptyTable":"No data available in table", "sInfo":"Showing _START_ to _END_ of _TOTAL_ entries", "sInfoEmpty":"Showing 0 to 0 of 0 entries", 
  "sInfoFiltered":"(filtered from _MAX_ total entries)", "sInfoPostFix":"", "sDecimal":"", "sThousands":",", "sLengthMenu":"Show _MENU_ entries", "sLoadingRecords":"Loading...", "sProcessing":"Processing...", "sSearch":"Search:", "sSearchPlaceholder":"", "sUrl":"", "sZeroRecords":"No matching records found"}, "oSearch":$.extend({}, DataTable.models.oSearch), "sAjaxDataProp":"data", "sAjaxSource":null, "sDom":"lfrtip", "searchDelay":null, "sPaginationType":"simple_numbers", "sScrollX":"", "sScrollXInner":"", 
  "sScrollY":"", "sServerMethod":"GET", "renderer":null, "rowId":"DT_RowId"};
  _fnHungarianMap(DataTable.defaults);
  DataTable.defaults.column = {"aDataSort":null, "iDataSort":-1, "asSorting":["asc", "desc"], "bSearchable":true, "bSortable":true, "bVisible":true, "fnCreatedCell":null, "mData":null, "mRender":null, "sCellType":"td", "sClass":"", "sContentPadding":"", "sDefaultContent":null, "sName":"", "sSortDataType":"std", "sTitle":null, "sType":null, "sWidth":null};
  _fnHungarianMap(DataTable.defaults.column);
  DataTable.models.oSettings = {"oFeatures":{"bAutoWidth":null, "bDeferRender":null, "bFilter":null, "bInfo":null, "bLengthChange":null, "bPaginate":null, "bProcessing":null, "bServerSide":null, "bSort":null, "bSortMulti":null, "bSortClasses":null, "bStateSave":null}, "oScroll":{"bCollapse":null, "iBarWidth":0, "sX":null, "sXInner":null, "sY":null}, "oLanguage":{"fnInfoCallback":null}, "oBrowser":{"bScrollOversize":false, "bScrollbarLeft":false, "bBounding":false, "barWidth":0}, "ajax":null, "aanFeatures":[], 
  "aoData":[], "aiDisplay":[], "aiDisplayMaster":[], "aIds":{}, "aoColumns":[], "aoHeader":[], "aoFooter":[], "oPreviousSearch":{}, "aoPreSearchCols":[], "aaSorting":null, "aaSortingFixed":[], "asStripeClasses":null, "asDestroyStripes":[], "sDestroyWidth":0, "aoRowCallback":[], "aoHeaderCallback":[], "aoFooterCallback":[], "aoDrawCallback":[], "aoRowCreatedCallback":[], "aoPreDrawCallback":[], "aoInitComplete":[], "aoStateSaveParams":[], "aoStateLoadParams":[], "aoStateLoaded":[], "sTableId":"", 
  "nTable":null, "nTHead":null, "nTFoot":null, "nTBody":null, "nTableWrapper":null, "bDeferLoading":false, "bInitialised":false, "aoOpenRows":[], "sDom":null, "searchDelay":null, "sPaginationType":"two_button", "iStateDuration":0, "aoStateSave":[], "aoStateLoad":[], "oSavedState":null, "oLoadedState":null, "sAjaxSource":null, "sAjaxDataProp":null, "bAjaxDataGet":true, "jqXHR":null, "json":undefined, "oAjaxData":undefined, "fnServerData":null, "aoServerParams":[], "sServerMethod":null, "fnFormatNumber":null, 
  "aLengthMenu":null, "iDraw":0, "bDrawing":false, "iDrawError":-1, "_iDisplayLength":10, "_iDisplayStart":0, "_iRecordsTotal":0, "_iRecordsDisplay":0, "bJUI":null, "oClasses":{}, "bFiltered":false, "bSorted":false, "bSortCellsTop":null, "oInit":null, "aoDestroyCallback":[], "fnRecordsTotal":function() {
    return _fnDataSource(this) == "ssp" ? this._iRecordsTotal * 1 : this.aiDisplayMaster.length;
  }, "fnRecordsDisplay":function() {
    return _fnDataSource(this) == "ssp" ? this._iRecordsDisplay * 1 : this.aiDisplay.length;
  }, "fnDisplayEnd":function() {
    var len = this._iDisplayLength, start = this._iDisplayStart, calc = start + len, records = this.aiDisplay.length, features = this.oFeatures, paginate = features.bPaginate;
    if (features.bServerSide) {
      return paginate === false || len === -1 ? start + records : Math.min(start + len, this._iRecordsDisplay);
    } else {
      return !paginate || calc > records || len === -1 ? records : calc;
    }
  }, "oInstance":null, "sInstance":null, "iTabIndex":0, "nScrollHead":null, "nScrollFoot":null, "aLastSort":[], "oPlugins":{}, "rowIdFn":null, "rowId":null};
  DataTable.ext = _ext = {buttons:{}, classes:{}, builder:"-source-", errMode:"window.console.error", feature:[], search:[], selector:{cell:[], column:[], row:[]}, internal:{}, legacy:{ajax:null}, pager:{}, renderer:{pageButton:{}, header:{}}, order:{}, type:{detect:[], search:{}, order:{}}, _unique:0, fnVersionCheck:DataTable.fnVersionCheck, iApiIndex:0, oJUIClasses:{}, sVersion:DataTable.version};
  $.extend(_ext, {afnFiltering:_ext.search, aTypes:_ext.type.detect, ofnSearch:_ext.type.search, oSort:_ext.type.order, afnSortData:_ext.order, aoFeatures:_ext.feature, oApi:_ext.internal, oStdClasses:_ext.classes, oPagination:_ext.pager});
  $.extend(DataTable.ext.classes, {"sTable":"dataTable", "sNoFooter":"no-footer", "sPageButton":"paginate_button", "sPageButtonActive":"current", "sPageButtonDisabled":"disabled", "sStripeOdd":"odd", "sStripeEven":"even", "sRowEmpty":"dataTables_empty", "sWrapper":"dataTables_wrapper", "sFilter":"dataTables_filter", "sInfo":"dataTables_info", "sPaging":"dataTables_paginate paging_", "sLength":"dataTables_length", "sProcessing":"dataTables_processing", "sSortAsc":"sorting_asc", "sSortDesc":"sorting_desc", 
  "sSortable":"sorting", "sSortableAsc":"sorting_asc_disabled", "sSortableDesc":"sorting_desc_disabled", "sSortableNone":"sorting_disabled", "sSortColumn":"sorting_", "sFilterInput":"", "sLengthSelect":"", "sScrollWrapper":"dataTables_scroll", "sScrollHead":"dataTables_scrollHead", "sScrollHeadInner":"dataTables_scrollHeadInner", "sScrollBody":"dataTables_scrollBody", "sScrollFoot":"dataTables_scrollFoot", "sScrollFootInner":"dataTables_scrollFootInner", "sHeaderTH":"", "sFooterTH":"", "sSortJUIAsc":"", 
  "sSortJUIDesc":"", "sSortJUI":"", "sSortJUIAscAllowed":"", "sSortJUIDescAllowed":"", "sSortJUIWrapper":"", "sSortIcon":"", "sJUIHeader":"", "sJUIFooter":""});
  (function() {
    var _empty = "";
    _empty = "";
    var _stateDefault = _empty + "ui-state-default";
    var _sortIcon = _empty + "css_right ui-icon ui-icon-";
    var _headerFooter = _empty + "fg-toolbar ui-toolbar ui-widget-header ui-helper-clearfix";
    $.extend(DataTable.ext.oJUIClasses, DataTable.ext.classes, {"sPageButton":"fg-button ui-button " + _stateDefault, "sPageButtonActive":"ui-state-disabled", "sPageButtonDisabled":"ui-state-disabled", "sPaging":"dataTables_paginate fg-buttonset ui-buttonset fg-buttonset-multi " + "ui-buttonset-multi paging_", "sSortAsc":_stateDefault + " sorting_asc", "sSortDesc":_stateDefault + " sorting_desc", "sSortable":_stateDefault + " sorting", "sSortableAsc":_stateDefault + " sorting_asc_disabled", "sSortableDesc":_stateDefault + 
    " sorting_desc_disabled", "sSortableNone":_stateDefault + " sorting_disabled", "sSortJUIAsc":_sortIcon + "triangle-1-n", "sSortJUIDesc":_sortIcon + "triangle-1-s", "sSortJUI":_sortIcon + "carat-2-n-s", "sSortJUIAscAllowed":_sortIcon + "carat-1-n", "sSortJUIDescAllowed":_sortIcon + "carat-1-s", "sSortJUIWrapper":"DataTables_sort_wrapper", "sSortIcon":"DataTables_sort_icon", "sScrollHead":"dataTables_scrollHead " + _stateDefault, "sScrollFoot":"dataTables_scrollFoot " + _stateDefault, "sHeaderTH":_stateDefault, 
    "sFooterTH":_stateDefault, "sJUIHeader":_headerFooter + " ui-corner-tl ui-corner-tr", "sJUIFooter":_headerFooter + " ui-corner-bl ui-corner-br"});
  })();
  var extPagination = DataTable.ext.pager;
  function _numbers(page, pages) {
    var numbers = [], buttons = extPagination.numbers_length, half = Math.floor(buttons / 2), i = 1;
    if (pages <= buttons) {
      numbers = _range(0, pages);
    } else {
      if (page <= half) {
        numbers = _range(0, buttons - 2);
        numbers.push("ellipsis");
        numbers.push(pages - 1);
      } else {
        if (page >= pages - 1 - half) {
          numbers = _range(pages - (buttons - 2), pages);
          numbers.splice(0, 0, "ellipsis");
          numbers.splice(0, 0, 0);
        } else {
          numbers = _range(page - half + 2, page + half - 1);
          numbers.push("ellipsis");
          numbers.push(pages - 1);
          numbers.splice(0, 0, "ellipsis");
          numbers.splice(0, 0, 0);
        }
      }
    }
    numbers.DT_el = "span";
    return numbers;
  }
  $.extend(extPagination, {simple:function(page, pages) {
    return ["previous", "next"];
  }, full:function(page, pages) {
    return ["first", "previous", "next", "last"];
  }, numbers:function(page, pages) {
    return [_numbers(page, pages)];
  }, simple_numbers:function(page, pages) {
    return ["previous", _numbers(page, pages), "next"];
  }, full_numbers:function(page, pages) {
    return ["first", "previous", _numbers(page, pages), "next", "last"];
  }, _numbers:_numbers, numbers_length:7});
  $.extend(true, DataTable.ext.renderer, {pageButton:{_:function(settings, host, idx, buttons, page, pages) {
    var classes = settings.oClasses;
    var lang = settings.oLanguage.oPaginate;
    var aria = settings.oLanguage.oAria.paginate || {};
    var btnDisplay, btnClass, counter = 0;
    var attach = function(container, buttons) {
      var i, ien, node, button;
      var clickHandler = function(e) {
        _fnPageChange(settings, e.data.action, true);
      };
      for (i = 0, ien = buttons.length; i < ien; i++) {
        button = buttons[i];
        if ($.isArray(button)) {
          var inner = $("<" + (button.DT_el || "div") + "/>").appendTo(container);
          attach(inner, button);
        } else {
          btnDisplay = null;
          btnClass = "";
          switch(button) {
            case "ellipsis":
              container.append('<span class="ellipsis">&#x2026;</span>');
              break;
            case "first":
              btnDisplay = lang.sFirst;
              btnClass = button + (page > 0 ? "" : " " + classes.sPageButtonDisabled);
              break;
            case "previous":
              btnDisplay = lang.sPrevious;
              btnClass = button + (page > 0 ? "" : " " + classes.sPageButtonDisabled);
              break;
            case "next":
              btnDisplay = lang.sNext;
              btnClass = button + (page < pages - 1 ? "" : " " + classes.sPageButtonDisabled);
              break;
            case "last":
              btnDisplay = lang.sLast;
              btnClass = button + (page < pages - 1 ? "" : " " + classes.sPageButtonDisabled);
              break;
            default:
              btnDisplay = button + 1;
              btnClass = page === button ? classes.sPageButtonActive : "";
              break;
          }
          if (btnDisplay !== null) {
            node = $("<a>", {"class":classes.sPageButton + " " + btnClass, "aria-controls":settings.sTableId, "aria-label":aria[button], "data-dt-idx":counter, "tabindex":settings.iTabIndex, "id":idx === 0 && typeof button === "string" ? settings.sTableId + "_" + button : null}).html(btnDisplay).appendTo(container);
            _fnBindAction(node, {action:button}, clickHandler);
            counter++;
          }
        }
      }
    };
    var activeEl;
    try {
      activeEl = $(host).find(document.activeElement).data("dt-idx");
    } catch (e) {
    }
    attach($(host).empty(), buttons);
    if (activeEl) {
      $(host).find("[data-dt-idx=" + activeEl + "]").focus();
    }
  }}});
  $.extend(DataTable.ext.type.detect, [function(d, settings) {
    var decimal = settings.oLanguage.sDecimal;
    return _isNumber(d, decimal) ? "num" + decimal : null;
  }, function(d, settings) {
    if (d && !(d instanceof Date) && (!_re_date_start.test(d) || !_re_date_end.test(d))) {
      return null;
    }
    var parsed = Date.parse(d);
    return parsed !== null && !isNaN(parsed) || _empty(d) ? "date" : null;
  }, function(d, settings) {
    var decimal = settings.oLanguage.sDecimal;
    return _isNumber(d, decimal, true) ? "num-fmt" + decimal : null;
  }, function(d, settings) {
    var decimal = settings.oLanguage.sDecimal;
    return _htmlNumeric(d, decimal) ? "html-num" + decimal : null;
  }, function(d, settings) {
    var decimal = settings.oLanguage.sDecimal;
    return _htmlNumeric(d, decimal, true) ? "html-num-fmt" + decimal : null;
  }, function(d, settings) {
    return _empty(d) || typeof d === "string" && d.indexOf("<") !== -1 ? "html" : null;
  }]);
  $.extend(DataTable.ext.type.search, {html:function(data) {
    return _empty(data) ? data : typeof data === "string" ? data.replace(_re_new_lines, " ").replace(_re_html, "") : "";
  }, string:function(data) {
    return _empty(data) ? data : typeof data === "string" ? data.replace(_re_new_lines, " ") : data;
  }});
  var __numericReplace = function(d, decimalPlace, re1, re2) {
    if (d !== 0 && (!d || d === "-")) {
      return -Infinity;
    }
    if (decimalPlace) {
      d = _numToDecimal(d, decimalPlace);
    }
    if (d.replace) {
      if (re1) {
        d = d.replace(re1, "");
      }
      if (re2) {
        d = d.replace(re2, "");
      }
    }
    return d * 1;
  };
  function _addNumericSort(decimalPlace) {
    $.each({"num":function(d) {
      return __numericReplace(d, decimalPlace);
    }, "num-fmt":function(d) {
      return __numericReplace(d, decimalPlace, _re_formatted_numeric);
    }, "html-num":function(d) {
      return __numericReplace(d, decimalPlace, _re_html);
    }, "html-num-fmt":function(d) {
      return __numericReplace(d, decimalPlace, _re_html, _re_formatted_numeric);
    }}, function(key, fn) {
      _ext.type.order[key + decimalPlace + "-pre"] = fn;
      if (key.match(/^html\-/)) {
        _ext.type.search[key + decimalPlace] = _ext.type.search.html;
      }
    });
  }
  $.extend(_ext.type.order, {"date-pre":function(d) {
    return Date.parse(d) || 0;
  }, "html-pre":function(a) {
    return _empty(a) ? "" : a.replace ? a.replace(/<.*?>/g, "").toLowerCase() : a + "";
  }, "string-pre":function(a) {
    return _empty(a) ? "" : typeof a === "string" ? a.toLowerCase() : !a.toString ? "" : a.toString();
  }, "string-asc":function(x, y) {
    return x < y ? -1 : x > y ? 1 : 0;
  }, "string-desc":function(x, y) {
    return x < y ? 1 : x > y ? -1 : 0;
  }});
  _addNumericSort("");
  $.extend(true, DataTable.ext.renderer, {header:{_:function(settings, cell, column, classes) {
    $(settings.nTable).on("order.dt.DT", function(e, ctx, sorting, columns) {
      if (settings !== ctx) {
        return;
      }
      var colIdx = column.idx;
      cell.removeClass(column.sSortingClass + " " + classes.sSortAsc + " " + classes.sSortDesc).addClass(columns[colIdx] == "asc" ? classes.sSortAsc : columns[colIdx] == "desc" ? classes.sSortDesc : column.sSortingClass);
    });
  }, jqueryui:function(settings, cell, column, classes) {
    $("<div/>").addClass(classes.sSortJUIWrapper).append(cell.contents()).append($("<span/>").addClass(classes.sSortIcon + " " + column.sSortingClassJUI)).appendTo(cell);
    $(settings.nTable).on("order.dt.DT", function(e, ctx, sorting, columns) {
      if (settings !== ctx) {
        return;
      }
      var colIdx = column.idx;
      cell.removeClass(classes.sSortAsc + " " + classes.sSortDesc).addClass(columns[colIdx] == "asc" ? classes.sSortAsc : columns[colIdx] == "desc" ? classes.sSortDesc : column.sSortingClass);
      cell.find("span." + classes.sSortIcon).removeClass(classes.sSortJUIAsc + " " + classes.sSortJUIDesc + " " + classes.sSortJUI + " " + classes.sSortJUIAscAllowed + " " + classes.sSortJUIDescAllowed).addClass(columns[colIdx] == "asc" ? classes.sSortJUIAsc : columns[colIdx] == "desc" ? classes.sSortJUIDesc : column.sSortingClassJUI);
    });
  }}});
  var __htmlEscapeEntities = function(d) {
    return typeof d === "string" ? d.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;") : d;
  };
  DataTable.render = {number:function(thousands, decimal, precision, prefix, postfix) {
    return {display:function(d) {
      if (typeof d !== "number" && typeof d !== "string") {
        return d;
      }
      var negative = d < 0 ? "-" : "";
      var flo = parseFloat(d);
      if (isNaN(flo)) {
        return __htmlEscapeEntities(d);
      }
      d = Math.abs(flo);
      var intPart = parseInt(d, 10);
      var floatPart = precision ? decimal + (d - intPart).toFixed(precision).substring(2) : "";
      return negative + (prefix || "") + intPart.toString().replace(/\B(?=(\d{3})+(?!\d))/g, thousands) + floatPart + (postfix || "");
    }};
  }, text:function() {
    return {display:__htmlEscapeEntities};
  }};
  function _fnExternApiFunc(fn) {
    return function() {
      var args = [_fnSettingsFromNode(this[DataTable.ext.iApiIndex])].concat(Array.prototype.slice.call(arguments));
      return DataTable.ext.internal[fn].apply(this, args);
    };
  }
  $.extend(DataTable.ext.internal, {_fnExternApiFunc:_fnExternApiFunc, _fnBuildAjax:_fnBuildAjax, _fnAjaxUpdate:_fnAjaxUpdate, _fnAjaxParameters:_fnAjaxParameters, _fnAjaxUpdateDraw:_fnAjaxUpdateDraw, _fnAjaxDataSrc:_fnAjaxDataSrc, _fnAddColumn:_fnAddColumn, _fnColumnOptions:_fnColumnOptions, _fnAdjustColumnSizing:_fnAdjustColumnSizing, _fnVisibleToColumnIndex:_fnVisibleToColumnIndex, _fnColumnIndexToVisible:_fnColumnIndexToVisible, _fnVisbleColumns:_fnVisbleColumns, _fnGetColumns:_fnGetColumns, 
  _fnColumnTypes:_fnColumnTypes, _fnApplyColumnDefs:_fnApplyColumnDefs, _fnHungarianMap:_fnHungarianMap, _fnCamelToHungarian:_fnCamelToHungarian, _fnLanguageCompat:_fnLanguageCompat, _fnBrowserDetect:_fnBrowserDetect, _fnAddData:_fnAddData, _fnAddTr:_fnAddTr, _fnNodeToDataIndex:_fnNodeToDataIndex, _fnNodeToColumnIndex:_fnNodeToColumnIndex, _fnGetCellData:_fnGetCellData, _fnSetCellData:_fnSetCellData, _fnSplitObjNotation:_fnSplitObjNotation, _fnGetObjectDataFn:_fnGetObjectDataFn, _fnSetObjectDataFn:_fnSetObjectDataFn, 
  _fnGetDataMaster:_fnGetDataMaster, _fnClearTable:_fnClearTable, _fnDeleteIndex:_fnDeleteIndex, _fnInvalidate:_fnInvalidate, _fnGetRowElements:_fnGetRowElements, _fnCreateTr:_fnCreateTr, _fnBuildHead:_fnBuildHead, _fnDrawHead:_fnDrawHead, _fnDraw:_fnDraw, _fnReDraw:_fnReDraw, _fnAddOptionsHtml:_fnAddOptionsHtml, _fnDetectHeader:_fnDetectHeader, _fnGetUniqueThs:_fnGetUniqueThs, _fnFeatureHtmlFilter:_fnFeatureHtmlFilter, _fnFilterComplete:_fnFilterComplete, _fnFilterCustom:_fnFilterCustom, _fnFilterColumn:_fnFilterColumn, 
  _fnFilter:_fnFilter, _fnFilterCreateSearch:_fnFilterCreateSearch, _fnEscapeRegex:_fnEscapeRegex, _fnFilterData:_fnFilterData, _fnFeatureHtmlInfo:_fnFeatureHtmlInfo, _fnUpdateInfo:_fnUpdateInfo, _fnInfoMacros:_fnInfoMacros, _fnInitialise:_fnInitialise, _fnInitComplete:_fnInitComplete, _fnLengthChange:_fnLengthChange, _fnFeatureHtmlLength:_fnFeatureHtmlLength, _fnFeatureHtmlPaginate:_fnFeatureHtmlPaginate, _fnPageChange:_fnPageChange, _fnFeatureHtmlProcessing:_fnFeatureHtmlProcessing, _fnProcessingDisplay:_fnProcessingDisplay, 
  _fnFeatureHtmlTable:_fnFeatureHtmlTable, _fnScrollDraw:_fnScrollDraw, _fnApplyToChildren:_fnApplyToChildren, _fnCalculateColumnWidths:_fnCalculateColumnWidths, _fnThrottle:_fnThrottle, _fnConvertToWidth:_fnConvertToWidth, _fnGetWidestNode:_fnGetWidestNode, _fnGetMaxLenString:_fnGetMaxLenString, _fnStringToCss:_fnStringToCss, _fnSortFlatten:_fnSortFlatten, _fnSort:_fnSort, _fnSortAria:_fnSortAria, _fnSortListener:_fnSortListener, _fnSortAttachListener:_fnSortAttachListener, _fnSortingClasses:_fnSortingClasses, 
  _fnSortData:_fnSortData, _fnSaveState:_fnSaveState, _fnLoadState:_fnLoadState, _fnSettingsFromNode:_fnSettingsFromNode, _fnLog:_fnLog, _fnMap:_fnMap, _fnBindAction:_fnBindAction, _fnCallbackReg:_fnCallbackReg, _fnCallbackFire:_fnCallbackFire, _fnLengthOverflow:_fnLengthOverflow, _fnRenderer:_fnRenderer, _fnDataSource:_fnDataSource, _fnRowAttributes:_fnRowAttributes, _fnCalculateEnd:function() {
  }});
  $.fn.dataTable = DataTable;
  DataTable.$ = $;
  $.fn.dataTableSettings = DataTable.settings;
  $.fn.dataTableExt = DataTable.ext;
  $.fn.DataTable = function(opts) {
    return $(this).dataTable(opts).api();
  };
  $.each(DataTable, function(prop, val) {
    $.fn.DataTable[prop] = val;
  });
  return $.fn.dataTable;
});
(function(factory) {
  if (typeof define === "function" && define.amd) {
    define(["jquery", "datatables.net"], function($) {
      return factory($, window, document);
    });
  } else {
    if (typeof exports === "object") {
      module.exports = function(root, $) {
        if (!root) {
          root = window;
        }
        if (!$ || !$.fn.dataTable) {
          $ = require("datatables.net")(root, $).$;
        }
        return factory($, root, root.document);
      };
    } else {
      factory(jQuery, window, document);
    }
  }
})(function($, window, document, undefined) {
  var DataTable = $.fn.dataTable;
  var Responsive = function(settings, opts) {
    if (!DataTable.versionCheck || !DataTable.versionCheck("1.10.3")) {
      throw "DataTables Responsive requires DataTables 1.10.3 or newer";
    }
    this.s = {dt:new DataTable.Api(settings), columns:[], current:[]};
    if (this.s.dt.settings()[0].responsive) {
      return;
    }
    if (opts && typeof opts.details === "string") {
      opts.details = {type:opts.details};
    } else {
      if (opts && opts.details === false) {
        opts.details = {type:false};
      } else {
        if (opts && opts.details === true) {
          opts.details = {type:"inline"};
        }
      }
    }
    this.c = $.extend(true, {}, Responsive.defaults, DataTable.defaults.responsive, opts);
    settings.responsive = this;
    this._constructor();
  };
  $.extend(Responsive.prototype, {_constructor:function() {
    var that = this;
    var dt = this.s.dt;
    var dtPrivateSettings = dt.settings()[0];
    var oldWindowWidth = $(window).width();
    dt.settings()[0]._responsive = this;
    $(window).on("resize.dtr orientationchange.dtr", DataTable.util.throttle(function() {
      var width = $(window).width();
      if (width !== oldWindowWidth) {
        that._resize();
        oldWindowWidth = width;
      }
    }));
    dtPrivateSettings.oApi._fnCallbackReg(dtPrivateSettings, "aoRowCreatedCallback", function(tr, data, idx) {
      if ($.inArray(false, that.s.current) !== -1) {
        $("td, th", tr).each(function(i) {
          var idx = dt.column.index("toData", i);
          if (that.s.current[idx] === false) {
            $(this).css("display", "none");
          }
        });
      }
    });
    dt.on("destroy.dtr", function() {
      dt.off(".dtr");
      $(dt.table().body()).off(".dtr");
      $(window).off("resize.dtr orientationchange.dtr");
      $.each(that.s.current, function(i, val) {
        if (val === false) {
          that._setColumnVis(i, true);
        }
      });
    });
    this.c.breakpoints.sort(function(a, b) {
      return a.width < b.width ? 1 : a.width > b.width ? -1 : 0;
    });
    this._classLogic();
    this._resizeAuto();
    var details = this.c.details;
    if (details.type !== false) {
      that._detailsInit();
      dt.on("column-visibility.dtr", function(e, ctx, col, vis) {
        that._classLogic();
        that._resizeAuto();
        that._resize();
      });
      dt.on("draw.dtr", function() {
        console.log("redraw");
      });
      $(dt.table().node()).addClass("dtr-" + details.type);
    }
    dt.on("column-reorder.dtr", function(e, settings, details) {
      that._classLogic();
      that._resizeAuto();
      that._resize();
    });
    dt.on("column-sizing.dtr", function() {
      that._resizeAuto();
      that._resize();
    });
    dt.on("init.dtr", function(e, settings, details) {
      that._resizeAuto();
      that._resize();
      if ($.inArray(false, that.s.current)) {
        dt.columns.adjust();
      }
    });
    this._resize();
  }, _columnsVisiblity:function(breakpoint) {
    var dt = this.s.dt;
    var columns = this.s.columns;
    var i, ien;
    var order = columns.map(function(col, idx) {
      return {columnIdx:idx, priority:col.priority};
    }).sort(function(a, b) {
      if (a.priority !== b.priority) {
        return a.priority - b.priority;
      }
      return a.columnIdx - b.columnIdx;
    });
    var display = $.map(columns, function(col) {
      return col.auto && col.minWidth === null ? false : col.auto === true ? "-" : $.inArray(breakpoint, col.includeIn) !== -1;
    });
    var requiredWidth = 0;
    for (i = 0, ien = display.length; i < ien; i++) {
      if (display[i] === true) {
        requiredWidth += columns[i].minWidth;
      }
    }
    var scrolling = dt.settings()[0].oScroll;
    var bar = scrolling.sY || scrolling.sX ? scrolling.iBarWidth : 0;
    var widthAvailable = dt.table().container().offsetWidth - bar;
    var usedWidth = widthAvailable - requiredWidth;
    for (i = 0, ien = display.length; i < ien; i++) {
      if (columns[i].control) {
        usedWidth -= columns[i].minWidth;
      }
    }
    var empty = false;
    for (i = 0, ien = order.length; i < ien; i++) {
      var colIdx = order[i].columnIdx;
      if (display[colIdx] === "-" && !columns[colIdx].control && columns[colIdx].minWidth) {
        if (empty || usedWidth - columns[colIdx].minWidth < 0) {
          empty = true;
          display[colIdx] = false;
        } else {
          display[colIdx] = true;
        }
        usedWidth -= columns[colIdx].minWidth;
      }
    }
    var showControl = false;
    for (i = 0, ien = columns.length; i < ien; i++) {
      if (!columns[i].control && !columns[i].never && !display[i]) {
        showControl = true;
        break;
      }
    }
    for (i = 0, ien = columns.length; i < ien; i++) {
      if (columns[i].control) {
        display[i] = showControl;
      }
    }
    if ($.inArray(true, display) === -1) {
      display[0] = true;
    }
    return display;
  }, _classLogic:function() {
    var that = this;
    var calc = {};
    var breakpoints = this.c.breakpoints;
    var dt = this.s.dt;
    var columns = dt.columns().eq(0).map(function(i) {
      var column = this.column(i);
      var className = column.header().className;
      var priority = dt.settings()[0].aoColumns[i].responsivePriority;
      if (priority === undefined) {
        var dataPriority = $(column.header()).data("priority");
        priority = dataPriority !== undefined ? dataPriority * 1 : 10000;
      }
      return {className:className, includeIn:[], auto:false, control:false, never:className.match(/\bnever\b/) ? true : false, priority:priority};
    });
    var add = function(colIdx, name) {
      var includeIn = columns[colIdx].includeIn;
      if ($.inArray(name, includeIn) === -1) {
        includeIn.push(name);
      }
    };
    var column = function(colIdx, name, operator, matched) {
      var size, i, ien;
      if (!operator) {
        columns[colIdx].includeIn.push(name);
      } else {
        if (operator === "max-") {
          size = that._find(name).width;
          for (i = 0, ien = breakpoints.length; i < ien; i++) {
            if (breakpoints[i].width <= size) {
              add(colIdx, breakpoints[i].name);
            }
          }
        } else {
          if (operator === "min-") {
            size = that._find(name).width;
            for (i = 0, ien = breakpoints.length; i < ien; i++) {
              if (breakpoints[i].width >= size) {
                add(colIdx, breakpoints[i].name);
              }
            }
          } else {
            if (operator === "not-") {
              for (i = 0, ien = breakpoints.length; i < ien; i++) {
                if (breakpoints[i].name.indexOf(matched) === -1) {
                  add(colIdx, breakpoints[i].name);
                }
              }
            }
          }
        }
      }
    };
    columns.each(function(col, i) {
      var classNames = col.className.split(" ");
      var hasClass = false;
      for (var k = 0, ken = classNames.length; k < ken; k++) {
        var className = $.trim(classNames[k]);
        if (className === "all") {
          hasClass = true;
          col.includeIn = $.map(breakpoints, function(a) {
            return a.name;
          });
          return;
        } else {
          if (className === "none" || col.never) {
            hasClass = true;
            return;
          } else {
            if (className === "control") {
              hasClass = true;
              col.control = true;
              return;
            }
          }
        }
        $.each(breakpoints, function(j, breakpoint) {
          var brokenPoint = breakpoint.name.split("-");
          var re = new RegExp("(min\\-|max\\-|not\\-)?(" + brokenPoint[0] + ")(\\-[_a-zA-Z0-9])?");
          var match = className.match(re);
          if (match) {
            hasClass = true;
            if (match[2] === brokenPoint[0] && match[3] === "-" + brokenPoint[1]) {
              column(i, breakpoint.name, match[1], match[2] + match[3]);
            } else {
              if (match[2] === brokenPoint[0] && !match[3]) {
                column(i, breakpoint.name, match[1], match[2]);
              }
            }
          }
        });
      }
      if (!hasClass) {
        col.auto = true;
      }
    });
    this.s.columns = columns;
  }, _detailsDisplay:function(row, update) {
    var that = this;
    var dt = this.s.dt;
    var details = this.c.details;
    if (details && details.type !== false) {
      var res = details.display(row, update, function() {
        return details.renderer(dt, row[0], that._detailsObj(row[0]));
      });
      if (res === true || res === false) {
        $(dt.table().node()).triggerHandler("responsive-display.dt", [dt, row, res, update]);
      }
    }
  }, _detailsInit:function() {
    var that = this;
    var dt = this.s.dt;
    var details = this.c.details;
    if (details.type === "inline") {
      details.target = "td:first-child, th:first-child";
    }
    dt.on("draw.dtr", function() {
      that._tabIndexes();
    });
    that._tabIndexes();
    $(dt.table().body()).on("keyup.dtr", "td, th", function(e) {
      if (e.keyCode === 13 && $(this).data("dtr-keyboard")) {
        $(this).click();
      }
    });
    var target = details.target;
    var selector = typeof target === "string" ? target : "td, th";
    $(dt.table().body()).on("click.dtr mousedown.dtr mouseup.dtr", selector, function(e) {
      if (!$(dt.table().node()).hasClass("collapsed")) {
        return;
      }
      if (!dt.row($(this).closest("tr")).length) {
        return;
      }
      if (typeof target === "number") {
        var targetIdx = target < 0 ? dt.columns().eq(0).length + target : target;
        if (dt.cell(this).index().column !== targetIdx) {
          return;
        }
      }
      var row = dt.row($(this).closest("tr"));
      if (e.type === "click") {
        that._detailsDisplay(row, false);
      } else {
        if (e.type === "mousedown") {
          $(this).css("outline", "none");
        } else {
          if (e.type === "mouseup") {
            $(this).blur().css("outline", "");
          }
        }
      }
    });
  }, _detailsObj:function(rowIdx) {
    var that = this;
    var dt = this.s.dt;
    return $.map(this.s.columns, function(col, i) {
      if (col.never || col.control) {
        return;
      }
      return {title:dt.settings()[0].aoColumns[i].sTitle, data:dt.cell(rowIdx, i).render(that.c.orthogonal), hidden:dt.column(i).visible() && !that.s.current[i], columnIndex:i, rowIndex:rowIdx};
    });
  }, _find:function(name) {
    var breakpoints = this.c.breakpoints;
    for (var i = 0, ien = breakpoints.length; i < ien; i++) {
      if (breakpoints[i].name === name) {
        return breakpoints[i];
      }
    }
  }, _redrawChildren:function() {
    var that = this;
    var dt = this.s.dt;
    dt.rows({page:"current"}).iterator("row", function(settings, idx) {
      var row = dt.row(idx);
      that._detailsDisplay(dt.row(idx), true);
    });
  }, _resize:function() {
    var that = this;
    var dt = this.s.dt;
    var width = $(window).width();
    var breakpoints = this.c.breakpoints;
    var breakpoint = breakpoints[0].name;
    var columns = this.s.columns;
    var i, ien;
    var oldVis = this.s.current.slice();
    for (i = breakpoints.length - 1; i >= 0; i--) {
      if (width <= breakpoints[i].width) {
        breakpoint = breakpoints[i].name;
        break;
      }
    }
    var columnsVis = this._columnsVisiblity(breakpoint);
    this.s.current = columnsVis;
    var collapsedClass = false;
    for (i = 0, ien = columns.length; i < ien; i++) {
      if (columnsVis[i] === false && !columns[i].never && !columns[i].control) {
        collapsedClass = true;
        break;
      }
    }
    $(dt.table().node()).toggleClass("collapsed", collapsedClass);
    var changed = false;
    dt.columns().eq(0).each(function(colIdx, i) {
      if (columnsVis[i] !== oldVis[i]) {
        changed = true;
        that._setColumnVis(colIdx, columnsVis[i]);
      }
    });
    if (changed) {
      this._redrawChildren();
      $(dt.table().node()).trigger("responsive-resize.dt", [dt, this.s.current]);
    }
  }, _resizeAuto:function() {
    var dt = this.s.dt;
    var columns = this.s.columns;
    if (!this.c.auto) {
      return;
    }
    if ($.inArray(true, $.map(columns, function(c) {
      return c.auto;
    })) === -1) {
      return;
    }
    var tableWidth = dt.table().node().offsetWidth;
    var columnWidths = dt.columns;
    var clonedTable = dt.table().node().cloneNode(false);
    var clonedHeader = $(dt.table().header().cloneNode(false)).appendTo(clonedTable);
    var clonedBody = $(dt.table().body()).clone(false, false).empty().appendTo(clonedTable);
    var headerCells = dt.columns().header().filter(function(idx) {
      return dt.column(idx).visible();
    }).to$().clone(false).css("display", "table-cell");
    $(clonedBody).append($(dt.rows({page:"current"}).nodes()).clone(false)).find("th, td").css("display", "");
    var footer = dt.table().footer();
    if (footer) {
      var clonedFooter = $(footer.cloneNode(false)).appendTo(clonedTable);
      var footerCells = dt.columns().footer().filter(function(idx) {
        return dt.column(idx).visible();
      }).to$().clone(false).css("display", "table-cell");
      $("<tr/>").append(footerCells).appendTo(clonedFooter);
    }
    $("<tr/>").append(headerCells).appendTo(clonedHeader);
    if (this.c.details.type === "inline") {
      $(clonedTable).addClass("dtr-inline collapsed");
    }
    $(clonedTable).find("[name]").removeAttr("name");
    var inserted = $("<div/>").css({width:1, height:1, overflow:"hidden"}).append(clonedTable);
    inserted.insertBefore(dt.table().node());
    headerCells.each(function(i) {
      var idx = dt.column.index("fromVisible", i);
      columns[idx].minWidth = this.offsetWidth || 0;
    });
    inserted.remove();
  }, _setColumnVis:function(col, showHide) {
    var dt = this.s.dt;
    var display = showHide ? "" : "none";
    $(dt.column(col).header()).css("display", display);
    $(dt.column(col).footer()).css("display", display);
    dt.column(col).nodes().to$().css("display", display);
  }, _tabIndexes:function() {
    var dt = this.s.dt;
    var cells = dt.cells({page:"current"}).nodes().to$();
    var ctx = dt.settings()[0];
    var target = this.c.details.target;
    cells.filter("[data-dtr-keyboard]").removeData("[data-dtr-keyboard]");
    var selector = typeof target === "number" ? ":eq(" + target + ")" : target;
    $(selector, dt.rows({page:"current"}).nodes()).attr("tabIndex", ctx.iTabIndex).data("dtr-keyboard", 1);
  }});
  Responsive.breakpoints = [{name:"desktop", width:Infinity}, {name:"tablet-l", width:1024}, {name:"tablet-p", width:768}, {name:"mobile-l", width:480}, {name:"mobile-p", width:320}];
  Responsive.display = {childRow:function(row, update, render) {
    if (update) {
      if ($(row.node()).hasClass("parent")) {
        row.child(render(), "child").show();
        return true;
      }
    } else {
      if (!row.child.isShown()) {
        row.child(render(), "child").show();
        $(row.node()).addClass("parent");
        return true;
      } else {
        row.child(false);
        $(row.node()).removeClass("parent");
        return false;
      }
    }
  }, childRowImmediate:function(row, update, render) {
    if (!update && row.child.isShown() || !row.responsive.hasHidden()) {
      row.child(false);
      $(row.node()).removeClass("parent");
      return false;
    } else {
      row.child(render(), "child").show();
      $(row.node()).addClass("parent");
      return true;
    }
  }, modal:function(options) {
    return function(row, update, render) {
      if (!update) {
        var close = function() {
          modal.remove();
          $(document).off("keypress.dtr");
        };
        var modal = $('<div class="dtr-modal"/>').append($('<div class="dtr-modal-display"/>').append($('<div class="dtr-modal-content"/>').append(render())).append($('<div class="dtr-modal-close">&times;</div>').click(function() {
          close();
        }))).append($('<div class="dtr-modal-background"/>').click(function() {
          close();
        })).appendTo("body");
        $(document).on("keyup.dtr", function(e) {
          if (e.keyCode === 27) {
            e.stopPropagation();
            close();
          }
        });
      } else {
        $("div.dtr-modal-content").empty().append(render());
      }
      if (options && options.header) {
        $("div.dtr-modal-content").prepend("<h2>" + options.header(row) + "</h2>");
      }
    };
  }};
  Responsive.renderer = {listHidden:function() {
    return function(api, rowIdx, columns) {
      var data = $.map(columns, function(col) {
        return col.hidden ? '<li data-dtr-index="' + col.columnIndex + '" data-dt-row="' + col.rowIndex + '" data-dt-column="' + col.columnIndex + '">' + '<span class="dtr-title">' + col.title + "</span> " + '<span class="dtr-data">' + col.data + "</span>" + "</li>" : "";
      }).join("");
      return data ? $('<ul data-dtr-index="' + rowIdx + '"/>').append(data) : false;
    };
  }, tableAll:function(options) {
    options = $.extend({tableClass:""}, options);
    return function(api, rowIdx, columns) {
      var data = $.map(columns, function(col) {
        return '<tr data-dt-row="' + col.rowIndex + '" data-dt-column="' + col.columnIndex + '">' + "<td>" + col.title + ":" + "</td> " + "<td>" + col.data + "</td>" + "</tr>";
      }).join("");
      return $('<table class="' + options.tableClass + '" width="100%"/>').append(data);
    };
  }};
  Responsive.defaults = {breakpoints:Responsive.breakpoints, auto:true, details:{display:Responsive.display.childRow, renderer:Responsive.renderer.listHidden(), target:0, type:"inline"}, orthogonal:"display"};
  var Api = $.fn.dataTable.Api;
  Api.register("responsive()", function() {
    return this;
  });
  Api.register("responsive.index()", function(li) {
    li = $(li);
    return {column:li.data("dtr-index"), row:li.parent().data("dtr-index")};
  });
  Api.register("responsive.rebuild()", function() {
    return this.iterator("table", function(ctx) {
      if (ctx._responsive) {
        ctx._responsive._classLogic();
      }
    });
  });
  Api.register("responsive.recalc()", function() {
    return this.iterator("table", function(ctx) {
      if (ctx._responsive) {
        ctx._responsive._resizeAuto();
        ctx._responsive._resize();
      }
    });
  });
  Api.register("responsive.hasHidden()", function() {
    var ctx = this.context[0];
    return ctx._responsive ? $.inArray(false, ctx._responsive.s.current) !== -1 : false;
  });
  Responsive.version = "2.1.0";
  $.fn.dataTable.Responsive = Responsive;
  $.fn.DataTable.Responsive = Responsive;
  $(document).on("preInit.dt.dtr", function(e, settings, json) {
    if (e.namespace !== "dt") {
      return;
    }
    if ($(settings.nTable).hasClass("responsive") || $(settings.nTable).hasClass("dt-responsive") || settings.oInit.responsive || DataTable.defaults.responsive) {
      var init = settings.oInit.responsive;
      if (init !== false) {
        new Responsive(settings, $.isPlainObject(init) ? init : {});
      }
    }
  });
  return Responsive;
});
(function(factory) {
  if (typeof define === "function" && define.amd) {
    define(["jquery", "datatables.net"], function($) {
      return factory($, window, document);
    });
  } else {
    if (typeof exports === "object") {
      module.exports = function(root, $) {
        if (!root) {
          root = window;
        }
        if (!$ || !$.fn.dataTable) {
          $ = require("datatables.net")(root, $).$;
        }
        return factory($, root, root.document);
      };
    } else {
      factory(jQuery, window, document);
    }
  }
})(function($, window, document, undefined) {
  var DataTable = $.fn.dataTable;
  var Scroller = function(dt, opts) {
    if (!(this instanceof Scroller)) {
      alert("Scroller warning: Scroller must be initialised with the 'new' keyword.");
      return;
    }
    if (opts === undefined) {
      opts = {};
    }
    this.s = {"dt":$.fn.dataTable.Api(dt).settings()[0], "tableTop":0, "tableBottom":0, "redrawTop":0, "redrawBottom":0, "autoHeight":true, "viewportRows":0, "stateTO":null, "drawTO":null, heights:{jump:null, page:null, virtual:null, scroll:null, row:null, viewport:null}, topRowFloat:0, scrollDrawDiff:null, loaderVisible:false};
    this.s = $.extend(this.s, Scroller.oDefaults, opts);
    this.s.heights.row = this.s.rowHeight;
    this.dom = {"force":document.createElement("div"), "scroller":null, "table":null, "loader":null};
    if (this.s.dt.oScroller) {
      return;
    }
    this.s.dt.oScroller = this;
    this._fnConstruct();
  };
  $.extend(Scroller.prototype, {"fnRowToPixels":function(rowIdx, intParse, virtual) {
    var pixels;
    if (virtual) {
      pixels = this._domain("virtualToPhysical", rowIdx * this.s.heights.row);
    } else {
      var diff = rowIdx - this.s.baseRowTop;
      pixels = this.s.baseScrollTop + diff * this.s.heights.row;
    }
    return intParse || intParse === undefined ? parseInt(pixels, 10) : pixels;
  }, "fnPixelsToRow":function(pixels, intParse, virtual) {
    var diff = pixels - this.s.baseScrollTop;
    var row = virtual ? this._domain("physicalToVirtual", pixels) / this.s.heights.row : diff / this.s.heights.row + this.s.baseRowTop;
    return intParse || intParse === undefined ? parseInt(row, 10) : row;
  }, "fnScrollToRow":function(iRow, bAnimate) {
    var that = this;
    var ani = false;
    var px = this.fnRowToPixels(iRow);
    var preRows = (this.s.displayBuffer - 1) / 2 * this.s.viewportRows;
    var drawRow = iRow - preRows;
    if (drawRow < 0) {
      drawRow = 0;
    }
    if ((px > this.s.redrawBottom || px < this.s.redrawTop) && this.s.dt._iDisplayStart !== drawRow) {
      ani = true;
      px = this.fnRowToPixels(iRow, false, true);
    }
    if (typeof bAnimate == "undefined" || bAnimate) {
      this.s.ani = ani;
      $(this.dom.scroller).animate({"scrollTop":px}, function() {
        setTimeout(function() {
          that.s.ani = false;
        }, 25);
      });
    } else {
      $(this.dom.scroller).scrollTop(px);
    }
  }, "fnMeasure":function(bRedraw) {
    if (this.s.autoHeight) {
      this._fnCalcRowHeight();
    }
    var heights = this.s.heights;
    if (heights.row) {
      heights.viewport = $(this.dom.scroller).height();
      this.s.viewportRows = parseInt(heights.viewport / heights.row, 10) + 1;
      this.s.dt._iDisplayLength = this.s.viewportRows * this.s.displayBuffer;
    }
    if (bRedraw === undefined || bRedraw) {
      this.s.dt.oInstance.fnDraw(false);
    }
  }, "fnPageInfo":function() {
    var dt = this.s.dt, iScrollTop = this.dom.scroller.scrollTop, iTotal = dt.fnRecordsDisplay(), iPossibleEnd = Math.ceil(this.fnPixelsToRow(iScrollTop + this.s.heights.viewport, false, this.s.ani));
    return {start:Math.floor(this.fnPixelsToRow(iScrollTop, false, this.s.ani)), end:iTotal < iPossibleEnd ? iTotal - 1 : iPossibleEnd - 1};
  }, "_fnConstruct":function() {
    var that = this;
    if (!this.s.dt.oFeatures.bPaginate) {
      this.s.dt.oApi._fnLog(this.s.dt, 0, "Pagination must be enabled for Scroller");
      return;
    }
    this.dom.force.style.position = "relative";
    this.dom.force.style.top = "0px";
    this.dom.force.style.left = "0px";
    this.dom.force.style.width = "1px";
    this.dom.scroller = $("div." + this.s.dt.oClasses.sScrollBody, this.s.dt.nTableWrapper)[0];
    this.dom.scroller.appendChild(this.dom.force);
    this.dom.scroller.style.position = "relative";
    this.dom.table = $(">table", this.dom.scroller)[0];
    this.dom.table.style.position = "absolute";
    this.dom.table.style.top = "0px";
    this.dom.table.style.left = "0px";
    $(this.s.dt.nTableWrapper).addClass("DTS");
    if (this.s.loadingIndicator) {
      this.dom.loader = $('<div class="dataTables_processing DTS_Loading">' + this.s.dt.oLanguage.sLoadingRecords + "</div>").css("display", "none");
      $(this.dom.scroller.parentNode).css("position", "relative").append(this.dom.loader);
    }
    if (this.s.heights.row && this.s.heights.row != "auto") {
      this.s.autoHeight = false;
    }
    this.fnMeasure(false);
    this.s.ingnoreScroll = true;
    this.s.stateSaveThrottle = this.s.dt.oApi._fnThrottle(function() {
      that.s.dt.oApi._fnSaveState(that.s.dt);
    }, 500);
    $(this.dom.scroller).on("scroll.DTS", function(e) {
      that._fnScroll.call(that);
    });
    $(this.dom.scroller).on("touchstart.DTS", function() {
      that._fnScroll.call(that);
    });
    this.s.dt.aoDrawCallback.push({"fn":function() {
      if (that.s.dt.bInitialised) {
        that._fnDrawCallback.call(that);
      }
    }, "sName":"Scroller"});
    $(window).on("resize.DTS", function() {
      that.fnMeasure(false);
      that._fnInfo();
    });
    var initialStateSave = true;
    this.s.dt.oApi._fnCallbackReg(this.s.dt, "aoStateSaveParams", function(oS, oData) {
      if (initialStateSave && that.s.dt.oLoadedState) {
        oData.iScroller = that.s.dt.oLoadedState.iScroller;
        oData.iScrollerTopRow = that.s.dt.oLoadedState.iScrollerTopRow;
        initialStateSave = false;
      } else {
        oData.iScroller = that.dom.scroller.scrollTop;
        oData.iScrollerTopRow = that.s.topRowFloat;
      }
    }, "Scroller_State");
    if (this.s.dt.oLoadedState) {
      this.s.topRowFloat = this.s.dt.oLoadedState.iScrollerTopRow || 0;
    }
    $(this.s.dt.nTable).one("init.dt", function() {
      that.fnMeasure();
    });
    this.s.dt.aoDestroyCallback.push({"sName":"Scroller", "fn":function() {
      $(window).off("resize.DTS");
      $(that.dom.scroller).off("touchstart.DTS scroll.DTS");
      $(that.s.dt.nTableWrapper).removeClass("DTS");
      $("div.DTS_Loading", that.dom.scroller.parentNode).remove();
      $(that.s.dt.nTable).off("init.dt");
      that.dom.table.style.position = "";
      that.dom.table.style.top = "";
      that.dom.table.style.left = "";
    }});
  }, "_fnScroll":function() {
    var that = this, heights = this.s.heights, iScrollTop = this.dom.scroller.scrollTop, iTopRow;
    if (this.s.skip) {
      return;
    }
    if (this.s.ingnoreScroll) {
      return;
    }
    if (this.s.dt.bFiltered || this.s.dt.bSorted) {
      this.s.lastScrollTop = 0;
      return;
    }
    this._fnInfo();
    clearTimeout(this.s.stateTO);
    this.s.stateTO = setTimeout(function() {
      that.s.dt.oApi._fnSaveState(that.s.dt);
    }, 250);
    if (iScrollTop < this.s.redrawTop || iScrollTop > this.s.redrawBottom) {
      var preRows = Math.ceil((this.s.displayBuffer - 1) / 2 * this.s.viewportRows);
      if (Math.abs(iScrollTop - this.s.lastScrollTop) > heights.viewport || this.s.ani) {
        iTopRow = parseInt(this._domain("physicalToVirtual", iScrollTop) / heights.row, 10) - preRows;
        this.s.topRowFloat = this._domain("physicalToVirtual", iScrollTop) / heights.row;
      } else {
        iTopRow = this.fnPixelsToRow(iScrollTop) - preRows;
        this.s.topRowFloat = this.fnPixelsToRow(iScrollTop, false);
      }
      if (iTopRow <= 0) {
        iTopRow = 0;
      } else {
        if (iTopRow + this.s.dt._iDisplayLength > this.s.dt.fnRecordsDisplay()) {
          iTopRow = this.s.dt.fnRecordsDisplay() - this.s.dt._iDisplayLength;
          if (iTopRow < 0) {
            iTopRow = 0;
          }
        } else {
          if (iTopRow % 2 !== 0) {
            iTopRow++;
          }
        }
      }
      if (iTopRow != this.s.dt._iDisplayStart) {
        this.s.tableTop = $(this.s.dt.nTable).offset().top;
        this.s.tableBottom = $(this.s.dt.nTable).height() + this.s.tableTop;
        var draw = function() {
          if (that.s.scrollDrawReq === null) {
            that.s.scrollDrawReq = iScrollTop;
          }
          that.s.dt._iDisplayStart = iTopRow;
          that.s.dt.oApi._fnDraw(that.s.dt);
        };
        if (this.s.dt.oFeatures.bServerSide) {
          clearTimeout(this.s.drawTO);
          this.s.drawTO = setTimeout(draw, this.s.serverWait);
        } else {
          draw();
        }
        if (this.dom.loader && !this.s.loaderVisible) {
          this.dom.loader.css("display", "block");
          this.s.loaderVisible = true;
        }
      }
    } else {
      this.s.topRowFloat = this._domain("physicalToVirtual", iScrollTop) / heights.row;
    }
    this.s.lastScrollTop = iScrollTop;
    this.s.stateSaveThrottle();
  }, _domain:function(dir, val) {
    var heights = this.s.heights;
    var coeff;
    if (heights.virtual === heights.scroll) {
      return val;
    }
    var xMax = (heights.scroll - heights.viewport) / 2;
    var yMax = (heights.virtual - heights.viewport) / 2;
    coeff = yMax / (xMax * xMax);
    if (dir === "virtualToPhysical") {
      if (val < yMax) {
        return Math.pow(val / coeff, 0.5);
      } else {
        val = yMax * 2 - val;
        return val < 0 ? heights.scroll : xMax * 2 - Math.pow(val / coeff, 0.5);
      }
    } else {
      if (dir === "physicalToVirtual") {
        if (val < xMax) {
          return val * val * coeff;
        } else {
          val = xMax * 2 - val;
          return val < 0 ? heights.virtual : yMax * 2 - val * val * coeff;
        }
      }
    }
  }, "_fnDrawCallback":function() {
    var that = this, heights = this.s.heights, iScrollTop = this.dom.scroller.scrollTop, iActualScrollTop = iScrollTop, iScrollBottom = iScrollTop + heights.viewport, iTableHeight = $(this.s.dt.nTable).height(), displayStart = this.s.dt._iDisplayStart, displayLen = this.s.dt._iDisplayLength, displayEnd = this.s.dt.fnRecordsDisplay();
    this.s.skip = true;
    this._fnScrollForce();
    if (displayStart === 0) {
      iScrollTop = this.s.topRowFloat * heights.row;
    } else {
      if (displayStart + displayLen >= displayEnd) {
        iScrollTop = heights.scroll - (displayEnd - this.s.topRowFloat) * heights.row;
      } else {
        iScrollTop = this._domain("virtualToPhysical", this.s.topRowFloat * heights.row);
      }
    }
    this.dom.scroller.scrollTop = iScrollTop;
    this.s.baseScrollTop = iScrollTop;
    this.s.baseRowTop = this.s.topRowFloat;
    var tableTop = iScrollTop - (this.s.topRowFloat - displayStart) * heights.row;
    if (displayStart === 0) {
      tableTop = 0;
    } else {
      if (displayStart + displayLen >= displayEnd) {
        tableTop = heights.scroll - iTableHeight;
      }
    }
    this.dom.table.style.top = tableTop + "px";
    this.s.tableTop = tableTop;
    this.s.tableBottom = iTableHeight + this.s.tableTop;
    var boundaryPx = (iScrollTop - this.s.tableTop) * this.s.boundaryScale;
    this.s.redrawTop = iScrollTop - boundaryPx;
    this.s.redrawBottom = iScrollTop + boundaryPx;
    this.s.skip = false;
    if (this.s.dt.oFeatures.bStateSave && this.s.dt.oLoadedState !== null && typeof this.s.dt.oLoadedState.iScroller != "undefined") {
      var ajaxSourced = (this.s.dt.sAjaxSource || that.s.dt.ajax) && !this.s.dt.oFeatures.bServerSide ? true : false;
      if (ajaxSourced && this.s.dt.iDraw == 2 || !ajaxSourced && this.s.dt.iDraw == 1) {
        setTimeout(function() {
          $(that.dom.scroller).scrollTop(that.s.dt.oLoadedState.iScroller);
          that.s.redrawTop = that.s.dt.oLoadedState.iScroller - heights.viewport / 2;
          setTimeout(function() {
            that.s.ingnoreScroll = false;
          }, 0);
        }, 0);
      }
    } else {
      that.s.ingnoreScroll = false;
    }
    if (this.s.dt.oFeatures.bInfo) {
      setTimeout(function() {
        that._fnInfo.call(that);
      }, 0);
    }
    if (this.dom.loader && this.s.loaderVisible) {
      this.dom.loader.css("display", "none");
      this.s.loaderVisible = false;
    }
  }, _fnScrollForce:function() {
    var heights = this.s.heights;
    var max = 1000000;
    heights.virtual = heights.row * this.s.dt.fnRecordsDisplay();
    heights.scroll = heights.virtual;
    if (heights.scroll > max) {
      heights.scroll = max;
    }
    this.dom.force.style.height = heights.scroll > this.s.heights.row ? heights.scroll + "px" : this.s.heights.row + "px";
  }, "_fnCalcRowHeight":function() {
    var dt = this.s.dt;
    var origTable = dt.nTable;
    var nTable = origTable.cloneNode(false);
    var tbody = $("<tbody/>").appendTo(nTable);
    var container = $('<div class="' + dt.oClasses.sWrapper + ' DTS">' + '<div class="' + dt.oClasses.sScrollWrapper + '">' + '<div class="' + dt.oClasses.sScrollBody + '"></div>' + "</div>" + "</div>");
    $("tbody tr:lt(4)", origTable).clone().appendTo(tbody);
    while ($("tr", tbody).length < 3) {
      tbody.append("<tr><td>&nbsp;</td></tr>");
    }
    $("div." + dt.oClasses.sScrollBody, container).append(nTable);
    var insertEl = this.s.dt.nHolding || origTable.parentNode;
    if (!$(insertEl).is(":visible")) {
      insertEl = "body";
    }
    container.appendTo(insertEl);
    this.s.heights.row = $("tr", tbody).eq(1).outerHeight();
    container.remove();
  }, "_fnInfo":function() {
    if (!this.s.dt.oFeatures.bInfo) {
      return;
    }
    var dt = this.s.dt, language = dt.oLanguage, iScrollTop = this.dom.scroller.scrollTop, iStart = Math.floor(this.fnPixelsToRow(iScrollTop, false, this.s.ani) + 1), iMax = dt.fnRecordsTotal(), iTotal = dt.fnRecordsDisplay(), iPossibleEnd = Math.ceil(this.fnPixelsToRow(iScrollTop + this.s.heights.viewport, false, this.s.ani)), iEnd = iTotal < iPossibleEnd ? iTotal : iPossibleEnd, sStart = dt.fnFormatNumber(iStart), sEnd = dt.fnFormatNumber(iEnd), sMax = dt.fnFormatNumber(iMax), sTotal = dt.fnFormatNumber(iTotal), 
    sOut;
    if (dt.fnRecordsDisplay() === 0 && dt.fnRecordsDisplay() == dt.fnRecordsTotal()) {
      sOut = language.sInfoEmpty + language.sInfoPostFix;
    } else {
      if (dt.fnRecordsDisplay() === 0) {
        sOut = language.sInfoEmpty + " " + language.sInfoFiltered.replace("_MAX_", sMax) + language.sInfoPostFix;
      } else {
        if (dt.fnRecordsDisplay() == dt.fnRecordsTotal()) {
          sOut = language.sInfo.replace("_START_", sStart).replace("_END_", sEnd).replace("_MAX_", sMax).replace("_TOTAL_", sTotal) + language.sInfoPostFix;
        } else {
          sOut = language.sInfo.replace("_START_", sStart).replace("_END_", sEnd).replace("_MAX_", sMax).replace("_TOTAL_", sTotal) + " " + language.sInfoFiltered.replace("_MAX_", dt.fnFormatNumber(dt.fnRecordsTotal())) + language.sInfoPostFix;
        }
      }
    }
    var callback = language.fnInfoCallback;
    if (callback) {
      sOut = callback.call(dt.oInstance, dt, iStart, iEnd, iMax, iTotal, sOut);
    }
    var n = dt.aanFeatures.i;
    if (typeof n != "undefined") {
      for (var i = 0, iLen = n.length; i < iLen; i++) {
        $(n[i]).html(sOut);
      }
    }
    $(dt.nTable).triggerHandler("info.dt");
  }});
  Scroller.defaults = {"trace":false, "rowHeight":"auto", "serverWait":200, "displayBuffer":9, "boundaryScale":0.5, "loadingIndicator":false};
  Scroller.oDefaults = Scroller.defaults;
  Scroller.version = "1.4.2";
  if (typeof $.fn.dataTable == "function" && typeof $.fn.dataTableExt.fnVersionCheck == "function" && $.fn.dataTableExt.fnVersionCheck("1.10.0")) {
    $.fn.dataTableExt.aoFeatures.push({"fnInit":function(oDTSettings) {
      var init = oDTSettings.oInit;
      var opts = init.scroller || init.oScroller || {};
      new Scroller(oDTSettings, opts);
    }, "cFeature":"S", "sFeature":"Scroller"});
  } else {
    alert("Warning: Scroller requires DataTables 1.10.0 or greater - www.datatables.net/download");
  }
  $(document).on("preInit.dt.dtscroller", function(e, settings) {
    if (e.namespace !== "dt") {
      return;
    }
    var init = settings.oInit.scroller;
    var defaults = DataTable.defaults.scroller;
    if (init || defaults) {
      var opts = $.extend({}, init, defaults);
      if (init !== false) {
        new Scroller(settings, opts);
      }
    }
  });
  $.fn.dataTable.Scroller = Scroller;
  $.fn.DataTable.Scroller = Scroller;
  var Api = $.fn.dataTable.Api;
  Api.register("scroller()", function() {
    return this;
  });
  Api.register("scroller().rowToPixels()", function(rowIdx, intParse, virtual) {
    var ctx = this.context;
    if (ctx.length && ctx[0].oScroller) {
      return ctx[0].oScroller.fnRowToPixels(rowIdx, intParse, virtual);
    }
  });
  Api.register("scroller().pixelsToRow()", function(pixels, intParse, virtual) {
    var ctx = this.context;
    if (ctx.length && ctx[0].oScroller) {
      return ctx[0].oScroller.fnPixelsToRow(pixels, intParse, virtual);
    }
  });
  Api.register("scroller().scrollToRow()", function(row, ani) {
    this.iterator("table", function(ctx) {
      if (ctx.oScroller) {
        ctx.oScroller.fnScrollToRow(row, ani);
      }
    });
    return this;
  });
  Api.register("row().scrollTo()", function(ani) {
    var that = this;
    this.iterator("row", function(ctx, rowIdx) {
      if (ctx.oScroller) {
        var displayIdx = that.rows({order:"applied", search:"applied"}).indexes().indexOf(rowIdx);
        ctx.oScroller.fnScrollToRow(displayIdx, ani);
      }
    });
    return this;
  });
  Api.register("scroller.measure()", function(redraw) {
    this.iterator("table", function(ctx) {
      if (ctx.oScroller) {
        ctx.oScroller.fnMeasure(redraw);
      }
    });
    return this;
  });
  Api.register("scroller.page()", function() {
    var ctx = this.context;
    if (ctx.length && ctx[0].oScroller) {
      return ctx[0].oScroller.fnPageInfo();
    }
  });
  return Scroller;
});
$.fn.dataTableExt.oPagination.two_button = {"fnInit":function(oSettings, nPaging, fnCallbackDraw) {
  var nPrevious = document.createElement("span");
  var nNext = document.createElement("span");
  nPrevious.className = "paginate_button previous fa fa-angle-left fa-2x";
  nNext.className = "paginate_button next fa-angle-right fa-2x";
  nPaging.appendChild(nPrevious);
  nPaging.appendChild(nNext);
  $(nPrevious).click(function() {
    oSettings.oApi._fnPageChange(oSettings, "previous");
    fnCallbackDraw(oSettings);
  });
  $(nNext).click(function() {
    oSettings.oApi._fnPageChange(oSettings, "next");
    fnCallbackDraw(oSettings);
  });
  $(nPrevious).bind("selectstart", function() {
    return false;
  });
  $(nNext).bind("selectstart", function() {
    return false;
  });
}, "fnUpdate":function(oSettings, fnCallbackDraw) {
  if (!oSettings.aanFeatures.p) {
    return;
  }
  var an = oSettings.aanFeatures.p;
  for (var i = 0, iLen = an.length; i < iLen; i++) {
    var buttons = an[i].getElementsByTagName("span");
    if (oSettings._iDisplayStart === 0) {
      buttons[0].className = "paginate_disabled_previous fa fa-caret-left fa-2x";
    } else {
      buttons[0].className = "paginate_enabled_previous fa fa-caret-left fa-2x";
    }
    if (oSettings.fnDisplayEnd() == oSettings.fnRecordsDisplay()) {
      buttons[1].className = "paginate_disabled_next fa fa-caret-right fa-2x";
    } else {
      buttons[1].className = "paginate_enabled_next fa fa-caret-right fa-2x";
    }
  }
}};
DataTablesBehavior = {properties:{multiSelect:{type:Boolean, value:false}, selection:{type:Array, notify:true}, meta:{type:Object, value:null}, data:{type:Object}, options:{type:String}, namespace:{value:null, type:String}}, observers:["_dataChanged(data,meta)"], _createTable:function(dtMeta, dataSet, options) {
  console.log("_createTable:", dtMeta);
  if (this.asyncRunning == null) {
    this._tableRecalcJob(function() {
    }.bind(this));
  } else {
    this.asyncRunning = true;
  }
  this.__createTable(dtMeta, dataSet, options);
}, recalc:function() {
  console.log("recalc:", this._api);
  if (this._api) {
    this._api.responsive.recalc();
    this._api.columns.adjust();
  }
}, __createTable:function(dtMeta, dataSet, options) {
  this.dataSet = dataSet;
  if (options) {
    options = this._parseOptions(options);
  } else {
    if (this.options) {
      options = this._parseOptions(this.options);
    } else {
      options = {dom:"t", scrollY:"50vh", paging:false};
    }
  }
  if (this._api) {
    this._api.destroy(false);
  }
  var self = this;
  var dtMainElem = $(this.$.dataTablesId);
  if (dataSet && dataSet.length < 10 && options && options.dom) {
  }
  if (typeof dtMeta === "string") {
    dtMeta = JSON5.parse(dtMeta);
  } else {
    dtMeta = simpl4.util.Merge.clone(dtMeta);
  }
  this._translate(dtMeta);
  if (dtMeta[0].class == null || dtMeta[0].class.indexOf("control") == -1) {
    dtMeta.splice(0, 0, {data:"__control", class:"control"});
    options.responsive = {details:{type:"column"}};
  }
  dataSet.forEach(function(row, idx) {
    row.__control = "";
  }.bind(this));
  console.trace("options:", dataSet);
  this._api = dtMainElem.DataTable(jQuery.extend({"initComplete":function(settings, json) {
    self.fire("init-complete", {settings:settings, json:json});
  }, language:this._getLang(), paging:true, pagingType:"two_button", bSort:false, bFilter:true, bDestroy:true, bLengthChange:true, stateSave:false, _columnDefs:[{className:"control", orderable:false, targets:0}], data:dataSet, columns:dtMeta}, options));
  $(this.root.querySelectorAll("table.dataTables")).attr("id", "dataTablesId");
  this._createRowListener();
  this._addDetailCopier(dtMainElem, this._api);
}, getApi:function() {
  return this._api;
}, _addDetailCopier:function(mainElem, api) {
  var self = this;
  mainElem.on("keyup change", ".child input, .child select, .child textarea", function(e) {
    var srcDetailElem = $(this);
    var rowIdx = srcDetailElem.closest("ul").data("dtr-index");
    var colIdx = srcDetailElem.closest("li").data("dtr-index");
    var cell = api.cell({row:rowIdx, column:colIdx}).node();
    $("input, select, textarea", cell).val(srcDetailElem.val());
    if (srcDetailElem.is(":checked")) {
      $("input", cell).prop("checked", true);
    }
  });
  mainElem.on("click", ".child iron-icon", function(e) {
    var index = self._getIndexDetail(e.target);
    var row = self._copySelection(self._api.rows(index.row).data());
    this.fire("rows-selected", {dt:self, doubleTap:false, index:index, target:e.target, rows:row});
  });
}, _createRowListener:function() {
  var self = this;
  var rows = this._api.rows().nodes();
  for (var i = 0; i < rows.length; i++) {
    $(rows[i]).swipe({tap:function(event, target) {
      self._tapAction(target, self._getIndex(target), $(target).closest("tr"), false);
    }, doubleTap:function(event, target) {
      self._tapAction(target, self._getIndex(target), $(target).closest("tr"), true);
    }, threshold:50});
  }
}, _tapAction:function(target, index, row, doubleTap) {
  this.currentRowIndex = row.index();
  if (this.multiSelect) {
    this._tapActionMulti(target, index, row, doubleTap);
  } else {
    this._tapActionSingle(target, index, row, doubleTap);
  }
}, _tapActionSingle:function(target, index, row, doubleTap) {
  if ($(row).hasClass("selected")) {
  }
  this.unselectAll();
  $(row).addClass("selected");
  var sel = this._copySelection(this._api.rows(".selected").data());
  this.fire("rows-selected", {dt:this, doubleTap:doubleTap, index:index, target:target, rows:sel});
  this.selection = sel;
}, _tapActionMulti:function(target, index, row, doubleTap) {
  $(row).toggleClass("selected");
  var sel = this._copySelection(this._api.rows(".selected").data());
  this.fire("rows-selected", {dt:this, doubleTap:doubleTap, index:index, target:target, rows:sel});
  this.selection = sel;
}, _getIndexDetail:function(target) {
  var closest = $(target).closest("li");
  return {row:closest.attr("data-dt-row"), column:closest.attr("data-dt-column")};
}, _getIndex:function(target) {
  var closest = $(target).closest("td");
  return this._api.cell(closest).index();
}, getSelection:function() {
  return this.selection;
}, unselectAll:function() {
  if (this._api == null) {
    return;
  }
  var rows = this._api.rows().nodes();
  if (rows != null) {
    $(rows).removeClass("selected");
  }
}, _copySelection:function(sel) {
  var raw = [];
  for (var i = 0; i < sel.length; i++) {
    raw.push(sel[i]);
  }
  return raw;
}, _dataChanged:function() {
  if (this.internalDataChanged === true) {
    this.internalDataChanged = null;
    return;
  }
  this.async(function() {
    this.__dataChanged();
  }, 10);
}, __dataChanged:function() {
  if (this.meta == null || this.meta.length == 0) {
    if (this.data == null || this.data.length == 0) {
      return;
    }
    if (this.data.length > 0) {
      this.preparedMeta = this._prepareMetaFromData(this.data);
    }
  } else {
    this.preparedMeta = this._prepareMeta(this.meta);
  }
  if (this.preparedMeta == null) {
    return;
  }
  if (this._api == null) {
    if (this.data == null) {
      this.internalDataChanged = true;
      this.data = [];
    }
    this._createTable(this.preparedMeta, this.data, this.options);
  } else {
    this._api.clear();
    if (this.data != null) {
      this.data.forEach(function(row, idx) {
        row.__control = "";
        this._api.row.add(row);
      }.bind(this));
    }
    this._api.draw();
    this._createRowListener();
  }
}, _prepareMeta:function(meta) {
  var fields = meta.fields;
  if (fields == null) {
    return meta;
  }
  var aliases = meta.aliases;
  var ret = [];
  fields.forEach(function(field, i) {
    var alias = aliases[i];
    var title = field;
    if (alias && alias.match(/^[@%]/)) {
      title = tr(alias.substring(1));
    }
    var col = {title:title, data:field};
    ret.push(col);
  }, this);
  return ret;
}, _prepareMetaFromData:function(data) {
  if (data == null) {
    return;
  }
  if (!Array.isArray(data)) {
    data = data.result;
  }
  if (data.length == 0) {
    return;
  }
  var maxKeys = [];
  for (var i = 0; i < data.length; i++) {
    var curKeys = Object.keys(data[i]);
    if (curKeys.length > maxKeys.length) {
      maxKeys = curKeys;
    }
  }
  var ret = [];
  var keys = maxKeys;
  keys.forEach(function(key) {
    var col = {title:key, data:key};
    ret.push(col);
  }, this);
  return ret;
}, _tableRecalcJob:function(done) {
  var self = this;
  var lastWidth = -1;
  function waitForTable() {
    var width = self.$.dataTablesId.offsetWidth;
    if (width > 0 && width != lastWidth) {
      self.recalc();
    }
    lastWidth = width;
    setTimeout(waitForTable, 30);
  }
  waitForTable();
}, _parseOptions:function(o) {
  if (o == null) {
    return;
  }
  if (typeof o == "string") {
    o = JSON5.parse(o);
  }
  return o;
}, _translate:function(meta) {
  var keys = Object.keys(meta);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var title = meta[key].title;
    if (title && title.match(/^[@%]/)) {
      meta[key].title = tr(title.substring(1));
    }
  }
  return meta;
}, _getLang:function() {
  return {"sEmptyTable":tr("datatables.sEmptyTable"), "sInfo":tr("datatables.sInfo"), "sInfoEmpty":tr("datatables.sInfoEmpty"), "sInfoFiltered":tr("datatables.sInfoFiltered"), "sInfoPostFix":tr("datatables.sInfoPostFix"), "sInfoThousands":tr("datatables.sInfoThousands"), "sLengthMenu":tr("datatables.sLengthMenu"), "sLoadingRecords":tr("datatables.sLoadingRecords"), "sProcessing":tr("datatables.sProcessing"), "sSearch":tr("datatables.sSearch"), "sZeroRecords":tr("datatables.sZeroRecords"), "oPaginate":{"sFirst":tr("datatables.sFirst"), 
  "sPrevious":tr("datatables.sPrevious"), "sNext":tr("datatables.sNext"), "sLast":tr("datatables.sLast")}, "oAria":{"sSortAscending":tr("datatables.sSortAscending"), "sSortDescending":tr("datatables.sSortDescending")}};
}};
Polymer({is:"simpl-datatables", behaviors:[ModernizrBehavior, DataTablesBehavior]});
Polymer({is:"simpl-crudtable", behaviors:[DataTablesBehavior, ModernizrBehavior, StyleScopeBehavior], properties:{disableSpinner:{type:Boolean, value:false}, dtOptions:{type:String, value:""}, buttons:{type:String}, filter:{type:Object}}, observers:["filterChanged(filter.*,dtOptions)", "buttonsChanged(buttons,isAttached)", "selectionChanged(selection)"], ready:function() {
}, attached:function() {
  this.isAttached = true;
}, addAction:function() {
  this.fire("add-action", {entity:this.entity, table:this, entityChild:this.id, namespace:this.namespace});
}, editAction:function() {
  if (this.selection == null) {
    return;
  }
  this.fire("edit-action", {data:this.selection[0], dataSet:this.dataSet, rowIndex:this.currentRowIndex, entity:this.entity, table:this, entityChild:this.id, namespace:this.namespace});
}, showAction:function() {
  if (this.selection == null) {
    return;
  }
  this.fire("show-action", {data:this.selection[0], entity:this.entity, table:this, entityChild:this.id, namespace:this.namespace});
}, detailAction:function() {
  if (this.selection == null) {
    return;
  }
  this.fire("detail-action", {data:this.selection[0]});
}, delAction:function() {
  if (this.selection == null) {
    return;
  }
  this.fire("del-action", {data:this.selection[0], entity:this.entity, table:this, entityChild:this.id, namespace:this.namespace});
}, refreshAction:function() {
  this.fire("refresh-action", {entity:this.entity, table:this, entityChild:this.id, namespace:this.namespace});
}, selectAction:function() {
  if (this.selection == null) {
    return;
  }
  this.fire("select-action", {data:this.selection[0]});
}, cancelAction:function() {
  this.fire("cancel-action", {});
}, copyAction:function() {
  if (this.selection == null) {
    return;
  }
  this.fire("copy-action", {data:this.selection[0], entity:this.entity, entityChild:this.id, table:this, namespace:this.namespace});
}, onTap:function(e) {
  var src = e.srcElement || e.target;
  var name = null;
  while (src) {
    name = src.getAttribute("name");
    if (name) {
      break;
    }
    src = src.parentElement;
  }
  if (name == null) {
    return;
  }
  this.buttonDef[name].action.call(this);
}, selectionChanged:function() {
  if (this.buttonDef == null) {
    return;
  }
  this.buttonDef["edit"].disabled = this.buttonDef["copy"].disabled = this.buttonDef["show"].disabled = this.buttonDef["select"].disabled = this.buttonDef["detail"].disabled = this.selection == null;
  for (var i = 0; i < this.buttonList.length; i++) {
    if (this.buttonList[i].name != "add" && this.buttonList[i].name != "cancel" && this.buttonList[i].name != "refresh") {
      this.set("buttonList." + i + ".disabled", this.selection == null);
    }
  }
}, buttonsChanged:function() {
  var buttons = {add:{action:this.addAction, icon:"add", text:tr("button.new"), disabled:false}, edit:{action:this.editAction, icon:"create", text:tr("button.edit"), disabled:true}, del:{action:this.delAction, icon:"delete", text:tr("button.del"), disabled:true}, refresh:{action:this.refreshAction, icon:"refresh", text:tr("button.refresh"), disabled:false}, show:{action:this.showAction, icon:"bookmark-outline", text:tr("button.show"), disabled:true}, copy:{action:this.copyAction, icon:"content-copy", 
  text:tr("button.copy"), disabled:true}, detail:{action:this.detailAction, icon:"view-list", text:tr("button.details"), disabled:true}, select:{action:this.selectAction, icon:"check", text:tr("button.select"), disabled:true}, cancel:{action:this.cancelAction, icon:"cancel", text:tr("button.cancel"), disabled:false}};
  this.buttonDef = buttons;
  var bList = [];
  this.buttons.split(",").forEach(function(name) {
    var b = buttons[name];
    b.name = name;
    bList.push(b);
  }.bind(this));
  this.buttonList = bList;
}, filterChanged:function(o, n) {
  if (!this.filter) {
    return;
  }
  this.entity = this.filter.entity;
  this.namespace = this.filter.namespace || simpl4.util.BaseManager.getNamespace();
  var firsttime = false;
  if (this.dtMeta == null || this._api == null) {
    firsttime = true;
  }
  if (firsttime) {
    this.dtMeta = this.preProcessMeta(simpl4EntityManager.getEntityViewFields(this.filter.entity, "main-grid", true, {namespace:this.namespace}));
  }
  if (this.dtMeta == null || this.dtMeta.length == 0) {
    console.error("crudtable.nometa:", this.filter);
    return;
  }
  this.showSpinner(this.$.dataTablesId);
  this.getData(this.filter, firsttime);
}, showSpinner:function(table) {
  if (this.disableSpinner) {
    return;
  }
  this.async(function() {
    var sel = this.querySelector(".spinner");
    if (sel) {
      sel.innerHTML = "";
      Spinners.create(sel, {radius:22, dashes:30, width:2.5, height:10, opacity:1, padding:3, rotation:600, color:"#000000"}).play();
    }
  }, 50);
}, _dataComplete:function(data, firsttime) {
  this.async(function() {
    var sel = this.querySelector(".spinner");
    if (sel) {
      sel.innerHTML = "";
    }
  }, 150);
  this.dataSet = this.preProcessData(data);
  if (firsttime) {
    if (this.dtOptions == "") {
      var options = {responsive:{details:{type:"column"}}, paging:false, dom:"frti", scrollY:"300px"};
    }
    this._createTable(this.dtMeta, this.dataSet, this.dtOptions);
  } else {
    this._api.clear();
    this.dataSet.forEach(function(row, idx) {
      row.__control = "";
      this._api.row.add(row);
    }.bind(this));
    this._api.draw();
    this._createRowListener();
  }
}, preProcessData:function(rows) {
  var selKeys = Object.keys(this.selectableList);
  var dateKeys = Object.keys(this.dateList);
  var datetimeKeys = Object.keys(this.datetimeList);
  rows.forEach(function(r) {
    selKeys.forEach(function(key) {
      var val = r[key];
      r[key + "_display"] = this.selectableList[key][val];
    }, this);
    dateKeys.forEach(function(key) {
      var val = r[key];
      r[key + "_display"] = this.getDate(val);
    }, this);
  }, this);
  return rows;
}, metaChanged:function() {
  this.dtMeta = this.preProcessMeta(this.meta);
}, preProcessMeta:function(fields) {
  this.selectableList = {};
  this.dateList = {};
  this.datetimeList = {};
  this.columns = [];
  var p = "data";
  var e = this.entity;
  if (this.entity.indexOf(":") > 0) {
    p = this.entity.split(":")[0];
    e = this.entity.split(":")[1];
  }
  var ret = [];
  fields.forEach(function(f) {
    var dtName = f.name;
    if (f.hidden) {
      return;
    }
    if (f.selectable_items) {
      this.selectableList[f.name] = this.toMap(f.selectable_items.getItems());
      dtName = f.name + "_display";
    }
    if (f.datatype == "date") {
      this.dateList[f.name] = true;
      dtName = f.name + "_display";
    }
    if (f.datatype == "datetime") {
      this.datetimeList[f.name] = true;
      dtName = f.name + "_display";
    }
    var col = {title:f.title || tr(p + "." + e + "." + f.name), data:dtName, visible:f.invisible !== true, class:f.tags, mRender:this.renderColumn.bind(this)};
    if (col.visible == false) {
      col.class = "never";
    }
    ret.push(col);
    this.columns.push(f.name);
  }, this);
  this.allModList = [];
  this.allModList.concat(this.selectableList);
  this.allModList.concat(this.dateList);
  this.allModList.concat(this.datetimeList);
  return ret;
}, renderColumn:function(data, type, row, meta) {
  var name = meta.settings.aoColumns[meta.col].mData;
  var clazz = meta.settings.aoColumns[meta.col].sClass;
  if (Detectizr.device.type == "mobile" && clazz && clazz.toLowerCase().indexOf("phone") > -1) {
    return "<div class='phone'><a href='tel:" + row[name] + "'>" + row[name] + "</a></div>";
  } else {
    if (this.entity == "document" && name == "filename") {
      var rpcString = encodeURIComponent(JSON.stringify(this._getRpcHeader(row.id)));
      var username = simpl4.util.Rpc._getUserName();
      var password = simpl4.util.Rpc._getPassword();
      var cred = simpl4.util.Base64.encode(username + ":" + password);
      return "<div class='filename'><a class='filename' target='_blank' href='/rpc/get?credentials=" + cred + "&rpc=" + rpcString + "'>" + row[name] + "</a></div>";
    } else {
      return row[name];
    }
  }
}, toMap:function(sel) {
  var map = {};
  sel.forEach(function(elem) {
    map[elem.value] = elem.label;
  }, this);
  return map;
}, _getRpcHeader:function(id) {
  return {"service":"data", "method":"queryOne", "params":{"storeId":this.namespace + "_data", "entity":"document", "getContent":true, "id":id}};
}, getDate:function(val) {
  if (val == null) {
    return "--";
  }
  return moment(parseInt(val)).format("L");
}, refresh:function() {
  this.filterChanged();
}, getData:function(filter, firsttime) {
  this.selection = null;
  var props = simpl4.util.EntityManager.getEntityViewProperties(filter.entity, "main-grid", {namespace:this.namespace});
  var propsEntity = simpl4.util.EntityManager.getPropertiesForEntity(filter.entity, {namespace:this.namespace});
  var fields = null;
  var meta = this.dtMeta;
  if (meta) {
    fields = [];
    for (var i = 0; i < meta.length; i++) {
      if (meta[i].data == null) {
        continue;
      }
      if (meta[i].data.endsWith("_display")) {
        var s = meta[i].data;
        fields.push(s.substring(0, s.length - 8));
      } else {
        fields.push(meta[i].data);
      }
    }
  }
  var p = "data";
  var e = filter.entity;
  if (filter.entity.indexOf(":") > 0) {
    p = filter.entity.split(":")[0];
    e = filter.entity.split(":")[1];
  }
  var data;
  if (filter.rpc) {
    data = simpl4.util.Rpc.rpcSync("data:query", filter.rpc);
    this._dataComplete(data.rows, firsttime);
  } else {
    if (propsEntity.customServiceRead) {
      var customService = propsEntity.customServiceRead;
      if (customService.indexOf(":") == -1) {
        customService = "camelRoute:" + customService;
      }
      if (customService.indexOf(".") == -1) {
        var x = customService.split(":");
        customService = x[0] + ":" + this.namespace + "." + x[1];
      }
      var params = {service:customService.split(":")[0], method:customService.split(":")[1], parameter:{storeId:this.namespace + "_" + p, pageSize:100, orderby:props.orderby, uuid:window.uuid, entity:e, fields:fields, filter:filter}, async:true, context:this, failed:function(e) {
        console.error("simpl-crudtable1:", e);
        this.fire("error", {error:e});
      }, completed:function(ret) {
        console.error("completed:", ret);
        this._dataComplete(ret, firsttime);
      }};
      simpl4.util.Rpc.rpcAsync(params);
    } else {
      var params = {service:"data", method:"query", parameter:{storeId:this.namespace + "_" + p, pageSize:100, orderby:props.orderby, entity:e, fields:fields, filter:filter}, async:true, context:this, failed:function(e) {
        console.error("simpl-crudtable2:", e);
        this.fire("error", {error:e});
      }, completed:function(ret) {
        console.log("completed2:", ret.rows);
        this._dataComplete(ret.rows, firsttime);
      }};
      simpl4.util.Rpc.rpcAsync(params);
    }
  }
}});
Polymer({is:"simpl-executefilter", properties:{pagesize:{type:Number, value:100}, offset:{type:Number, value:0}, params:{type:Object, value:function() {
  return {};
}, notify:true}, meta:{notify:true, type:Object}, data:{type:Object, notify:true}, name:{value:null, type:String}, namespace:{value:null, type:String}}, observers:["paramsChanged(params.*,name,namespace)"], ready:function() {
}, paramsChanged:function() {
  console.log("executefilter.paramsChanged:", this.params);
  this.execute(true);
}, parseParams:function(o) {
  if (o == null) {
    return;
  }
  if (typeof o == "string") {
    o = JSON5.parse(o);
  }
  return o;
}, execute:function(withMeta) {
  var params = this.parseParams(this.params);
  var namespace = this.namespace || simpl4.util.BaseManager.getNamespace();
  console.debug("execute.namespace:", namespace);
  console.debug("execute.name:", this.name);
  console.debug("execute.params:", params);
  console.debug("execute.pagesize:", this.pagesize);
  console.debug("execute.offset:", this.offset);
  var map = null;
  try {
    map = simpl4.util.Rpc.rpcSync("data:executeFilterByName", {storeId:namespace + "_data", withMeta:withMeta, pageSize:this.pagesize, offset:this.offset, params:params, name:this.name});
  } catch (e) {
    console.error("executefilter:", e.stack);
    return;
  }
  if (withMeta) {
    this.meta = map.meta;
    console.log("Meta:", this.meta);
  }
  console.log("executeFilter.data:", map.rows);
  this.data = map.rows;
}});
Polymer({is:"simpl-buildfilter", properties:{params:{type:Object, notify:true}, namespace:{value:null, type:String}, filter:{value:null, notify:true, type:String}}, observers:["paramsChanged(params.*)"], paramsChanged:function() {
  this.build(true);
}, parseParams:function(o) {
  if (o == null) {
    return;
  }
  if (typeof o == "string") {
    o = JSON5.parse(o);
  }
  return o;
}, insertFilterParams:function(filter, params) {
  if (filter == null) {
    return false;
  }
  var ok = true;
  var label = filter["label"];
  if (filter["connector"] == null && label != null) {
    if (label.match(/^[a-zA-Z].*/)) {
      if (params != null && (Object.keys(params).indexOf(label) > -1 || Object.keys(params).indexOf(label.toLowerCase()) > -1)) {
        var data = params[label];
        if (data == null) {
          label = label.toLowerCase();
          data = params[label];
        }
        if (data != null) {
          filter["data"] = data;
        }
        ok = true;
      } else {
        ok = false;
      }
      delete filter.connector;
      delete filter.label;
    }
  }
  var children = filter["children"];
  var newChildren = [];
  for (var i = 0; i < children.length; i++) {
    var c = children[i];
    if (this.insertFilterParams(c, params)) {
      newChildren.push(c);
    }
  }
  filter["children"] = newChildren;
  return ok;
}, addPack:function(entity, pack) {
  if (entity.indexOf(":") > 0) {
    return entity;
  }
  return pack + ":" + entity;
}, build:function(withMeta) {
  var params = this.parseParams(this.params);
  var namespace = this.namespace || simpl4.util.BaseManager.getNamespace();
  console.log("buildFilter.build:", namespace + "." + this.name + "/", params);
  var map = simpl4.util.Rpc.rpcSync("git:searchContent", {reponame:namespace, name:this.name, type:"sw.filter"});
  var filter = map.filter;
  this.insertFilterParams(filter, this.params);
  filter.namespace = namespace;
  filter.entity = this.addPack(map.modulename, map.pack);
  console.log("buildFilter.filter:", filter);
  this.set("filter", filter);
}});
FormBehavior = {_valueChanged:function(e) {
  var data = this._getData();
  var lang = simpl4.util.BaseManager.getLanguage();
  var env = {$mode:this.mode, $lang:lang};
  env = simpl4.util.Merge.merge(true, data, env);
  this.saveDisabled = this._isSaveDisabled(env);
  this._errorMessage = null;
  for (var i = 0, l = this.fields.length; i < l; i++) {
    var f = this.fields[i];
    var enabledExpr = f.getAttribute("enabled-expr");
    var readonlyExpr = f.getAttribute("readonly-expr");
    if (this._isNotEmpty(readonlyExpr)) {
      var e = this._maskedEval(readonlyExpr, env);
      if (e) {
        f.setAttribute("disabled", "r");
      } else {
        f.removeAttribute("disabled");
      }
    } else {
      if (this._isNotEmpty(enabledExpr)) {
        var e = this._maskedEval(enabledExpr, env);
        if (e) {
          f.removeAttribute("disabled");
        } else {
          f.setAttribute("disabled", "e");
        }
      }
    }
    var excludeExpr = f.getAttribute("exclude-expr");
    if (this._isNotEmpty(excludeExpr)) {
      var e = this._maskedEval(excludeExpr, env);
      if (e) {
        f.setAttribute("hidden", "");
      } else {
        f.removeAttribute("hidden");
      }
    }
    var invisibleExpr = f.getAttribute("invisible-expr");
    if (this._isNotEmpty(invisibleExpr)) {
      var e = this._maskedEval(invisibleExpr, env);
      if (e) {
        f.setAttribute("visibility", "hidden");
      } else {
        f.removeAttribute("visibility");
      }
    }
  }
  var abuttons = this.$.formdiv.parentNode.querySelectorAll("xaction-button");
  for (var i = 0; i < abuttons.length; i++) {
    var ab = abuttons[i];
    if (ab.xaction == "execute") {
      if (this.saveDisabled) {
        ab.setAttribute("disabled", "");
      } else {
        ab.removeAttribute("disabled");
      }
    }
  }
}, _isSaveDisabled:function(env) {
  var script = this._form.xf_save_disabled;
  if (this._isEmpty(script)) {
    return false;
  }
  try {
    var res = this._maskedEval(script, env);
    return res;
  } catch (e) {
    console.error("_postProcessLocalForm:", e);
  }
}, _isNotEmpty:function(s) {
  if (s == null || s.length == 0) {
    return false;
  }
  return true;
}, created:function() {
}, ready:function() {
}, _shapesChanged:function() {
  console.debug("simpl-baseform._shapesChanged");
  this._valueChanged();
}, validate:function(dontInvalidate) {
  var errorList = [];
  var elements = this._filterToArray("input-field,checkbox-field,select-field", this.$.formdiv, true, false);
  Array.prototype.forEach.call(elements, function(elem) {
    elem.setInvalid(false);
  });
  if (elements.length > 0) {
    regula.bind({elements:elements});
    errorList = regula.validate({elements:elements});
    if (dontInvalidate !== true) {
      errorList.forEach(function(err) {
        err.failingElements.forEach(function(elem) {
          elem.setInvalid(true);
          elem.setErrorMessage(err.message);
        });
      });
    }
  }
  var elements = this._filterToArray("gridinput-field,tableselect-field,upload-field,embeddedobj-inline-field,linkedobj-field,linkedlist-field,embeddedobj-field,embeddedlist-field,tree-field,select-field", this.$.formdiv, true, true);
  for (var i = 0; i < elements.length; i++) {
    var saveInvalid = elements[i].isInvalid;
    elements[i].checkConstraints();
    if (elements[i].isInvalid) {
      errorList.push("Error");
    }
    if (dontInvalidate === true) {
      elements[i].setInvalid(saveInvalid);
    }
  }
  if (errorList && errorList.length > 0) {
  }
  this._validateLocal(errorList);
  this._validateService(errorList);
  return errorList.length == 0;
}, _validateLocal:function(errorListGlobal) {
  var validateExprs = this._form.xf_validate_local;
  if (this._isEmpty(validateExprs)) {
    return null;
  }
  var data = this._getData();
  var lang = simpl4.util.BaseManager.getLanguage();
  var env = {$mode:this.mode, $lang:lang};
  env = simpl4.util.Merge.merge(true, data, env);
  var items = validateExprs.items;
  var errorListLocal = [];
  for (var i = 0; i < items.length; i++) {
    var item = items[i];
    var valid = this._maskedEval(item.expr, env) === false;
    if (valid == false) {
      var errormsg = item.errormsg;
      if (errormsg && errormsg.match(/^[@%]/)) {
        errormsg = tr(errormsg.substring(1));
      }
      errorListGlobal.push(errormsg);
      errorListLocal.push(errormsg);
    }
  }
  var e = "";
  var br = "";
  for (var i = 0; i < errorListLocal.length; i++) {
    e += br + errorListLocal[i];
    br = "<br/>";
  }
  this._setGlobalErrorMessage(e);
}, _validateService:function(errorListGlobal) {
  var method = this._form.xf_validate_service;
  var mode = this._form.xf_postprocess_service_mode;
  if (this._isEmpty(method)) {
    return null;
  }
  try {
    if (method.indexOf(".") == -1) {
      method = this.namespace + "." + method;
    }
    var lang = simpl4.util.BaseManager.getLanguage();
    var data = this._getData();
    var items = simpl4.util.Rpc.rpcSync("camelRoute:" + method, {data:data, lang:lang, formName:this._removeExtension(this.formName), mode:this.mode, uuid:window.uuid});
    var errorListLocal = [];
    for (var i = 0; i < items.length; i++) {
      var item = items[i];
      var errormsg = item.message;
      var fieldname = item.path;
      if (errormsg && errormsg.match(/^[@%]/)) {
        errormsg = tr(errormsg.substring(1));
      }
      var isErrorSet = false;
      if (fieldname) {
        var field = this._getField(fieldname);
        if (field) {
          field.setInvalid(true);
          field.setErrorMessage(errormsg);
          isErrorSet = true;
        }
      }
      errorListGlobal.push(errormsg);
      if (!isErrorSet) {
        errorListLocal.push(errormsg);
      }
    }
    var err = "";
    var br = "";
    for (var i = 0; i < errorListLocal.length; i++) {
      err += br + errorListLocal[i];
      br = "<br/>";
    }
    this._setGlobalErrorMessage(err);
  } catch (e) {
    console.error("_validateServiceForm.call:camelRoute:" + method);
    console.error("_validateServiceForm:", e);
  }
}, _setGlobalErrorMessage:function(msg) {
  if (_.isEmpty(msg)) {
    return;
  }
  this._errorMessage = msg;
  this.async(function() {
    var error = this.querySelector("#globalErrorId");
    error.innerHTML = msg;
  }, 50);
}, _getExcludes:function(selector) {
  var exclude = [];
  var self = this;
  $("simpl-form", this.$.formdiv).each(function(index) {
    exclude = exclude.concat(self._filterToArray(selector, this, false, false));
  });
  return exclude;
}, _filterToArray:function(selector, context, doExclude, all) {
  var excludes = null;
  if (doExclude === true) {
    excludes = this._getExcludes(selector);
  }
  var elements = [];
  $(selector, context).each(function(index) {
    var c = this.getAttribute("data-constraints");
    if (all || c != null && c.length > 0) {
      if (excludes) {
        var contains = excludes.indexOf(this);
        if (contains < 0) {
          elements.push(this);
        }
      } else {
        elements.push(this);
      }
    }
  });
  return elements;
}, _maskedEval:function(scr, env, def) {
  try {
    env._ = _;
    env.moment = moment;
    env.Math = Math;
    env.form = this;
    env.tr = window.tr;
    return metaes.evaluate(scr.toString(), env);
  } catch (e) {
    console.error("\t" + e);
    console.debug("Form._maskedEval.script:" + scr);
    console.debug("Form._maskedEval.env:" + env);
  }
  return def;
}, _whenFieldsReady:function(done) {
  var self = this;
  function waitForFields() {
    if (self.fields != null && self.fields.length > 0) {
      done();
      return;
    }
    setTimeout(waitForFields, 20);
  }
  waitForFields();
}, _getField:function(path) {
  var f = this.fieldsMap[path];
  return f;
}, _getLabel:function(path) {
  var f = this.fieldsMap[path];
  return f.label;
}, _dataChanged:function() {
  if (this.internal !== true) {
    this.__dataChanged();
  }
  this.internal = false;
}, __dataChanged:function() {
  this._whenFieldsReady(function() {
    if (this.preProcessData) {
      simpl4.util.Merge.merge(false, this.data, this.preProcessData);
      this.preProcessData = null;
    } else {
      this._doPreProcess();
      simpl4.util.Merge.merge(false, this.data, this.preProcessData);
      this.preProcessData = null;
    }
    this._setData(this.data);
  }.bind(this));
}, _setFieldData:function(data) {
  var keys = Object.keys(data);
  keys.forEach(function(k) {
    var field = this._getField(k);
    if (field == null || field.setValue == null) {
      return;
    }
    if (field.setInvalid) {
      field.setInvalid(false);
    }
    field.setValue(data[k]);
  }, this);
}, setData:function(data) {
  this.resetData = jQuery.extend({}, data);
  if (data == null) {
    return;
  }
  this.internal = true;
  this.data = data;
  this.__dataChanged();
}, _setData:function(data) {
  if (data == null) {
    return;
  }
  this.fields.forEach(function(field) {
    if (field.setValue == null) {
      return;
    }
    field.withoutCheck = true;
    if (field.setInvalid) {
      field.setInvalid(false);
      field.setErrorMessage(null);
    }
    var fieldData = data[field.name];
    var oldValue = fieldData;
    if (field.expressionIn) {
      var env = {$mode:this.mode, $lang:simpl4.util.BaseManager.getLanguage(), $self:fieldData};
      env = simpl4.util.Merge.merge(true, data, env);
      fieldData = this._maskedEval(field.expressionIn, env);
    }
    field.setValue(fieldData || field.defaultvalue || null);
  }, this);
  this._valueChanged();
}, clearData:function() {
  this.fields.forEach(function(field) {
    if (field.setValue == null) {
      return;
    }
    field.withoutCheck = true;
    if (field.setInvalid) {
      field.setInvalid(false);
    }
    field.setValue(null);
  }, this);
}, updateData:function(data) {
  this.internal = true;
  this.data = this.data || {};
  var keys = Object.keys(data);
  keys.forEach(function(key) {
    this.data[key] = data[key];
    var field = this.fieldsMap[key];
    if (field) {
      field.withoutCheck = true;
      if (field.setInvalid) {
        field.setInvalid(false);
      }
      var fieldData = this.data[key];
      var oldValue = fieldData;
      if (field.expressionIn) {
        var env = {$mode:this.mode, $lang:simpl4.util.BaseManager.getLanguage(), $self:fieldData};
        env = simpl4.util.Merge.merge(true, data, env);
        fieldData = this._maskedEval(field.expressionIn, env);
        console.log("expressionIn(" + field.name + "\t," + field.expressionIn + "\t," + oldValue + ") -> ", fieldData);
      }
      field.setValue(fieldData);
    }
  }.bind(this));
  this._valueChanged();
}, _getData:function() {
  var data = simpl4.util.Merge.merge(true, this.data);
  this.fields.forEach(function(field) {
    if (field.getValue == null) {
      return;
    }
    data[field.name] = field.getValue();
  }, this);
  return data;
}, getData:function() {
  var data = simpl4.util.Merge.merge(true, this.data);
  this.fields.forEach(function(field) {
    if (field.getValue == null) {
      return;
    }
    data[field.name] = field.getValue();
  }, this);
  this.fields.forEach(function(field) {
    if (field.getValue == null || field.expressionOut == null) {
      return;
    }
    var oldValue = field.getValue();
    var env = {$mode:this.mode, $lang:simpl4.util.BaseManager.getLanguage(), $self:field.getValue()};
    env = simpl4.util.Merge.merge(true, data, env);
    data[field.name] = this._maskedEval(field.expressionOut, env);
  }, this);
  return data;
}, setItems:function(items) {
  this._whenFieldsReady(function() {
    this._setItems(items);
  }.bind(this));
}, _setItems:function(items) {
  this.fields.forEach(function(field) {
    if (field.setItems == null || items[field.name] == null) {
      return;
    }
    field.setItems(items[field.name]);
  }, this);
}, _getSelectionLists:function(method) {
  if (this._isEmpty(method)) {
    return {};
  }
  try {
    if (method.indexOf(".") == -1) {
      method = this.namespace + "." + method;
    }
    var params = {service:"camelRoute", method:method, parameter:{lang:simpl4.util.BaseManager.getLanguage(), mode:this.mode, uuid:window.uuid}, async:false, context:this, failed:function(e) {
      console.error("_getSelectionLists:", e);
      console.log(e.stack);
    }, completed:function(lists) {
      console.log("_getSelectionLists._selectionLists:", lists);
      this._selectionLists = lists;
    }};
    return simpl4.util.Rpc.rpcAsync(params);
  } catch (e) {
    console.error("_getSelectionLists.call:camelRoute:" + method);
    console.error("_getSelectionLists:", e);
  }
}, _postProcessService:function() {
  var method = this._form.xf_postprocess_service;
  var mode = this._form.xf_postprocess_service_mode;
  var ok = mode == this.mode || mode == "edit_add";
  if (!ok || this._isEmpty(method)) {
    return null;
  }
  try {
    if (method.indexOf(".") == -1) {
      method = this.namespace + "." + method;
    }
    var lang = simpl4.util.BaseManager.getLanguage();
    var data = this._getData();
    var formData = simpl4.util.Rpc.rpcSync("camelRoute:" + method, {formData:data, lang:lang, formName:this._removeExtension(this.formName), mode:this.mode, prePost:"post", uuid:window.uuid});
    console.log("_postProcessForm.replaceFormData:", formData);
    return formData;
  } catch (e) {
    console.error("_postProcessForm.call:camelRoute:" + method);
    console.error("_postProcessForm:", e);
  }
}, _postProcessLocal:function() {
  var script = this._form.xf_postprocess_local;
  if (this._isEmpty(script)) {
    return null;
  }
  try {
    var data = this._getData();
    var lang = simpl4.util.BaseManager.getLanguage();
    var env = {$mode:this.mode, $uuid:window.uuid, $lang:lang};
    env = simpl4.util.Merge.merge(true, data, env);
    var formData = this._maskedEval(script, env);
    return formData;
  } catch (e) {
    console.error("_postProcessLocalForm:", e);
  }
}, _preProcessService:function() {
  var method = this._form.xf_preprocess_service;
  var mode = this._form.xf_preprocess_service_mode;
  var ok = mode == this.mode || mode == "edit_add";
  if (!ok || this._isEmpty(method)) {
    return null;
  }
  console.log("_preProcessService:", method + "/" + ok + "/preProcessData:", this.preProcessData + "/data:", this.data);
  try {
    if (method.indexOf(".") == -1) {
      method = this.namespace + "." + method;
    }
    var params = {service:"camelRoute", method:method, parameter:{formData:this.data, lang:simpl4.util.BaseManager.getLanguage(), formName:this._removeExtension(this.formName), mode:this.mode, prePost:"pre", uuid:window.uuid}, async:false, context:this, failed:function(e) {
      console.error("_postProcessForm:", e);
      console.log(e.stack);
    }, completed:function(formData) {
      console.log("_preProcessService.replaceFormData:", formData);
      if (formData != null) {
        this._preData = formData;
        if (formData._selectionLists) {
          this._selectionLists = formData._selectionLists;
        }
      }
    }};
    return simpl4.util.Rpc.rpcAsync(params);
  } catch (e) {
    console.error("_postProcessServic:", e);
    console.debug("_postProcessService.call:method:" + method);
  }
}, _preProcessLocal:function() {
  var script = this._form.xf_preprocess_local;
  if (this._isEmpty(script)) {
    return null;
  }
  try {
    var data = this.data;
    var lang = simpl4.util.BaseManager.getLanguage();
    var env = {$mode:this.mode, $lang:lang};
    env = simpl4.util.Merge.merge(true, data, env);
    var formData = this._maskedEval(script, env);
    if (formData != null) {
      this._preData = formData;
      console.log("_preProcessLocal.replaceFormData:", formData);
    }
  } catch (e) {
    console.error("_preProcessLocal:", e);
    console.debug("_preProcessLocal.script:", script);
  }
}, _doPreProcess:function() {
  this._preProcessService();
  var dataSer = this._preData;
  this._preProcessLocal();
  var dataLoc = this._preData;
  this.preProcessData = simpl4.util.Merge.merge(true, dataSer, dataLoc);
  this._preData = null;
}, _formNameChanged:function() {
  this.async(function() {
    this.__formNameChanged();
  }, 10);
}, __formNameChanged:function() {
  this.fields = [];
  this.fieldsMap = {};
  this.shapes = [];
  this._form = {};
  this._preData = null;
  if (this.formName == "empty") {
    return;
  }
  this.async(function() {
    var form = simpl4FormManager.getForm(this.formName, this.namespace);
    this._form = form.properties;
    this.defaultButtons = form.properties.xf_default_buttons;
    this.formVar = form.properties.xf_name;
    this._getSelectionLists(form.properties.xf_method_fetch);
    this._doPreProcess();
    this.shapes = this._prepareShape(form).childShapes;
    this._shapeMap = {};
    this._buildShapeMap(this.shapes[0]);
    this.async(function() {
      this.fields = this._filterToArray("[field]", this.$.formdiv, true, true);
      this.fields.forEach(function(field) {
        field.setForm(this);
      }, this);
      this.fieldsMap = this._toMap(this.fields);
      this.fire("form-ready", this);
      this._valueChanged();
      if (this.resetData == null) {
        this.resetData = this._getData();
      }
    }, 1);
  }, 1);
}, _specChanged:function() {
  this.fields = [];
  this.fieldsMap = {};
  this.shapes = [];
  this._form = {};
  this.async(function() {
    this.shapes = this.spec;
    this._shapeMap = {};
    this._buildShapeMap(this.shapes[0]);
    this.async(function() {
      this.fields = this._filterToArray("[field]", this.$.formdiv, true, true);
      this.fields.forEach(function(field) {
        field.setForm(this);
      }, this);
      this.fieldsMap = this._toMap(this.fields);
      this._valueChanged();
      this.fire("form-ready", this);
      if (this.resetData == null) {
        this.resetData = this._getData();
      }
    }, 1);
  }, 1);
}, _formTabRenderer:function(shape) {
  for (var i = 0; i < shapes.length; i++) {
    var shape = shapes[i];
    this._formElementRenderer(shape);
  }
}, _formElementSelector:function(shapes) {
  for (var i = 0; i < shapes.length; i++) {
    var shape = shapes[i];
    if (this.isField(shape.id)) {
      this._formElementRenderer(shape);
    }
    if (this.isTabView(shape.id)) {
      this._formTabRenderer(shape.childShapes);
    }
    if (this.isGroup(shape.id) || this.isRow(shape.id) || this.isForm(shape.id)) {
      this._formElementSelector(shape.childShapes);
    }
  }
}, _formElementRenderer:function(shape) {
  if (this.isEnumSelect(shape.id)) {
    this._itemMap[shape.xf_id] = shape.items;
  }
}, getItems:function(name) {
  return this._itemMap[name];
}, initForm:function(namespace, name) {
  this.fields = [];
  this.fieldsMap = {};
  this.shapes = [];
  this._form = {};
  this._itemMap = {};
  this._preData = null;
  this.namespace = namespace;
  var form = simpl4FormManager.getForm(name, namespace);
  this._form = form.properties;
  this.formVar = form.properties.xf_name;
  this._getSelectionLists(form.properties.xf_method_fetch);
  this._doPreProcess();
  this.shapes = this._prepareShape(form).childShapes;
  this._shapeMap = {};
  this._buildShapeMap(this.shapes[0]);
  this._formElementSelector(this.shapes);
}, _toMap:function(arr) {
  var map = {};
  arr.forEach(function(elem) {
    map[elem.name] = elem;
  }, this);
  return map;
}, _convertType:function(t) {
  if (t == "datetime") {
    return "date";
  }
  if (t == "password") {
    return "text";
  }
  return t;
}, _buildShapeMap:function(shape) {
  if (shape.xf_id) {
    this._shapeMap[shape.xf_id] = shape;
  }
  var childShapes = shape.childShapes;
  for (var i = 0; childShapes && i < childShapes.length; i++) {
    this._buildShapeMap(childShapes[i]);
  }
}, _prepareShape:function(shape) {
  shape = this._cleanShape(shape);
  if (shape.id == "Input") {
    shape.regulaConstraints = this._constructRegulaConstraints(shape["xf_constraint_" + this._convertType(shape.xf_type)], shape.xf_errormsg);
  }
  shape.childShapes = _.sortBy(shape.childShapes, function(element) {
    return element.bounds.upperLeft.y * 10000 + element.bounds.upperLeft.x;
  });
  var childShapes = shape.childShapes;
  shape.childShapes = [];
  var row = null;
  for (var i = 0; i < childShapes.length; i++) {
    if (shape.id == "Tabview") {
      shape.childShapes.push(this._prepareShape(childShapes[i]));
    } else {
      if (i == 0 || i > 0 && this._isLineBreak(childShapes[i - 1], childShapes[i])) {
        row = {id:"Row", childShapes:[]};
        shape.childShapes.push(row);
      }
      row.childShapes.push(this._prepareShape(childShapes[i]));
    }
  }
  return shape;
}, _cleanShape:function(shape) {
  if (shape.stencil.id.toLowerCase() == "input" || shape.stencil.id.toLowerCase() == "textarea" || shape.stencil.id.toLowerCase() == "linkedobj" || shape.stencil.id.toLowerCase() == "upload" || shape.stencil.id.toLowerCase() == "embeddedlist" || shape.stencil.id.toLowerCase() == "linkedlist" || shape.stencil.id.toLowerCase() == "linkedobj" || shape.stencil.id.toLowerCase() == "embeddedobj" || shape.stencil.id.toLowerCase() == "moduleselector" || shape.stencil.id.toLowerCase() == "enumselect" || shape.stencil.id.toLowerCase() == 
  "treeselect" || shape.stencil.id.toLowerCase() == "tableselect" || shape.stencil.id.toLowerCase() == "gridinput" || shape.stencil.id.toLowerCase() == "checkbox" || shape.stencil.id.toLowerCase() == "custom" || shape.stencil.id.toLowerCase() == "page" || shape.stencil.id.toLowerCase() == "group") {
    var labelChild = this._getLabelShape(shape.childShapes);
    if (labelChild != null) {
      shape.properties.label = labelChild.properties.xf_text;
      if ((shape.properties.xf_id == null || shape.properties.xf_id == "") && shape.properties.label) {
        shape.properties.xf_id = shape.properties.label.toLowerCase().replace(/\s/g, "");
      }
      if (shape.childShapes.length == 1) {
        shape.childShapes = [];
      }
      var label = shape.properties.label;
      if (label && label.match(/^[@%]/)) {
        shape.properties.label = tr(label.substring(1));
      }
    } else {
      shape.properties.label = "";
    }
    var helpChild = this._getHelpShape(shape.childShapes);
    if (helpChild != null) {
      shape.properties.help = helpChild.properties.xf_message;
      if (shape.childShapes.length == 1) {
        shape.childShapes = [];
      }
      var help = shape.properties.help;
      if (help && help.match(/^[@%]/)) {
        shape.properties.help = tr(help.substring(1));
      }
    } else {
      shape.properties.help = null;
    }
    if (!this._isEmpty(shape.properties.xf_default)) {
      if (shape.stencil.id.toLowerCase() == "input") {
        if (shape.properties.xf_type.startsWith("date")) {
          var d = shape.properties.xf_default;
          if (shape.properties.xf_default == "now") {
            shape.properties.xf_default = Date.create().getTime();
          } else {
            if (d != null && typeof d === "string" && d.length > 0) {
              shape.properties.xf_default = Date.create(d).getTime();
              if (isNaN(shape.properties.xf_default)) {
                console.error("form-behavior:parse.error.DefaultDate(" + shape.properties.xf_id + "):" + d);
              }
            }
          }
        }
      }
    }
    if (_.isEmpty(shape.properties.xf_required)) {
      shape.properties.xf_required = "false";
    }
    if (shape.stencil.id.toLowerCase() == "textarea") {
      if (shape.properties.xf_rows == null) {
        shape.properties.xf_rows = 3;
      }
    }
    if (shape.stencil.id.toLowerCase() == "moduleselector") {
      shape.properties.xf_namespace = this.namespace;
    }
    if (shape.stencil.id.toLowerCase() == "embeddedlist" || shape.stencil.id.toLowerCase() == "linkedlist" || shape.stencil.id.toLowerCase() == "linkedobj" || shape.stencil.id.toLowerCase() == "embeddedobj") {
      shape.properties.xf_namespace = this.namespace;
      var bounds = shape.bounds;
      shape.properties.height = bounds.lowerRight.y - bounds.upperLeft.y;
    }
    if (shape.stencil.id.toLowerCase() == "gridinput") {
      var props = shape.properties;
      props.columns = props.xf_columns.items;
      for (var i = 0; i < props.columns.length; i++) {
        var col = props.columns[i];
        if (col.display && col.display.match(/^[@%]/)) {
          col.display = tr(col.display.substring(1));
        }
        if (col.label && col.label.match(/^[@%]/)) {
          col.label = tr(col.label.substring(1));
        }
        if (col.type == "selection") {
          col.id = "Enumselect";
          try {
            col.items = JSONPath({json:this._selectionLists, path:col.parameter, callback:function() {
            }})[0];
          } catch (e) {
            console.error("JSONPath:", e);
          }
        }
      }
      props.xf_columns = undefined;
      var bounds = shape.bounds;
      props.height = bounds.lowerRight.y - bounds.upperLeft.y;
    }
    if (shape.stencil.id.toLowerCase() == "page") {
      var label = shape.properties.xf_label;
      if (label && label.match(/^[@%]/)) {
        shape.properties.label = tr(label.substring(1));
      }
    }
    if (shape.stencil.id.toLowerCase() == "enumselect" || shape.stencil.id.toLowerCase() == "tableselect" || shape.stencil.id.toLowerCase() == "treeselect") {
      var isTableSelect = shape.stencil.id.toLowerCase() == "tableselect";
      var isTreeSelect = shape.stencil.id.toLowerCase() == "treeselect";
      var props = shape.properties;
      var enumembed = props.xf_enumembed;
      var _enum = props.xf_enum;
      var service = props.xf_service;
      var filter = props.xf_filter;
      var jsonpath = props.xf_jsonpath;
      var parammapping = props.xf_parammapping;
      var resultmapping = props.xf_resultmapping;
      var varname = props.xf_varname;
      var namespace = props.xf_namespace;
      if (!namespace || namespace == "-") {
        namespace = this.namespace;
      }
      if (!this._isEmpty(varname)) {
        props.items = this.variables[varname];
        if (!isTreeSelect) {
          props.items = this._doResultMapping(props.items, resultmapping);
        }
      } else {
        if (!this._isEmpty(jsonpath)) {
          var a = JSONPath({json:this._selectionLists, path:jsonpath, callback:function() {
          }});
          if (a == null || a.length == 0) {
            props.items = [];
          } else {
            props.items = a[0];
          }
          props.items = this._doResultMapping(props.items, resultmapping);
        } else {
          if (!isTreeSelect && !isTableSelect && enumembed && enumembed.totalCount > 0) {
            var si = simpl4FormManager.createSelectableItems(namespace, this.formName, props.xf_id, enumembed);
            props.items = si.getItems();
          } else {
            if (!isTreeSelect && !isTableSelect && _enum && _enum.totalCount > 0) {
              var si = simpl4FormManager.createSelectableItems(namespace, this.formName, props.xf_id, JSON.stringify(props.xf_enum));
              props.items = si.getItems();
            } else {
              if (!isTreeSelect && !this._isEmpty(filter)) {
                var filterDesc = {"totalCount":1, "enumDescription":"sw.filter:" + filter, items:[]};
                filterDesc.params = this._doParameterMapping(parammapping);
                filterDesc.checkParams = true;
                var si = simpl4FormManager.createSelectableItems(namespace, this.formName, props.xf_id, JSON.stringify(filterDesc));
                var items = si.getItems();
                if (si.getMissingParamList()) {
                  console.error("Filter:", filterDesc);
                  console.error("Filter.misingParameters:", si.getMissingParamList());
                } else {
                  props.items = this._doResultMapping(items, resultmapping);
                }
              } else {
                if (!this._isEmpty(service)) {
                  var serviceDesc = {"totalCount":1, "enumDescription":"sw.service:" + service, items:[]};
                  serviceDesc.params = this._doParameterMapping(parammapping);
                  var si = simpl4FormManager.createSelectableItems(namespace, this.formName, props.xf_id, JSON.stringify(serviceDesc));
                  props.items = this._doResultMapping(si.getItems(), resultmapping);
                } else {
                  var si = simpl4FormManager.createSelectableItems(namespace, this.formName, props.xf_id, JSON.stringify(props.xf_enum));
                  props.items = si.getItems();
                }
              }
            }
          }
        }
      }
      if (shape.stencil.id.toLowerCase() == "tableselect") {
        if (props.items == null) {
          props.items = [];
        }
        var columns = props.xf_columns;
        var fields = columns ? columns.items : [];
        props.meta = [];
        fields.forEach(function(field, i) {
          var title = field.display;
          var alias = field.display;
          if (alias && alias.match(/^[@%]/)) {
            title = tr(alias.substring(1));
          }
          if (title == null) {
            title = xf_id + "." + field.colname;
          }
          var col = {title:title, data:field.colname};
          props.meta.push(col);
        }, this);
        var bounds = shape.bounds;
        props.height = bounds.lowerRight.y - bounds.upperLeft.y;
        if (props.height < 75) {
          props.height = 75;
        }
      }
      if (props.items.length > 0 && !this._isEmpty(shape.properties.xf_default) && shape.properties.xf_default.startsWith("#")) {
        try {
          shape.properties.xf_default = props.items[parseInt(shape.properties.xf_default.substring(1))].value;
        } catch (e$8) {
          console.error("set xf_default(" + shape.properties.xf_id + "):", e$8);
        }
      }
    }
  } else {
    if (shape.stencil.id.toLowerCase() == "actionbutton") {
      var icon = shape.properties.xf_iconname;
      var action = shape.properties.xf_action;
      var enter = shape.properties.xf_enter;
      if (icon == null || icon == "") {
        shape.properties.xf_iconname = action == "execute" ? "check" : "clear";
      }
      if (this.enterAction == null && enter === true) {
        this.enterAction = action;
      }
      var label = shape.properties.xf_label;
      if (label && label.match(/^[@%]/)) {
        shape.properties.xf_label = tr(label.substring(1));
      }
    } else {
      if (shape.stencil.id.toLowerCase() == "alert") {
        var lang = simpl4.util.BaseManager.getLanguage();
        if (shape.properties["xf_message_" + lang]) {
          shape.properties.xf_message = this._expandString(shape.properties["xf_message_" + lang], this.variables);
        } else {
          shape.properties.xf_message = this._expandString(shape.properties.xf_message, this.variables);
        }
      } else {
        shape.properties.label = "";
      }
    }
  }
  if (shape.properties.xf_type == null) {
    shape.properties.xf_type = "noop";
  }
  return _.extend(shape.properties, {bounds:shape.bounds}, shape.stencil, {childShapes:shape.childShapes});
}, _getHelpShape:function(childs) {
  for (var i = 0; i < childs.length; i++) {
    if (childs[i].stencil.id.toLowerCase() == "help") {
      return childs[i];
    }
  }
  return null;
}, _getLabelShape:function(childs) {
  for (var i = 0; i < childs.length; i++) {
    if (childs[i].stencil.id.toLowerCase() == "label") {
      return childs[i];
    }
  }
  return null;
}, _isLineBreak:function(child, next) {
  var UL = child.bounds.upperLeft;
  var lineBreak = false;
  var nextUL = next.bounds.upperLeft;
  if (UL.y != nextUL.y) {
    lineBreak = true;
  }
  return lineBreak;
}, _doParameterMapping:function(parammapping) {
  var parameterMap = {};
  if (!parammapping) {
    return parameterMap;
  }
  console.log("----paramMapping:", parammapping);
  var env = simpl4.util.Merge.merge(true, this.preProcessData, this._getData());
  env.$uuid = window.uuid;
  env.$lang = simpl4.util.BaseManager.getLanguage();
  env.$mode = this.mode;
  console.log("----paramEnv:", env);
  var mapping = parammapping.items;
  for (var j = 0; j < mapping.length; j++) {
    var formexpr = mapping[j].formexpr;
    var param = mapping[j].param;
    parameterMap[param] = this._maskedEval(formexpr, env);
  }
  console.log("====paramMap:", parameterMap);
  return parameterMap;
}, _doResultMapping:function(items, resultmapping) {
  console.log("----resultList:", items);
  if (typeof items == "string") {
    console.error("----doResultMapping.cannot handle String result:", items);
    return [];
  }
  var selectionList = [];
  if (resultmapping == null || this._isEmpty(resultmapping.items)) {
    return items;
  }
  var mapping = resultmapping.items;
  for (var i = 0; i < items.length; i++) {
    var item = items[i];
    var selectionObject = clone(item);
    if (_.isString(item)) {
      selectionObject = {"self":item};
    }
    for (var j = 0; j < mapping.length; j++) {
      var _mapping = mapping[j].mapping;
      var resexpr = mapping[j].resultexpr;
      if (_.isString(item)) {
        item = {"self":item};
      }
      selectionObject[_mapping] = this._maskedEval(resexpr, item);
    }
    selectionList.push(selectionObject);
  }
  console.log("====selectionList:", selectionList);
  return selectionList;
}, _constructRegulaConstraints:function(constraints, message) {
  if (constraints == null || constraints.length == 0) {
    return "";
  }
  constraints = constraints.replace(/DecimalMin/g, "Min");
  constraints = constraints.replace(/DecimalMax/g, "Max");
  constraints = JSON.parse(constraints);
  var ret = "";
  var b = "";
  var keys = Object.keys(constraints);
  var self = this;
  keys.forEach(function(key) {
    var values = constraints[key];
    if (values[0] === true) {
      ret += b + "@" + self._mapKeys(key);
      var params = self._constraintParams[key];
      if (message) {
        msg = message;
        if (msg && msg.match(/^[@%]/)) {
          msg = tr(msg.substring(1));
        }
      } else {
        msg = tr("validation." + self._mapKeys(key));
      }
      for (var i = 0; params && i < params.length; i++) {
        var param = params[i];
        var val = values[i + 1];
        if (("Size" == key || "Length" == key) && i == 1) {
          val = val || "512";
        }
        var replaceText = param;
        if (param == "regex") {
          replaceText += "p";
        }
        msg = msg.replace("{" + replaceText + "}", val);
      }
      ret += '(message="' + msg + '"';
      if (params && params.length > 0) {
        var pkey = params[0];
        var val = pkey == "format" ? '"YMD"' : values[1];
        if (pkey == "regex") {
          val = this._correctRegex(values[1]);
        }
        ret += "," + pkey + "=" + val;
        if (params.length > 1) {
          var pkey = params[1];
          var val = values[2];
          if (val == null || val == "") {
            if ("Size" == key || "Length" == key) {
              val = "512";
            }
          }
          ret += "," + pkey + "=" + val;
        }
      }
      ret += ")";
      b = " ";
    }
  }, this);
  return ret;
}, _correctRegex:function(r) {
  if (r == null) {
    return "/.*/";
  }
  if (r.indexOf("/") === 0) {
    return r;
  }
  return "/" + r + "/";
}, _mapKeys:function(key) {
  if (key == "NotNull") {
    return "NotEmpty";
  }
  if (key == "Size") {
    return "Length";
  }
  return key;
}, _constraintParams:{Max:["value"], Min:["value"], Range:["min", "max"], Pattern:["regex"], Length:["min", "max"], Size:["min", "max"], Digits:["integer", "fraction"], Past:["format"], Future:["format"], Step:["min", "max", "value"]}, _isEmpty:function(s) {
  if (s == null || s == "") {
    return true;
  }
  return false;
}, _removeExtension:function(s) {
  if (s.endsWith(".form")) {
    return s.substring(0, s.length - 5);
  }
  return s;
}, _expandString:function(str, binding) {
  if (str == null || str.length == 0) {
    return "";
  }
  var countRepl = 0;
  var countPlainStr = 0;
  var replacement = null;
  var newString = "";
  var openBrackets = 0;
  var first = 0;
  for (var i = 0; i < str.length; i++) {
    if (i < str.length - 2 && str.substring(i, i + 2) == "${") {
      if (openBrackets == 0) {
        first = i + 2;
      }
      openBrackets++;
    } else {
      if (str.charAt(i) == "}" && openBrackets > 0) {
        openBrackets -= 1;
        if (openBrackets == 0) {
          countRepl++;
          replacement = this._maskedEval(str.substring(first, i), binding);
          newString += replacement;
        }
      } else {
        if (openBrackets == 0) {
          newString += str.charAt(i);
          countPlainStr++;
        }
      }
    }
  }
  if (countRepl == 1 && countPlainStr == 0) {
    return replacement;
  } else {
    return newString;
  }
}};
FieldBehavior = {properties:{readonly:{value:false, type:Boolean}, autofocus:{value:false, type:Boolean}, disabled:{value:false, type:Boolean}, label:{value:null, type:String}, name:{value:null, type:String}, value:{type:String}, defaultValue:{value:null, type:String}, editValue:{value:null, type:String}}, created:function() {
  this._iid = getShortId();
}, attached:function() {
  this.isDomReady = true;
}, detached:function() {
}, setForm:function(form) {
  this.form = form;
  this.convertNullToEmpty = form._form.xf_string_null_in_empty === true;
}, getPack:function() {
  if (this.form == null) {
    return null;
  }
  var pack = this.form.pack;
  return pack;
}, setValue:function(v) {
  this.value = v;
}, getValue:function() {
  return this.value;
}, observers:["disabledChanged(disabled)"], getForm:function() {
  return this.form;
}, getSimpleEntityName:function(entity) {
  if (entity.indexOf(":") >= 0) {
    return entity.split(":")[1];
  }
  return entity;
}, disabledChanged:function(event) {
  this.alwaysFloatLabel = this.disabled;
}, _focusBlurHandler:function(event) {
  var target = event.path ? event.path[0] : event.target;
  if (target === this) {
    var focused = event.type === "focus";
    this._setFocused(focused);
  } else {
    if (!this.shadowRoot) {
      if (false) {
        event.stopPropagation();
        this.fire(event.type, {sourceEvent:event}, {node:this, bubbles:event.bubbles, cancelable:event.cancelable});
      }
    }
  }
}, checkConstraints:function() {
  var c = this.getAttribute("data-constraints");
  if (c == null || c.length == 0) {
    return;
  }
  var elements = [this];
  regula.bind({elements:elements});
  this.async(function() {
    var errorList = regula.validate({elements:elements});
    this.setInvalid(errorList.length > 0);
    if (errorList.length > 0) {
      this.setErrorMessage(errorList[0].message);
    } else {
      this.setErrorMessage(null);
    }
  });
}, setErrorMessage:function(message) {
  this.errorMessage = message;
}, setInvalid:function(b) {
  this.invalid = b;
}};
(function(factory) {
  if (typeof define === "function" && define.amd) {
    define(["jquery"], factory);
  } else {
    if (typeof exports === "object") {
      module.exports = factory(require("jquery"));
    } else {
      factory(jQuery);
    }
  }
})(function($) {
  var methods = {options:{"optionClass":"", "dropdownClass":"", "autoinit":false, "callback":false, "onSelected":false, "dynamicOptLabel":"Add a new option..."}, init:function(options) {
    if (options) {
      options = $.extend(methods.options, options);
    } else {
      options = methods.options;
    }
    function initElement($select) {
      if ($select.data("dropdownjs") || !$select.is("select")) {
        return;
      }
      var multi = $select.attr("multiple");
      var dynamicOptions = $select.attr("data-dynamic-opts"), $dynamicInput = $();
      var $dropdown = $("<div></div>");
      $dropdown.addClass("dropdownjs").addClass(options.dropdownStyle);
      $dropdown.data("select", $select);
      $dropdown.data("options", options);
      var $input = $("<input type=text readonly class=fakeinput>");
      if ($.material) {
        $input.data("mdproc", true);
      }
      $dropdown.append($input);
      var $ul = $("<ul></ul>");
      $ul.data("select", $select);
      $dropdown.append($ul);
      $input.attr("placeholder", $select.attr("placeholder"));
      $select.find("option").each(function() {
        var $this = $(this);
        methods._addOption($ul, $this);
      });
      if (dynamicOptions) {
        $dynamicInput = $("<li class=dropdownjs-add></li>");
        $dynamicInput.append("<input>");
        $dynamicInput.find("input").attr("placeholder", options.dynamicOptLabel);
        $ul.append($dynamicInput);
      }
      var selectOptions = $dropdown.find("li");
      if (!multi) {
        var $selected;
        if ($select.find(":selected").length) {
          $selected = $select.find(":selected").last();
        } else {
          $selected = $select.find("option, li").first();
        }
        methods._select($dropdown, $selected);
      } else {
        methods._select($dropdown, $select.find(":selected"));
      }
      $input.addClass($select[0].className);
      $select.hide().attr("data-dropdownjs", true);
      $select.after($dropdown);
      if (options.callback) {
        options.callback($dropdown);
      }
      $ul.on("click", "li:not(.dropdownjs-add)", function(e) {
        methods._select($dropdown, $(this));
        $select.change();
      });
      $ul.on("keydown", "li:not(.dropdownjs-add)", function(e) {
        if (e.which === 27) {
          $(".dropdownjs > ul > li").attr("tabindex", -1);
          return $input.removeClass("focus").blur();
        }
        if (e.which === 32 && !$(e.target).is("input")) {
          methods._select($dropdown, $(this));
          return false;
        }
      });
      $ul.on("focus", "li:not(.dropdownjs-add)", function() {
        if (true) {
          return;
        }
        if ($select.is(":disabled")) {
          return;
        }
        $input.addClass("focus");
      });
      if (dynamicOptions && dynamicOptions.length) {
        $dynamicInput.on("keydown", function(e) {
          if (e.which !== 13) {
            return;
          }
          var $option = $("<option>"), val = $dynamicInput.find("input").val();
          $dynamicInput.find("input").val("");
          $option.attr("value", val);
          $option.text(val);
          $select.append($option);
        });
      }
      $select.on("DOMNodeInserted", function(e) {
        if (true) {
          return;
        }
        var $this = $(e.target);
        if (!$this.val().length) {
          return;
        }
        methods._addOption($ul, $this);
        $ul.find("li").not(".dropdownjs-add").attr("tabindex", 0);
      });
      $input.on("click focus", function(e) {
        e.stopPropagation();
        if ($select.is(":disabled")) {
          return;
        }
        $(".dropdownjs > ul > li").attr("tabindex", -1);
        $(".dropdownjs > input").not($(this)).removeClass("focus").blur();
        $(".dropdownjs > ul > li").not(".dropdownjs-add").attr("tabindex", 0);
        var coords = {top:$(this).offset().top - $(document).scrollTop(), left:$(this).offset().left - $(document).scrollLeft(), bottom:$(window).height() - ($(this).offset().top - $(document).scrollTop()), right:$(window).width() - ($(this).offset().left - $(document).scrollLeft())};
        var height = coords.bottom;
        if (height < 200 && coords.top > coords.bottom) {
          height = coords.top;
          $ul.attr("placement", "top-left");
        } else {
          $ul.attr("placement", "bottom-left");
        }
        console.log("height:", height);
        var ul = $(this).next("ul");
        ul.css("max-height", height - 20);
        $(this).addClass("focus");
      });
      $(document).on("click", function(e) {
        if (multi && $(e.target).parents(".dropdownjs").length) {
          return;
        }
        if ($(e.target).parents(".dropdownjs-add").length || $(e.target).is(".dropdownjs-add")) {
          return;
        }
        $(".dropdownjs > ul > li").attr("tabindex", -1);
        $input.removeClass("focus");
      });
    }
    if (options.autoinit) {
      $(document).on("DOMNodeInserted", function(e) {
        var $this = $(e.target);
        if ($this.is("select") && $this.is(options.autoinit)) {
          initElement($this);
        }
      });
    }
    $(this).each(function() {
      initElement($(this));
    });
  }, select:function(target) {
    var $target = $(this).find('[value="' + target + '"]');
    methods._select($(this), $target);
  }, _select:function($dropdown, $target) {
    if ($target.is(".dropdownjs-add")) {
      return;
    }
    var $select = $dropdown.data("select"), $options = $dropdown.data("options"), $input = $dropdown.find("input.fakeinput");
    var multi = $select.attr("multiple");
    var selectOptions = $dropdown.find("li");
    if (multi) {
      $target.toggleClass("selected");
      var $selected = $select.find('[value="' + $target.attr("value") + '"]');
      if ($selected.prop("selected")) {
        $selected.prop("selected", true);
      } else {
        $selected.prop("selected", false);
      }
      var text = [];
      selectOptions.each(function() {
        if ($(this).hasClass("selected")) {
          text.push($(this).text());
        }
      });
      $input.val(text.join(", "));
    }
    if (!multi) {
      selectOptions.not($target).removeClass("selected");
      $target.addClass("selected");
      $select.val($target.attr("value"));
      $input.val($target.text().trim());
    }
    if ($.material) {
      if ($input.val().trim()) {
        $select.removeClass("empty");
      } else {
        $select.addClass("empty");
      }
    }
    if ($options.onSelected) {
      $options.onSelected($target.attr("value"));
    }
  }, _addOption:function($ul, $this) {
    var $option = $("<li></li>");
    $option.addClass(this.options.optionStyle);
    if ($this.text()) {
      $option.text($this.text());
    } else {
      $option.html("&nbsp;");
    }
    $option.attr("value", $this.val());
    if ($ul.data("select").attr("data-dynamic-opts")) {
      $option.append("<span class=close></span>");
      $option.find(".close").on("click", function() {
        $option.remove();
        $this.remove();
      });
    }
    if ($this.prop("selected")) {
      $option.attr("selected", true);
    }
    if ($ul.find(".dropdownjs-add").length) {
      $ul.find(".dropdownjs-add").before($option);
    } else {
      $ul.append($option);
    }
  }};
  $.fn.dropdown = function(params) {
    if (methods[params]) {
      return methods[params].apply(this, Array.prototype.slice.call(arguments, 1));
    } else {
      if (typeof params === "object" | !params) {
        return methods.init.apply(this, arguments);
      } else {
        $.error("Method " + params + " does not exists on jQuery.dropdown");
      }
    }
  };
});
Polymer({is:"html-echo", behaviors:[FieldBehavior], properties:{html:{observer:"htmlChanged", type:String}}, htmlChanged:function() {
  Polymer.dom(this).innerHTML = this.html;
}});
Polymer({is:"input-field", behaviors:[Polymer.IronFormElementBehavior, Polymer.PaperInputBehavior, Polymer.IronControlState, FieldBehavior, ModernizrBehavior], properties:{compact:{value:false, type:Boolean}, noLabelFloat:{type:Boolean, computed:"_noLabelFloat(floatingLabel)"}, floatingLabel:{value:"true", type:String}, name:{type:String}, type:{value:"text", observer:"typeChanged", type:String}, step:{type:String}, max:{type:String}, min:{type:String}, name:{type:String}}, hasDate:false, observers:["editValueChanged(editValue)", 
"valueChanged(value)", "validateAttributes(type)"], _noLabelFloat:function() {
  return this.floatingLabel === "false" || this.floatingLabel === false;
}, typeChanged:function() {
  if (this.type && this.type.match(/^date/)) {
    this._origType = this.type;
    if (!this.hasDate) {
      this.type = "text";
      this.$.input.setAttribute("type", "text");
    }
  }
  if (this.type && this.type.match(/^password/)) {
    this.autocomplete = "new-password";
  }
}, isNumber:function() {
  if (this.type && this.type.match(/^number$/) && !this.isDecimal()) {
    return true;
  }
  return false;
}, isDecimal:function() {
  if (this._origType && this._origType.match(/^decimal/)) {
    return true;
  }
  return false;
}, isDate:function() {
  if (this.isDateYearMonth()) {
    return true;
  }
  if (this._origType && this._origType.match(/^date/)) {
    return true;
  }
  return false;
}, isDateYearMonth:function() {
  if (this._origType && this._origType.match(/^dateyearmonth/)) {
    return true;
  }
  return false;
}, isDateTime:function() {
  if (this._origType && this._origType.match(/^datetime/)) {
    return true;
  }
  return false;
}, created:function() {
  this._origType = null;
}, ready:function() {
  var self = this;
  Object.keys(this.properties).forEach(function(key) {
    var value = self.properties[key];
    if (value === undefined && self[key] === undefined) {
      if (self.$.input.hasAttribute(key)) {
        self.$.input.removeAttribute(key);
      }
    }
  });
}, attached:function() {
  this.pickerType = "bootstrap";
  if (this.label == null || this.label == "") {
    this.label = this.name;
  }
  this.validateAttributes();
  this.decorator = this.$.decorator;
  this.input = this.$.input;
  this.validateAttributes();
  if (this.type == "number") {
    this.preventInvalidInput = true;
  }
  var showTime = this.isDateTime();
  if (this.isDate() && !this.hasDate) {
    this.datetimePicker = this.getDatePicker(showTime, {});
    if (this.hasTouch()) {
      this.readonly = true;
    }
    if (this._date) {
      this.datetimePickerGotoDate(this._date);
    }
  }
  if (this.isDate() && this.hasDate) {
    this.async(function() {
      this.decorator._inputHasContent = true;
      this.alwaysFloatLabel = true;
    });
  }
  if (this.compact) {
    jQuery(this.decorator).addClass("compact");
    jQuery(this.$.input).addClass("compact");
    if (is_chromium && !this.isDate()) {
      jQuery(this.$.input).css("margin-top", "0px");
    }
  }
}, i18n_de:{previousMonth:"Vorheriger Monat", nextMonth:"Nächster Monat", months:["Januar", "Februar", "März", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember"], weekdays:["Sontag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"], weekdaysShort:["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"]}, i18n_en:{previousMonth:"Previous Month", nextMonth:"Next Month", months:["January", "February", "March", "April", "May", "June", "July", "August", "September", 
"October", "November", "December"], weekdays:["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], weekdaysShort:["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], midnight:"Midnight", noon:"Noon"}, tooltips:{today:"Go to today", clear:"Clear selection", close:"Close the picker", selectMonth:"Select Month", prevMonth:"Previous Month", nextMonth:"Next Month", selectYear:"Select Year", prevYear:"Previous Year", nextYear:"Next Year", selectDecade:"Select Decade", prevDecade:"Previous Decade", 
nextDecade:"Next Decade", prevCentury:"Previous Century", nextCentury:"Next Century", pickHour:"Pick Hour", incrementHour:"Increment Hour", decrementHour:"Decrement Hour", pickMinute:"Pick Minute", incrementMinute:"Increment Minute", decrementMinute:"Decrement Minute", pickSecond:"Pick Second", incrementSecond:"Increment Second", decrementSecond:"Decrement Second", togglePeriod:"Toggle Period", selectTime:"Select Time"}, tooltips_de:{today:"Heute auswählen", clear:"Löschen", close:"Schließen", selectMonth:"Monat auswählen", 
prevMonth:"vorheriger Monat", nextMonth:"nächster Monat", selectYear:"Jahr auswählen", prevYear:"vorheriges Jahr", nextYear:"nächstes Jahr", selectDecade:"Dekade auswählen", prevDecade:"vorherige Dekade", nextDecade:"nächste Dekade", prevCentury:"vorheriges Jahrhundert", nextCentury:"nächstes Jahrhundert", pickHour:"Stunde auswählen", incrementHour:"Stunde +1", decrementHour:"Stunde -1", pickMinute:"Minute auswählen", incrementMinute:"Minute +1", decrementMinute:"Minute -1", pickSecond:"Sekunde auswählen", 
incrementSecond:"Sekunde +1", decrementSecond:"Sekunde -1", togglePeriod:"Periode umschalten", selectTime:"Zeit auswählen"}, isAuthorizedType:function() {
  var okTypes = ["checkbox", "color", "date", "datetime", "datetime-local", "dateyearmonth", "email", "file", "month", "number", "password", "radio", "range", "tel", "text", "time", "url", "week"];
  return okTypes.indexOf(this.type) != -1;
}, lpad:function pad(value, length) {
  length = length || 2;
  return value.toString().length < length ? this.lpad("0" + value, length) : value;
}, validateAttributes:function() {
  if (!this.input) {
    return;
  }
  if (this.type != "text" && !this.isAuthorizedType()) {
    this._origType = this.type;
    if (this.type == "double" || this.type == "decimal") {
      this.step = "0.01";
      this.type = "number";
    } else {
      if (this.type == "integer") {
        this.step = "1";
        this.type = "number";
      } else {
        this.type = "text";
      }
    }
  }
  if (this.isDateTime() && this.hasDate) {
    this.input.setAttribute("type", "datetime-local");
  } else {
    if (this.isDateYearMonth() && this.hasDate) {
      this.input.setAttribute("type", "date");
    } else {
      this.input.setAttribute("type", this.type);
    }
  }
}, committedValueChanged:function() {
}, editValueChanged:function() {
  if (this.type == null) {
    return;
  }
  if (this.isDate() && !this.hasDate) {
    this.value = this._i18nToIso(this.editValue);
  } else {
    this.value = this.editValue;
  }
  if (this.editValue) {
  } else {
  }
  this.fire("value-changed", this);
}, valueChanged:function() {
  if (!this.$.decorator) {
    return;
  }
  if (this.withoutCheck) {
    this.withoutCheck = false;
    return;
  }
  this.checkConstraints();
}, setValue:function(v) {
  if (this.isDate()) {
    if (!this.hasDate) {
      v = this._convertDate(v);
    } else {
      v = this._toIso(v);
    }
  }
  console.log("setValue(" + this.name + "):", v);
  this.editValue = v;
}, getValue:function() {
  if (this.isDate()) {
    if (typeof this.value === "string" && !this._isIsoDate(this.value)) {
      return null;
    }
  }
  if (this.isNumber()) {
    if (this.value != null) {
      return parseInt(this.value);
    }
  }
  if (this.isDecimal()) {
    if (this.value != null) {
      if (typeof this.value === "string" && this.value.indexOf(",") >= 0) {
        this.value = this.value.replace(/,/, ".");
      }
      return parseFloat(this.value);
    }
  }
  if (this.value == null && this.convertNullToEmpty) {
    return "";
  }
  return this.value;
}, getDatePicker:function(showTime, options) {
  if (this.pickerType == "pikaday") {
    var picker = new Pikaday({field:this.$.input, trigger:this.$.input, onSelect:function(a) {
    }.bind(this), i18n:simpl4.util.BaseManager.getLanguage() == "de" ? this.i18n_de : this.i18n_en, format:simpl4.util.BaseManager.getDateFormat() + (showTime ? " HH:mm" : ""), showTime:showTime, showSeconds:false, use24hour:simpl4.util.BaseManager.getLanguage() == "de" ? true : false, firstDay:1, yearRange:[1900, 2030]});
    return picker;
  }
  if (this.pickerType == "bootstrap") {
    var _format = simpl4.util.BaseManager.getDateFormat() + (showTime ? " HH:mm" : "");
    var viewMode = this.isDateYearMonth() ? "years" : "days";
    var showComponents = "MYd";
    if (this.isDateYearMonth()) {
      showComponents = "MY";
    } else {
      if (this.isDateTime()) {
        showComponents = "MYdhm";
      } else {
        showComponents = "MYd";
      }
    }
    var tooltips = this["tooltips_" + simpl4.util.BaseManager.getLanguage()];
    var locale = simpl4.util.BaseManager.getLanguage();
    var picker = $(this.$.input).datetimepicker({locale:locale, viewMode:viewMode, showComponents:showComponents, ignoreReadonly:true, tooltips:tooltips, focusOnShow:false, format:_format, showTodayButton:true, showClear:false, showClose:true});
    var self = this;
    picker.on("dp.change", function(e) {
      self.editValue = $(self.$.input).val();
    });
    return picker;
  }
}, datetimePickerGotoDate:function(date) {
  if (this.pickerType == "pikaday") {
    this.datetimePicker.gotoDate(date);
  }
  if (this.pickerType == "bootstrap") {
  }
}, _convertDate:function(v) {
  if (!v) {
    if (this.datetimePicker) {
      this.datetimePickerGotoDate(new Date);
    } else {
      this._date = new Date;
    }
    return null;
  }
  var iso = this._toIso(v);
  this._date = this._isoToDate(iso);
  if (this.datetimePicker) {
    this.datetimePickerGotoDate(this._date);
    this._date = null;
  }
  return this._isoToI18n(iso);
}, _toIso:function(v) {
  var iso = v;
  var isString = typeof v === "string";
  var isNumber = typeof v === "number";
  if (isNumber || isString && !v.match(/[-]/)) {
    var showTime = this.isDateTime();
    iso = moment(parseInt(v)).format(showTime ? "YYYY-MM-DDTHH:mm" : "YYYY-MM-DD");
  }
  return iso;
}, _isoToI18n:function(iso) {
  var mdate = moment(iso);
  var showTime = this.isDateTime();
  var format = simpl4.util.BaseManager.getDateFormat() + (showTime ? " HH:mm" : "");
  var i18n = mdate.format(format);
  return i18n;
}, _isoToDate:function(iso) {
  var mdate = moment(iso);
  return mdate.toDate();
}, _i18nToIso:function(i18n) {
  var iso;
  if (this.isDateTime()) {
    var mdate = moment(i18n, simpl4.util.BaseManager.getDateFormat() + " HH:mm");
    iso = mdate.year() + "-" + this.lpad(mdate.month() + 1) + "-" + this.lpad(mdate.date()) + "T" + this.lpad(mdate.hour()) + ":" + this.lpad(mdate.minute());
  } else {
    var mdate = moment(i18n, simpl4.util.BaseManager.getDateFormat());
    iso = mdate.year() + "-" + this.lpad(mdate.month() + 1) + "-" + this.lpad(mdate.date());
  }
  return iso;
}, _isIsoDate:function(s) {
  var hasTime = this.isDateTime();
  if (hasTime) {
    return s.match(/(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2})/);
  } else {
    return s.match(/(\d{4})-(\d{2})-(\d{2})/);
  }
}, setErrorMessage:function(message) {
  this.errorMessage = message;
}, setInvalid:function(b) {
  if (this.decorator == null) {
    return;
  }
  this.invalid = b;
}, hasTouch:function() {
  return "ontouchstart" in window || window.DocumentTouch && document instanceof window.DocumentTouch;
}, setCustomValidity:function(message) {
}});
Polymer({is:"multiline-field", behaviors:[Polymer.IronFormElementBehavior, Polymer.PaperInputBehavior, Polymer.IronControlState, FieldBehavior], observers:["editValueChanged(editValue)"], properties:{}, editValueChanged:function() {
  this.value = this.editValue;
  this.fire("value-changed", this);
}, valueChanged:function() {
  if (!this.$.decorator) {
    return;
  }
  if (this.withoutCheck) {
    this.withoutCheck = false;
    return;
  }
  this.checkConstraints();
}, setValue:function(v) {
  this.editValue = v;
}});
Polymer({is:"upload-field", behaviors:[Polymer.IronFormElementBehavior, Polymer.PaperInputBehavior, Polymer.IronControlState, TranslationsBehavior, FieldBehavior], listeners:{"upload-complete":"valueChanged"}, properties:{required:{value:"", type:String}, value:{type:Object}, multi:{type:Boolean, value:true}}, ready:function() {
  this.isInvalid = false;
}, valueChanged:function(e) {
  var f = this.form._getField("filename");
  if (f != null) {
    f.setValue(e.detail.target.file.name);
  }
  if (this.multi) {
    this.value[e.detail.target.file.name] = e.detail.target.result;
  } else {
    this.value = {};
    this.value[e.detail.currentTarget.file.name] = e.detail.currentTarget.result;
  }
  this.fire("value-changed", this);
  this.checkConstraints();
}, getValue:function() {
  return this.value;
}, setValue:function(v) {
  this.value = {};
  this.disabled = false;
  var f = this.form._getField("filename");
  if (f != null && !this.isEmpty(f.getValue())) {
    this.disabled = true;
  }
  this.$.input.clear();
}, checkConstraints:function() {
  this.setInvalid(false);
  if (!this.isRequired()) {
    return;
  }
  if (Object.keys(this.value).length > 0) {
    return;
  }
  this.setInvalid(true);
  this.setErrorMessage(tr("This field is required"));
}, setErrorMessage:function(message) {
  this.error = message;
}, setInvalid:function(b) {
  this.isInvalid = b;
}, isRequired:function() {
  var data = this.form._getData();
  var req = this.form._maskedEval(this.required, data, false);
  return req;
}, isEmpty:function(s) {
  if (s == null || s == "") {
    return true;
  }
  return false;
}});
Polymer({is:"custom-field", behaviors:[FieldBehavior], properties:{url:{type:String}, elementname:{type:String}, url:{observer:"urlChanged", type:String}}, observers:[], urlChanged:function() {
  if (this.url == null) {
    return;
  }
  this.importHref(this.url + "?time=" + (new Date).getTime(), this.onResponse.bind(this));
}, onResponse:function(e) {
  var body = e.target.import.body;
  var insertPoint = this.$.insertPoint;
  while (insertPoint.firstChild) {
    Polymer.dom(insertPoint).removeChild(insertPoint.firstChild);
  }
  if (body && body.firstElementChild) {
    if ($(body).children().length == 1) {
      Polymer.dom(insertPoint).appendChild(body.firstElementChild);
    } else {
      Polymer.dom(insertPoint).appendChild(body);
    }
  }
  this.field = this.querySelector(this.elementname);
  this.field.setValue(this.value);
  console.log("Custom(" + this.name + ").setValue:", this.value);
  this.field.label = this.label;
}, setValue:function(v) {
  this.value = v;
  if (this.field == null) {
    return;
  }
  console.log("Custom(" + this.name + ").setValue:", this.value);
  this.field.setValue(v);
}, getValue:function() {
  if (this.field == null) {
    console.log("custom-field.getValue:field is null");
    return null;
  }
  this.value = this.field.getValue();
  console.log("Custom(" + this.name + ").getValue:", this.value);
  return this.value;
}, valueChanged:function(e) {
  if (this.isDomReady != true) {
    return;
  }
  if (this.withoutCheck) {
    this.withoutCheck = false;
    return;
  }
}});
Polymer({is:"checkbox-field", behaviors:[FieldBehavior], properties:{compact:{value:false, type:Boolean}}, observers:["valueChanged(value)"], attached:function() {
  if (this.compact) {
    jQuery(this).addClass("compact");
  }
}, setValue:function(v) {
  this.value = v;
}, getValue:function() {
  return this.value;
}, valueChanged:function(e) {
  if (this.isDomReady != true) {
    return;
  }
  if (this.withoutCheck) {
    this.withoutCheck = false;
    return;
  }
  this.checkConstraints();
  this.fire("value-changed", this);
}});
Polymer({is:"toggle-field"});
Polymer({is:"select-field", behaviors:[Polymer.IronFormElementBehavior, Polymer.PaperInputBehavior, Polymer.IronControlState, StyleScopeBehavior, FieldBehavior], listeners:{"value-changed":"ignore"}, properties:{multiple:{value:false}, compact:{value:false}, jsonItems:{type:String}, items:{observer:"itemsChanged", type:Object}, required:{value:"false", type:String}, delimiter:{type:String, value:","}, diacritics:{type:Boolean, value:true}, create:{type:Boolean, value:false}, createOnBlur:{type:Boolean, 
value:false}, createFilter:{type:String, value:null}, highlight:{type:Boolean, value:true}, persist:{type:Boolean, value:true}, openOnFocus:{type:Boolean, value:true}, maxOptions:{type:Number, value:1000}, maxItems:{type:Number, value:1}, hideSelected:{type:Boolean, value:true}, closeAfterSelect:{type:Boolean, value:false}, allowEmptyOption:{type:Boolean, value:false}, scrollDuration:{type:Number, value:60}, loadThrottle:{type:Number, value:300}, loadingClass:{type:String, value:"loading"}, preload:{type:String, 
value:false}, dropdownParent:{type:String, value:"body"}, addPrecedence:{type:Boolean, value:false}, selectOnTab:{type:Boolean, value:false}, options:{type:Array, value:[]}, optgroups:{type:Array, value:[]}, dataAttr:{type:String, value:"data-data"}, valueField:{type:String, value:"value"}, optgroupValueField:{type:String, value:"value"}, labelField:{type:String, value:"text"}, optgroupLabelField:{type:String, value:"label"}, optgroupField:{type:String, value:"optgroup"}, sortField:{type:String, 
value:"$order"}, searchField:{type:Array, value:["text"]}, searchConjunction:{type:String, value:"and"}, lockOptgroupOrder:{type:Boolean, value:false}, copyClassesToDropdown:{type:Boolean, value:true}, ajaxOptions:{type:String, value:null}, ajaxOptionsRoot:{type:String, value:null}, ajaxOptionsDataType:{type:String, value:null}, mutationObserver:{value:function() {
  var observer = new MutationObserver(this.mutated.bind(this));
  observer.observe(this, {attributes:true, attributeOldValue:true, attributeFilter:["disabled"]});
  return observer;
}}}, observers:["valueChanged(value)", "compactChanged(compact)", "jsonItemsChanged(jsonItems)"], mutated:function(mutations) {
  var self = this;
  mutations.forEach(function(mutation) {
    var entry = {name:mutation.target.getAttribute("name"), value:mutation.target.getAttribute("disabled"), oldValue:mutation.oldValue};
    if (entry.oldValue == entry.value) {
      return;
    }
    var fl = self.querySelector(".focused-line");
    var inp = self.querySelector('input[type="text"]');
    if (fl == null) {
      return;
    }
    if (entry.value == "r") {
      fl.style.display = "none";
      if (inp) {
        inp.setAttribute("tabindex", "-1");
      }
    } else {
      fl.style.display = "block";
      if (inp) {
        inp.removeAttribute("tabindex");
      }
    }
  });
}, ready:function() {
  this.isInvalid = false;
}, compactChanged:function() {
  if (this.compact === false) {
    return;
  }
  this.async(function() {
    jQuery(this.decorator).addClass("compact");
    jQuery(this.$.label).addClass("compact");
    jQuery(this).addClass("compact");
    var e = this.$.decorator.querySelector(".floated-label-placeholder");
    jQuery(e).addClass("compact");
  }, 20);
}, jsonItemsChanged:function(v) {
  var o = JSON.parse(this.jsonItems);
  this.items = o;
}, itemsChanged:function() {
  var select = this.$.select;
  while (select.firstChild) {
    select.removeChild(select.firstChild);
  }
  if (this.items == null) {
    return;
  }
  if (this.selectize) {
    this.selectize.clearOptions();
  }
  if (this.items.length) {
    for (var i = 0; i < this.items.length; i++) {
      var item = this.items[i];
      if (this.selectize) {
        this.selectize.addOption({value:item.value, text:item.label});
      } else {
        var option = document.createElement("option");
        var label = document.createTextNode(item.label);
        option.value = item.value;
        Polymer.dom(option).appendChild(label);
        Polymer.dom(select).appendChild(option);
      }
    }
  } else {
    var items = this.items;
    Object.keys(items).forEach(function(k) {
      var item = items[k];
      if (this.selectize) {
        this.selectize.addOption({value:item.value, text:item.label});
      } else {
        var option = document.createElement("option");
        var label = document.createTextNode(item.label);
        option.value = item.value;
        Polymer.dom(option).appendChild(label);
        Polymer.dom(select).appendChild(option);
      }
    });
  }
  if (this.selectize) {
    this.selectize.refreshOptions(false);
  }
}, valueChanged:function(v) {
  if (this._invalueSetting === true) {
    return;
  }
  this.async(function() {
    if (this.selectize && this.selectize.getValue() != this.value) {
      this._invalueSetting = true;
      this.selectize.setValue(this.value);
      this._invalueSetting = false;
    }
  }, 300);
  if (this.isDomReady != true) {
    return;
  }
  if (this.withoutCheck) {
    this.withoutCheck = false;
    return;
  }
  this.checkConstraints();
}, setValue:function(v) {
  this.value = v;
  if (this.selectize) {
    this.selectize.setValue(v);
  } else {
    this.__value = v;
  }
}, getValue:function() {
  if (this.multiple !== true && this.value && Array.isArray(this.value) && this.value.length > 0) {
    return this.value[0];
  }
  return this.value;
}, onFocus:function(val) {
}, onChange:function(val) {
  if (val == "null") {
    val = null;
  }
  if (this.isEmpty(this.value) && this.isEmpty(val)) {
    return;
  }
  this.value = val;
  this.fire("value-changed", this);
}, createSelectize:function() {
  if (this.multiple === true) {
    this.maxItems = 1000;
  }
  var options = {delimiter:this.delimiter, diacritics:this.diacritics, create:this.create, createOnBlur:this.createOnBlur, createFilter:this.createFilter, highlight:this.highlight, persist:this.persist, openOnFocus:this.openOnFocus, maxOptions:this.maxOptions, maxItems:this.maxItems, hideSelected:this.hideSelected, closeAfterSelect:this.closeAfterSelect, alglowEmptyOption:this.allowEmptyOption, scrollDuration:this.scrollDuration, loadThrottle:this.loadThrottle, loadingClass:this.loadingClass, preload:this.preload, 
  dropdownParent:this.dropdownParent, addPrecedence:this.addPrecedence, selectOnTab:this.selectOnTab, options:this.options, optgroups:this.optgroups, dataAttr:this.dataAttr, valueField:this.valueField, optgroupValueField:this.optgroupValueField, labelField:this.labelField, optgroupLabelField:this.optgroupLabelField, optgroupField:this.optgroupField, sortField:this.sortField, searchField:this.searchField, searchConjunction:this.searchConjunction, lockOptgroupOrder:this.lockOptgroupOrder, copyClassesToDropdown:this.copyClassesToDropdown, 
  onChange:this.onChange.bind(this), onFocus:this.onFocus.bind(this)};
  var field = this.$.select;
  var $select = $(field).selectize(options);
  this.selectize = $select[0].selectize;
  if (this.__value) {
    this.selectize.setValue(this.__value);
    this.__value = null;
  }
}, ignore:function(e) {
  if (this.parentNode.tagName != "FORM-ELEMENT-RENDERER") {
    e.preventDefault();
    e.stopPropagation();
  }
}, attached:function() {
  this.async(function() {
    this._attached();
  });
}, _attached:function() {
  this.alwaysFloatLabel = true;
  this.placeholder = " ";
  this.isDomReady = true;
  if (this.compact) {
    this.compactChanged();
  }
  this.createSelectize();
  this.selectizeControl = this.$.decorator.querySelector(".selectize-control");
}, isEmpty:function(s) {
  if (Array.isArray(s)) {
    return s.length == 0;
  }
  if (s == null || s == "") {
    return true;
  }
  return false;
}, checkConstraints:function() {
  this.setInvalid(false);
  if (!this.isRequired()) {
    return;
  }
  if (!this.isEmpty(this.value)) {
    return;
  }
  this.setInvalid(true);
  this.setErrorMessage(tr("This field is required"));
}, setErrorMessage:function(message) {
  this.errorMessage = message;
}, setInvalid:function(b) {
  this.isInvalid = b;
}, isRequired:function() {
  if (!this.form) {
    return false;
  }
  var data = this.form._getData();
  var req = this.form._maskedEval(this.required, data, false);
  return req;
}});
Polymer({is:"tree-field", behaviors:[Polymer.IronFormElementBehavior, Polymer.PaperInputBehavior, Polymer.IronControlState, StyleScopeBehavior, FieldBehavior], properties:{selectedItem:{observer:"selectedItemChanged", notify:true, type:Object}, multiple:{value:false}, compact:{value:false}, jsonItems:{type:String}, items:{observer:"itemsChanged", type:Object}, required:{value:"false", type:String}, closeAfterSelect:{type:Boolean, value:false}}, observers:["valueChanged(value)", "compactChanged(compact)", 
"jsonItemsChanged(jsonItems)"], ready:function() {
  this.isInvalid = false;
  this.options = {autoOpen:true};
}, compactChanged:function() {
  if (this.compact === false) {
    return;
  }
  this.async(function() {
    jQuery(this.decorator).addClass("compact");
    jQuery(this.$.label).addClass("compact");
    jQuery(this).addClass("compact");
    var e = this.$.decorator.querySelector(".floated-label-placeholder");
    jQuery(e).addClass("compact");
  }, 20);
}, jsonItemsChanged:function(v) {
  var o = JSON.parse(this.jsonItems);
  this.items = o;
}, itemsChanged:function() {
  console.log("tree-field(" + this.name + ").itemsChanged:", this.items);
}, valueChanged:function(v) {
  console.log("tree-field(" + this.name + ",wo:" + this.withoutCheck + ").valueChanged:", this.value);
  if (this.isDomReady != true) {
    return;
  }
  if (this.withoutCheck) {
    this.withoutCheck = false;
    return;
  }
  this.checkConstraints();
}, setValue:function(v) {
  console.log("tree-field(" + this.name + ").setValue:", v);
  var id = v;
  if (_.isString(v)) {
    try {
      id = JSON5.parse(v).id;
    } catch (e) {
    }
  }
  if (!_.isEmpty(id)) {
    var node = this.jqtree.tree("getNodeById", id);
    this.jqtree.tree("selectNode", node);
    this.jqtree.tree("scrollToNode", node);
    this.$.dropdownId.querySelector("#input").value = node.name;
  } else {
    this.jqtree.tree("selectNode", null);
    this.selectedItem = null;
    this.$.dropdownId.querySelector("#input").value = "";
    this.setInvalid(false);
  }
}, getValue:function() {
  return JSON.stringify(this.value);
}, selectedItemChanged:function(val) {
  console.log("tree-field(" + this.name + ").selectedItemChanged:", this.value + "/val:" + val);
  this.value = val;
  this.checkConstraints();
  this.fire("value-changed", this);
}, attached:function() {
  this.async(function() {
    this._attached();
  });
}, _attached:function() {
  this.alwaysFloatLabel = true;
  this.placeholder = " ";
  console.log("tree-field(" + this.name + ").attached");
  this.isDomReady = true;
  if (this.compact) {
    this.compactChanged();
  }
}, isEmpty:function(s) {
  if (Array.isArray(s)) {
    return s.length == 0;
  }
  if (s == null || s == "") {
    return true;
  }
  return false;
}, checkConstraints:function() {
  console.log("tree-field(" + this.name + ").checkConstraints");
  this.setInvalid(false);
  if (!this.isRequired()) {
    return;
  }
  if (!this.isEmpty(this.value)) {
    return;
  }
  console.log("tree-field(" + this.name + ").checkConstraints2");
  this.setInvalid(true);
  this.setErrorMessage(tr("This field is required"));
}, setErrorMessage:function(message) {
  this.errorMessage = message;
}, setInvalid:function(b) {
  this.isInvalid = b;
}, isRequired:function() {
  var data = this.form._getData();
  var req = this.form._maskedEval(this.required, data, false);
  return req;
}});
Polymer({is:"dropdown-field", behaviors:[Polymer.IronFormElementBehavior, Polymer.PaperInputBehavior, Polymer.IronControlState, StyleScopeBehavior, FieldBehavior], properties:{multiple:{value:false}, compact:{value:false}, _dropdown:{type:Object}, jsonItems:{type:String}, items:{observer:"itemsChanged", type:Object}}, observers:["valueChanged(value)", "compactChanged(compact)", "jsonItemsChanged(jsonItems)"], compactChanged:function() {
  if (this.compact === false) {
    return;
  }
  this.async(function() {
    jQuery(this.decorator).addClass("compact");
    jQuery(this.$.label).addClass("compact");
    jQuery(this).addClass("compact");
    var e = this.$.decorator.querySelector(".floated-label-placeholder");
    jQuery(e).addClass("compact");
  }, 20);
}, jsonItemsChanged:function(v) {
  var o = JSON.parse(this.jsonItems);
  this.items = o;
}, itemsChanged:function() {
  var select = this.$.select;
  while (select.firstChild) {
    select.removeChild(select.firstChild);
  }
  if (this.items == null) {
    return;
  }
  for (var i = 0; i < this.items.length; i++) {
    var item = this.items[i];
    var option = document.createElement("option");
    var label = document.createTextNode(item.label);
    option.value = item.value;
    Polymer.dom(option).appendChild(label);
    Polymer.dom(select).appendChild(option);
  }
}, valueChanged:function(v) {
  if (this.isDomReady != true) {
    return;
  }
  if (this.withoutCheck) {
    this.withoutCheck = false;
    return;
  }
  this.checkConstraints();
}, setValue:function(v) {
  this._dropdown.data("options", this._options);
  this.value = v;
  this.async(function() {
    $(this._dropdown).dropdown("select", this.value);
  }, 10);
}, getValue:function() {
  return this.value;
}, onSelected:function(val) {
  if (val == undefined) {
    return;
  }
  this.value = val;
  this.fire("value-changed", this);
}, onCallback:function(dropdown) {
  this._dropdown = dropdown;
  this.setStyleScope(this._dropdown.get(0), "style-scope", this.tagName.toLowerCase());
}, attached:function() {
  this.isDomReady = true;
  if (this.compact) {
    this.compactChanged();
  }
  this._options = {onSelected:this.onSelected.bind(this), callback:this.onCallback.bind(this), optionClass:this.name};
  this.async(function() {
    $(this.$.select).dropdown(this._options);
  });
}});
Polymer({is:"gridinput-field", behaviors:[Polymer.IronFormElementBehavior, Polymer.PaperInputBehavior, Polymer.IronControlState, TranslationsBehavior, DialogBehavior, FormBehavior, FieldBehavior], properties:{required:{value:"", type:String}, columns:{value:null, observer:"columnsChanged", type:Array}, lines:{value:function() {
  return [];
}, type:Array}, entity:{type:String}, search:{value:false, type:Boolean}, arrows:{value:true, type:Boolean}, height:{value:null, type:String}}, listeners:{"value-changed":"_valueChanged", "internal-xaction":"_internalXAction"}, observers:["entityChanged(entity,namespace)"], ready:function() {
  this.isInvalid = false;
  this.push("lines", {});
}, clearLines:function() {
  this.splice("lines", 0, this.lines.length);
  this.push("lines", {});
}, _valueChanged:function(e) {
  var lid = e.target.parentNode.dataset.lid;
  var data = {};
  var fields = {};
  for (var j = 0; j < this.columns.length; j++) {
    var e = this.querySelector("#id" + lid + "_" + j);
    var col = this.columns[j];
    data[col.colname] = e.getValue();
    fields[col.colname] = e;
  }
  var keys = Object.keys(this.exprMap);
  keys.forEach(function(key) {
    var expr = this.exprMap[key];
    var result = this.form._maskedEval(expr, data, "");
    fields[key].setValue(result);
  }.bind(this));
}, getValue:function() {
  var value = [];
  for (var i = 0; i < this.lines.length; i++) {
    var line = this.lines[i];
    value.push(this.getLineValues(i));
  }
  return value;
}, setValue:function(v) {
  if (!v) {
    this.clearLines();
    this.async(function() {
      this.setLineValues({}, 0);
    }, 100);
    return;
  }
  this.clearLines();
  this.async(function() {
    for (var i = 1; i < v.length; i++) {
      this.push("lines", {});
    }
    this.async(function() {
      for (var i = 0; i < v.length; i++) {
        var line = v[i];
        this.setLineValues(line, i);
      }
    }, 100);
  }, 100);
}, getContainerStyle:function() {
  return "border:0px solid #f5f5f5;padding:2px;min-height:" + this.height + "px";
}, getElementId:function(lid, cid) {
  return "id" + lid + "_" + cid;
}, entityChanged:function() {
  this.async(function() {
    if (this.entity == null) {
      return;
    }
    var pack = this.getPack();
    this.entityName = pack ? pack + ":" + this.getSimpleEntityName(this.entity) : this.entity;
  }, 10);
}, getHeader:function(entityName) {
  this.pack = this.getPack() || "data";
  return tr(this.pack + "." + this.getSimpleEntityName(entityName));
}, _search:function(e) {
  this._lid = parseInt(e.target.dataset.lid);
  this._entityName = this.entityName;
  this.$.filterId.doSearch();
  this.async(function() {
    this.openDialog(this.$.searchDialog);
  }, 250);
}, rowsSelected:function(e) {
  if (!e.detail.doubleTap) {
    return;
  }
  var data = e.detail.rows[0];
  this.closeDialog(this.$.searchDialog);
  console.log("data:", data);
  this.setLineValues(data, this._lid);
}, cancelAction:function() {
  this.async(function() {
    this.closeDialog(this.$.searchDialog);
  }, 50);
}, getHelp:function() {
  return tr("crud2.select_with");
}, columnsChanged:function() {
  var exprMap = {};
  this.columns.each(function(c) {
    c.regulaConstraints = this._constructRegulaConstraints(c.constraints);
    c.label = c.display;
    if (c.id != "Enumselect") {
      c.id = "Input";
    }
    c.xf_type = c.type;
    c.xf_id = c.colname;
    if (c.parameter && c.parameter.startsWith("expr:")) {
      exprMap[c.colname] = c.parameter.substring(5);
    }
  }.bind(this));
  this.exprMap = exprMap;
}, addLine:function(e) {
  var lid = parseInt(e.target.dataset.lid);
  this.push("lines", {});
  this.async(function() {
    for (var i = this.lines.length - 1; i - 1 > lid; i--) {
      this._upLine(i);
    }
  }, 20);
}, removeLine:function(e) {
  if (this.lines.length > 1) {
    var lid = e.target.dataset.lid;
    var ret = this.splice("lines", lid, 1);
  }
}, upLine:function(e) {
  var lid = parseInt(e.target.dataset.lid);
  if (lid == 0 || this.lines.length == 1) {
    return;
  }
  this._upLine(lid);
}, _upLine:function(lid) {
  var temp = this.getLineValues(lid - 1);
  this.setLineValues(this.getLineValues(lid), lid - 1);
  this.setLineValues(temp, lid);
}, downLine:function(e) {
  var lid = parseInt(e.target.dataset.lid);
  if (lid == this.lines.length - 1 || this.lines.length == 1) {
    return;
  }
  var temp = this.getLineValues(lid + 1);
  this.setLineValues(this.getLineValues(lid), lid + 1);
  this.setLineValues(temp, lid);
}, setLineValues:function(line, i) {
  for (var j = 0; j < this.columns.length; j++) {
    var e = this.querySelector("#id" + i + "_" + j);
    var col = this.columns[j];
    var name = col.colname;
    var val = line[name];
    e.getGridField().withoutCheck = true;
    e.setValue(val);
  }
}, getLineValues:function(i) {
  var line = {};
  for (var j = 0; j < this.columns.length; j++) {
    var e = this.querySelector("#id" + i + "_" + j);
    var val = e.getValue();
    var col = this.columns[j];
    line[col.colname] = val;
  }
  return line;
}, checkConstraints:function() {
  this.setInvalid(false);
  for (var i = 0; i < this.lines.length; i++) {
    this.validateLine(i);
  }
}, getColFlex:function(w) {
  if (w != null && parseInt(w) > 0) {
    return "";
  }
  return "flex";
}, getColStyle:function(w) {
  if (w != null && parseInt(w) > 0) {
    return "width:" + w + "px;min-width:" + w + "px;";
  }
  return "";
}, validateLine:function(i) {
  var line = {};
  for (var j = 0; j < this.columns.length; j++) {
    var e = this.querySelector("#id" + i + "_" + j);
    var elements = e.getGridField();
    if (!elements.getAttribute("data-constraints")) {
      continue;
    }
    regula.bind({elements:[elements]});
    var errorList = regula.validate({elements:[elements]});
  }
}, setErrorMessage:function(message) {
  this.error = message;
}, setInvalid:function(b) {
  this.isInvalid = b;
}, isRequired:function() {
  var data = this.form._getData();
  var req = this.form._maskedEval(this.required, data, false);
  return req;
}});
Polymer({is:"tableselect-field", behaviors:[Polymer.IronFormElementBehavior, Polymer.PaperInputBehavior, Polymer.IronControlState, TranslationsBehavior, FieldBehavior], properties:{multiSelect:{value:false, type:Boolean}, required:{value:"", type:String}, items:{observer:"itemsChanged", type:Object}, selection:{type:Object, notify:true}, meta:{type:Object}, height:{value:null, observer:"heightChanged", type:String}}, observers:["selectionChanged(selection)"], getHeight:function() {
  return "height:" + this.height + "px";
}, checkConstraints:function() {
  this.setInvalid(false);
  if (!this.isRequired()) {
    return;
  }
  if (this.selection && this.selection.length > 0) {
    return;
  }
  this.setInvalid(true);
  this.setErrorMessage(tr("This field is required"));
}, setValue:function(v) {
  this.$.dataTable.unselectAll();
  this.value = null;
}, getValue:function() {
  if (this.multiSelect) {
    return this.value;
  } else {
    if (Array.isArray(this.value) && this.value.length > 0) {
      return this.value[0];
    }
  }
  return null;
}, setErrorMessage:function(message) {
  this.error = message;
}, setInvalid:function(b) {
  this.isInvalid = b;
}, selectionChanged:function() {
  this.value = this.selection;
  this.checkConstraints();
  this.fire("value-changed", this);
}, heightChanged:function() {
  this.dataTablesOptions = {paging:true, dom:"rt", scrollCollapse:false, scrollY:this.height - 40 + "px"};
  this.setInvalid(false);
}, itemsChanged:function(items) {
}, setItems:function(items) {
  this.items = items;
}, isRequired:function() {
  var data = this.form._getData();
  var req = this.form._maskedEval(this.required, data, false);
  return req;
}});
Polymer({is:"linkedlist-field", behaviors:[Polymer.IronFormElementBehavior, Polymer.PaperInputBehavior, Polymer.IronControlState, TranslationsBehavior, FieldBehavior], properties:{required:{value:"", type:String}, entity:{value:null, type:String}, namespace:{value:null, type:String}, meta:{type:Object}, height:{value:null, observer:"heightChanged", type:String}}, observers:["entityChanged(entity,namespace)"], onChanged:function(e) {
  console.log("onChanged:", e);
  this.value = e.detail.data;
}, entityChanged:function() {
  console.log("Field.linkedlist-field.entityChanged:", this.entity + "/" + this.namespace);
  this.setInvalid(false);
}, checkConstraints:function() {
  this.setInvalid(false);
  if (!this.isRequired()) {
    return;
  }
  if (this.value && this.value.length > 0) {
    return;
  }
  this.setInvalid(true);
  this.setErrorMessage(tr("This field is required"));
}, setValue:function(v) {
  this.value = v;
  this.querySelector("#miniId").setData(v);
}, getValue:function() {
  return this.value;
}, setErrorMessage:function(message) {
  this.error = message;
}, setInvalid:function(b) {
  this.isInvalid = b;
}, heightChanged:function() {
  this.setInvalid(false);
}, isRequired:function() {
  var data = this.form._getData();
  var req = this.form._maskedEval(this.required, data, false);
  return req;
}});
Polymer({is:"embeddedlist-field", behaviors:[Polymer.IronFormElementBehavior, Polymer.PaperInputBehavior, Polymer.IronControlState, TranslationsBehavior, FieldBehavior], properties:{required:{value:"", type:String}, entity:{value:null, type:String}, namespace:{value:null, type:String}, meta:{type:Object}, height:{value:null, observer:"heightChanged", type:String}}, observers:["entityChanged(entity,namespace)"], onChanged:function(e) {
  console.log("onChanged:", e);
  this.value = e.detail.data;
}, entityChanged:function() {
  console.log("Field.embeddedlist-field.entityChanged:", this.entity + "/" + this.namespace);
  this.setInvalid(false);
}, checkConstraints:function() {
  this.setInvalid(false);
  if (!this.isRequired()) {
    return;
  }
  if (this.value && this.value.length > 0) {
    return;
  }
  this.setInvalid(true);
  this.setErrorMessage(tr("This field is required"));
}, setValue:function(v) {
  this.value = v;
  console.log("setValue(" + this.entity + "," + this.name + "):", this.value);
  this.querySelector("#miniId").setData(v);
}, getValue:function() {
  console.log("getValue(" + this.entity + "," + this.name + "):", this.value);
  return this.value;
}, setErrorMessage:function(message) {
  this.error = message;
}, setInvalid:function(b) {
  this.isInvalid = b;
}, heightChanged:function() {
  this.setInvalid(false);
}, isRequired:function() {
  var data = this.form._getData();
  var req = this.form._maskedEval(this.required, data, false);
  return req;
}});
Polymer({is:"linkedobj-field", behaviors:[Polymer.IronFormElementBehavior, Polymer.PaperInputBehavior, Polymer.IronControlState, DialogBehavior, TranslationsBehavior, FieldBehavior], properties:{namespace:{type:String}, entity:{type:String}}, observers:["editValueChanged(editValue)", "entityChanged(entity,namespace)"], id:null, isMetaNull:function() {
  return this.meta == null;
}, isFilter:function(filter) {
  return this.filter != null;
}, ready:function() {
  console.log("Field.linkedobj.ready:", this.entity + "/" + this.namespace);
  this.props = simpl4.util.EntityManager.getPropertiesForEntity(this.entity, {namespace:this.namespace});
}, actionCallback:function() {
  this._entityName = this.entityName;
  this.$.filterId.doSearch();
  this.async(function() {
    this.openDialog(this.$.linkedObjDialog);
  }, 250);
}, clearCallback:function() {
  this.editValue = null;
  this.id = null;
}, rowsSelected:function(e) {
  if (!e.detail.doubleTap) {
    return;
  }
  this.data = e.detail.rows[0];
  this.closeDialog(this.$.linkedObjDialog);
  var t = this._maskedEval(this.props.title_expression, this.data);
  this.id = this.data.id || this.data._id;
  this.editValue = t || this.id || ".";
}, cancelAction:function() {
  this.async(function() {
    this.closeDialog(this.$.linkedObjDialog);
  }, 50);
}, editValueChanged:function() {
  if (this.editValue) {
    if ("odata" == this.getPack()) {
      this.value = this.data;
    } else {
      this.value = this.editValue + "/" + this.id;
    }
  } else {
    this.value = null;
  }
  console.log("editValueChanged(" + this.getPack() + "," + this.entityName + "," + this.name + "):", this.value);
  this.fire("value-changed", this);
}, getValue:function(v) {
  console.log("getValue(" + this.entityName + "," + this.name + "):", this.value);
  return this.value;
}, setValue:function(v) {
  console.log("setValue(" + this.entityName + "," + this.name + "):", v);
  if (v != null) {
    if (_.isString(v)) {
      var s = v.split("/");
      this.editValue = s[0];
      this.id = s[1];
    } else {
      this.data = v;
      var t = this._maskedEval(this.props.title_expression, this.data);
      this.editValue = t || this.data._id || this.data.id | ".";
    }
  } else {
    this.editValue = null;
  }
}, namespaceChanged:function() {
  simpl4.util.MessageManager.installMessages(this.namespace);
}, entityChanged:function() {
  this.async(function() {
    if (this.entity == null) {
      return;
    }
    var pack = this.getPack();
    this.entityName = pack ? pack + ":" + this.getSimpleEntityName(this.entity) : this.entity;
  }, 10);
}, getHelp:function() {
  return tr("crud2.select_with");
}, getHeader:function(entityName) {
  this.pack = this.getPack() || "data";
  return tr(this.pack + "." + this.getSimpleEntityName(entityName));
}, _maskedEval:function(scr, env, def) {
  try {
    return (new Function("with(this) { return " + scr + "}")).call(env);
  } catch (e) {
    console.log("LinkedObjFieldField._maskedEval:" + scr);
    console.error("error:" + e);
  }
  return def;
}});
Polymer({is:"embeddedobj-field", behaviors:[Polymer.IronFormElementBehavior, Polymer.PaperInputBehavior, Polymer.IronControlState, DialogBehavior, TranslationsBehavior, FieldBehavior], properties:{namespace:{type:String}, entity:{type:String}}, observers:["editValueChanged(editValue)", "entityChanged(entity,namespace)"], id:null, ready:function() {
  this.props = simpl4.util.EntityManager.getPropertiesForEntity(this.entity, {namespace:this.namespace});
  this.buttonsave = {icon:"undo", position:"form", text:tr("button.take_over"), disabled:false};
  this.buttoncancel = {icon:"cancel", position:"form", text:tr("button.cancel"), disabled:false};
}, setFormSpec:function(namespace, entity) {
  var formSpec = simpl4FormManager.getCrudForm(entity, namespace);
  console.log("setFormSpec(" + this.name + "):", formSpec);
  if (typeof formSpec === "string") {
    this.formName = formSpec;
  } else {
    this.formSpec = [formSpec];
  }
}, actionCallback:function() {
  this._pack = this.getPack();
  this.$.formid.setData(this.data);
  this.async(function() {
    this.openDialog(this.$.embeddedObjDialog);
  }, 50);
}, clearCallback:function() {
  this.editValue = null;
  this.id = null;
}, takeOverAction:function(e) {
  this.data = this.$.formid.getData();
  this.closeDialog(this.$.embeddedObjDialog);
  var t = this._maskedEval(this.props.title_expression, this.data);
  this.editValue = t || this.data._id || ".";
}, cancelAction:function() {
  this.async(function() {
    this.closeDialog(this.$.embeddedObjDialog);
  }, 50);
}, editValueChanged:function() {
  if (this.editValue) {
    this.value = this.data;
  } else {
    this.value = null;
  }
  console.log("editValueChanged(" + this.name + "):", this.value);
  this.fire("value-changed", this);
}, setValue:function(v) {
  console.log("setValue(" + this.name + "):", v);
  if (v != null) {
    this.data = v;
    var t = this._maskedEval(this.props.title_expression, this.data);
    this.editValue = t || this.data._id || ".";
  } else {
    this.editValue = null;
  }
}, namespaceChanged:function() {
  simpl4.util.MessageManager.installMessages(this.namespace);
}, entityChanged:function() {
  console.log("entityChanged(" + this.name + "):", this.entity);
  this.async(function() {
    if (this.entity == null) {
      return;
    }
    this.setFormSpec(this.namespace, this.entity);
  }, 10);
}, _maskedEval:function(scr, env, def) {
  try {
    return (new Function("with(this) { return " + scr + "}")).call(env);
  } catch (e) {
    console.log("EmbeddedObjFieldField._maskedEval:" + scr);
    console.error("error:" + e);
  }
  return def;
}});
Polymer({is:"embeddedobj-inline-field", behaviors:[Polymer.IronFormElementBehavior, Polymer.PaperInputBehavior, Polymer.IronControlState, TranslationsBehavior, FieldBehavior], properties:{namespace:{type:String}, entity:{type:String}}, observers:["entityChanged(entity,namespace)"], setFormSpec:function(namespace, entity) {
  var formSpec = simpl4FormManager.getCrudForm(entity, namespace);
  console.log("setFormSpec(" + this.name + "):", formSpec);
  if (typeof formSpec === "string") {
    this.formName = formSpec;
  } else {
    this.formSpec = [formSpec];
  }
}, checkConstraints:function() {
  var valid = this.$.formid.validate();
  this.setInvalid(!valid);
}, setInvalid:function(b) {
  this.isInvalid = b;
}, getValue:function(v) {
  var val = null;
  try {
    val = this.$.formid.getData();
  } catch (e) {
    return null;
  }
  console.log("getValue(" + this.name + "):", val);
  return val;
}, setValue:function(v) {
  console.log("setValue(" + this.name + "):", v);
  if (v != null) {
    this.$.formid.setData(v);
  } else {
    this.$.formid.setData({});
  }
}, namespaceChanged:function() {
  simpl4.util.MessageManager.installMessages(this.namespace);
}, entityChanged:function() {
  console.log("entityChanged(" + this.name + "):", this.entity);
  this.async(function() {
    if (this.entity == null) {
      return;
    }
    this.setFormSpec(this.namespace, this.entity);
    this._pack = this.getPack();
  }, 10);
}, _maskedEval:function(scr, env, def) {
  try {
    return (new Function("with(this) { return " + scr + "}")).call(env);
  } catch (e) {
    console.log("EmbeddedObjFieldField._maskedEval:" + scr);
    console.error("error:" + e);
  }
  return def;
}});
Polymer({is:"db-selector-field", behaviors:[Polymer.IronFormElementBehavior, Polymer.PaperInputBehavior, Polymer.IronControlState, TranslationsBehavior, FieldBehavior], properties:{namespace:{type:String}, entity:{type:String}}, observers:["editValueChanged(editValue)", "entityChanged(entity,namespace)"], id:null, isMetaNull:function() {
  return this.meta == null;
}, isFilter:function(filter) {
  return this.filter != null;
}, ready:function() {
  this.props = simpl4.util.EntityManager.getPropertiesForEntity(this.entity, {namespace:this.namespace});
}, actionCallback:function() {
  this.async(function() {
    this.$.selectorDialog.open();
  }, 50);
}, clearCallback:function() {
  this.editValue = null;
  this.id = null;
}, selectAction:function(e) {
  var data = e.detail.data;
  this.$.selectorDialog.close();
  this.assignValues(data);
}, assignValues:function(record) {
  var items = JSON.parse(this.fieldlist).items;
  for (var i = 0; i < items.length; i++) {
    var item = items[i];
    var path = item.path + "." + item.id;
    var value = record[path];
    if (value == null) {
      path = item.id;
      value = record[path];
    }
    if (value == undefined) {
      value = null;
    }
    var form_fieldname = item.form_fieldname ? item.form_fieldname : item.db_fieldname;
    try {
      var f = this.form._getField(form_fieldname);
      if (f == null) {
        console.error("db-selector-field.assignValue:field:" + form_fieldname + " not found");
        continue;
      }
      f.setValue(value);
    } catch (e) {
      console.error("db-selector-field.Cannot set value:" + e + "/" + e.stack);
    }
  }
}, getFieldDesc:function(entity, id) {
  var colModel = this.fieldmap[entity];
  if (colModel == null) {
    this.getSelectableFields(entity);
    colModel = this.fieldmap[entity];
  }
  for (var f = 0; f < colModel.length; f++) {
    var field = colModel[f];
    if (field.hidden) {
      continue;
    }
    if (field.id == id) {
      return field;
    }
  }
  return null;
}, getSelectableFields:function(entity) {
  var colModel = this.fieldmap[entity];
  if (colModel === undefined) {
    try {
      var em = simpl4.util.EntityManager;
      var data = em.getEntityViewFields(entity, this.namespace, "report", false);
      colModel = em.buildColModel(data, this.namespace, entity, "search");
      this.fieldmap[entity] = colModel;
    } catch (e) {
      console.error("db-selector-field.getSelectableFields:" + e.stack);
      return;
    }
  }
  return colModel;
}, fieldlistChanged:function() {
  simpl4.util.MessageManager.installMessages(this.namespace);
  this.fieldmap = {};
  var columns = new Array;
  var displayColumns = new Array;
  var aliasColumns = new Array;
  var selFields = JSON.parse(this.fieldlist).items;
  for (var f = 0; f < selFields.length; f++) {
    var selField = selFields[f];
    if (selField.display === true) {
      var fieldDesc = this.getFieldDesc(selField.module, selField.id);
      if (fieldDesc == null) {
        console.error('db-selector-field.fieldlistChanged:field("' + selField.id + '") not found in "' + selField.module + '"');
        return null;
      }
      var dt = fieldDesc["datatype"];
      if (dt && dt.match("^array")) {
        continue;
      }
      var fd = simpl4.util.Merge.deepmerge({}, fieldDesc);
      fd.fqn = selField.path + "." + selField.id;
      fd.label = tr("data." + simpl4.util.Inflector.getEntityName(selField.module)) + "/" + tr("data." + selField.module + "." + selField.id);
      fd.title = fd.label;
      displayColumns.push(fd.fqn);
      aliasColumns.push(selField.mapping);
      fd["id"] = fd.fqn;
      fd["name"] = fd.fqn;
      columns.push(fd);
    }
  }
  this.meta = columns;
}, cancelAction:function() {
  this.async(function() {
    this.$.selectorDialog.close();
  }, 50);
}, editValueChanged:function() {
  if (this.editValue) {
    this.value = this.editValue + "/" + this.id;
  } else {
    this.value = null;
  }
  this.fire("value-changed", this);
}, setValue:function(v) {
  if (v != null) {
    var s = v.split("/");
    this.editValue = s[0];
    this.id = s[1];
  } else {
    this.editValue = null;
  }
}, namespaceChanged:function() {
  simpl4.util.MessageManager.installMessages(this.namespace);
}, entityChanged:function() {
  this.async(function() {
    console.log("Field(" + this.name + "):entityChanged:" + this.getPack() + "/" + this.getSimpleEntityName(this.entity) + "/" + this.namespace);
    if (this.entity == null) {
      return;
    }
    var pack = this.getPack();
    this.entityName = pack ? pack + ":" + this.getSimpleEntityName(this.entity) : this.entity;
  }, 10);
}, getHeader:function(entityName) {
  var pack = this.getPack() || "data";
  return tr(pack + "." + this.getSimpleEntityName(entityName));
}, _maskedEval:function(scr, env, def) {
  try {
    return (new Function("with(this) { return " + scr + "}")).call(env);
  } catch (e) {
    console.log("DbSelectorField._maskedEval:" + scr);
    console.error("error:" + e);
  }
  return def;
}});
Polymer({is:"xaction-button", behaviors:[Polymer.PaperButtonBehavior], properties:{xaction:{type:String}, xid:{type:String}}});
Polymer({is:"simpl-group"});
Polymer({is:"simpl-row"});
FormElementSelectorBehavior = {isTabView:function(id) {
  return id == "Tabview";
}, isEnumSelect:function(id) {
  return id == "Enumselect";
}, isTreeSelect:function(id) {
  return id == "Treeselect";
}, isUpload:function(id) {
  return id == "Upload";
}, isModuleSelector:function(id) {
  return id == "Moduleselector";
}, isAlert:function(id) {
  return id == "Alert";
}, isCustom:function(id) {
  return id == "Custom";
}, isActionButton:function(id) {
  return id == "ActionButton";
}, isTableSelect:function(id) {
  return id == "Tableselect";
}, isEmbeddedList:function(id) {
  return id == "EmbeddedList";
}, isLinkedList:function(id) {
  return id == "LinkedList";
}, isEmbeddedObj:function(item) {
  return item.id == "EmbeddedObj" && (!item.xf_inline || item.xf_inline === false);
}, isEmbeddedObjInline:function(item) {
  return item.id == "EmbeddedObj" && item.xf_inline;
}, isGridInput:function(id) {
  return id == "Gridinput";
}, isTextArea:function(id) {
  return id == "Textarea";
}, isLinkedObj:function(id) {
  return id == "LinkedObj";
}, isGroup:function(id) {
  return id == "Group";
}, isRow:function(id) {
  var r = id == "Row";
  return r;
}, isPage:function(id) {
  return id == "Page";
}, isForm:function(id) {
  var r = id == "Form";
  return r;
}, isField:function(id) {
  var r = id == "Input" || id == "Tableselect" || id == "Gridinput" || id == "EmbeddedList" || id == "LinkedList" || id == "Enumselect" || id == "Treeselect" || id == "Upload" || id == "Custom" || id == "Textarea" || id == "LinkedObj" || id == "EmbeddedObj" || id == "Moduleselector" || id == "Alert" || id == "break";
  return r;
}, isInputAndBoolean:function(id, xf_type) {
  var r = id == "Input" && xf_type == "boolean";
  return r;
}, isInputAndNotBoolean:function(id, xf_type) {
  var r = id == "Input" && xf_type != "boolean";
  return r;
}, tabTitle:function(t) {
  return t;
}};
Polymer({is:"grid-element-renderer", properties:{item:{observer:"itemChanged", type:Object}}, behaviors:[FormElementSelectorBehavior], setValue:function(v) {
  this._getGridField().setValue(v);
}, getGridField:function() {
  return this._getGridField();
}, getValue:function() {
  var v = this._getGridField().getValue();
  return v;
}, itemChanged:function() {
}, _getGridField:function() {
  if (this.field) {
    return this.field;
  }
  this.field = this.querySelector("[gridfield]");
  return this.field;
}, attached:function() {
}});
Polymer({is:"form-element-renderer", properties:{item:{observer:"itemChanged", type:Object}}, behaviors:[FormElementSelectorBehavior], itemChanged:function() {
}, getActionButtonColor:function(action) {
  return "min-width:140px !important;";
}, getActionButtonClasses:function(action) {
  return action == "execute" ? "button button_primary" : "button";
}, _internalXAction:function(e) {
  var target = e.target || e.srcElement;
  this.fire("internal-xaction", null, {node:target});
}, attached:function() {
}});
Polymer({is:"form-tab-renderer", behaviors:[FormElementSelectorBehavior], properties:{item:{type:Object}, pagesStyle:{computed:"computePagesStyle(item)"}}, observers:["routeChanged(route)"], getElementStyle:function() {
  return "display:block;padding-top:0px;padding-bottom:0px;";
}, getPageStyle:function() {
  return "margin-top:0px;padding:0px;";
}, computePagesStyle:function(item) {
  var maxHeight = 0;
  for (var i = 0; i < item.childShapes.length; i++) {
    var s = item.childShapes[i];
    var h = 0;
    if (s && s.bounds) {
      h = s.bounds.lowerRight.y - s.bounds.upperLeft.y;
    }
    maxHeight = Math.max(maxHeight, h);
  }
  if (maxHeight == 0) {
    maxHeight = 500;
  }
  return "overflow:hidden;min-height:" + (maxHeight - 30) + "px;";
}, ready:function() {
  var tab = this.item.selected;
  if (!tab && this.item.childShapes.length > 0) {
    tab = this.item.childShapes[0].xf_id;
  }
  this.tabsId = tab;
}});
Polymer({is:"form-element-selector", properties:{items:{type:Object}}, behaviors:[FormElementSelectorBehavior], attached:function() {
}});
Polymer({is:"simpl-form", behaviors:[Polymer.IronA11yKeysBehavior, FormBehavior, TranslationsBehavior], properties:{namespace:{type:String}, formName:{type:String}, mode:{type:String}, data:{type:Object}, variables:{type:Object}, enterAction:{type:String, value:null}, enterDisabled:{type:Boolean, value:false}, saveDisabled:{type:Boolean, value:false, notify:true}}, observers:["_dataChanged(data.*)", "_specChanged(spec.*)", "_formNameChanged(formName)"], listeners:{"value-changed":"_valueChanged", 
"internal-xaction":"_internalXAction"}, keyBindings:{"enter":"_enterPressed"}, _enterPressed:function() {
  var enterAction = this.enterAction;
  if (enterAction == null && this._form.xf_default_buttons === true && this._form.xf_used_default_buttons != null) {
    var _defButtons = this._form.xf_used_default_buttons.items;
    for (var i = 0; i < _defButtons.length; i++) {
      var db = _defButtons[i];
      if (db.enter === true) {
        enterAction = db.action;
      }
    }
  }
  console.log("_enterPressedForm:", this.saveDisabled + "/" + enterAction);
  if (this.enterDisabled || enterAction == null || this.saveDisabled === true) {
    return;
  }
  var action = {xaction:enterAction};
  this._internalXAction(action);
}, _getButtonLabel:function(l) {
  if (l && l.startsWith("@")) {
    return tr(l.substring(1));
  }
  return l;
}, __isSaveDisabled:function(sd, item) {
  return this.saveDisabled && item.action == "execute";
}, _internalXAction:function(e) {
  var target = e.target || e.srcElement;
  target = target || e;
  var data = this.getData();
  var valid;
  if (target.xaction === "reset") {
    console.log("resetData:", this.resetData);
    this._setData(this.resetData);
  }
  if (target.xaction !== "cancel" && target.xaction !== "reset") {
    var ppData = this._postProcessService();
    if (ppData != null) {
      this._setFieldData(ppData);
      data = simpl4.util.Merge.deepmerge(data, ppData);
    }
    var ppData = this._postProcessLocal();
    if (ppData != null) {
      this._setFieldData(ppData);
      data = simpl4.util.Merge.deepmerge(data, ppData);
    }
    valid = this.validate();
  }
  this.fire("xaction", {xaction:target.xaction, xid:target.xid, formVar:this.formVar, data:data, valid:valid});
}, attached:function() {
  this.saveDisabled = false;
}});
(function() {
  Polymer({is:"simpl-carousel", properties:{items:{type:Object}}, getSelector:function(index) {
    return "*[data-index='" + index + "']";
  }, get pageWidth() {
    return this.getBoundingClientRect().width;
  }, attached:function() {
    this.threshold = 0.2;
    this.carousel = this.$.carousel;
    this.carousel.selected = 0;
    this.addEventListener("track", function(event) {
      if (event.detail.state === "start") {
        return;
      }
      var userIsSwipingLeftwards = event.detail.dx < 0;
      var userIsSwipingRightwards = event.detail.dx > 0;
      var thresholdWasCrossed = Math.abs(event.detail.dx) / this.pageWidth > this.threshold;
      if (thresholdWasCrossed) {
        if (userIsSwipingRightwards) {
          this.prev();
        }
        if (userIsSwipingLeftwards) {
          this.next();
        }
      }
    });
  }, detached:function() {
    this.carousel = null;
  }, next:function() {
    this.entryAnimation = "slide-from-right-animation";
    $(this.$.carousel.querySelectorAll("section")).css("display", "");
    $(this.$.carousel.querySelector("section.iron-selected")).css("display", "none");
    this.carousel.selected = this.carousel.items.length === this.carousel.selected + 1 ? 0 : this.carousel.selected + 1;
  }, prev:function() {
    this.entryAnimation = "slide-from-left-animation";
    $(this.$.carousel.querySelectorAll("section")).css("display", "");
    $(this.$.carousel.querySelector("section.iron-selected")).css("display", "none");
    this.carousel.selected = this.carousel.selected === 0 ? this.carousel.items.length - 1 : this.carousel.selected - 1;
  }, get selected() {
    if (this.carousel == null) {
      return;
    }
    return this.carousel.selected;
  }});
})();
ScrollbarBehavior = {attached:function() {
  if (this._autoScrollbar === false) {
    return;
  }
  this.async(function() {
    this._initScrollbars();
    $(".panel").on("onFullScreen.lobiPanel", function(ev, lobiPanel) {
      var sbElements = lobiPanel.$body[0].querySelectorAll(".smooth-scrollbar");
      for (var i = 0; i < sbElements.length; i++) {
        var sb = Scrollbar.get(sbElements[i]);
        if (sb) {
          sb.setPosition(0, 0);
          sb.update();
        }
      }
    }.bind(this));
  }, 1000);
}, _initScrollbar:function(elem) {
  elem = elem || this;
  var isTouch = "ontouchstart" in window || navigator.msMaxTouchPoints > 0;
  if (isTouch) {
    return;
  }
  window.Scrollbar.init(elem, {speed:isTouch ? 1 : 4, damping:isTouch ? 0.1 : 0.05, renderByPixels:true, overscrollEffect:"bounce", alwaysShowTracks:true, overscrollEffectColor:"#87ceeb", thumbMinSize:10});
}, _initScrollbars:function(elem) {
  elem = elem || this;
  var isTouch = "ontouchstart" in window || navigator.msMaxTouchPoints > 0;
  var tables = [];
  if (!isTouch) {
    tables = this._toElementArray(elem.querySelectorAll(".dataTables_scrollBody"));
  }
  var sbElements = this._toElementArray(elem.querySelectorAll(".smooth-scrollbar"));
  var elementArray = tables.concat(sbElements);
  console.log("smoothElementArray:", elementArray);
  for (var i = 0; i < elementArray.length; i++) {
    window.Scrollbar.init(elementArray[i], {speed:isTouch ? 1 : 4, damping:isTouch ? 0.1 : 0.05, renderByPixels:true, overscrollEffect:"bounce", alwaysShowTracks:true, overscrollEffectColor:"#87ceeb", thumbMinSize:10});
    elementArray[i].setAttribute("scrollbar", "");
  }
}, _toElementArray:function(elements) {
  var res = [];
  for (var i = 0; i < elements.length; i++) {
    res.push(elements[i]);
  }
  return res;
}};
(function() {
  Polymer({is:"simpl-socialbuttons", properties:{data:{observer:"dataChanged", value:null, type:String}, text:{value:null, type:String}, url:{value:null, type:String}}, attached:function() {
    console.log("attached:", this.data);
  }, dataChanged:function() {
    this.async(function() {
      var a = this.data.split(",");
      console.log("dataChanged:", this.data);
      console.log("url:", this.url);
      $("#socialbuttons").jsSocials({url:this.url, text:this.text, shares:a});
    }, 100);
  }});
})();
Polymer({is:"simpl-upload", properties:{target:{type:String, value:""}, progressHidden:{type:Boolean, value:false}, droppable:{type:Boolean, value:false}, dropText:{type:String, value:"Drop Files Here"}, multi:{type:Boolean, value:false}, files:{type:Array, value:function() {
  return [];
}}, method:{type:String, value:"PUT"}, raised:{type:Boolean, value:false}, noink:{type:Boolean, value:false}, headers:{type:Object, value:{}}, retryText:{type:String, value:"Retry Upload"}, removeText:{type:String, value:"Remove"}, successText:{type:String, value:"Success"}, errorText:{type:String, value:"Error uploading file..."}, _shownDropText:{type:Boolean, value:false}}, behaviors:[TranslationsBehavior], clear:function() {
  $(this.$.fileInput).val(null);
  this.set("files", []);
  this._showDropText();
}, ready:function() {
  if (this.raised) {
    this.toggleAttribute("raised", true, this.$.button);
  }
  if (this.noink) {
    this.toggleAttribute("noink", true, this.$.button);
  }
  if (this.droppable) {
    this._showDropText();
    this.setupDrop();
  }
}, setupDrop:function() {
  var uploadBorder = this.$.UploadBorder;
  this.toggleClass("enabled", true, uploadBorder);
  this.ondragover = function(e) {
    e.stopPropagation();
    this.toggleClass("hover", true, uploadBorder);
    return false;
  };
  this.ondragleave = function() {
    this.toggleClass("hover", false, uploadBorder);
    return false;
  };
  this.ondrop = function(event) {
    this.toggleClass("hover", false, uploadBorder);
    event.preventDefault();
    var length = event.dataTransfer.files.length;
    for (var i = 0; i < length; i++) {
      var file = event.dataTransfer.files[i];
      file.progress = 0;
      file.error = false;
      file.complete = false;
      if (this.multi == false) {
        this.clear();
      }
      this.push("files", file);
      this.uploadFile(file);
    }
  };
}, _fileClick:function() {
  var elem = this.$.fileInput;
  if (elem && document.createEvent) {
    var evt = document.createEvent("MouseEvents");
    evt.initEvent("click", true, false);
    elem.dispatchEvent(evt);
  }
}, _fileChange:function(e) {
  var length = e.target.files.length;
  for (var i = 0; i < length; i++) {
    var file = e.target.files[i];
    file.progress = 0;
    file.error = false;
    file.complete = false;
    if (this.multi == false) {
      this.clear();
    }
    this.push("files", file);
    this.uploadFile(file);
  }
}, cancel:function(file) {
  if (file && file.xhr) {
    file.xhr.abort();
    this.splice("files", this.files.indexOf(file), 1);
    this._showDropText();
  }
}, _cancelUpload:function(e) {
  this.cancel(e.model.__data__.item);
}, _retryUpload:function(e) {
  e.model.set("item.error", false);
  e.model.set("item.progress", 0);
  var self = this;
  this.async(function() {
    self.uploadFile(e.model.__data__.item);
  }, 50);
}, _showDropText:function() {
  this.set("_shownDropText", !this.files.length && this.droppable);
}, uploadFile:function(file) {
  if (!file) {
    return;
  }
  this._showDropText();
  var prefix = "files." + this.files.indexOf(file);
  var filereader = new FileReader;
  filereader.file = file;
  filereader.onloadend = function(evt) {
    console.log("onloadend:", evt);
    this.set(prefix + ".complete", true);
    this.fire("upload-complete", evt);
  }.bind(this);
  filereader.readAsDataURL(file);
}});
Polymer({is:"simpl-tree", properties:{nameProp:{value:"name", type:String}, data:{observer:"dataChanged", type:Object}, opened:{value:false, type:Boolean}, idProp:{value:"path", type:String}, childrenProp:{value:"children", type:String}, selected:{observer:"selectedChanged", type:String}}, ready:function(e) {
  this.iconOpen = "hardware:keyboard-arrow-right";
  this.iconClose = "hardware:keyboard-arrow-down";
  this.iconBOM = "arrow-drop-down";
}, toggleEvent:function(e) {
  e.preventDefault();
  e.stopPropagation();
  var target = e.target || e.srcElement;
  var div = target.parentNode;
  var icon = target;
  this.toggleChildren(div, icon);
}, toggleChildren:function(div, icon) {
  if (div.className.indexOf("parent") > -1 && div.nextElementSibling) {
    var current_display = div.nextElementSibling.style.display;
    if (current_display === "none") {
      div.className = "parent expanded";
      div.nextElementSibling.style.display = "block";
      icon.setAttribute("icon", this.iconClose);
    } else {
      div.className = "parent collapsed";
      div.nextElementSibling.style.display = "none";
      icon.setAttribute("icon", this.iconOpen);
    }
  }
}, openChildren:function(div, icon) {
  if (div.className.indexOf("parent") > -1 && div.nextElementSibling) {
    var current_display = div.nextElementSibling.style.display;
    if (current_display === "none") {
      div.className = "parent expanded";
      div.nextElementSibling.style.display = "block";
      icon.setAttribute("icon", this.iconClose);
    }
  }
}, _selectItem:function(e) {
  var target = e.target || e.srcElement;
  var span = target;
  target = target.parentNode;
  var id = target.getAttribute("idvalue");
  console.log("selectItem:", id);
  if (id == null) {
    return;
  }
  if (this.prevSelected) {
    this.prevSelected.removeAttribute("selected");
  }
  var selectedItem = this.getItemById(id, this.data);
  this.fire("item-selected", {item:selectedItem});
  span.setAttribute("selected", "");
  this.prevSelected = span;
}, selectedChanged:function() {
  var selector = '[idvalue="' + this.selected + '"] span';
  var span = this._tree.querySelector(selector);
  this.openTree(span);
  if (this.prevSelected) {
    this.prevSelected.removeAttribute("selected");
  }
  this.prevSelected = span;
  span.setAttribute("selected", "");
  var selectedItem = this.getItemById(this.selected, this.data);
  this.fire("item-selected", {item:selectedItem});
}, openTree:function(span) {
  var div = span.parentElement;
  while (div && div.nodeName == "DIV") {
    var li = div.parentElement;
    if (li.nodeName != "LI") {
      break;
    }
    li = li.parentElement.parentElement;
    var div = li.querySelector("div[idvalue]");
    var icon = div.querySelector("iron-icon");
    this.openChildren(div, icon);
  }
}, getItemById:function(id, node) {
  if (node[this.idProp] == id) {
    return node;
  }
  var children = node[this.childrenProp];
  for (var i = 0; children && i < children.length; i++) {
    var node = this.getItemById(id, children[i]);
    if (node) {
      return node;
    }
  }
  return null;
}, dataChanged:function() {
  this._createRoot();
}, _createRoot:function() {
  var div = document.createElement("div");
  Polymer.dom(div).setAttribute("id", "main");
  this._tree = div;
  if (this.$.treeRootId.firstChild) {
    Polymer.dom(this.$.treeRootId).removeChild(this.$.treeRootId.firstChild);
  }
  Polymer.dom(this.$.treeRootId).appendChild(div);
  console.log("simpl-tree._createRoot:", this.data);
  this._createNode(div, this.data, this.opened ? true : false);
}, _createNode:function(parent, data, firstLevel) {
  var div = document.createElement("div");
  Polymer.dom(div).classList.add("layout");
  Polymer.dom(div).classList.add("horizontal");
  div.addEventListener("click", this._selectItem.bind(this));
  Polymer.dom(parent).appendChild(div);
  var hashChilds = false;
  if (data.children && data.children.length > 0) {
    Polymer.dom(div).classList.add("parent");
    hashChilds = true;
  }
  Polymer.dom(div).classList.add(firstLevel ? "expanded" : "collapsed");
  Polymer.dom(div).setAttribute("idvalue", data[this.idProp]);
  var icon = document.createElement("iron-icon");
  Polymer.dom(div).appendChild(icon);
  if (hashChilds) {
    Polymer.dom(icon).setAttribute("icon", firstLevel ? "hardware:keyboard-arrow-down" : "hardware:keyboard-arrow-right");
  }
  icon.addEventListener("click", this.toggleEvent.bind(this));
  var span = document.createElement("span");
  Polymer.dom(div).appendChild(span);
  Polymer.dom(span).classList.add("truncate");
  Polymer.dom(span).setAttribute("style", hashChilds ? "color:black;" : "color:gray;");
  Polymer.dom(span).setAttribute("title", data[this.nameProp]);
  var t = document.createTextNode(data[this.nameProp]);
  Polymer.dom(span).appendChild(t);
  var ul = document.createElement("ul");
  Polymer.dom(ul).setAttribute("style", firstLevel ? "display:block;" : "display:none;");
  Polymer.dom(parent).appendChild(ul);
  if (hashChilds) {
    for (var i = 0; i < data.children.length; i++) {
      var dataChild = data.children[i];
      var li = document.createElement("li");
      Polymer.dom(ul).appendChild(li);
      this._createNode(li, dataChild, false);
    }
  }
}, detached:function() {
}, attributeChanged:function(attr, oldVal, newVal) {
}});
(function() {
  Polymer({is:"simpl-toast", properties:{text:{type:String}, duration:{type:Number, value:3000}, type:{type:String}, heat:{type:String}, shelf:{type:String}, _breads:{type:Array, value:function() {
    return [];
  }}}, show:function(msg, type, duration, shelf, heat) {
    var data = {text:msg, type:type || "info", duration:duration, heat:heat || "high", shelf:shelf || "bottom-left"};
    this._bake(data);
  }, _bake:function(bread) {
    var text = bread.text || this.text;
    if (text && text.trim().length) {
      this.push("_breads", bread);
      this._emptyTheToaster();
    }
  }, _emptyTheToaster:function() {
    if (!this._breads.length) {
      this.async(function() {
        this._turnOffTheToaster();
      }, 1000);
      return;
    }
    var bread = this._breads[0], duration = bread.duration || this.duration, type = bread.type || this.type, heat = bread.heat || this.heat, shelf = bread.shelf || this.shelf, toast = this.$.toast;
    if (true) {
      this.shift("_breads");
      toast.text = bread.text || this.text;
      toast.duration = duration;
      this._turnOnTheToaster(type, heat, shelf);
      this.async(function() {
        toast.show();
      }, 100);
    }
    this.async(function() {
      this._emptyTheToaster();
    }, duration + 500);
  }, _turnOnTheToaster:function(type, heat, shelf) {
    var grill = this.$.grill;
    type = type && type.toLowerCase() || "";
    this.toggleClass("info", type === "info", grill);
    this.toggleClass("success", type === "success", grill);
    this.toggleClass("warning", type === "warning", grill);
    this.toggleClass("error", type === "error", grill);
    heat = heat && heat.toLowerCase() || "";
    this.toggleClass("low", heat === "low", grill);
    this.toggleClass("middle", heat === "middle", grill);
    this.toggleClass("high", heat === "high", grill);
    shelf = shelf && shelf.toLowerCase() || "";
    this.toggleClass("top-left", shelf === "top-left");
    this.toggleClass("top-right", shelf === "top-right");
    this.toggleClass("bottom-left", shelf === "bottom-left");
    this.toggleClass("bottom-right", shelf === "bottom-right");
    if (type == "error") {
      this.icon = "error";
    }
    if (type == "info") {
      this.icon = "info";
    }
    if (type == "warning") {
      this.icon = "warning";
    }
    if (type == "success") {
      this.icon = "check";
    }
    if (shelf.indexOf("right") >= 0) {
      this.style.right = grill.clientWidth + 24 + "px";
    }
  }, close:function() {
    var toast = this.$.toast;
    toast.hide();
  }, _turnOffTheToaster:function() {
    var grill = this.$.grill;
    this.toggleClass("low", false, grill);
    this.toggleClass("middle", false, grill);
    this.toggleClass("high", false, grill);
  }});
})();
Polymer({is:"simpl-svg-hscroll", properties:{contentStyle:{computed:"getContentStyle(height)"}, src:{value:null, type:String}, height:{value:null, type:String}}, getContentStyle:function() {
  return "height:" + this.height + "px;";
}, attached:function() {
  var objId = this.$.objId;
  objId.addEventListener("load", function() {
    var svgDoc = objId.getSVGDocument();
    var svg = svgDoc.querySelector("svg");
    var draw = SVG(svg);
    var layer1 = SVG.get("layer1", svgDoc);
    $(svg).swipe({swipe:function(event, direction, distance, duration, fingerCount, fingerData) {
      console.log("You swiped " + direction + "/" + Math.pow(distance, 2) / 100 + "/" + fingerCount);
      distance = Math.pow(distance, 2) / 100;
      if (fingerCount == 0) {
        return;
      }
      if (direction == "right") {
        layer1.transform({x:distance}, true);
      } else {
        if (direction == "left") {
          layer1.transform({x:-distance}, true);
        }
      }
    }, allowPageScroll:"vertical", threshold:0});
  });
}});
Polymer({is:"simpl-animatable-page", behaviors:[Polymer.NeonAnimatableBehavior], properties:{animationConfig:{type:Object, value:function() {
  return {"entry":{name:"slide-from-right-animation", node:this}, "exit":{name:"slide-left-animation", node:this}};
}}}});
Polymer({is:"simpl-zoom", properties:{styleClosed:{computed:"computeStyleClosed(maxWidthClosed)"}, backdrop:{value:false, type:Boolean}, maxWidthClosed:{value:"600px", type:String}, image:{type:String}}, computeStyleClosed:function() {
  var ret = "width:" + this.maxWidthClosed;
  return ret;
}, _dialogOpened:function() {
  this.async(function() {
    this.dialogOpened();
  }, 50);
}, dialogOpened:function() {
  this.dh = $(this.$.imageDialog).height();
  if (this.ih == null) {
    this.ih = $(this.$.bigImage).height();
  }
  $(this.$.bigImage).panzoom({disablePan:true});
  $(this.$.bigImage).pep({useCSSTranslation:false, velocityMultiplier:1.0, allowDragEventPropagation:false, xonstrainTo:"window"});
  $(this.$.bigImage).panzoom("zoom", this.dh / this.ih * 0.85);
  $(this.$.imageDialog).offset({top:0, left:this.isDrawerOpen() ? 230 : 0});
  $("#scroller", this).height(this.dh);
  $(this.$.bigImage).offset({top:58, left:this.isDrawerOpen() ? 230 : 0});
  var self = this;
  var mc = new Hammer.Manager(this.$.bigImage, {});
  mc.add(new Hammer.Tap({event:"doubletap", taps:2, threshold:50, interval:400, time:250}));
  mc.on("doubletap", function(event) {
    console.log("about to close");
    self.dialogClose();
  });
}, attached:function() {
  var self = this;
  var mc = new Hammer.Manager(this.$.imageClosed, {});
  mc.add(new Hammer.Tap({event:"doubletap", taps:2, threshold:10, interval:250, time:250}));
  mc.on("doubletap pinch", function(event) {
    console.log("about to open");
    self.dialogOpen();
  });
  if (Detectizr.browser.userAgent.indexOf("edge/") >= 0) {
    this.$.closedImageId.src = this.image;
    this.$.bigImage.src = this.image;
  }
}, dialogOpen:function() {
  try {
    this._setParentsScrolling(true);
  } catch (e) {
    alert(e);
  }
  this.async(function() {
    this.$.imageDialog.open();
    this.showMainToolbar(false);
  }, 50);
}, dialogClose:function() {
  this.async(function() {
    this.$.imageDialog.close();
    this.showMainToolbar(true);
  }, 50);
}, dialogClosed:function() {
  this._setParentsScrolling(false);
  this.showMainToolbar(true);
}, showMainToolbar:function(b) {
  if (b) {
    $("#mainToolbar").show();
  } else {
    $("#mainToolbar").hide();
  }
}, isDrawerOpen:function() {
  return false;
}, detached:function() {
}, _setParentsScrolling:function(opened) {
  console.log("_setParentsScrolling,", this.tagName);
  if ("-webkit-overflow-scrolling" in this.style) {
    var parent = Polymer.dom(this).parentNode;
    while (parent) {
      if (opened) {
        if (parent.style) {
          parent._oldWebkitOverflowScrolling = parent.style["-webkit-overflow-scrolling"];
          parent.style["-webkit-overflow-scrolling"] = "auto";
        }
      } else {
        if ("_oldWebkitOverflowScrolling" in parent) {
          parent.style["-webkit-overflow-scrolling"] = parent._oldWebkitOverflowScrolling;
          delete parent._oldWebkitOverflowScrolling;
        }
      }
      parent = parent.parentNode;
    }
  }
}});
Polymer({is:"simpl-viewer", properties:{}, observers:[], ready:function() {
  this.panelBackgroundColor = "#666666";
  this.panelHeader = "Maschine";
  this.panelHeaderBom = "Stückliste";
  this.panelHeaderDrawing = "Zeichnung";
  this.showAssemblies = true;
  this.dataTablesOptions = {paging:true, dom:"frtiS", scrollY:"150px"};
  simpl4.util.MessageManager.installMessages("bhs");
  var t = null;
  try {
    t = simpl4.util.Rpc.rpcSync("bhs:getBOMTree", {namespace:"bhs", machine:"2100097"});
  } catch (e) {
    alert("Viewer._init:" + e);
    return;
  }
  if (this.showAssemblies != null && (this.showAssemblies == "false" || this.showAssemblies === false)) {
    $(this.$.assemblyId).css("display", "none");
    $(this.$.viewerAndListId).attr("vl100", "");
    $(this.$.viewerAndListId).removeAttr("vl66");
  }
  this.assemblies = t;
  window.buttonClicked = this.buttonClicked.bind(this);
}, tableHeightChanged:function() {
  if (this.tableHeight) {
    this.dataTablesOptions.scrollY = this.tableHeight + "px";
  }
}, viewerHeightChanged:function() {
  if (this.viewerHeight) {
    $(this.$.viewer).css("min-height", this.viewerHeight + "px");
    $(this.$.viewer).css("height", this.viewerHeight + "px");
  }
}, attached:function(context) {
  var prefixUrl = simpl4.util.BaseManager.getBaseUrl() + "/sw/resource/openseadragon/";
  this._openSeadragon = OpenSeadragon({hash:"hash_" + this, element:this.$.viewer, prefixUrl:prefixUrl, zoomPerClick:2.0, showFullPageControl:false, autoHideControls:false, navigatorMaintainSizeRatio:true, navigatorSizeRatio:0.22, navigatorPosition:"BOTTOM_LEFT", showNavigator:true});
  this.assemblyTableMeta = this.getAssembyTableMeta();
  this._openSeadragon.addHandler("open", this._addOverlays.bind(this));
  var viewerInputHook = this._openSeadragon.addViewerInputHook({hooks:[{tracker:"viewer", handler:"clickHandler", hookHandler:this.onViewerClick.bind(this)}]});
  this.selected = "2100097.141027600.135450200";
  if (navigator.userAgent.match(/android/i)) {
    $(this.$.viewer.querySelector(".openseadragon-container")).css("overflow", "auto");
  }
  if (window.etk) {
    window.etk.onExternalReady();
  }
}, panelOpen:function() {
  var dt = this.$.bomTable;
  var dtApi = dt._api;
  $(window).trigger("resize.DT-dataTablesId");
  $(window).trigger("resize.dtr");
}, selectedAssemblyChanged:function(e) {
  console.log("Details:", e.detail);
  var selectedAssembly = e.detail.item;
  var part = selectedAssembly.part;
  var mapUrl = simpl4.util.BaseManager.getBaseUrl() + "/sw/resource/png_" + part + "/map.xml";
  var hotspots = this.getHotspots(mapUrl);
  this._hotspots = hotspots;
  this.showLoading("Loading " + selectedAssembly.name + "...");
  setTimeout(function() {
    console.log("selectedAssemblyChanged:", selectedAssembly);
    this.panelHeaderBom = "Stückliste(" + selectedAssembly.name + ")";
    this.assemblyTableData = this.getAssembyTableData(selectedAssembly.path);
    this.open(part, hotspots, "page-width");
  }.bind(this), 10);
}, showLoading:function(message) {
  this.toastMessage = message;
  this.$.toast.show();
}, partSelected:function(e) {
  var dataRow = e.detail.rows[0];
  console.log("partSelected:", dataRow["part"]);
  this.selectHotspot(dataRow["part"]);
}, open:function(url, hotspots, scale) {
  var self = this;
  var map = this._getParameter(url);
  this._openSeadragon.open({width:map.width, height:map.height, tileSize:256, getTileUrl:function(level, x, y) {
    return simpl4.util.BaseManager.getBaseUrl() + "/sw/resource/deep/SD_" + url + "/" + level + "/" + x + "_" + y + ".png";
  }});
}, close:function() {
  this._openSeadragon.close();
}, selectHotspot:function(href, intern) {
  this._selectHotspot(href, false);
}, destroy:function() {
  this._openSeadragon.destroy();
}, getHotspots:function(url) {
  var xmlResult;
  jQuery.ajax({url:url, async:false, dataType:"text", success:function(e) {
    xmlResult = e;
  }});
  var xml = new simpl4.util.Xml2Json;
  var jsonData = xml.convert(xmlResult);
  var hotspots = jsonData.area;
  return hotspots;
}, getAssembyTableMeta:function(data) {
  var colHds = [];
  var col = {};
  col.data = "menge";
  col.title = "";
  col.class = "input menge";
  col.mRender = this.renderColumn;
  colHds.push(col);
  var col = {};
  col.data = "basket";
  col.title = "";
  col.class = "wbutton";
  col.icon = "basket.gif";
  col.mRender = this.renderColumn;
  colHds.push(col);
  var col = {};
  col.data = "part";
  col.class = "teilenummer alignLeft";
  col.width = "50";
  col.title = tr("bomviewer.part");
  colHds.push(col);
  var col = {};
  col.data = "name";
  col.class = "teilename";
  col.width = "70";
  col.title = tr("bomviewer.name");
  colHds.push(col);
  var col = {};
  col.data = "name2";
  col.title = "Beschreibung";
  colHds.push(col);
  var col = {};
  col.data = "qty";
  col.title = tr("bomviewer.qty");
  col.width = "20";
  colHds.push(col);
  var col = {};
  col.data = "price";
  col.title = tr("bomviewer.price");
  return colHds;
}, renderColumn:function(data, type, row, meta) {
  var name = meta.settings.aoColumns[meta.col].mData;
  var clazz = meta.settings.aoColumns[meta.col].sClass;
  var baseUrl = simpl4.util.BaseManager.getBaseUrl();
  var ns = simpl4.util.BaseManager.getNamespace();
  if (clazz && clazz.toLowerCase().indexOf("input") > -1) {
    return "<div style='' class='input'><input id='id" + row.part + "' style='padding:0px !important; padding-top:3px !important; ;max-width:38px;margin:0px;font-size:10px;height:16px;xidth:100%;' type='text'></input></div>";
  } else {
    if (clazz && clazz.toLowerCase().indexOf("wbutton") > -1) {
      return "<div onClick='window.buttonClicked(" + row.part + ");' class='wbutton'><input style='height:16px;background:#787878;' src='" + baseUrl + "/repo/" + ns + "/basket.gif' type='image'></input></div>";
    } else {
      return row[name];
    }
  }
}, buttonClicked:function(e) {
  var nr = e;
  var inp = $(document.querySelector("html /deep/ #id" + e));
  var val = this.isEmpty(inp.val()) ? 1 : parseInt(inp.val());
  console.log("Part:" + nr + "/" + val);
  if (!isNaN(val) && val > 0) {
    inp.val(null);
    if (window.etk) {
      window.etk.addToBasket(nr, val);
    }
  }
}, isEmpty:function(s) {
  if (s == null || s == "") {
    return true;
  }
  return false;
}, getAssembyTableData:function(path) {
  try {
    var d = simpl4.util.Rpc.rpcSync("bhs:getAssembly", {namespace:"bhs", path:path + ".*{1}"});
    d.forEach(function(r) {
      if (this._hasHotspot(r.part)) {
      } else {
        r.name = "<span style='color:rgba(0, 0, 0, 0.5);'>" + r.name + "</span>";
      }
    }.bind(this));
    return d;
  } catch (e) {
    alert("BOMViewer._getAssemby:" + e);
    return;
  }
}, _hasHotspot:function(href) {
  if (this._hotspotMap == null) {
    this._hotspotMap = {};
    this._hotspots.forEach(function(h) {
      this._hotspotMap[h.href] = true;
    }.bind(this));
  }
  return this._hotspotMap[href];
}, _selectHotspot:function(href, intern) {
  if (this.internalHotspotEvent === true) {
    return;
  }
  var elems = this.$.viewer.getElementsByClassName("hotspot");
  var firstSelected = null;
  for (var i = 0; i < elems.length; i++) {
    var e = elems[i];
    jQuery(e).removeClass("selected");
    var data = e["$$hotspot"];
    if (data && data.href == href) {
      jQuery(e).addClass("selected");
      if (!firstSelected) {
        firstSelected = e;
      }
    }
  }
  if (!intern && firstSelected) {
    var e = firstSelected;
    var data = e["$$hotspot"];
    var offsetY = e.offsetTop + e.clientTop;
    var offsetX = e.offsetLeft + e.clientLeft;
    this._openSeadragon.viewport.panTo(data.p, true);
  }
}, _addOverlays:function(ev) {
  console.log("addOverlays:", ev);
  var viewer = ev.eventSource;
  var hsList = this._hotspots;
  for (var i = 0; i < hsList.length; i++) {
    var hs = hsList[i];
    var rect = hs.coords.split(",");
    var f = 5.0;
    var c = 0;
    var x = rect[0] * f;
    var y = rect[1] * f;
    var w = (rect[2] - rect[0] + 2) * f;
    var h = (rect[3] - rect[1] + 2) * f;
    var rec = viewer.viewport.imageToViewportRectangle(x, y, w, h);
    var p = viewer.viewport.imageToViewportCoordinates(x, y);
    var div = this.createDiv(hs.href, p);
    viewer.addOverlay(div, rec);
  }
}, createDiv:function(href, p) {
  var div = document.createElement("div");
  div.className = "hotspot";
  div["$$hotspot"] = {p:p, href:href};
  return div;
}, onViewerClick:function(event) {
  var e = event.originalEvent;
  var target = e.target || e.srcElement;
  if (target["$$hotspot"]) {
    event.preventDefaultAction = true;
    event.stopBubbling = true;
    var data = target["$$hotspot"];
    console.log("onViewerClick:", data);
    this._selectHotspot(data.href, true);
    this.internalHotspotEvent = true;
    this.selectBom(data.href);
    this.internalHotspotEvent = false;
    event.preventDefaultAction = true;
  }
}, selectBom:function(nr) {
  var dt = this.$.bomTable;
  var dtApi = dt._api;
  var rows = dtApi.rows(function(idx, data, node) {
    return data.part === nr ? true : false;
  });
  console.log("RowNodes:", rows[0]);
  dt.unselectAll();
  dtApi.rows(rows[0]).nodes().to$().addClass("selected");
  if (rows[0].length > 0) {
    console.log("RowNodes:", rows[0][0]);
    var scroller = dtApi.scroller();
    console.log("Scroller:", scroller);
    scroller.scrollToRow(rows[0][0] - 2, false);
  }
}, _getParameter:function(part) {
  var map = {123490603:{width:5263, height:3719}, 123551E3:{width:5263, height:3719}, 123555401:{width:5263, height:3719}, 123565300:{width:5263, height:3719}, 124451600:{width:4950, height:3825}, 124665200:{width:4950, height:3825}, 124665600:{width:5263, height:3719}, 124665700:{width:4950, height:3825}, 124751400:{width:5263, height:3719}, 124769600:{width:4950, height:3825}, 125429200:{width:5263, height:3719}, 125684601:{width:4950, height:3825}, 125684602:{width:4950, height:3825}, 127323700:{width:5263, 
  height:3719}, 128486700:{width:5263, height:3719}, 129729E3:{width:4950, height:3825}, 132818800:{width:5263, height:3719}, 132885800:{width:4950, height:3825}, 133294500:{width:5263, height:3719}, 133336500:{width:5263, height:3719}, 133424600:{width:5263, height:3719}, 133682500:{width:4950, height:3825}, 133777E3:{width:5263, height:3719}, 133793603:{width:7444, height:5263}, 133967200:{width:5263, height:3719}, 133971600:{width:5263, height:3719}, 133974300:{width:4950, height:3825}, 133974600:{width:4950, 
  height:3825}, 133999600:{width:5263, height:3719}, 134000600:{width:5263, height:3719}, 134000601:{width:5263, height:3719}, 134006E3:{width:5263, height:3719}, 134006001:{width:5263, height:3719}, 134102600:{width:5263, height:3719}, 134179500:{width:5263, height:3719}, 134413200:{width:4950, height:3825}, 134777700:{width:4950, height:3825}, 134861900:{width:5263, height:3719}, 134953200:{width:5263, height:3719}, 135096200:{width:5263, height:3719}, 135161500:{width:4950, height:3825}, 135224600:{width:4950, 
  height:3825}, 135234600:{width:4950, height:3825}, 135450200:{width:5263, height:3719}, 136421400:{width:5263, height:3719}, 136421800:{width:5263, height:3719}, 136924204:{width:3831, height:2394}, 137421800:{width:4950, height:3825}, 137756400:{width:5263, height:3719}, 138412E3:{width:5263, height:3719}, 139094200:{width:5263, height:3719}, 140645400:{width:4950, height:3825}, 140755100:{width:5263, height:3719}, 140755101:{width:4950, height:3825}, 140763300:{width:4950, height:3825}, 140763301:{width:5263, 
  height:3719}, 140779200:{width:3831, height:2394}, 140833100:{width:5263, height:3719}, 140833200:{width:5263, height:3719}, 141012800:{width:5263, height:3719}, 141027500:{width:3844, height:2394}, 141027600:{width:3844, height:2394}, 141027700:{width:3844, height:2394}, 141027800:{width:3831, height:2388}, 141027900:{width:3844, height:2394}, 141042700:{width:4950, height:3825}, 141078500:{width:5263, height:3719}, 141078600:{width:5263, height:3719}, 141078900:{width:5263, height:3719}, 141216100:{width:4950, 
  height:3825}, 141363400:{width:3831, height:2394}, 141363500:{width:5263, height:3719}, 141371E3:{width:3831, height:2388}, 141371800:{width:5263, height:3719}, 141378900:{width:3831, height:2394}, 141379300:{width:5263, height:3719}, 142080900:{width:4950, height:3825}, 145023400:{width:5263, height:3719}, 145028200:{width:5263, height:3719}, 145651400:{width:5263, height:3719}, 145661E3:{width:4950, height:3825}, 2100097:{width:3831, height:2388}};
  return map[part];
}});
Polymer({is:"simpl-xhr", request:function(options) {
  var xhr = new XMLHttpRequest;
  var url = options.url;
  var method = options.method || "GET";
  var async = !options.sync;
  var params = this.toQueryString(options.params);
  if (params && method.toUpperCase() == "GET") {
    url += (url.indexOf("?") > 0 ? "&" : "?") + params;
  }
  var xhrParams = this.isBodyMethod(method) ? options.body || params : null;
  xhr.open(method, url, async);
  if (options.responseType) {
    xhr.responseType = options.responseType;
  }
  if (options.withCredentials) {
    xhr.withCredentials = true;
  }
  this.makeReadyStateHandler(xhr, options.callback);
  this.setRequestHeaders(xhr, options.headers);
  xhr.send(xhrParams);
  if (!async) {
    xhr.onreadystatechange(xhr);
  }
  return xhr;
}, toQueryString:function(params) {
  var r = [];
  for (var n in params) {
    var v = params[n];
    n = encodeURIComponent(n);
    r.push(v == null ? n : n + "=" + encodeURIComponent(v));
  }
  return r.join("&");
}, isBodyMethod:function(method) {
  return this.bodyMethods[(method || "").toUpperCase()];
}, bodyMethods:{POST:1, PUT:1, PATCH:1, DELETE:1}, makeReadyStateHandler:function(xhr, callback) {
  xhr.onreadystatechange = function() {
    if (xhr.readyState == 4) {
      callback && callback.call(null, xhr.response, xhr);
    }
  };
}, setRequestHeaders:function(xhr, headers) {
  if (headers) {
    for (var name in headers) {
      xhr.setRequestHeader(name, headers[name]);
    }
  }
}});
!function() {
  Polymer({is:"app-grid", behaviors:[Polymer.Templatizer], properties:{itemWidth:{type:Number, value:128}, itemHeight:{type:Number, value:128}, itemSpacing:{type:Number, value:16}, items:{type:Array, value:function() {
    return new Array;
  }, observer:"_itemsChanged"}}, attached:function() {
    window.addEventListener("resize", this._layout.bind(this));
  }, detached:function() {
    window.removeEventListener("resize", this._layout);
  }, get parent() {
    if (this.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
      return this.parentNode.host;
    }
    return this.parentNode;
  }, addItems:function(newValue) {
    gridEl = Polymer.dom(this.$.grid);
    for (k = 0; k < newValue.length; k++) {
      var itemEl = document.createElement("div");
      itemEl.classList.add("item-container");
      itemEl.style.width = this.itemWidth + "px";
      itemEl.style.height = this.itemHeight + "px";
      itemEl.style.margin = 0;
      itemEl.style.opacity = 0;
      gridEl.appendChild(itemEl);
      userEl = this.stamp(null);
      userEl.item = newValue[k];
      itemEl.appendChild(userEl.root);
    }
    this._layout();
  }, removeAllItems:function() {
    var gridEl = Polymer.dom(this.$.grid);
    while (gridEl.firstChild) {
      gridEl.removeChild(gridEl.firstChild);
    }
  }, _itemsChanged:function(newValue, oldValue) {
    var userTemplate, item, gridEl;
    userTemplate = Polymer.dom(this).querySelector("template");
    if (userTemplate) {
      this.templatize(userTemplate);
    }
    gridEl = Polymer.dom(this.$.grid);
    while (gridEl.firstChild) {
      gridEl.removeChild(gridEl.firstChild);
    }
    for (k = 0; k < newValue.length; k++) {
      var itemEl = document.createElement("div");
      itemEl.classList.add("item-container");
      itemEl.style.width = this.itemWidth + "px";
      itemEl.style.height = this.itemHeight + "px";
      itemEl.style.margin = 0;
      itemEl.style.opacity = 0;
      gridEl.appendChild(itemEl);
      userEl = this.stamp(null);
      userEl.item = newValue[k];
      itemEl.appendChild(userEl.root);
    }
    this._layout();
  }, _layout:function() {
    var gridEl, gridWidth, itemEls, itemEl, itemWidth, itemHeight, rows, cols, colIdx, rowIdx, k, paddingTop, paddingLeft;
    gridEl = Polymer.dom(this.$.grid).node;
    itemEls = Polymer.dom(gridEl).querySelectorAll(".item-container");
    if (itemEls.length > 0) {
      gridWidth = +window.getComputedStyle(gridEl).width.replace("px", "");
      itemWidth = this.itemWidth + this.itemSpacing;
      itemHeight = this.itemHeight + this.itemSpacing;
      cols = Math.floor(gridWidth / itemWidth);
      paddingTop = this.itemSpacing;
      paddingLeft = (gridWidth - cols * this.itemWidth - (cols - 1) * this.itemSpacing) / 2;
      for (k = 0; k < itemEls.length; k++) {
        itemEl = itemEls[k];
        colIdx = Math.floor(k % cols);
        rowIdx = Math.floor(k / cols);
        itemEl.style.opacity = 1;
        itemEl.style.top = rowIdx * itemHeight + paddingTop + "px";
        itemEl.style.left = colIdx * itemWidth + paddingLeft + "px";
      }
      rows = rowIdx + 1;
      gridEl.style.height = rows * itemHeight + paddingTop + "px";
    }
  }});
}();
(function() {
  Polymer({is:"simpl-websocket", properties:{namespace:{type:String}, websocketName:{type:String}, osgiService:{type:String}, connected:{type:Boolean, value:false, notify:true}, recvMessage:{type:Object, notify:true}}, observers:[], sendMessage:function(data) {
    if (!this.connected) {
      throw new Error("simpl-websocket.send(...): not connected.");
    }
    data = JSON.stringify(data);
    console.log("<- sendMessage:", data);
    this.socket.onNext(data);
  }, closeConnection:function() {
    this.socket.onCompleted();
  }, openConnection:function(params, timeoutCallback) {
    var password = simpl4.util.BaseManager.getPassword();
    var username = simpl4.util.BaseManager.getUser();
    var credentials = simpl4.util.Base64.encode(username + ":" + password);
    var baseUrl = simpl4.util.BaseManager.getBaseUrl();
    baseUrl = baseUrl.replace("http", "ws");
    params = params || {};
    params["credentials"] = credentials;
    if (!params["namespace"]) {
      params["namespace"] = this.namespace;
    }
    if (!params["name"]) {
      params["name"] = this.websocketName;
    }
    if (!params["connectionKey"]) {
      params["connectionKey"] = getShortId();
    }
    params["osgiService"] = this.osgiService;
    var qs = $.param(params);
    this.url = baseUrl + "/ws/xyz?" + qs;
    var openObserver = Rx.Observer.create(function(e) {
      console.info("-> websocket open");
      this.connected = true;
    }.bind(this));
    var closingObserver = Rx.Observer.create(function(x) {
      console.log("websocket is about to close:", x);
      this.connected = false;
    }.bind(this));
    var options = {timeoutCallback:timeoutCallback, debug:false, reconnectInterval:50};
    this.socket = simpl4.util.Rx.observableFromWebSocket(this.url, options, openObserver, closingObserver);
    var self = this;
    this.socket.subscribe(function(e) {
      var data = e.data;
      data = JSON.parse(data);
      self.fire("message", {data:data});
      self.async(function() {
        self.recvMessage = data;
      }, null, 0);
    }, function(e) {
      console.error("Error:" + e.reason + "(" + e.code + ")");
      var message = {errorMessage:e.reason};
      self.async(function() {
        self.recvMessage = message;
      }, null, 0);
    }, function() {
      console.info("websocket closed");
      self.connected = false;
    });
  }});
})();
(function() {
  Polymer({is:"simpl-websocket-plain", properties:{namespace:{type:String}, websocketName:{type:String}, osgiservice:{type:String}, connected:{type:Boolean, notify:true}, recvMessage:{type:Object, notify:true}}, connected:false, send:function(data) {
    if (!this.connected) {
      throw new Error("simpl-websocket-plain.send(...): not connected.");
    }
    data = JSON.stringify(data);
    console.log("<- sendMessage:", data);
    this.wssocket.send(data);
  }, sendMessage:function(msg) {
    this.send(msg);
  }, closeConnection:function() {
    this.wssocket.close();
  }, openConnection:function(params, timeoutCallback) {
    var password = simpl4.util.BaseManager.getPassword();
    var username = simpl4.util.BaseManager.getUser();
    var credentials = simpl4.util.Base64.encode(username + ":" + password);
    var baseUrl = simpl4.util.BaseManager.getBaseUrl();
    baseUrl = baseUrl.replace("http", "ws");
    params = params || {};
    params["namespace"] = this.namespace;
    params["credentials"] = credentials;
    params["osgiService"] = this.osgiService;
    params["name"] = this.websocketName;
    if (!params["connectionKey"]) {
      params["connectionKey"] = getShortId();
    }
    var qs = $.param(params);
    this.url = baseUrl + "/ws/xyz?" + qs;
    var options = {timeoutCallback:timeoutCallback, debug:false, reconnectInterval:50};
    var self = this;
    var wssocket = new ReconnectingWebSocket(this.url, null, options);
    this.wssocket = wssocket;
    wssocket.onopen = function(e) {
      self.connected = true;
    };
    wssocket.onclose = function(e) {
      console.log("onclose:", e);
      self.connected = false;
      var message = {errorMessage:e.reason};
      self.async(function() {
        self.recvMessage = message;
      }, null, 0);
    };
    wssocket.onerror = function(error) {
      console.error("WebSocket Error " + error);
    };
    wssocket.onmessage = function(e) {
      var data = JSON.parse(e.data);
      self.async(function() {
        self.recvMessage = data;
      }, null, 0);
    };
  }});
})();
Polymer({is:"simpl-chat", behaviors:[TranslationsBehavior], properties:{demotext:{value:false, type:Boolean}, chatList:{value:function() {
  return [];
}, type:Array}, connected:{value:false, type:Boolean}, chatId:{value:"main", notify:true, type:String}}, observers:["connectedChanged(connected)", "recvMessageChanged(recvMessage)", "chatIdChanged(chatId)"], attached:function() {
  this.chatId = "main";
}, ready:function() {
  this.entryAnimation = "slide-from-right-animation";
  this.exitAnimation = "slide-right-animation";
  this.viewId = "loginView";
  this.camelWS = false;
  this.recvMessage = null;
  this.autoConnect = true;
  this.resourceId = null;
  this.pausingTimeout = 2500;
  this.isCurrentParticipant = false;
  this.resourceId = getShortId();
  this.addUserCallback = this.addUser.bind(this);
  this.addGroupCallback = this.addGroup.bind(this);
  this.loginCallback = this.login.bind(this);
  this.joinRoomCallback = this.joinRoom.bind(this);
  this.leaveRoomCallback = this.leaveRoom.bind(this);
  window.addEventListener("unload", function(e) {
    if (this.connected === true) {
      this.sendChatState("gone");
    }
  }.bind(this));
  this.loginData = {username:Simpl4.Cache.getItem("chat.username"), password:Simpl4.Cache.getItem("chat.password"), domain:Simpl4.Cache.getItem("chat.domain")};
}, sendMessageInput:function() {
  var chat = this.chatHash[this.chatId];
  var messageInput = this.querySelector("#messageInput-" + chat.id);
  var participant = chat.participant || $(this.querySelector("#participant-" + chat.id)).val();
  if (this.isEmpty(participant) && chat.type === "mixedchat") {
    this.showError("no participant selected");
    console.error("no participant selected");
    return;
  }
  if (messageInput.value != "") {
    var message = {body:messageInput.value, from:this.loginData.username};
    if (!this.isEmpty(participant)) {
      message.participant = participant;
    }
    if (chat.type === "groupchat") {
      message.room = chat.id;
    }
    if (chat.type !== "groupchat") {
      message.style = "background:light-yellow;";
      message.time = this.getTime();
      var t = this.getMessageBoxTemplate();
      t.unshift("items", message);
    }
    this.$.websocket.sendMessage(message);
    messageInput.setValue("");
    this.sendChatState("active");
    chat.isComposing = false;
  }
}, recvMessageChanged:function() {
  var message = this.recvMessage;
  if (message == null) {
    return;
  }
  message.time = this.getTime();
  console.log("-> recvMessage", message);
  var chat = null;
  if (message.errorMessage) {
    var errorMessage = message.errorMessage;
    var request = message.request;
    if (request && request.command && request.command === "open") {
      this.async(function() {
        this.connected = false;
      }, null, 30);
    }
    this.showError(this.mapSomeErrors(errorMessage));
    console.error(errorMessage);
    if (request && request.room) {
      this.removeChat(request.room);
    }
    return;
  }
  if (message.type == "groupchat") {
    var room = this.getNameFromJid(message.from);
    message.from = message.from.split("/")[1];
    chat = this.chatHash[room];
  } else {
    if (message.type == "chat") {
      chat = this.chatHash[this.getNameFromJid(message.from)];
      if (!chat) {
        chat = this.chatHash["main"];
      }
    }
  }
  if (!this.isEmpty(message.body)) {
    message.style = "background:#f8f8f8;";
    var t = this.getMessageBoxTemplate();
    t.unshift("items", message);
  }
  if (chat && message.chatState) {
    chat.chatState = tr("chat.state_" + message.chatState);
  }
  if (chat && chat.type === "groupchat") {
    chat.chatState = "";
  }
  if (chat && chat.type === "mixedchat") {
    var participant = $(this.querySelector("#participant-" + this.chatId)).val();
    if (participant != this.getNameAndDomainFromJid(message.from)) {
      chat.chatState = "";
    }
  }
  if (message.rosterEntries) {
    var re = this.filterSingleChat(message.rosterEntries);
    re.sort(this.sortRosterEntries);
    this.rosterEntries = re;
  }
  if (message.presence) {
    var chatId = this.getNameFromJid(message.from);
    var chat = this.chatHash[chatId];
    if (chat) {
      var index = this.getChatIndex(chat);
      console.log("index:", index);
      this.set("chatList." + index + ".presence", message.presence);
      console.log("chat.presence:", this.chatList[index].presence);
    }
  }
}, login:function(e) {
  var loginForm = this.querySelector("#loginForm");
  var formData = loginForm.getData();
  if (this.isEmpty(formData.username)) {
    return;
  }
  if (!this.isEmpty(formData.resource)) {
    this.resourceId = formData.resource;
  }
  this.loginData = formData;
  Simpl4.Cache.setItem("chat.username", this.loginData.username);
  Simpl4.Cache.setItem("chat.password", this.loginData.password);
  Simpl4.Cache.setItem("chat.domain", this.loginData.domain);
  this.rosterEntries = [];
  this.chatId = "main";
  this.resetChatList();
  var params = {};
  if (this.camelWS) {
    var headers = {xmppUsername:formData.username, xmppPassword:formData.password, xmppResourceId:this.resourceId};
    var closeCommandBody = {command:"close"};
    params["camelHeaders"] = JSON.stringify(headers);
    params["closeCommandBody"] = JSON.stringify(closeCommandBody);
    params["connectionKey"] = formData.username + "/" + this.resourceId;
  } else {
    params["username"] = formData.username;
    params["password"] = formData.password;
    params["resourceId"] = this.resourceId;
  }
  this.$.websocket.openConnection(params, this.socketTimeoutCallback.bind(this));
}, disconnect:function() {
  this.sendChatState("gone");
  this.async(function() {
    this.removeAllChat();
    this.$.websocket.closeConnection();
  }, null, 300);
}, socketTimeoutCallback:function() {
  this.async(function() {
    var chat = this.chatHash[this.chatId];
    this.sendOpen();
    for (var i = 0; i < this.chatList.length; i++) {
      var chat = this.chatList[i];
      if (chat.type === "groupchat") {
        this.sendJoin(chat);
      }
    }
  }, null, 500);
}, connectedChanged:function() {
  if (this.connected === true) {
    this.viewId = "chatView";
    this.sendOpen();
  } else {
    this.viewId = "loginView";
  }
  if (this.connected === true) {
    this.bindFocusListener(true);
  } else {
    for (var i = 0; this.chatList && i < this.chatList.length; i++) {
      var chat = this.chatList[i];
      if (chat.type !== "groupchat") {
        this.bindFocusListener(false);
      }
    }
  }
}, bindFocusListener:function(bind) {
  this.async(function() {
    var messageInputElement = this.querySelector("#messageInput-" + this.chatId + " /deep/ #input");
    if (bind) {
      $(messageInputElement).on("focus", this.chatEventListener.bind(this));
      $(messageInputElement).on("blur", this.chatEventListener.bind(this));
    } else {
      $(messageInputElement).off("focus", this.chatEventListener);
      $(messageInputElement).off("blur", this.chatEventListener);
    }
  }, null, 100);
}, showJoinRoomForm:function() {
  this.viewId = "joinRoomView";
  var params = {service:"xmpp", method:"getRooms", parameter:{serviceName:"conference"}, async:true, context:this, failed:function(e) {
    console.error("showJoinRoomForm:", e);
  }, completed:function(roomList) {
    var rooms = [];
    for (var i = 0; i < roomList.length; i++) {
      var room = {};
      room.name = roomList[i].name;
      room.description = roomList[i].description;
      rooms.push(room);
    }
    var items = {room:rooms};
    var joinRoomForm = this.querySelector("#joinRoomForm");
    joinRoomForm.setItems(items);
  }};
  simpl4.util.Rpc.rpcAsync(params);
}, joinRoom:function(e) {
  var formData = e.detail.data;
  this.viewId = "chatView";
  if (e.detail.xaction == "cancel") {
    return;
  }
  if (formData.room == null) {
    return;
  }
  var chat = {};
  chat.id = formData.room.length ? formData.room[0].name : formData.room.name;
  chat.description = formData.room.length ? formData.room[0].description : formData.room.description;
  if (this.chatHash[chat.id]) {
    this.set("chatId", chat.id);
    this.$.chatTabId.selected = chat.id;
    return;
  }
  chat.messages = [];
  chat.type = "groupchat";
  this.addChat(chat);
  this.async(function() {
    this.set("chatId", chat.id);
    this.sendJoin();
  }, null, 300);
  this.$.chatTabId.selected = chat.id;
}, openSingleChat:function() {
  var participant = $(this.querySelector("#participant-" + this.chatId)).val();
  var chat = {};
  chat.id = this.getNameFromJid(participant);
  chat.participant = participant;
  chat.type = "singlechat";
  this.addChat(chat);
  this.bindFocusListener(true);
  this.updateRoster();
  $(this.querySelector("#participant-" + this.chatId)).val(null);
  this.isCurrentParticipant = false;
  try {
    this.set("chatId", chat.id);
  } catch (e) {
  }
}, showLeaveRoomForm:function() {
  this.viewId = "leaveRoomView";
  var items = [];
  for (var i = 0; i < this.chatList.length; i++) {
    if (this.chatList[i].type === "groupchat") {
      var item = {name:this.chatList[i].id, description:this.chatList[i].description};
      items.push(item);
    }
  }
  this.async(function() {
    var leaveRoomForm = this.querySelector("#leaveRoomForm");
    leaveRoomForm.setItems({room:items});
    var actionButton = leaveRoomForm.querySelector("simpl-form /deep/ xaction-button");
    actionButton.innerHTML = '<iron-icon icon="launch"></iron-icon>' + tr("chat.leaveRoom");
  }, 30);
}, leaveRoom:function(e) {
  var leaveRoomForm = this.querySelector("#leaveRoomForm");
  var formData = leaveRoomForm.getData();
  this.viewId = "chatView";
  if (e.detail.xaction == "cancel") {
    return;
  }
  if (formData.room == null) {
    return;
  }
  var chatId = formData.room[0].name;
  var message = {command:"leaveRoom", parameter:{room:chatId}};
  this.$.websocket.sendMessage(message);
  this.removeChat(chatId);
}, showAddUserForm:function() {
  this.viewId = "addUserView";
}, showAddGroupForm:function() {
  this.viewId = "addGroupView";
}, addUser:function(e) {
  var addUserForm = this.querySelector("#addUserForm");
  if (e.detail.xaction == "execute") {
    if (addUserForm.validate() == false) {
      return;
    }
  }
  this.viewId = "chatView";
  if (e.detail.xaction == "cancel") {
    return;
  }
  var formData = addUserForm.getData();
  if (this.isEmpty(formData.username)) {
    return;
  }
  var domain = this.loginData.domain;
  var username = formData.username;
  if (username.indexOf("@") == -1 && !this.isEmpty(domain)) {
    username = username + "@" + domain;
  }
  var message = {command:"addUser", parameter:{username:username, nickname:formData.nickname}};
  this.$.websocket.sendMessage(message);
}, addGroup:function(e) {
  var addGroupForm = this.querySelector("#addGroupForm");
  if (e.detail.xaction == "execute") {
    if (addGroupForm.validate() == false) {
      return;
    }
  }
  this.viewId = "chatView";
  if (e.detail.xaction == "cancel") {
    return;
  }
  var formData = addUserForm.getData();
  if (this.isEmpty(formData.groupname)) {
    return;
  }
  var message = {command:"addGroup", parameter:{groupname:formData.groupname}};
  this.$.websocket.sendMessage(message);
}, onMessageKeydown:function(e) {
  if (e.keyCode && e.keyCode == 13) {
    this.sendMessageInput();
  }
}, chatEventListener:function(e) {
  var chat = this.chatHash[this.chatId];
  if (chat.type === "groupchat") {
    return;
  }
  var type = e.type;
  if (type == "keyup" && e.keyCode != 13) {
    var messageInputElement = this.querySelector("#messageInput-" + this.chatId + " /deep/ #input");
    if ($(messageInputElement).val() && chat.isComposing == false) {
      chat.isComposing = true;
      this.checkPausingTimeout = setTimeout(this.checkPausing.bind(this), this.pausingTimeout);
      this.sendChatState("composing");
    } else {
      if (!$(messageInputElement).val() && chat.isComposing == true) {
        chat.isComposing = false;
        this.sendChatState("active");
      } else {
        if ($(messageInputElement).val() && chat.isComposing == true) {
          clearTimeout(this.checkPausingTimeout);
          this.checkPausingTimeout = setTimeout(this.checkPausing.bind(this), this.pausingTimeout);
        }
      }
    }
  }
  if (type == "focus") {
    var messageInputElement = this.querySelector("#messageInput-" + this.chatId + " /deep/ #input");
    if (!$(messageInputElement).val()) {
      this.sendChatState("active");
    } else {
      this.sendChatState("paused");
    }
  }
  if (type == "blur") {
    this.sendChatState("inactive");
  }
}, checkPausing:function() {
  var chat = this.chatHash[this.chatId];
  if (chat.isComposing) {
    this.sendChatState("paused");
    chat.isComposing = false;
  }
}, sendOpen:function(chat) {
  var message = {};
  message["command"] = "open";
  message["participant"] = "dummy";
  this.async(function() {
    this.$.websocket.sendMessage(message);
  }, null, 20);
}, sendJoin:function(chat) {
  if (chat == null) {
    chat = this.chatHash[this.chatId];
  }
  if (chat.type !== "groupchat") {
    return;
  }
  var message = {body:"", from:this.loginData.username, room:chat.id};
  this.$.websocket.sendMessage(message);
}, sendChatState:function(state) {
  var chat = this.chatHash[this.chatId];
  var participant = chat.participant || $(this.querySelector("#participant-" + chat.id)).val();
  if (this.isEmpty(participant)) {
    if (chat.type === "mixedchat") {
      console.error("no participant selected");
    }
    return;
  }
  var message = {command:"chatState", participant:participant, parameter:{state:state}};
  this.$.websocket.sendMessage(message);
}, sortRosterEntries:function compare(a, b) {
  if (a.username < b.username) {
    return -1;
  }
  if (a.username > b.username) {
    return 1;
  }
  return 0;
}, getMessageBoxTemplate:function() {
  var chat = this.chatHash[this.chatId];
  var t = this.querySelector("#messageBoxTemplate-" + chat.id);
  return t;
}, showError:function(msg) {
  this.errorMessage = msg;
  this.$.toast_error.show();
}, getTime:function() {
  var format = " HH:mm.ss";
  return "[" + moment().format(format) + "]";
}, chatIdChanged:function() {
  var chatPages = this.querySelector("#chatPages");
  if (this.chatHash) {
    this.currentChat = this.chatHash[this.chatId];
  }
}, getNameFromJid:function(name) {
  if (name.indexOf("@") == -1) {
    return name;
  }
  return name.split("@")[0];
}, getNameAndDomainFromJid:function(name) {
  if (name.indexOf("/") == -1) {
    return name;
  }
  return name.split("/")[0];
}, setCurrentParticipant:function(e) {
  var chat = this.chatHash[this.chatId];
  var participant = $(this.querySelector("#participant-" + chat.id));
  participant.val(e.target.dataset.username);
  this.isCurrentParticipant = true;
  chat.chatState = "";
}, filterSingleChat:function(roster) {
  var ret = [];
  for (var i = 0; i < roster.length; i++) {
    if (!this.chatHash[this.getNameFromJid(roster[i].username)]) {
      ret.push(roster[i]);
    }
  }
  return ret;
}, updateRoster:function() {
  this.rosterEntries = this.filterSingleChat(this.rosterEntries);
}, resetChatList:function() {
  this.arrayClear(this.chatList);
  var chat = {id:"main", isComposing:false, messages:[], type:"mixedchat"};
  this.currentChat = chat;
  this.addChat(chat);
}, removeAllChat:function() {
  this.splice("chatList", 1, this.chatList.length - 1);
  this.chatHash = this.toHash(this.chatList);
  this.set("chatId", "main");
}, removeChat:function(name) {
  for (var i = 0; i < this.chatList.length; i++) {
    if (name === this.chatList[i].id) {
      this.splice("chatList", i, 1);
      break;
    }
  }
  this.chatHash = this.toHash(this.chatList);
  this.set("chatId", "main");
}, addChat:function(chat) {
  chat.messages = [];
  chat.presence = [];
  chat.isComposing = false;
  chat.chatState = "";
  this.push("chatList", chat);
  this.chatHash = this.toHash(this.chatList);
}, arrayClear:function(a) {
  if (a.length == 0) {
    return;
  }
  this.splice("chatList", 0, a.length);
}, getChatIndex:function(chat) {
  for (var i = 0; i < this.chatList.length; i++) {
    if (chat.id === this.chatList[i].id) {
      return i;
    }
  }
}, toHash:function(list) {
  var hash = {};
  for (var i = 0; i < list.length; i++) {
    hash[list[i].id] = list[i];
  }
  return hash;
}, isChatType:function(t1, t2) {
  return t1 == t2;
}, isView:function(t1, t2) {
  return t1 == t2;
}, strcat:function(s1, s2) {
  return s1 + s2;
}, isLang:function(lang) {
  var _lang = Simpl4.Cache.getItem("lang");
  return lang == _lang;
}, mapSomeErrors:function(msg) {
  if (msg.indexOf("not-authorized") > 0) {
    return tr("chat.not-authorized");
  }
  if (msg.indexOf("registration-required") > 0) {
    return tr("chat.registration-required");
  }
  return msg;
}, isEmpty:function(s) {
  if (s == null || s == "") {
    return true;
  }
  return false;
}});
Polymer({is:"simpl-processcontroller", properties:{namespace:{type:String}, name:{type:String}, parameter:{type:String}}, observers:["nameChanged(namespace,name,parameter)"], behaviors:[LobiboxBehavior], ready:function() {
  this.panelBackgroundColor = "black";
  this.panelHeader = "";
  this.formName = null;
  console.log("ProcessController.ready");
}, attached:function() {
  console.log("ProcessController.attached:", this.namespace + "/" + this.name + "/" + this.paramObject);
  if (this.name && this.namespace && this.paramObject) {
    this.startByName(this.namespace, this.name, this.paramObject);
  }
}, isParamsOk:function(namespace, formName) {
  return this.namespace != null && this.formName != null;
}, nameChanged:function() {
  var params = null;
  if (this.parameter && this.parameter.startsWith("{")) {
    params = JSON.parse(this.parameter);
  }
  this.paramObject = params || {};
}, startByName:function(namespace, name, parameter) {
  this.namespace = namespace || simpl4.util.BaseManager.getNamespace();
  var pc = this.getProcessDefinition(namespace, name);
  if (pc == null) {
    this.alert("ProcessController.workflow(" + namespace + "," + name + ") not found");
    return;
  }
  console.log("ProcessController:startByName" + namespace + "/" + name);
  this.start(pc, parameter);
}, start:function(processDefinition, parameter, finishCallback) {
  this.processDefinition = processDefinition;
  this.processName = processDefinition.name;
  this.namespace = this.processDefinition.key.substring(0, this.processDefinition.key.indexOf("_"));
  console.log("Start:" + JSON.stringify(processDefinition, null, 2));
  console.log("startFormResourceKey:" + this.processDefinition.startFormResourceKey);
  if (this.processDefinition.startFormResourceKey) {
    this.showForm(null, finishCallback);
  } else {
    var processVariables = parameter || {};
    processVariables["processDefinitionId"] = this.processDefinition.id;
    this.completeActivity(processVariables, null, finishCallback);
  }
}, showForm:function(task, finishCallback) {
  if (finishCallback) {
    this.finishCallback = finishCallback;
  }
  var formResourceKey = null;
  var taskName = null;
  var processName = null;
  if (task == null) {
    formResourceKey = this.processDefinition.startFormResourceKey;
    this.namespace = this.processDefinition.key.substring(0, this.processDefinition.key.indexOf("_"));
    processName = this.processName;
  } else {
    formResourceKey = task.formResourceKey;
    if (task.processName) {
      this.processName = task.processName;
    }
    processName = this.processName;
    taskName = task.name;
    this.namespace = task.processDefinitionKey.substring(0, task.processDefinitionKey.indexOf("-"));
  }
  if (formResourceKey == null) {
    this.handleExecuteButton(null, task, null, null, finishCallback);
    return;
  }
  var formName = this.getFormName(formResourceKey);
  console.log("{task,process}Name:" + taskName + "/" + processName);
  console.log("formResourceKey:" + formResourceKey);
  console.log("formName:" + formName);
  console.log("namespace:" + this.namespace);
  var self = this;
  this.actionCallback = function(e) {
    console.log("ProcessController.actionCallback:", e.detail);
    var xaction = e.detail.xaction;
    var xid = e.detail.xid;
    var data = e.detail.data;
    var formVar = e.detail.formVar;
    var valid = e.detail.valid;
    if (xaction == "execute") {
      var buttonKey = xid;
      if (!valid) {
        Lobibox.notify("error", {delay:6000, icon:"vaadin-icons:exclamation", msg:tr("process.form_incomplete")});
        return;
      }
      self.handleExecuteButton(data, task, formVar, buttonKey, finishCallback);
    }
    if (xaction == "cancel") {
      if (self.finishCallback) {
        self.finishCallback();
      }
    }
  };
  var processVariables = {};
  var mappedFormValues = null;
  if (task != null) {
    processVariables = this.getProcessVariables(this.namespace, formResourceKey, task.processInstanceId);
    mappedFormValues = this.getMappedFormValues(task.id, task.processInstanceId);
  } else {
    processVariables["__namespace"] = simpl4.util.BaseManager.getNamespace();
  }
  if (taskName) {
    this.panelHeader = tr(processName) + "/" + taskName;
  } else {
    this.panelHeader = tr(processName);
  }
  this.variables = processVariables;
  this.formName = "empty";
  this.async(function() {
    this.formName = formName;
    console.log("formName:", formName);
    this.async(function() {
      var form = this.querySelector("#formid");
      console.log("form:", form);
      form.setData(mappedFormValues);
    }, 300);
  }, 100);
}, getFormName:function(formResourceKey) {
  var formName = null;
  if (formResourceKey.indexOf(",") == -1) {
    formName = formResourceKey;
  } else {
    formName = formResourceKey.split(",")[0];
  }
  return formName;
}, handleExecuteButton:function(data, task, formName, executeButtonKey, finishCallback) {
  var processVariables = {};
  var formVals = {};
  if (data) {
    Object.keys(data).forEach(function(p, index) {
      if (p.match("^__")) {
        return;
      }
      var val = data[p];
      formVals[p] = val;
    });
  }
  if (executeButtonKey != null) {
    formVals["actionButton"] = executeButtonKey;
  }
  if (task == null) {
    processVariables["processDefinitionId"] = this.processDefinition.id;
  }
  if (formName) {
    processVariables[this.removeSuffix(formName)] = formVals;
  }
  console.log("processVariables:" + JSON.stringify(processVariables, null, 2));
  this.completeActivity(processVariables, task, finishCallback);
}, removeSuffix:function(formName) {
  if (formName.match(/.*\.form$/)) {
    return formName.substring(0, formName.length - 5);
  }
  return formName;
}, getMappedFormValues:function(tid, processInstanceId) {
  var failed = function(e) {
    var message = "<div style='width:100%;overflow:auto'>" + e + "</div>";
    this.alert(message);
  }.bind(this);
  var result = null;
  try {
    result = simpl4.util.Rpc.rpcSync("process:getTaskFormProperties", {executionId:processInstanceId, taskId:tid});
  } catch (e) {
    this.alert("ProcessController.getMappedFormValues:" + e);
    failed.call(this, e);
    return;
  }
  if (result && result.values) {
    var m = JSON.stringify(result.values);
    console.warn("values:" + m);
    return result.values;
  }
  return null;
}, getProcessVariables:function(namespace, formId, pid) {
  var result = null;
  try {
    result = simpl4.util.Rpc.rpcSync("process:getVariables", {namespace:namespace, formId:formId, executionId:pid});
  } catch (e) {
    this.alert("ProcessController.getProcessVariables:" + e);
    return;
  }
  return result;
}, completeActivity:function(processVariables, task, finishCallback) {
  var pdata = JSON.stringify(processVariables);
  var completed = function(ret) {
    var x = JSON.stringify(ret);
    console.log("ret:" + x);
    var pid = ret.id;
    if (task) {
      x = JSON.stringify(task);
      console.log("task:" + x);
      pid = task.executionId;
    }
    var tasks = this.getTasks(pid);
    if (tasks && tasks.total > 0) {
      this.showForm(tasks.data[0], finishCallback);
    } else {
      if (task) {
        this.finish(tr("processes.taskform.started") + " -> ID" + task.processInstanceId, finishCallback);
      } else {
        this.finish(tr("processes.startform.started") + " -> ID" + (task ? task.processInstanceId : ret.id), finishCallback);
      }
    }
  }.bind(this);
  var failed = function(ret) {
    console.log("ret:" + JSON.stringify(ret));
    if (ret.message) {
      ret = ret.message;
    } else {
      ret = ret.toString();
    }
    var msg = ret.replace(/\|/g, "<br/>");
    var msg = msg.replace(/Script.*groovy: [0-9]{0,4}:/g, "<br/><br/>");
    var msg = msg.replace(/ for class: Script[0-9]{1,2}/g, "");
    var msg = msg.replace(/Script[0-9]{1,2}/g, "");
    var msg = msg.replace(/Application error 500:/g, "");
    var msg = msg.replace(/:java.lang.RuntimeException/g, "");
    var msg = msg.replace(/:Line:/g, "<br/>Line:");
    var msg = msg.replace(/: {0,2}Line:/g, "<br/>Line:");
    msg = simpl4.util.Text.explode(msg, 100);
    var message = "<b>" + tr("processes." + (task != null ? "taskform" : "startform") + ".notstarted") + ": </b><pre style='font-size:10px'>" + msg + "</pre>";
    this.alert(message, "large");
    if (task != null) {
      this.showForm(task, finishCallback);
    }
  }.bind(this);
  var params = null;
  if (task == null) {
    params = {service:"process", method:"startProcessInstance", parameter:{namespace:this.namespace ? this.namespace : simpl4.util.BaseManager.getNamespace(), processDefinitionId:processVariables["processDefinitionId"], processDefinitionKey:processVariables["processDefinitionKey"], processDefinitionName:processVariables["processDefinitionName"], businessKey:processVariables["businessKey"], startParams:processVariables}, async:false, context:this, failed:failed, completed:completed};
    return simpl4.util.Rpc.rpcAsync(params);
  } else {
    this.completeTask(task.id, processVariables, completed, failed);
  }
}, completeTask:function(taskId, processVariables, completed, failed) {
  var showErrors = function(cv) {
    if (cv) {
      var message = "";
      for (var i = 0; i < cv.length; i++) {
        var c = cv[i];
        if (c.time) {
          var d = new Date;
          d.setTime(c.time);
          var lang = simpl4.util.BaseManager.getLanguage();
          c.message = c.message.replace("{0}", d.toString(lang == "de" ? "d.M.yyyy" : "M/d/yyyy"));
        }
        if (c.message && c.message.match(/^@/)) {
          c.message = tr(c.message.substring(1));
        }
        if (c.message && c.message.match(/^%/)) {
          c.message = tr(c.message.substring(1));
        }
        if (c.path) {
          message += c.path + " : " + c.message + "<br />";
        } else {
          message += c.message + "<br />";
        }
      }
      this.alert(message);
      return;
    }
  }.bind(this);
  var result = null;
  try {
    result = simpl4.util.Rpc.rpcSync("process:executeTaskOperation", {taskId:taskId, operation:"complete", startParams:processVariables});
    console.error("RET:" + result.success);
    if (result.success === true) {
      completed.call(this, result);
      return result;
    } else {
      showErrors(result.errors);
    }
  } catch (e) {
    failed.call(this, e);
    return;
  }
  return result;
}, getTasks:function(processInstanceId) {
  var result = null;
  var userid = simpl4.util.BaseManager.getUser();
  try {
    result = simpl4.util.Rpc.rpcSync("process:getTasks", {queryParams:{assignee:userid, processInstanceId:processInstanceId}, listParams:{size:1000}});
  } catch (e) {
    this.alert("ProcessController.getTasks:" + e);
    return;
  }
  return result;
}, getProcessDefinition:function(namespace, name) {
  var result = null;
  try {
    result = simpl4.util.Rpc.rpcSync("process:getProcessDefinitions", {namespace:namespace ? namespace : simpl4.util.BaseManager.getNamespace(), version:-1, key:name});
  } catch (e) {
    this.alert("ProcessController.getProcessDefinitions:" + e);
    return;
  }
  var defs = result["data"];
  if (defs.length > 0) {
    return defs[0];
  }
  return null;
}, finish:function(message, callback) {
  this.notify(message, "success", 8000);
  this.async(function() {
    callback();
  }, 500);
}, alert:function(message, size) {
  var s = size || "normal";
  Lobibox.notify("error", {size:s, delay:6000, icon:"vaadin-icons:exclamation", msg:message});
}});
Polymer({is:"simpl-processes", behaviors:[DataTablesBehavior, ModernizrBehavior, TranslationsBehavior], properties:{namespace:{type:String}}, observers:["selectionChanged(selection)"], attached:function() {
  this.entryAnimation = "slide-from-right-animation";
  this.exitAnimation = "slide-right-animation";
  this.panelBackgroundColor = "black";
  this.panelHeader = tr("tr.menu.process_list");
  this.dtMeta = null;
  this.pageSelected = 0;
  this.action = tr("processexplorer.definition.start_workflow");
  this.currentProcess = null;
  this.meta = this.getMeta();
  this.data = this.getProcessDefinitions();
}, startProcess:function(e) {
  var process = this.selection[0];
  var self = this;
  this.$.processController.start(process, {}, function() {
    self.pageSelected = 0;
  });
  this.async(function() {
    self.pageSelected = 1;
  }, 200);
}, selectionChanged:function() {
  this.currentProcess = this.selection[0].key;
}, getCurrentProcessDescription:function() {
  return this.action + " (" + this.currentProcess + ")";
}, getMeta:function() {
  var colHds = [];
  var col = {};
  col.data = "id";
  col.title = "Id";
  colHds.push(col);
  var col = {};
  col.data = "key";
  col.title = tr("tasks.table.processName");
  colHds.push(col);
  return colHds;
}, getProcessDefinitions:function() {
  var result = null;
  var namespace = this.namespace || simpl4.util.BaseManager.getNamespace();
  try {
    result = simpl4.util.Rpc.rpcSync("process:getProcessDefinitions", {namespace:namespace, version:-1});
  } catch (e) {
    alert("ProcessDefinitions.getProcessDefinitions:" + e);
    return;
  }
  return result["data"];
}});
Polymer({is:"simpl-tasks", behaviors:[DataTablesBehavior, StyleScopeBehavior, ModernizrBehavior, TranslationsBehavior], properties:{namespace:{type:String}}, observers:["taskListModeSelectedChanged(taskListModeSelected)", "selectionChanged(selection)"], ready:function() {
  this.entryAnimation = "slide-from-right-animation";
  this.exitAnimation = "slide-right-animation";
  this.panelBackgroundColor = "black";
  this.panelHeader = tr("tasks.table.assigned");
  this.meta = null;
  this.action = tr("tasks.table.complete");
  this.currentTask = null;
  this.pageSelected = 0;
  var subscription = channel.subscribe("route.changed", function(data) {
    if (data.route != "tasklist") {
      return;
    }
    if (this.pageSelected != 0) {
      return;
    }
    console.debug("TaskList active:" + this.taskListModeSelected);
    this.taskListModeSelectedChanged(this.taskListModeSelected == 0 ? 0 : 1);
  }.bind(this));
}, attached:function() {
  this.meta = this.getMeta();
  this.taskListModeSelected = 1;
}, startTask:function(e) {
  console.log("startTask:", this.selection[0]);
  var task = this.selection[0];
  task.fromTaskList = true;
  var self = this;
  this.$.processController.showForm(task, function() {
    self.async(function() {
      self.pageSelected = 0;
      self.taskListModeSelectedChanged(this.taskListModeSelected == 0 ? 0 : 1);
    }, 50);
  });
  this.async(function() {
    self.pageSelected = 1;
  }, 200);
}, selectionChanged:function() {
  var sel = this.selection[0];
  this.currentTask = sel.processName + " / " + sel.name;
}, taskListModeSelectedChanged:function(e) {
  this.action = e == 1 ? tr("tasks.task.complete") : tr("tasks.task.claim");
  this.panelHeader = e == 1 ? tr("tasks.table.assigned") : tr("tasks.table.not_assigned");
  var dataSet = this.getTasks(e == 1 ? "assigned" : "notassigned");
  this.data = dataSet;
  this.currentTask = null;
}, getCurrentTaskDescription:function() {
  return this.action + " (" + this.currentTask + ")";
}, getMeta:function() {
  var colHds = [];
  var col = {};
  col.data = "name";
  col.title = tr("tasks.table.name");
  colHds.push(col);
  var col = {};
  col.data = "processName";
  col.title = tr("tasks.table.processName");
  colHds.push(col);
  var col = {};
  col.data = "processTenantId";
  col.title = tr("tasks.table.processCategory");
  colHds.push(col);
  var col = {};
  col.data = "id";
  col.title = tr("tasks.table.taskid");
  colHds.push(col);
  var col = {};
  col.data = "processInstanceId";
  col.title = tr("tasks.table.processInstanceId");
  colHds.push(col);
  var col = {};
  col.data = "description";
  col.title = tr("tasks.table.description");
  colHds.push(col);
  var col = {};
  col.data = "createTime";
  col.title = tr("tasks.table.time");
  colHds.push(col);
  return colHds;
}, getTasks:function(what) {
  this.userid = simpl4.util.BaseManager.getUser();
  var self = this;
  var completed = function(map) {
    var rows = [];
    var data = map["data"];
    for (var row = 0; row < data.length; row++) {
      var rmap = data[row];
      if (rmap.assignee == null) {
        rmap["assigned"] = tr("tasks.table.not_assigned");
        rmap["action"] = tr("tasks.table.claim");
      } else {
        rmap["assigned"] = rmap.assignee;
        rmap["action"] = tr("tasks.table.complete");
      }
      rows.push(rmap);
    }
    self.dataSet = rows;
    return rows;
  };
  try {
    var queryParams = {assignee:this.userid, tenantId:this.namespace};
    if (what == "notassigned") {
      queryParams = {candidate:this.userid, tenantId:this.namespace};
    }
    var result = simpl4.util.Rpc.rpcSync("process:getTasks", {queryParams:queryParams, listParams:{size:1000}});
    return completed.call(this, result);
  } catch (e) {
    console.log("Tasks.getTasks:", e);
    alert("Tasks.getTasks:" + e);
    return;
  }
}});
DmnFieldBehavior = {behaviors:[Polymer.IronFormElementBehavior, Polymer.IronControlState], observers:["setValue(value)", "expressionValueChanged(expressionValue)"], attached:function() {
  this.appendItems();
}, focus:function() {
  this.$.expressionInput.focus();
}, appendItems:function() {
  var items = this.items;
  var select = this.$.operationSelect;
  while (select.firstChild) {
    select.removeChild(select.firstChild);
  }
  for (var i = 0; i < items.length; i++) {
    var item = items[i];
    var option = document.createElement("option");
    var label = document.createTextNode(item.label);
    option.value = item.value;
    Polymer.dom(option).appendChild(label);
    Polymer.dom(select).appendChild(option);
  }
}, expressionValueChanged:function() {
  if (!this.value) {
    this.value = {};
  }
  this.value.expr = this.expressionValue;
}, operationValueChanged:function() {
  this.operationValue = this.$.operationSelect.value;
  if (!this.value) {
    this.value = {};
  }
  this.value.op = this.operationValue;
}, setValue:function(v) {
  if (v) {
    this.async(function() {
      this.$.operationSelect.value = this.getOp(v.op);
      this.expressionValue = v.expr;
    }, 10);
  } else {
    this.async(function() {
      this.$.operationSelect.value = this.getOp(null);
    }, 10);
  }
}, getValue:function() {
  var v = {op:this.operationValue, expr:this.expressionValue};
  return v;
}, getOp:function(op) {
  var ret = op || this.items[0].value;
  return ret;
}};
Polymer({is:"dmn-string", behaviors:[DmnFieldBehavior], ready:function() {
  this.items = [{value:"=", label:"="}, {value:"==~", label:"==~"}, {value:"startsWith", label:"startsWith"}, {value:"endsWith", label:"endsWith"}, {value:"contains", label:"contains"}, {value:"equalsIgnoreCase", label:"equalsIgnoreCase"}];
}});
Polymer({is:"dmn-integer", behaviors:[DmnFieldBehavior], ready:function() {
  this.items = [{value:"=", label:"="}, {value:">", label:">"}, {value:"<", label:"<"}, {value:">=", label:">="}, {value:"<=", label:"<="}];
}});
Polymer({is:"dmn-date", behaviors:[DmnFieldBehavior], ready:function() {
  this.items = [{value:"=", label:"="}, {value:">", label:">"}, {value:"<", label:"<"}];
}});
Polymer({is:"dmn-list", behaviors:[DmnFieldBehavior], ready:function() {
  this.items = [{value:"oneOf", label:"oneOf"}, {value:"notOneOf", label:"notOneOf"}];
}});
Polymer({is:"dmn-paramdialog", behaviors:[DialogBehavior, TranslationsBehavior], onTap:function() {
  if (this.$.formId.validate()) {
    console.log("val");
    var data = this.$.formId.getData();
    console.log("fire:" + this.type + "paramdialog-ok");
    this.fire(this.type + "paramdialog-ok", {index:this.index, data:data});
  }
}, close:function(msg) {
  this.destroyDialog(this.$.dialogId);
}, open:function(type, index) {
  this.formname = "dmn" + type + ".form";
  this.type = type;
  this.index = index;
  if ("input" === this.type) {
    this.icon = "icons:file-download";
  } else {
    this.icon = "icons:file-upload";
  }
  this.$.formId.setData({});
  this.openDialog(this.$.dialogId, "inherit");
}});
Polymer({is:"dmn-testdialog", behaviors:[DialogBehavior, TranslationsBehavior], isBoolean:function(item) {
  return item.variableType == "boolean";
}, isString:function(item) {
  return item.variableType != "boolean" && item.realType != "date";
}, isDate:function(item) {
  return item.realType == "date";
}, onTest:function() {
  var variables = {};
  for (var i = 0; i < this.decision.columns.conditions.length; i++) {
    var cond = this.decision.columns.conditions[i];
    var f = this.inputArea.querySelector("#" + cond.variableName);
    var val = f.getValue();
    var def = null;
    if (cond.variableType == "string") {
      def = "";
    }
    if (val == null) {
      val = def;
    }
    if (cond.realType == "date") {
      variables[cond.variableName] = moment(val).valueOf();
    } else {
      if (cond.variableType == "integer") {
        variables[cond.variableName] = parseInt(val);
      } else {
        if (cond.variableType == "double") {
          variables[cond.variableName] = parseFloat(val);
        } else {
          variables[cond.variableName] = val;
        }
      }
    }
  }
  console.log("variables:", variables);
  this.doTest(variables);
}, doTest:function(variables) {
  var decision = this.decision;
  var variables = variables;
  var params = {service:"dmn", method:"executeDecision", parameter:{namespace:"mdm", variables:variables, decisionString:JSON.stringify(decision)}, async:true, context:this, failed:function(e) {
    console.error("executeDecision:", e);
    if (e == null) {
      return;
    }
    this.$.toastId.show(tr("error"), "error", "10000");
    try {
      if (e.message.indexOf("MultipleCompilationErrors") > 0) {
        this.testResult = e.message.substring(this.getPosition(e.message, ":", 5) + 1);
      } else {
        this.testResult = e.message.substring(this.getPosition(e.message, ":", 2) + 1);
      }
    } catch (e$9) {
    }
  }, completed:function(ret) {
    console.log("executeDecision.ret:", ret);
    this.$.toastId.show(tr("Test ok"), "success", "10000");
    var res = {vars:variables, result:ret};
    var json = JSON.stringify(res, null, 2);
    this.testResult = json.substr(2, json.length - 3);
  }};
  simpl4.util.Rpc.rpcAsync(params);
}, getPosition:function(s, sub, index) {
  return s.split(sub, index).join(sub).length;
}, onClose:function() {
  this.destroyDialog(this.$.dialogId);
}, open:function(decision) {
  this.decision = decision;
  this.inputArea = this.$.inputAreaId;
  this.openDialog(this.$.dialogId, "inherit");
}});
(function() {
  var GridEdit, root, indexOf = [].indexOf || function(item) {
    for (var i = 0, l = this.length; i < l; i++) {
      if (i in this && this[i] === item) {
        return i;
      }
    }
    return -1;
  };
  GridEdit = function() {
    function GridEdit(config1, actionStack1) {
      var cell, key, ref, value;
      this.config = config1;
      this.actionStack = actionStack1;
      this.dirtyCells = [];
      this.dirtyRows = [];
      this.copiedGridChange = this.config.copiedGridChange;
      this.uniqueValueKey = this.config.uniqueValueKey;
      this.rowIndex = this.config.rowIndex;
      this.useFixedHeaders = this.config.useFixedHeaders;
      this.element = this.config.element, this.contextMenu = new GridEdit.ContextMenu(this);
      this.themeName = this.config.themeName;
      this.customTheme = this.config.themeTemplate;
      this.theme = new GridEdit.Theme(this.themeName, this.customTheme);
      this.draggingRow = null;
      this.lastDragOver = null;
      this.lastDragOverIsBeforeFirstRow = false;
      this.lastClickCell = null;
      this.headers = [];
      this.rows = [];
      this.subtotalRows = [];
      this.cols = [];
      this.source = this.config.rows;
      this.redCells = [];
      this.activeCells = [];
      this.copiedCells = null;
      this.selectionStart = null;
      this.selectionEnd = null;
      this.selectedCol = null;
      this.openCell = null;
      this.state = "ready";
      this.mobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      this.topOffset = !this.config.topOffset ? 0 : this.config.topOffset;
      if (this.config.custom) {
        ref = this.config.custom;
        for (key in ref) {
          value = ref[key];
          if (key in this.config.custom) {
            this.set(key, value);
          }
        }
        delete this.config.custom;
      }
      if (this.config.initialize) {
        this.init();
      }
      if (!this.actionStack) {
        this.actionStack = new GridEdit.ActionStack(this);
      }
      if (this.config.selectedCell) {
        cell = this.getCell(this.config.selectedCell[0], this.config.selectedCell[1]);
        if (cell) {
          cell.makeActive();
        }
        this.config.selectedCell = void 0;
      }
    }
    GridEdit.prototype.init = function() {
      if (this.config.beforeInit) {
        this.config.beforeInit();
      }
      GridEdit.Hook.prototype.initTableHooks(this);
      this.build();
      this.events();
      this.render();
      this.removeBrowserHighlighting();
      if (!this.rowIndex) {
        this.setRowIndexes();
      }
      if (this.config.afterInit) {
        this.config.afterInit();
      }
    };
    GridEdit.prototype.setRowIndexes = function() {
      var i, j, len, ref, row, rowIndex, uniqueValueKey;
      if (!this.config.uniqueValueKey) {
        return false;
      }
      rowIndex = {};
      uniqueValueKey = this.config.uniqueValueKey;
      ref = this.source;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        row = ref[i];
        rowIndex[i] = row[uniqueValueKey];
      }
      return this.rowIndex = rowIndex;
    };
    GridEdit.prototype.removeBrowserHighlighting = function() {
      var j, len, results, styleToSet, stylesToSet;
      stylesToSet = ["-webkit-touch-callout", "-webkit-user-select", "-khtml-user-select", "-moz-user-select", "-ms-user-select", "user-select"];
      results = [];
      for (j = 0, len = stylesToSet.length; j < len; j++) {
        styleToSet = stylesToSet[j];
        results.push(this.tableEl.style[styleToSet] = "none");
      }
      return results;
    };
    GridEdit.prototype.build = function() {
      var col, colAttributes, ge, handleHeader, i, j, k, len, len1, ref, ref1, row, rowAttributes, rowType, table, tbody, tr;
      tr = document.createElement("tr");
      if (this.config.includeRowHandles) {
        handleHeader = document.createElement("th");
        tr.appendChild(handleHeader);
      }
      ref = this.config.cols;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        colAttributes = ref[i];
        col = new GridEdit.Column(colAttributes, this);
        this.cols.push(col);
        tr.appendChild(col.element);
      }
      this.thead = document.createElement("thead");
      ge = this;
      this.thead.ondragenter = function() {
        var prevRow;
        ge.lastDragOverIsBeforeFirstRow = true;
        prevRow = ge.lastDragOver;
        if (prevRow) {
          prevRow.element.style.borderBottom = prevRow.oldBorderBottom;
          return prevRow.element.style.borderTop = ge.theme.borders.dragBorderStyle;
        }
      };
      this.thead.ondragleave = function() {
        var firstRow;
        firstRow = ge.rows[0];
        return firstRow.element.style.borderTop = firstRow.oldBorderTop;
      };
      this.thead.appendChild(tr);
      tbody = document.createElement("tbody");
      ref1 = this.source;
      for (i = k = 0, len1 = ref1.length; k < len1; i = ++k) {
        rowAttributes = ref1[i];
        switch(rowAttributes.gridEditRowType) {
          case "static":
            row = new GridEdit.StaticRow(rowAttributes, this);
            break;
          case "subtotal":
            row = new GridEdit.SubTotalRow(rowAttributes, this);
            break;
          case "heading":
            row = new GridEdit.HeaderRow(rowAttributes, this);
            break;
          case "custom":
            rowType = rowAttributes.customClassName || "GenericRow";
            row = new GridEdit[rowType](rowAttributes, this);
            break;
          default:
            row = new GridEdit.GenericRow(rowAttributes, this);
        }
        this.rows.push(row);
        tbody.appendChild(row.element);
      }
      table = document.createElement("table");
      GridEdit.Utilities.prototype.setAttributes(table, {id:"editable-grid", "class":this.config.tableClass});
      table.appendChild(this.thead);
      table.appendChild(tbody);
      this.tableEl = table;
      if (this.useFixedHeaders) {
        this.element.style.overflowY = "scroll";
        GridEdit.Utilities.prototype.fixHeaders(this);
        return window.addEventListener("resize", function() {
          return GridEdit.Utilities.prototype.fixHeaders(ge);
        });
      }
    };
    GridEdit.prototype.rebuild = function(newConfig) {
      var actionStack, config, optionKey, optionValue;
      if (newConfig == null) {
        newConfig = null;
      }
      this.contextMenu.hide();
      config = Object.create(this.config);
      config.rowIndex = this.rowIndex;
      if (newConfig !== null) {
        for (optionKey in newConfig) {
          optionValue = newConfig[optionKey];
          config[optionKey] = newConfig[optionKey];
        }
      }
      config.copiedGridChange = this.copiedGridChange;
      actionStack = this.actionStack;
      this.destroy();
      return this.constructor(config, actionStack);
    };
    GridEdit.prototype.hideControl = function() {
      if (this.openCell) {
        return this.openCell.edit(this.openCell.control.value);
      }
    };
    GridEdit.prototype.events = function() {
      var table;
      table = this;
      document.onkeydown = function(e) {
        var action, cmd, ctrl, key, shift;
        if (table.activeCell()) {
          key = e.keyCode;
          shift = e.shiftKey;
          ctrl = e.ctrlKey;
          cmd = e.metaKey;
          if (cmd || ctrl) {
            if (key && key !== 91 && key !== 92) {
              action = table.contextMenu.actionCallbacks.byControl[key];
              if (action) {
                e.preventDefault();
                return table.contextMenu.execute(action, e);
              }
            }
          } else {
            switch(key) {
              case 8:
                if (!table.openCell) {
                  e.preventDefault();
                  table["delete"]();
                }
                break;
              case 9:
                e.preventDefault();
                if (shift) {
                  return table.moveTo(table.previousCell());
                } else {
                  return table.moveTo(table.nextCell());
                }
                break;
              case 13:
                table.activeCell().onReturnKeyPress();
                break;
              case 16:
                break;
              case 32:
                if (!table.openCell) {
                  e.preventDefault();
                  table.activeCell().onSpaceKeyPress();
                }
                break;
              case 37:
                table.moveTo(table.previousCell());
                break;
              case 38:
                table.moveTo(table.aboveCell());
                break;
              case 39:
                if (!table.activeCell().isBeingEdited()) {
                  table.moveTo(table.nextCell());
                }
                break;
              case 40:
                table.moveTo(table.belowCell());
                break;
              case 46:
                if (!table.openCell) {
                  e.preventDefault();
                  table["delete"]();
                  break;
                }
                break;
              default:
                if (indexOf.call([96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111], key) >= 0) {
                  key = key - 48;
                }
                return table.openCellAndPopulateInitialValue(shift, key);
            }
          }
        }
      };
      window.onresize = function() {
        if (table.openCell) {
          return GridEdit.Utilities.prototype.setStyles(table.openCell.control, table.openCell.position());
        }
      };
      window.onscroll = function() {
        if (table.openCell) {
          return table.openCell.reposition();
        }
      };
      this.element.onscroll = function(e) {
        if (table.openCell) {
          table.openCell.reposition();
        }
        if (table.useFixedHeaders) {
          return GridEdit.Utilities.prototype.repositionFixedHeader(table);
        }
      };
      this.tableEl.oncontextmenu = function(e) {
        return false;
      };
      document.oncontextmenu = function(e) {
        if (table.contextMenu.element === e.target) {
          return false;
        }
        return true;
      };
      return document.onclick = function(e) {
        var activeCell;
        activeCell = table.firstActiveCell();
        if (!table.isDescendant(e.target || table.contextMenu.isVisible())) {
          var inPath = activeCell != null && Polymer.dom(e).path.indexOf(activeCell.control) >= 0;
          if (inPath === false) {
            if (activeCell != null ? activeCell.isBeingEdited() : void 0) {
              if (activeCell != null) {
                activeCell.edit(activeCell != null ? activeCell.control.value : void 0);
              }
            }
            GridEdit.Utilities.prototype.clearActiveCells(table);
          }
        }
        return table.contextMenu.hide();
      };
    };
    GridEdit.prototype.render = function() {
      if (this.element.hasChildNodes()) {
        this.element = this.config.element || document.querySelectorAll("#gridedit")[0];
      }
      return this.element.appendChild(this.tableEl);
    };
    GridEdit.prototype.getCell = function(x, y) {
      var e;
      try {
        return this.rows[x].cells[y];
      } catch (_error) {
        e = _error;
      }
    };
    GridEdit.prototype.set = function(key, value) {
      if (key !== void 0) {
        return this.config[key] = value;
      }
    };
    GridEdit.prototype.activeCell = function() {
      if (this.activeCells.length > 1) {
        return this.activeCells;
      } else {
        return this.activeCells[0];
      }
    };
    GridEdit.prototype.firstActiveCell = function() {
      return this.activeCells[0];
    };
    GridEdit.prototype.nextCell = function() {
      var ref;
      return (ref = this.firstActiveCell()) != null ? ref.next() : void 0;
    };
    GridEdit.prototype.previousCell = function() {
      var ref;
      return (ref = this.firstActiveCell()) != null ? ref.previous() : void 0;
    };
    GridEdit.prototype.aboveCell = function() {
      var ref;
      return (ref = this.firstActiveCell()) != null ? ref.above() : void 0;
    };
    GridEdit.prototype.belowCell = function() {
      var ref;
      return (ref = this.firstActiveCell()) != null ? ref.below() : void 0;
    };
    GridEdit.prototype.moveTo = function(toCell, fromCell) {
      var beforeCellNavigateReturnVal, direction, directionModifier, newY, oldY;
      if (toCell) {
        if (fromCell === void 0) {
          fromCell = toCell.table.firstActiveCell();
        }
        direction = toCell.table.getDirection(fromCell, toCell);
        if (toCell.beforeNavigateTo) {
          beforeCellNavigateReturnVal = toCell.beforeNavigateTo(toCell, fromCell, direction);
        }
        if (beforeCellNavigateReturnVal !== false) {
          if (!toCell.isVisible()) {
            oldY = toCell.table.activeCell().address[0];
            newY = toCell.address[0];
            directionModifier = 1;
            if (newY < oldY) {
              directionModifier = -1;
            }
            window.scrollBy(0, (toCell != null ? toCell.position().height : void 0) * directionModifier);
          }
          toCell.makeActive();
        }
      }
      return false;
    };
    GridEdit.prototype.getDirection = function(fromCell, toCell) {
      var direction, fromAddressX, fromAddressY, toAddressX, toAddressY;
      fromAddressY = fromCell.address[0];
      toAddressY = toCell.address[0];
      fromAddressX = fromCell.address[1];
      toAddressX = toCell.address[1];
      if (fromAddressY === toAddressY) {
        if (fromAddressX > toAddressX) {
          direction = "left";
        } else {
          if (fromAddressX < toAddressX) {
            direction = "right";
          } else {
            console.log("Cannot calculate direction going from cell " + fromCell.address + " to cell " + toCell.address);
          }
        }
      } else {
        if (fromAddressY > toAddressY) {
          direction = "up";
        } else {
          if (fromAddressY < toAddressY) {
            direction = "down";
          } else {
            console.log("Cannot calculate direction going from cell " + fromCell.address + " to cell " + toCell.address);
          }
        }
      }
      return direction;
    };
    GridEdit.prototype.edit = function(cell, newValue) {
      if (newValue == null) {
        newValue = null;
      }
      if (newValue !== null) {
        return cell != null ? cell.cellTypeObject.edit(newValue) : void 0;
      } else {
        cell.cellTypeObject.edit();
        return false;
      }
    };
    GridEdit.prototype["delete"] = function() {
      var cell, j, len, ref;
      ref = this.activeCells;
      for (j = 0, len = ref.length; j < len; j++) {
        cell = ref[j];
        if (cell.editable) {
          cell.value("");
        }
      }
      return true;
    };
    GridEdit.prototype.clearActiveCells = function() {
      return GridEdit.Utilities.prototype.clearActiveCells(this);
    };
    GridEdit.prototype.setSelection = function() {
      var cell, col, colRange, j, k, l, len, len1, len2, m, n, ref, ref1, ref2, ref3, ref4, results, results1, row, rowRange;
      if (this.selectionStart && this.selectionEnd && this.selectionStart !== this.selectionEnd) {
        ref = this.activeCells;
        for (j = 0, len = ref.length; j < len; j++) {
          cell = ref[j];
          cell.showInactive();
        }
        this.activeCells = [];
        rowRange = function() {
          results = [];
          for (var k = ref1 = this.selectionStart.address[0], ref2 = this.selectionEnd.address[0]; ref1 <= ref2 ? k <= ref2 : k >= ref2; ref1 <= ref2 ? k++ : k--) {
            results.push(k);
          }
          return results;
        }.apply(this);
        colRange = function() {
          results1 = [];
          for (var l = ref3 = this.selectionStart.address[1], ref4 = this.selectionEnd.address[1]; ref3 <= ref4 ? l <= ref4 : l >= ref4; ref3 <= ref4 ? l++ : l--) {
            results1.push(l);
          }
          return results1;
        }.apply(this);
        for (m = 0, len1 = rowRange.length; m < len1; m++) {
          row = rowRange[m];
          for (n = 0, len2 = colRange.length; n < len2; n++) {
            col = colRange[n];
            this.rows[row].cells[col].addToSelection();
          }
        }
      }
    };
    GridEdit.prototype.data = function() {
      var cell, data, j, k, len, len1, ref, ref1, row, rowData;
      data = [];
      ref = this.rows;
      for (j = 0, len = ref.length; j < len; j++) {
        row = ref[j];
        rowData = [];
        ref1 = row.cells;
        for (k = 0, len1 = ref1.length; k < len1; k++) {
          cell = ref1[k];
          rowData.push(cell.value());
        }
        data.push(rowData);
      }
      return data;
    };
    GridEdit.prototype.repopulate = function() {
      var cell, j, len, ref, results, row;
      ref = this.rows;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        row = ref[j];
        results.push(function() {
          var k, len1, ref1, results1;
          ref1 = row.cells;
          results1 = [];
          for (k = 0, len1 = ref1.length; k < len1; k++) {
            cell = ref1[k];
            results1.push(cell.value(cell.source[cell.valueKey] || cell.col.defaultValue, false));
          }
          return results1;
        }());
      }
      return results;
    };
    GridEdit.prototype.destroy = function() {
      var key, results;
      if (this.useFixedHeaders) {
        if (this.fixedHeader && this.fixedHeader.table && this.fixedHeader.table.parentNode) {
          document.body.removeChild(this.fixedHeader.table);
        }
      }
      this.element.removeChild(this.tableEl);
      results = [];
      for (key in this) {
        results.push(delete this[key]);
      }
      return results;
    };
    GridEdit.prototype.isDescendant = function(child) {
      var node;
      node = child.parentNode;
      while (node != null) {
        if (node === this.tableEl) {
          return true;
        }
        node = node.parentNode;
      }
      return false;
    };
    GridEdit.prototype.addToStack = function(action) {
      return this.actionStack.addAction(action);
    };
    GridEdit.prototype.undo = function() {
      return this.actionStack.undo();
    };
    GridEdit.prototype.redo = function() {
      return this.actionStack.redo();
    };
    GridEdit.prototype.moveRow = function(rowToMoveIndex, newIndex, addToStack) {
      var row;
      if (addToStack == null) {
        addToStack = true;
      }
      row = this.source[rowToMoveIndex];
      if (GridEdit.Hook.prototype.run(this, "beforeMoveRow", rowToMoveIndex, newIndex)) {
        this.source.splice(rowToMoveIndex, 1);
        this.source.splice(newIndex, 0, row);
        if (addToStack) {
          this.addToStack({type:"move-row", oldIndex:rowToMoveIndex, newIndex:newIndex});
        }
        this.rebuild({rows:this.source, initialize:true, selectedCell:[newIndex, 0]});
        this.setDirtyRows();
        return GridEdit.Hook.prototype.run(this, "afterMoveRow", rowToMoveIndex, newIndex);
      }
    };
    GridEdit.prototype.moveRows = function(rowToMoveIndex, newIndex, numRows, addToStack) {
      var endIndex, modifiedRowToMoveIndex, originalNewindex, row, source;
      if (addToStack == null) {
        addToStack = true;
      }
      if (GridEdit.Hook.prototype.run(this, "beforeMoveRows", rowToMoveIndex, newIndex)) {
        modifiedRowToMoveIndex = rowToMoveIndex;
        originalNewindex = newIndex;
        endIndex = rowToMoveIndex + numRows;
        if (newIndex > rowToMoveIndex) {
          if (newIndex < endIndex) {
            this.clearActiveCells();
            return;
          } else {
            newIndex = newIndex - numRows + 1;
          }
        } else {
          modifiedRowToMoveIndex = rowToMoveIndex + numRows - 1;
        }
        source = this.source.splice(rowToMoveIndex, numRows);
        row = source.pop();
        while (row) {
          this.source.splice(newIndex, 0, row);
          row = source.pop();
        }
        if (addToStack) {
          this.addToStack({type:"move-rows", modifiedRowToMoveIndex:modifiedRowToMoveIndex, modifiedNewIndex:newIndex, numRows:numRows, originalRowToMoveIndex:rowToMoveIndex, originalNewIndex:originalNewindex});
        }
        this.rebuild({rows:this.source, initialize:true, selectedCell:[newIndex, 0]});
        this.setDirtyRows();
        return GridEdit.Hook.prototype.run(this, "afterMoveRows", rowToMoveIndex, newIndex, numRows);
      }
    };
    GridEdit.prototype.addRow = function(index, addToStack, rowObject) {
      var c, j, len, ref, row;
      if (addToStack == null) {
        addToStack = true;
      }
      if (rowObject == null) {
        rowObject = false;
      }
      if (GridEdit.Hook.prototype.run(this, "beforeAddRow", index, rowObject)) {
        if (rowObject) {
          row = rowObject;
        } else {
          row = {};
          ref = this.cols;
          for (j = 0, len = ref.length; j < len; j++) {
            c = ref[j];
            row[c.valueKey] = c.defaultValue || "";
          }
        }
        if (index || index === 0) {
          this.source.splice(index, 0, row);
        } else {
          index = this.source.length - 1;
          this.source.push(row);
        }
        if (addToStack) {
          this.addToStack({type:"add-row", index:index, rowObject:rowObject});
        }
        this.rebuild({rows:this.source, initialize:true, selectedCell:[index, 0]});
        this.setDirtyRows();
        return GridEdit.Hook.prototype.run(this, "afterAddRow", index, rowObject);
      }
    };
    GridEdit.prototype.addRows = function(index, addToStack, rowObjects) {
      var c, i, j, k, len, len1, myIndex, ref, row, rowObject;
      if (addToStack == null) {
        addToStack = true;
      }
      if (rowObjects == null) {
        rowObjects = [];
      }
      if (GridEdit.Hook.prototype.run(this, "beforeAddRows", index, rowObjects)) {
        for (i = j = 0, len = rowObjects.length; j < len; i = ++j) {
          rowObject = rowObjects[i];
          myIndex = index + i;
          if (rowObject) {
            row = rowObject;
          } else {
            row = {};
            ref = this.cols;
            for (k = 0, len1 = ref.length; k < len1; k++) {
              c = ref[k];
              row[c.valueKey] = c.defaultValue || "";
            }
          }
          if (myIndex || myIndex === 0) {
            this.source.splice(myIndex, 0, row);
          } else {
            myIndex = this.source.length - 1;
            this.source.push(row);
          }
        }
        if (addToStack) {
          this.addToStack({type:"add-rows", index:index, rowObjects:rowObjects});
        }
        this.rebuild({rows:this.source, initialize:true, selectedCell:[index, 0]});
        this.setDirtyRows();
        return GridEdit.Hook.prototype.run(this, "afterAddRows", index, rowObjects);
      }
    };
    GridEdit.prototype.addScatteredRows = function(rowObjects) {
      var index, j, len, rowIndexes, rowObject;
      rowIndexes = Object.keys(rowObjects);
      rowIndexes = rowIndexes.sort();
      for (j = 0, len = rowIndexes.length; j < len; j++) {
        index = rowIndexes[j];
        rowObject = rowObjects[index];
        this.source.splice(index, 0, rowObject);
      }
      this.rebuild({rows:this.source, initialize:true, selectedCell:[index, 0]});
      return this.setDirtyRows();
    };
    GridEdit.prototype.insertBelow = function() {
      var cell;
      cell = this.contextMenu.getUpperLeftPasteCell();
      if (GridEdit.Hook.prototype.run(this, "beforeInsertBelow", cell)) {
        this.addRow(cell.address[0] + 1);
        this.setDirtyRows();
        return GridEdit.Hook.prototype.run(this, "afterInsertBelow", cell);
      }
    };
    GridEdit.prototype.insertAbove = function() {
      var cell;
      cell = this.contextMenu.getUpperLeftPasteCell();
      if (GridEdit.Hook.prototype.run(this, "beforeInsertAbove", cell)) {
        this.addRow(cell.address[0]);
        this.setDirtyRows();
        return GridEdit.Hook.prototype.run(this, "afterInsertAbove", cell);
      }
    };
    GridEdit.prototype.removeRow = function(index, addToStack) {
      var row, rowObject, rows;
      if (addToStack == null) {
        addToStack = true;
      }
      if (GridEdit.Hook.prototype.run(this, "beforeRemoveRow", index)) {
        rowObject = this.source[index];
        row = this.rows[index];
        rows = this.source.splice(index, 1);
        if (addToStack) {
          this.addToStack({type:"remove-row", index:index, rowObject:rowObject});
        }
        this.rebuild({rows:this.source, initialize:true, selectedCell:[index, 0]});
        this.setDirtyRows();
        return GridEdit.Hook.prototype.run(this, "afterRemoveRow", index);
      }
    };
    GridEdit.prototype.removeRows = function(rowIndexes, addToStack) {
      var index, j, len, rowObject, rowObjects;
      if (addToStack == null) {
        addToStack = true;
      }
      if (GridEdit.Hook.prototype.run(this, "beforeRemoveRows", rowIndexes)) {
        rowIndexes = rowIndexes.sort(function(a, b) {
          return b - a;
        });
        rowObjects = {};
        for (j = 0, len = rowIndexes.length; j < len; j++) {
          index = rowIndexes[j];
          rowObject = this.source[index];
          rowObjects[index] = rowObject;
          this.source.splice(index, 1);
        }
        if (addToStack) {
          this.addToStack({type:"remove-rows", rowIndexes:rowIndexes, rowObjects:rowObjects});
        }
        this.rebuild({rows:this.source, initialize:true, selectedCell:[index, 0]});
        this.setDirtyRows();
        return GridEdit.Hook.prototype.run(this, "afterRemoveRows", rowIndexes);
      }
    };
    GridEdit.prototype.selectRow = function(e, index) {
      var cmd, ctrl, currentRowIndex, diff, j, k, len, len1, ref, ref1, results, results1, row, shift;
      if (this.activeCell() && e) {
        currentRowIndex = this.activeCells[0].address[0];
        shift = e.shiftKey;
        ctrl = e.ctrlKey;
        cmd = e.metaKey;
        if (!(ctrl || cmd)) {
          GridEdit.Utilities.prototype.clearActiveCells(this);
        }
        if (shift) {
          diff = currentRowIndex - index;
          if (diff < 0) {
            ref = this.rows.slice(currentRowIndex, +index + 1 || 9e9);
            results = [];
            for (j = 0, len = ref.length; j < len; j++) {
              row = ref[j];
              results.push(row.select());
            }
            return results;
          } else {
            ref1 = this.rows.slice(index, +currentRowIndex + 1 || 9e9);
            results1 = [];
            for (k = 0, len1 = ref1.length; k < len1; k++) {
              row = ref1[k];
              results1.push(row.select());
            }
            return results1;
          }
        } else {
          row = this.rows[index];
          return row.select();
        }
      } else {
        row = this.rows[index];
        return row.select();
      }
    };
    GridEdit.prototype.calculateSubtotals = function() {
      var j, len, ref, results, row;
      ref = this.subtotalRows;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        row = ref[j];
        results.push(row.calculate());
      }
      return results;
    };
    GridEdit.prototype.openCellAndPopulateInitialValue = function(shift, key) {
      if (!this.openCell) {
        return this.activeCell().onKeyPress(GridEdit.Utilities.prototype.valueFromKey(key, shift));
      }
    };
    GridEdit.prototype.checkIfCellIsDirty = function(cell) {
      var dirtyIndex;
      dirtyIndex = this.dirtyCells.indexOf(cell);
      if (dirtyIndex === -1) {
        if (cell.isDirty()) {
          return this.dirtyCells.push(cell);
        }
      } else {
        if (!cell.isDirty()) {
          return this.dirtyCells.splice(dirtyIndex, 1);
        }
      }
    };
    GridEdit.prototype.setDirtyRows = function() {
      var ref, results, rowIndex, uniqueIdentifier, uniqueValueKey;
      if (!this.config.uniqueValueKey) {
        return false;
      }
      this.dirtyRows = [];
      uniqueValueKey = this.uniqueValueKey;
      ref = this.rowIndex;
      results = [];
      for (rowIndex in ref) {
        uniqueIdentifier = ref[rowIndex];
        if (uniqueIdentifier !== this.source[rowIndex][uniqueValueKey]) {
          results.push(this.dirtyRows.push(rowIndex));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };
    GridEdit.prototype.isDirty = function() {
      return this.dirtyRows.length > 0 || this.dirtyCells.length > 0;
    };
    GridEdit.prototype.addUndoAction = function(actionName, f) {
      return this.actionStack.addUndo(actionName, f);
    };
    GridEdit.prototype.addRedoAction = function(actionName, f) {
      return this.actionStack.addRedo(actionName, f);
    };
    return GridEdit;
  }();
  root = typeof exports !== "undefined" && exports !== null ? exports : window;
  root.GridEdit = GridEdit;
}).call(this);
(function() {
  GridEdit.ActionStack = function() {
    function ActionStack(table) {
      this.table = table;
      this.userDefinedActions = {undo:{}, redo:{}};
      this.index = -1;
      this.actions = [];
    }
    ActionStack.prototype.getCell = function(action) {
      return this.table.getCell(action.address[0], action.address[1]);
    };
    ActionStack.prototype.addAction = function(actionObject) {
      if (this.actions.length > 0 && this.index < this.actions.length - 1) {
        this.actions = this.actions.splice(0, this.index + 1);
      }
      this.actions.push(actionObject);
      return this.index++;
    };
    ActionStack.prototype.addUndo = function(actionName, f) {
      return this.userDefinedActions.undo[actionName] = f;
    };
    ActionStack.prototype.addRedo = function(actionName, f) {
      return this.userDefinedActions.redo[actionName] = f;
    };
    ActionStack.prototype.undo = function() {
      var action, cell, i, j, ref, rowIndexes;
      if (this.index > -1) {
        this.index--;
        action = this.actions[this.index + 1];
        switch(action.type) {
          case "cell-edit":
            cell = this.getCell(action);
            cell.value(action.oldValue, false);
            break;
          case "cut":
            action.grid.undo(false, false);
            break;
          case "paste-pasteGrid":
            action.pasteGrid.undo(action.x, action.y);
            break;
          case "paste-copyGrid":
            action.grid.undo(action.x, action.y);
            break;
          case "fill":
            action.grid.undo(false, false);
            break;
          case "add-row":
            this.table.removeRow(action.index, false);
            break;
          case "remove-row":
            this.table.addRow(action.index, false, action.rowObject);
            break;
          case "move-row":
            this.table.moveRow(action.newIndex, action.oldIndex, false);
            break;
          case "add-rows":
            rowIndexes = [];
            for (i = j = 0, ref = action.rowObjects.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
              rowIndexes.push(i + action.index);
            }
            this.table.removeRows(rowIndexes, false);
            break;
          case "remove-rows":
            this.table.addScatteredRows(action.rowObjects);
            break;
          case "move-rows":
            this.table.moveRows(action.modifiedNewIndex, action.modifiedRowToMoveIndex, action.numRows, false);
            break;
          default:
            return this.userDefinedActions.undo[action.type](action);
        }
      }
    };
    ActionStack.prototype.redo = function() {
      var action, cell;
      if (this.index < this.actions.length - 1) {
        this.index++;
        action = this.actions[this.index];
        switch(action.type) {
          case "cell-edit":
            cell = this.table.getCell(action.address[0], action.address[1]);
            cell.value(action.newValue, false);
            break;
          case "cut":
            action.grid.apply(false, false);
            break;
          case "paste-pasteGrid":
            action.grid.applyTo(action.pasteGrid);
            break;
          case "paste-copyGrid":
            action.grid.apply(action.x, action.y);
            break;
          case "fill":
            action.grid.apply(false, false);
            break;
          case "add-row":
            this.table.addRow(action.index, false, action.rowObject);
            break;
          case "remove-row":
            this.table.removeRow(action.index, false);
            break;
          case "move-row":
            this.table.moveRow(action.oldIndex, action.newIndex, false);
            break;
          case "add-rows":
            this.table.addRows(action.index, false, action.rowObjects);
            break;
          case "remove-rows":
            this.table.removeRows(action.rowIndexes, false);
            break;
          case "move-rows":
            this.table.moveRows(action.originalRowToMoveIndex, action.originalNewIndex, action.numRows, false);
            break;
          default:
            return this.userDefinedActions.redo[action.type](action);
        }
      }
    };
    return ActionStack;
  }();
}).call(this);
(function() {
  GridEdit.ContextMenu = function() {
    function ContextMenu(table1) {
      var action, actionName, ctrlOrCmd, i, len, ref, ref1, ref2;
      this.table = table1;
      this.active = this.table.config.includeContextMenu !== false;
      this.userDefinedActions = this.table.config.contextMenuItems;
      this.userDefinedOrder = this.table.config.contextMenuOrder;
      ctrlOrCmd = /Mac/.test(navigator.platform) ? "Cmd" : "Ctrl";
      this.actionNodes = {};
      this.actionCallbacks = {byName:{}, byControl:{}};
      this.borderedCells = [];
      this.defaultActions = {cut:{name:"Cut", shortCut:ctrlOrCmd + "+X", callback:this.cut}, copy:{name:"Copy", shortCut:ctrlOrCmd + "+C", callback:this.copy}, paste:{name:"Paste", shortCut:ctrlOrCmd + "+V", callback:this.paste}, undo:{name:"Undo", shortCut:ctrlOrCmd + "+Z", callback:this.undo}, redo:{name:"Redo", shortCut:ctrlOrCmd + "+Y", callback:this.redo}, fill:{name:"Fill", shortCut:"", hasDivider:true, callback:this.fill}, selectAll:{name:"Select All", shortCut:ctrlOrCmd + "+A", callback:this.selectAll}, 
      insertBelow:{name:"Insert Row Below", shortCut:"", callback:this.insertBelow}, insertAbove:{name:"Insert Row Above", shortCut:"", callback:this.insertAbove}, removeRow:{name:"Remove Row(s)", shortCut:"", callback:this.removeRow}};
      this.element = document.createElement("div");
      this.element.id = "gridedit-context-menu";
      this.element.style.position = "fixed";
      this.element.style.zIndex = "1040";
      this.menu = document.createElement("ul");
      GridEdit.Utilities.prototype.setAttributes(this.menu, {"class":"dmn-dropdown-menu", role:"menu", "aria-labelledby":"aria-labelledby", style:"display:block;position:static;margin-bottom:5px;"});
      if (this.active) {
        if (this.userDefinedOrder) {
          ref = this.userDefinedOrder;
          for (i = 0, len = ref.length; i < len; i++) {
            actionName = ref[i];
            if (this.userDefinedActions) {
              action = this.userDefinedActions[actionName] || this.defaultActions[actionName];
            } else {
              action = this.defaultActions[actionName];
            }
            if (action) {
              this.addAction(action);
            }
          }
        } else {
          ref1 = this.defaultActions;
          for (actionName in ref1) {
            action = ref1[actionName];
            if (this.userDefinedActions && (this.userDefinedActions[actionName] || this.userDefinedActions[actionName] === false)) {
              continue;
            }
            this.addAction(action);
          }
          ref2 = this.userDefinedActions;
          for (actionName in ref2) {
            action = ref2[actionName];
            if (this.userDefinedActions[actionName] === false) {
              continue;
            }
            this.addAction(action);
          }
        }
      }
      this.element.appendChild(this.menu);
      this.events(this);
      GridEdit.Hook.prototype.initContextMenuHooks(this);
      this;
    }
    ContextMenu.prototype.addDivider = function() {
      var divider;
      divider = document.createElement("li");
      GridEdit.Utilities.prototype.setAttributes(divider, {"class":"divider"});
      return this.menu.appendChild(divider);
    };
    ContextMenu.prototype.addAction = function(action) {
      var a, code, div, key, li, shortCut, span;
      li = document.createElement("li");
      li.setAttribute("name", action.name);
      div = document.createElement("div");
      span = document.createElement("span");
      span.textContent = action.shortCut;
      GridEdit.Utilities.prototype.setAttributes(span, {style:"float: right !important;"});
      a = document.createElement("a");
      a.textContent = action.name;
      a.setAttribute("name", action.name);
      GridEdit.Utilities.prototype.setAttributes(a, {"class":"enabled", tabIndex:"-1"});
      if (action.hasDivider) {
        this.addDivider();
      }
      a.appendChild(span);
      li.appendChild(a);
      this.actionNodes[action.name] = li;
      this.actionCallbacks.byName[action.name] = action.callback;
      shortCut = action.shortCut;
      if (shortCut) {
        if (/(ctrl|cmd)/i.test(shortCut)) {
          key = shortCut.split("+")[1];
          code = key.charCodeAt(0);
          this.actionCallbacks.byControl[code] = action.callback;
        }
      }
      return this.menu.appendChild(li);
    };
    ContextMenu.prototype.show = function(x, y, cell1) {
      var menu;
      this.cell = cell1;
      if (this.active) {
        if (this.cell && !this.cell.isActive()) {
          this.cell.makeActive();
        }
        if (this.cell) {
          this.cells = this.cell.table.activeCells;
        }
        GridEdit.Utilities.prototype.setStyles(this.element, {left:x, top:y});
        document.body.appendChild(this.element);
        menu = this.element;
        setTimeout(function() {
          var bottom, cutsBottom, cutsLeft, cutsRight, cutsTop, fitsHorizontally, fitsVertically, left, menuBounds, right, screenDimensions, top;
          menuBounds = menu.getBoundingClientRect();
          screenDimensions = GridEdit.Utilities.prototype.getScreenDimensions();
          fitsVertically = screenDimensions.height > menuBounds.height;
          cutsBottom = menuBounds.bottom > screenDimensions.height;
          cutsTop = menuBounds.top < 0;
          fitsHorizontally = screenDimensions.width > menuBounds.width;
          cutsRight = menuBounds.right > screenDimensions.width;
          cutsLeft = menuBounds.left < 0;
          if (fitsVertically) {
            menu.style.overflowY = "hidden";
            menu.style.height = "auto";
            if (cutsBottom) {
              top = menuBounds.top - (menuBounds.bottom - screenDimensions.height);
              menu.style.top = top + "px";
            }
            if (cutsTop) {
              bottom = menuBounds.bottom + Math.abs(menuBounds.top);
              menu.style.bottom = bottom + "px";
            }
          } else {
            menu.style.top = 0;
            menu.style.height = screenDimensions.height + "px";
            menu.style.overflowY = "scroll";
          }
          if (fitsHorizontally) {
            menu.style.overflowX = "hidden";
            menu.style.width = "auto";
            if (cutsRight) {
              left = menuBounds.left - (menuBounds.right - screenDimensions.width);
              menu.style.left = left + "px";
            }
            if (cutsLeft) {
              right = menuBounds.right + Math.abs(menuBounds.left);
              return menu.style.right = right + "px";
            }
          } else {
            menu.style.left = 0;
            menu.style.width = screenDimensions.width + "px";
            return menu.style.overflowX = "scroll";
          }
        }, 100);
        return false;
      }
    };
    ContextMenu.prototype.hide = function() {
      if (this.isVisible()) {
        return document.body.removeChild(this.element);
      }
    };
    ContextMenu.prototype.isVisible = function() {
      return this.element.parentNode != null;
    };
    ContextMenu.prototype.getTargetPasteCell = function() {
      return this.table.activeCells.sort(this.sortFunc)[0];
    };
    ContextMenu.prototype.sortFunc = function(a, b) {
      return a.address[0] - b.address[0];
    };
    ContextMenu.prototype.getUpperLeftPasteCell = function() {
      var cell, cells, col, i, len, lowCell, row;
      cells = this.table.activeCells;
      lowCell = cells[0];
      for (i = 0, len = cells.length; i < len; i++) {
        cell = cells[i];
        row = cell.address[0];
        col = cell.address[1];
        if (row < lowCell.address[0]) {
          lowCell = cell;
        } else {
          if (row === lowCell.address[0]) {
            if (col < lowCell.address[1]) {
              lowCell = cell;
            }
          }
        }
      }
      return lowCell;
    };
    ContextMenu.prototype.displayBorders = function() {
      if (this.table.copiedGridChange) {
        return this.table.copiedGridChange.displayBorders();
      }
    };
    ContextMenu.prototype.hideBorders = function() {
      if (this.table.copiedGridChange) {
        return this.table.copiedGridChange.removeBorders();
      }
    };
    ContextMenu.prototype.cut = function(e, table) {
      var gridChange, menu;
      menu = table.contextMenu;
      menu.hideBorders();
      table.copiedGridChange = new GridEdit.GridChange(table.activeCells);
      gridChange = new GridEdit.GridChange(table.activeCells, "ge-blank");
      gridChange.apply(false, false);
      table.addToStack({type:"cut", grid:gridChange});
      menu.displayBorders();
      return menu.hide();
    };
    ContextMenu.prototype.copy = function(e, table) {
      var menu;
      menu = table.contextMenu;
      table.copiedGridChange = new GridEdit.GridChange(table.activeCells);
      menu.displayBorders();
      return menu.hide();
    };
    ContextMenu.prototype.paste = function(e, table) {
      var cell, gridChange, gridChangeUsed, menu, pasteGridChange, x, y;
      menu = table.contextMenu;
      menu.hide();
      cell = menu.getUpperLeftPasteCell();
      gridChange = table.copiedGridChange;
      if (cell.editable && gridChange) {
        pasteGridChange = new GridEdit.GridChange(table.activeCells);
        pasteGridChange.copyValues();
        gridChangeUsed = gridChange.applyTo(pasteGridChange);
        x = cell.address[0];
        y = cell.address[1];
        if (gridChangeUsed === "pasteGrid") {
          return table.addToStack({type:"paste-pasteGrid", grid:gridChange, pasteGrid:pasteGridChange, x:x, y:y});
        } else {
          return table.addToStack({type:"paste-copyGrid", grid:gridChange, x:x, y:y});
        }
      }
    };
    ContextMenu.prototype.fill = function(e, table) {
      var cell, fillValue, gridChange, menu;
      menu = table.contextMenu;
      cell = menu.getUpperLeftPasteCell();
      fillValue = cell.value();
      gridChange = new GridEdit.GridChange(table.activeCells, fillValue);
      gridChange.apply(false, false);
      table.addToStack({type:"fill", grid:gridChange});
      return menu.hide();
    };
    ContextMenu.prototype.selectAll = function(e, table) {
      table.clearActiveCells();
      return setTimeout(function() {
        var i, len, ref, results, row;
        ref = table.rows;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          row = ref[i];
          results.push(row.select());
        }
        return results;
      }, 100);
    };
    ContextMenu.prototype.insertBelow = function(e, table) {
      return table.insertBelow();
    };
    ContextMenu.prototype.insertAbove = function(e, table) {
      return table.insertAbove();
    };
    ContextMenu.prototype.removeRow = function(e, table) {
      var cell, gridChange, i, len, ref, rows;
      gridChange = new GridEdit.GridChange(table.activeCells);
      rows = {};
      ref = gridChange.cells;
      for (i = 0, len = ref.length; i < len; i++) {
        cell = ref[i];
        rows[cell.address[0]] = true;
      }
      return table.removeRows(Object.keys(rows));
    };
    ContextMenu.prototype.undo = function(e, table) {
      return table.undo();
    };
    ContextMenu.prototype.redo = function(e, table) {
      return table.redo();
    };
    ContextMenu.prototype.toggle = function(action) {
      var classes;
      classes = this.actionNodes[action].classList;
      classes.toggle("enabled");
      return classes.toggle("disabled");
    };
    ContextMenu.prototype.execute = function(actionCallback, event) {
      var table;
      if (this.table.openCell) {
        this.table.openCell.hideControl();
      }
      if (GridEdit.Hook.prototype.run(this, "beforeContextMenuAction", event, this.table)) {
        actionCallback(event, this.table);
        table = this.table;
        setTimeout(function() {
          if (table.useFixedHeaders) {
            return GridEdit.Utilities.prototype.fixHeaders(table);
          }
        }, 100);
        return GridEdit.Hook.prototype.run(this, "afterContextMenuAction", event, this.table);
      }
    };
    ContextMenu.prototype.events = function(menu) {
      return this.element.onclick = function(e) {
        var actionName;
        actionName = e.target.getAttribute("name");
        return menu.execute(menu.actionCallbacks.byName[actionName], e);
      };
    };
    return ContextMenu;
  }();
}).call(this);
(function() {
  GridEdit.Utilities = function() {
    function Utilities() {
    }
    Utilities.prototype.setAttributes = function(el, attrs) {
      var key, results, value;
      results = [];
      for (key in attrs) {
        value = attrs[key];
        if (value) {
          results.push(el.setAttribute(key, value));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };
    Utilities.prototype.setStyles = function(el, styles) {
      var key, results, value;
      results = [];
      for (key in styles) {
        value = styles[key];
        results.push(el.style[key] = value + "px");
      }
      return results;
    };
    Utilities.prototype.clearActiveCells = function(table) {
      var activeCell, activeCells, i, index, j, len, len1, redCell, redCells;
      redCells = table.redCells;
      activeCells = table.activeCells;
      if (table.openCell) {
        table.openCell.edit(table.openCell.control.value);
      }
      if (redCells.length > 0) {
        for (index = i = 0, len = redCells.length; i < len; index = ++i) {
          redCell = redCells[index];
          if (redCell != null) {
            redCell.makeInactive();
          }
        }
        table.redCells = [];
      }
      if (activeCells.length > 0) {
        for (index = j = 0, len1 = activeCells.length; j < len1; index = ++j) {
          activeCell = activeCells[index];
          if (activeCell != null) {
            activeCell.makeInactive();
          }
          if (activeCell != null) {
            activeCell.hideControl();
          }
        }
        table.activeCells = [];
      }
      table.selectionStart = null;
      table.selectionEnd = null;
      table.contextMenu.hide();
      if (table.selectedCol) {
        return table.selectedCol.makeInactive();
      }
    };
    Utilities.prototype.capitalize = function(string) {
      return string.toLowerCase().replace(/\b./g, function(a) {
        return a.toUpperCase();
      });
    };
    Utilities.prototype.valueFromKey = function(key, shift) {
      var char;
      char = String.fromCharCode(key);
      if (shift) {
        return char;
      } else {
        return char.toLowerCase();
      }
    };
    Utilities.prototype.getScreenDimensions = function() {
      var d, e, g, w, x, y;
      w = window;
      d = document;
      e = d.documentElement;
      g = d.getElementsByTagName("body")[0];
      x = w.innerWidth || e.clientWidth || g.clientWidth;
      y = w.innerHeight || e.clientHeight || g.clientHeight;
      return {width:x, height:y};
    };
    Utilities.prototype.repositionFixedHeader = function(ge) {
      var currentTH, currentTHBounds, doc, fakeTable, fixedHeader, pageLeft;
      fixedHeader = ge.fixedHeader;
      if (fixedHeader) {
        fakeTable = fixedHeader.table;
        if (fakeTable) {
          doc = document.documentElement;
          pageLeft = (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);
          currentTH = ge.thead;
          currentTHBounds = currentTH.getBoundingClientRect();
          return fakeTable.style.left = currentTHBounds.left + pageLeft + "px";
        }
      }
    };
    Utilities.prototype.fixHeaders = function(ge) {
      clearTimeout(this.fixHeadersBuffer);
      return this.fixHeadersBuffer = setTimeout(function() {
        var backgroundColor, col, currentTH, currentTHBounds, currentTHElement, currentTHElementBounds, currentTHElements, doc, fakeTH, fakeTHead, fakeTR, fakeTable, geElement, geLeft, geTop, i, index, indexModifier, key, left, len, pageLeft, pageTop, ref, ref1, table, value;
        indexModifier = ge.config.includeRowHandles ? 1 : 0;
        currentTH = ge.thead;
        currentTHElements = currentTH.getElementsByTagName("th");
        if (ge.fixedHeader) {
          table = ge.fixedHeader.table;
          if (table && table.parentNode) {
            ge.fixedHeader.table.parentNode.removeChild(table);
          }
          backgroundColor = ge.fixedHeader.backgroundColor;
        } else {
          backgroundColor = window.getComputedStyle(currentTH).backgroundColor;
          if (backgroundColor === "rgba(0, 0, 0, 0)" || backgroundColor === "transparent") {
            backgroundColor = "white";
          }
        }
        doc = document.documentElement;
        pageLeft = (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);
        pageTop = (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);
        geElement = ge.element;
        geLeft = geElement.scrollLeft || 0;
        geTop = geElement.scrollTop || 0;
        currentTHBounds = currentTH.getBoundingClientRect();
        fakeTable = document.createElement("table");
        fakeTable.className = ge.tableEl.className + " ge-fixed-table-header";
        fakeTable.style.position = "absolute";
        fakeTable.style.top = currentTHBounds.top + pageTop + geTop + "px";
        fakeTable.style.left = currentTHBounds.left + pageLeft + geLeft + "px";
        fakeTable.style.width = currentTHBounds.width + "px";
        fakeTable.style.zIndex = 1039;
        fakeTable.style.pointerEvents = "none";
        fakeTHead = document.createElement("thead");
        fakeTHead.className = currentTH.className;
        fakeTHead.ondragenter = currentTH.ondragenter;
        fakeTHead.ondragleave = currentTH.ondragleave;
        fakeTR = document.createElement("tr");
        left = 0;
        for (index = i = 0, len = currentTHElements.length; i < len; index = ++i) {
          currentTHElement = currentTHElements[index];
          currentTHElementBounds = currentTHElement.getBoundingClientRect();
          fakeTH = document.createElement("th");
          fakeTH.innerHTML = currentTHElement.innerHTML;
          fakeTH.className = currentTHElement.className;
          fakeTH.style.position = "absolute";
          fakeTH.style.minWidth = currentTHElementBounds.width + "px";
          fakeTH.style.maxWidth = currentTHElementBounds.width + "px";
          fakeTH.style.minHeight = currentTHElementBounds.height + "px";
          fakeTH.style.maxHeight = currentTHElementBounds.height + "px";
          fakeTH.style.left = left + "px";
          fakeTH.style.backgroundColor = backgroundColor;
          fakeTH.setAttribute("col-id", index - indexModifier);
          fakeTH.onclick = function(e) {
            var col, n;
            n = this.getAttribute("col-id");
            col = ge.cols[n];
            GridEdit.Utilities.prototype.clearActiveCells(ge);
            return setTimeout(function() {
              var cell, j, len1, ref, results;
              col.makeActive();
              ref = col.cells;
              results = [];
              for (j = 0, len1 = ref.length; j < len1; j++) {
                cell = ref[j];
                results.push(cell.addToSelection());
              }
              return results;
            }, 0);
          };
          col = ge.cols[index - indexModifier];
          if (col) {
            if (col.headerStyle) {
              ref = col.headerStyle;
              for (key in ref) {
                value = ref[key];
                fakeTH.style[key] = value;
              }
            } else {
              ref1 = col.style;
              for (key in ref1) {
                value = ref1[key];
                fakeTH.style[key] = value;
              }
            }
          }
          left += currentTHElementBounds.width;
          fakeTR.appendChild(fakeTH);
        }
        fakeTHead.appendChild(fakeTR);
        fakeTable.appendChild(fakeTHead);
        document.body.appendChild(fakeTable);
        return ge.fixedHeader = {table:fakeTable, backgroundColor:backgroundColor};
      }, 100);
    };
    return Utilities;
  }();
}).call(this);
(function() {
  GridEdit.Column = function() {
    function Column(attributes, table1) {
      var format, key, ref, value;
      this.attributes = attributes;
      this.table = table1;
      this.id = this.index = this.table.cols.length;
      this.defaultValue = this.attributes.defaultValue;
      this.cellClass = this.attributes.cellClass;
      this.cells = [];
      this.element = document.createElement("th");
      this.textNode = document.createTextNode(this.attributes.label);
      this.element.appendChild(this.textNode);
      format = this.attributes.format;
      this.format = function(v) {
        if (format) {
          return format(v);
        } else {
          return v;
        }
      };
      ref = this.attributes;
      for (key in ref) {
        value = ref[key];
        this[key] = value;
      }
      delete this.attributes;
      this.applyStyle();
      this.events();
    }
    Column.prototype.applyStyle = function() {
      var results, results1, styleName;
      if (this.headerStyle) {
        results = [];
        for (styleName in this.headerStyle) {
          results.push(this.element.style[styleName] = this.headerStyle[styleName]);
        }
        return results;
      } else {
        results1 = [];
        for (styleName in this.style) {
          results1.push(this.element.style[styleName] = this.style[styleName]);
        }
        return results1;
      }
    };
    Column.prototype.next = function() {
      return this.table.cols[this.index + 1];
    };
    Column.prototype.previous = function() {
      return this.table.cols[this.index - 1];
    };
    Column.prototype.makeActive = function() {
      this.element.classList.add("active");
      return this.table.selectedCol = this;
    };
    Column.prototype.makeInactive = function() {
      this.element.classList.remove("active");
      return this.table.selectedCol = null;
    };
    Column.prototype.events = function() {
      var col, table;
      col = this;
      table = col.table;
      this.element.onclick = function(e) {
        var cell, i, len, ref, results;
        GridEdit.Utilities.prototype.clearActiveCells(table);
        col.makeActive();
        ref = col.cells;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          cell = ref[i];
          results.push(cell.addToSelection());
        }
        return results;
      };
      return this.element.onmousedown = function(e) {
        if (e.which === 3) {
          table.contextMenu.show(e.x, e.y, col.cells[0]);
          return;
        }
        return false;
      };
    };
    return Column;
  }();
}).call(this);
(function() {
  var extend = function(child, parent) {
    for (var key in parent) {
      if (hasProp.call(parent, key)) {
        child[key] = parent[key];
      }
    }
    function ctor() {
      this.constructor = child;
    }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor;
    child.__super__ = parent.prototype;
    return child;
  }, hasProp = {}.hasOwnProperty;
  GridEdit.Row = function() {
    function Row(attributes, table1) {
      var row, table;
      this.attributes = attributes;
      this.table = table1;
      this.id = this.table.rows.length;
      this.cells = [];
      this.index = this.table.rows.length;
      this.element = document.createElement("tr");
      this.cssClass = this.attributes.cssClass;
      if (this.cssClass) {
        this.element.className = this.cssClass;
      }
      this.oldBorderBottom = this.element.style.borderBottom;
      this.oldBorderTop = this.element.style.borderTop;
      this.type = this.attributes.gridEditRowType;
      this.alwaysPristine = false;
      table = this.table;
      row = this;
      this.element.ondragenter = function(e) {
        var prevRow;
        table.lastDragOverIsBeforeFirstRow = false;
        prevRow = table.lastDragOver;
        if (prevRow) {
          if (row.index !== 0 && prevRow.index === row.index) {
          } else {
            prevRow.element.style.borderBottom = row.oldBorderBottom;
            row.element.style.borderBottom = table.theme.borders.dragBorderStyle;
          }
        } else {
          row.element.style.borderBottom = table.theme.borders.dragBorderStyle;
        }
        return table.lastDragOver = row;
      };
      this.includeRowHandles = this.table.config.includeRowHandles;
      GridEdit.Utilities.prototype.setAttributes(this.element, {id:"row-" + this.id});
    }
    Row.prototype.createCell = function(value) {
      var cell, col, index, type;
      index = this.cells.length;
      col = this.table.cols[index];
      type = col.type;
      cell;
      switch(type) {
        case "string":
          cell = new GridEdit.StringCell(value, this);
          break;
        case "dmn-string":
          cell = new GridEdit.DMNStringCell(value, this, "dmn-string");
          break;
        case "dmn-integer":
          cell = new GridEdit.DMNStringCell(value, this, "dmn-integer");
          break;
        case "dmn-double":
          cell = new GridEdit.DMNStringCell(value, this, "dmn-integer");
          break;
        case "dmn-date":
          cell = new GridEdit.DMNStringCell(value, this, "dmn-date");
          break;
        case "dmn-list":
          cell = new GridEdit.DMNStringCell(value, this, "dmn-list");
          break;
        case "number":
          cell = new GridEdit.NumberCell(value, this);
          break;
        case "date":
          cell = new GridEdit.DateCell(value, this);
          break;
        case "html":
          cell = new GridEdit.HTMLCell(value, this);
          break;
        case "select":
          cell = new GridEdit.SelectCell(value, this);
          break;
        case "textarea":
          cell = new GridEdit.TextAreaCell(value, this);
          break;
        case "checkbox":
          cell = new GridEdit.CheckBoxCell(value, this);
          break;
        default:
          cell = new GridEdit.GenericCell(value, this);
          break;
      }
      return cell;
    };
    Row.prototype.below = function() {
      return this.table.rows[this.index + 1];
    };
    Row.prototype.above = function() {
      return this.table.rows[this.index - 1];
    };
    Row.prototype.select = function() {
      var cell, j, len, ref, results;
      ref = this.cells;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        cell = ref[j];
        results.push(cell.addToSelection());
      }
      return results;
    };
    Row.prototype.afterEdit = function() {
      return this.table.calculateSubtotals();
    };
    Row.prototype.addHandle = function() {
      var cell;
      if (this.includeRowHandles) {
        cell = new GridEdit.HandleCell(this);
        return this.element.appendChild(cell.element);
      }
    };
    return Row;
  }();
  GridEdit.GenericRow = function(superClass) {
    extend(GenericRow, superClass);
    function GenericRow(attributes, table1) {
      var cell, col, i, j, len, ref;
      this.attributes = attributes;
      this.table = table1;
      GenericRow.__super__.constructor.apply(this, arguments);
      this.editable = true;
      this.addHandle();
      ref = this.table.cols;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        col = ref[i];
        cell = this.createCell(this.attributes[col.valueKey]);
        this.cells.push(cell);
        this.table.cols[i].cells.push(cell);
        this.element.appendChild(cell.element);
      }
      delete this.attributes;
      this;
    }
    return GenericRow;
  }(GridEdit.Row);
  GridEdit.StaticRow = function(superClass) {
    extend(StaticRow, superClass);
    function StaticRow(attributes, table1) {
      this.attributes = attributes;
      this.table = table1;
      StaticRow.__super__.constructor.apply(this, arguments);
      this.addHandle();
      this.editable = this.attributes.editable = false;
      this.element.innerHTML = this.attributes.html;
      this.type = "static";
      delete this.attributes;
      this;
    }
    return StaticRow;
  }(GridEdit.Row);
  GridEdit.SubTotalRow = function(superClass) {
    extend(SubTotalRow, superClass);
    function SubTotalRow(attributes, table1) {
      var cell, col, i, j, len, ref, value;
      this.attributes = attributes;
      this.table = table1;
      SubTotalRow.__super__.constructor.apply(this, arguments);
      this.subtotalColumns = {};
      this.labels = this.attributes.labels;
      this.running = this.attributes.running;
      this.alwaysPristine = true;
      this.addHandle();
      ref = this.table.cols;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        col = ref[i];
        cell = new GridEdit.GenericCell("", this);
        cell.editable = false;
        if (this.labels) {
          value = this.labels[col.valueKey];
          cell.element.innerHTML = value || "";
        }
        this.cells.push(cell);
        this.table.cols[i].cells.push(cell);
        this.element.appendChild(cell.element);
        if (this.attributes.subtotal[col.valueKey]) {
          this.subtotalColumns[col.valueKey] = i;
        }
      }
      this.table.subtotalRows.push(this);
      this.calculate();
    }
    SubTotalRow.prototype.calculate = function() {
      var cell, col, index, j, k, len, len1, ref, ref1, ref2, results, row, rowIndex, start, sub, total;
      start = -1;
      if (!this.running) {
        ref = this.table.subtotalRows;
        for (j = 0, len = ref.length; j < len; j++) {
          sub = ref[j];
          rowIndex = sub.index;
          if (rowIndex < this.index && rowIndex > start) {
            start = rowIndex;
          }
        }
      }
      ref1 = this.subtotalColumns;
      results = [];
      for (col in ref1) {
        index = ref1[col];
        total = 0;
        ref2 = this.table.rows;
        for (k = 0, len1 = ref2.length; k < len1; k++) {
          row = ref2[k];
          if (!(row.index > start)) {
            continue;
          }
          if (row.index === this.index) {
            break;
          }
          if (row.type === "subtotal" || row.type === "header") {
            continue;
          }
          cell = row.cells[index];
          if (cell) {
            total += Number(cell.value());
          }
        }
        results.push(this.cells[index].value(total, false));
      }
      return results;
    };
    SubTotalRow.prototype.afterEdit = function() {
    };
    return SubTotalRow;
  }(GridEdit.Row);
  GridEdit.HeaderRow = function(superClass) {
    extend(HeaderRow, superClass);
    function HeaderRow(attributes, table1) {
      var cell, col, i, j, len, ref;
      this.attributes = attributes;
      this.table = table1;
      HeaderRow.__super__.constructor.apply(this, arguments);
      this.editable = true;
      this.addHandle();
      ref = this.table.cols;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        col = ref[i];
        cell = new GridEdit.HTMLCell(this.attributes[col.valueKey], this);
        cell.editable = true;
        this.cells.push(cell);
        this.table.cols[i].cells.push(cell);
        this.element.appendChild(cell.element);
      }
      delete this.attributes;
      this;
    }
    return HeaderRow;
  }(GridEdit.Row);
}).call(this);
(function() {
  var extend = function(child, parent) {
    for (var key in parent) {
      if (hasProp.call(parent, key)) {
        child[key] = parent[key];
      }
    }
    function ctor() {
      this.constructor = child;
    }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor;
    child.__super__ = parent.prototype;
    return child;
  }, hasProp = {}.hasOwnProperty;
  GridEdit.Cell = function() {
    function Cell(originalValue, row1) {
      this.originalValue = originalValue;
      this.row = row1;
      this.index = this.row.cells.length;
      this.id = this.row.id + "-" + this.index;
      this.address = [this.row.id, this.index];
      this.table = this.row.table;
      this.col = this.table.cols[this.index];
      this.meta = this.col;
      this.element = document.createElement("td");
    }
    Cell.prototype.initialize = function() {
      this.initEditable();
      this.initValueKey();
      this.initSource();
      this.initOriginalValue();
      this.initSourceValue();
      this.initNode();
      this.initControl();
      this.applyControlBehavior();
      this.applyEventBehavior();
      GridEdit.Hook.prototype.initCellHooks(this);
      return this.applyStyle();
    };
    Cell.prototype.initOriginalValue = function() {
      if (this.originalValue === void 0) {
        return this.originalValue = "";
      }
    };
    Cell.prototype.initSourceValue = function() {
      return this.source[this.valueKey] = this.originalValue;
    };
    Cell.prototype.initEditable = function() {
      return this.editable = this.col.editable !== false;
    };
    Cell.prototype.initValueKey = function() {
      return this.valueKey = this.col.valueKey;
    };
    Cell.prototype.initSource = function() {
      return this.source = this.table.config.rows[this.address[0]];
    };
    Cell.prototype.initControl = function() {
      return this.control = document.createElement("input");
    };
    Cell.prototype.initNode = function() {
      this.element.appendChild(document.createTextNode(this.col.format(this.originalValue)));
      if ((this.placeholder || this.col.placeholder) && !this.originalValue) {
        return this.renderPlaceholder();
      }
    };
    Cell.prototype.renderPlaceholder = function() {
      this.originalColor = this.element.style.color;
      this.element.style.color = "#ccc";
      return this.element.textContent = this.placeholder || this.col.placeholder;
    };
    Cell.prototype.showRed = function() {
      return this.showUneditable();
    };
    Cell.prototype.applyStyle = function() {
      var results, styleName;
      if (this.col.cellClass) {
        this.element.classList.add(this.col.cellClass);
      }
      if (this.col.style) {
        results = [];
        for (styleName in this.col.style) {
          results.push(this.element.style[styleName] = this.col.style[styleName]);
        }
        return results;
      }
    };
    Cell.prototype.addToSelection = function() {
      this.showActive();
      return this.table.activeCells.push(this);
    };
    Cell.prototype.removeFromSelection = function() {
      var index;
      index = this.table.activeCells.indexOf(this);
      this.table.activeCells.splice(index, 1);
      return this.showInactive();
    };
    Cell.prototype.isActive = function() {
      return this.table.activeCells.indexOf(this) !== -1;
    };
    Cell.prototype.makeActive = function(clearActiveCells) {
      var openCell;
      if (clearActiveCells == null) {
        clearActiveCells = true;
      }
      this.table.hideControl();
      if (clearActiveCells) {
        GridEdit.Utilities.prototype.clearActiveCells(this.table);
      }
      if (!this.isActive()) {
        if (GridEdit.Hook.prototype.run(this, "beforeActivate", this)) {
          this.showActive();
          this.table.activeCells.push(this);
          this.table.selectionStart = this;
          openCell = this.table.openCell;
          if (openCell) {
            openCell.edit(openCell.control.value);
          }
          return GridEdit.Hook.prototype.run(this, "afterActivate", this);
        }
      }
    };
    Cell.prototype.makeInactive = function() {
      return this.showInactive();
    };
    Cell.prototype.showActive = function() {
      if (!this.isActive()) {
        this.oldBackgroundColor = this.element.style.backgroundColor;
        return this.element.style.backgroundColor = this.table.theme.cells.activeColor;
      }
    };
    Cell.prototype.showInactive = function() {
      return this.element.style.backgroundColor = this.oldBackgroundColor || "";
    };
    Cell.prototype.showUneditable = function() {
      var cell;
      this.element.style.backgroundColor = this.table.theme.cells.uneditableColor;
      if (this.table.mobile) {
        cell = this;
        return setTimeout(function() {
          return cell.makeInactive();
        }, 1000);
      } else {
        return this.table.redCells.push(this);
      }
    };
    Cell.prototype.edit = function(value) {
      if (value == null) {
        value = null;
      }
      if (this.editable) {
        if (value !== null) {
          this.value(value);
          if (this.isBeingEdited()) {
            return this.hideControl();
          }
        } else {
          return this.showControl();
        }
      } else {
        return this.showUneditable();
      }
    };
    Cell.prototype.value = function(newValue, addToStack) {
      var currentValue, oldValue;
      if (newValue == null) {
        newValue = null;
      }
      if (addToStack == null) {
        addToStack = true;
      }
      var v = this.source[this.valueKey] || this.col.defaultValue;
      currentValue = typeof v === "object" ? JSON.parse(JSON.stringify(v)) : v;
      if (newValue !== null && newValue !== currentValue) {
        newValue = this.formatValue(newValue);
        oldValue = this.value();
        if (GridEdit.Hook.prototype.run(this, "beforeEdit", this, oldValue, newValue)) {
          if (addToStack) {
            this.table.addToStack({type:"cell-edit", oldValue:oldValue, newValue:newValue, address:this.address});
          }
          this.setValue(newValue);
          this.renderValue(newValue);
          this.row.afterEdit();
          if (this.table.useFixedHeaders) {
            GridEdit.Utilities.prototype.fixHeaders(this.table);
          }
          GridEdit.Hook.prototype.run(this, "afterEdit", this, oldValue, newValue, this.table.contextMenu.getUpperLeftPasteCell());
          this.table.checkIfCellIsDirty(this);
          return newValue;
        } else {
          return currentValue;
        }
      } else {
        return currentValue;
      }
    };
    Cell.prototype.formatValue = function(value) {
      console.trace("Cell.formatValue:", value);
      return value;
    };
    Cell.prototype.setValue = function(value) {
      return this.source[this.valueKey] = value;
    };
    Cell.prototype.select = function() {
      return this.control.select();
    };
    Cell.prototype.renderValue = function(value) {
      if ((this.placeholder || this.col.placeholder) && value === "") {
        return this.renderPlaceholder();
      } else {
        this.element.style.color = this.originalColor || "";
        return this.element.textContent = this.col.format(value);
      }
    };
    Cell.prototype.isDirty = function() {
      if (this.row.alwaysPristine) {
        return false;
      }
      return this.originalValue !== this.value();
    };
    Cell.prototype.focus = function() {
      var control;
      if (this.table.mobile) {
        return this.control.focus();
      } else {
        control = this.control;
        return setTimeout(function() {
          var pos, range;
          control.focus();
          pos = 0;
          if (control.value) {
            pos = control.value.length;
          }
          if (control.setSelectionRange) {
            return control.setSelectionRange(pos, pos);
          } else {
            if (control.createTextRange) {
              range = control.createTextRange();
              range.collapse(true);
              range.moveEnd("character", pos);
              range.moveStart("character", pos);
              return range.select();
            }
          }
        }, 0);
      }
    };
    Cell.prototype.showControl = function(value) {
      if (value == null) {
        value = null;
      }
      if (this.editable) {
        if (GridEdit.Hook.prototype.run(this, "beforeControlInit", this)) {
          this.table.contextMenu.hideBorders();
          this.renderControl();
          this.setControlValue(value);
          this.table.openCell = this;
          this.focus();
          return GridEdit.Hook.prototype.run(this, "afterControlInit", this);
        }
      } else {
        return this.showUneditable();
      }
    };
    Cell.prototype.setControlValue = function(value) {
      return this.control.value = value;
    };
    Cell.prototype.renderControl = function() {
      GridEdit.Utilities.prototype.setStyles(this.control, this.position());
      this.table.element.appendChild(this.control);
      return this.control.style.position = "absolute";
    };
    Cell.prototype.hideControl = function() {
      if (GridEdit.Hook.prototype.run(this, "beforeControlHide", this)) {
        if (this.isBeingEdited()) {
          this.control.parentNode.removeChild(this.control);
        }
        this.table.openCell = null;
        return GridEdit.Hook.prototype.run(this, "afterControlHide", this);
      }
    };
    Cell.prototype.applyControlBehavior = function() {
      var cell, table;
      cell = this;
      table = this.table;
      return this.control.onkeydown = function(e) {
        var key;
        key = e.which;
        switch(key) {
          case 13:
            return cell.edit(this.value);
          case 9:
            cell.edit(this.value);
            return table.moveTo(table.nextCell());
        }
      };
    };
    Cell.prototype.position = function() {
      var bounds;
      bounds = this.element.getBoundingClientRect();
      return {top:this.element.offsetTop, bottom:this.element.offsetTop + bounds.height, left:this.element.offsetLeft, right:this.element.offsetLeft + bounds.width, width:bounds.width, height:bounds.height};
    };
    Cell.prototype.reposition = function() {
      if (!this.table.mobile) {
        return GridEdit.Utilities.prototype.setStyles(this.control, this.position());
      }
    };
    Cell.prototype.next = function() {
      var ref;
      return this.row.cells[this.index + 1] || ((ref = this.row.below()) != null ? ref.cells[0] : void 0);
    };
    Cell.prototype.previous = function() {
      var ref;
      return this.row.cells[this.index - 1] || ((ref = this.row.above()) != null ? ref.cells[this.row.cells.length - 1] : void 0);
    };
    Cell.prototype.above = function() {
      var ref;
      return (ref = this.row.above()) != null ? ref.cells[this.index] : void 0;
    };
    Cell.prototype.below = function() {
      var ref;
      return (ref = this.row.below()) != null ? ref.cells[this.index] : void 0;
    };
    Cell.prototype.isBefore = function(cell) {
      return cell.address[0] === this.address[0] && cell.address[1] > this.address[1];
    };
    Cell.prototype.isAfter = function(cell) {
      return cell.address[0] === this.address[0] && cell.address[1] < this.address[1];
    };
    Cell.prototype.isAbove = function(cell) {
      return cell.address[0] > this.address[0] && cell.address[1] === this.address[1];
    };
    Cell.prototype.isBelow = function(cell) {
      return cell.address[0] < this.address[0] && cell.address[1] === this.address[1];
    };
    Cell.prototype.addClass = function(newClass) {
      return this.element.classList.add(newClass);
    };
    Cell.prototype.removeClass = function(classToRemove) {
      return this.element.classList.remove(classToRemove);
    };
    Cell.prototype.isBeingEdited = function() {
      if (this.control) {
        return this.control.parentNode != null;
      } else {
        return false;
      }
    };
    Cell.prototype.toggleActive = function() {
      if (this.isActive()) {
        return this.removeFromSelection();
      } else {
        return this.makeActive(false);
      }
    };
    Cell.prototype.isVisible = function() {
      var position;
      position = this.position();
      return position.top >= this.table.topOffset && position.bottom <= window.innerHeight;
    };
    Cell.prototype.onReturnKeyPress = function() {
      return this.table.moveTo(this.table.belowCell());
    };
    Cell.prototype.onSpaceKeyPress = function() {
      return this.edit();
    };
    Cell.prototype.onKeyPress = function(value) {
      return this.showControl(value);
    };
    Cell.prototype.applyEventBehavior = function() {
      var cell, doubleClickTimeout, startY, table;
      cell = this;
      table = this.table;
      doubleClickTimeout = null;
      this.element.onfocus = function(e) {
        return cell.reposition();
      };
      if (table.mobile) {
        startY = null;
        this.element.ontouchstart = function(e) {
          startY = e.changedTouches[0].clientY;
          GridEdit.Utilities.prototype.clearActiveCells(table);
          if (table.openCell) {
            return table.openCell.hideControl();
          }
        };
        return this.element.ontouchend = function(e) {
          var y;
          y = e.changedTouches[0].clientY;
          if (e.changedTouches.length < 2 && y === startY) {
            e.preventDefault();
            return cell.edit();
          }
        };
      } else {
        this.element.onclick = function(e) {
          var activateRow, c, cellFrom, cellFromCol, cellFromRow, cellToCol, cellToRow, cmd, col, ctrl, j, k, l, m, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, row, shift;
          table.contextMenu.hideBorders();
          if (table.lastClickCell === cell) {
            if (GridEdit.Hook.prototype.run(cell, "onDblClick", cell, e)) {
              table.lastClickCell = null;
              cell.showControl(cell.value());
            }
          } else {
            table.lastClickCell = cell;
            clearInterval(doubleClickTimeout);
            doubleClickTimeout = setTimeout(function() {
              return table.lastClickCell = null;
            }, 1000);
            if (GridEdit.Hook.prototype.run(cell, "onClick", cell, e)) {
              ctrl = e.ctrlKey;
              cmd = e.metaKey;
              shift = e.shiftKey;
              activateRow = function(row) {
              };
              if (cellFromCol <= cellToCol) {
                for (col = j = ref = cellFromCol, ref1 = cellToCol; ref <= ref1 ? j <= ref1 : j >= ref1; col = ref <= ref1 ? ++j : --j) {
                  c = table.getCell(row, col);
                  c.makeActive(false);
                }
              } else {
                for (col = k = ref2 = cellToCol, ref3 = cellFromCol; ref2 <= ref3 ? k <= ref3 : k >= ref3; col = ref2 <= ref3 ? ++k : --k) {
                  c = table.getCell(row, col);
                  c.makeActive(false);
                }
              }
              if (ctrl || cmd) {
                cell.toggleActive();
              }
              if (shift) {
                cellFrom = table.activeCells[0];
                cellFromRow = cellFrom.address[0];
                cellFromCol = cellFrom.address[1];
                cellToRow = cell.address[0];
                cellToCol = cell.address[1];
                if (cellFromRow <= cellToRow) {
                  for (row = l = ref4 = cellFromRow, ref5 = cellToRow; ref4 <= ref5 ? l <= ref5 : l >= ref5; row = ref4 <= ref5 ? ++l : --l) {
                    activateRow(row);
                  }
                } else {
                  for (row = m = ref6 = cellToRow, ref7 = cellFromRow; ref6 <= ref7 ? m <= ref7 : m >= ref7; row = ref6 <= ref7 ? ++m : --m) {
                    activateRow(row);
                  }
                }
              }
            }
          }
          return false;
        };
        this.element.onmousedown = function(e) {
          if (e.which === 3) {
            table.contextMenu.show(e.x, e.y, cell);
            return;
          } else {
            if (!(e.shiftKey || e.ctrlKey || e.metaKey)) {
              table.state = "selecting";
              cell.makeActive();
            }
          }
          return false;
        };
        this.element.onmouseover = function(e) {
          if (table.state === "selecting") {
            table.selectionEnd = cell;
            return table.setSelection();
          }
        };
        return this.element.onmouseup = function(e) {
          if (e.which !== 3) {
            table.selectionEnd = cell;
            table.state = "ready";
            if (!(e.metaKey || e.ctrlKey)) {
              return table.setSelection();
            }
          }
        };
      }
    };
    return Cell;
  }();
  GridEdit.StringCell = function(superClass) {
    extend(StringCell, superClass);
    function StringCell(value, row1) {
      this.row = row1;
      StringCell.__super__.constructor.apply(this, arguments);
      this.type = "string";
      this.initialize();
      this;
    }
    return StringCell;
  }(GridEdit.Cell);
  GridEdit.NumberCell = function(superClass) {
    extend(NumberCell, superClass);
    function NumberCell(value, row1) {
      this.row = row1;
      NumberCell.__super__.constructor.apply(this, arguments);
      this.type = "number";
      this.initialize();
      this;
    }
    NumberCell.prototype.focus = function() {
      var control;
      if (this.table.mobile) {
        return this.control.focus();
      } else {
        control = this.control;
        return setTimeout(function() {
          return control.focus();
        }, 0);
      }
    };
    NumberCell.prototype.initControl = function() {
      this.control = document.createElement("input");
      return this.control.type = "number";
    };
    NumberCell.prototype.normalizeValue = function(value) {
      var n;
      if (value === null || value === void 0 || value === "") {
        return null;
      } else {
        n = Number(value);
        if (isNaN(n)) {
          return null;
        } else {
          return n;
        }
      }
    };
    NumberCell.prototype.formatValue = function(newValue) {
      return this.normalizeValue(newValue);
    };
    NumberCell.prototype.setValue = function(newValue) {
      return this.source[this.valueKey] = this.normalizeValue(newValue);
    };
    return NumberCell;
  }(GridEdit.Cell);
  GridEdit.CheckBoxCell = function(superClass) {
    extend(CheckBoxCell, superClass);
    function CheckBoxCell(value, row1) {
      this.row = row1;
      CheckBoxCell.__super__.constructor.apply(this, arguments);
      this.type = "checkbox";
      this.initialize();
      this;
    }
    CheckBoxCell.prototype.initialize = function() {
      this.initEditable();
      this.initValueKey();
      this.initSource();
      this.initOriginalValue();
      this.initSourceValue();
      this.applyEventBehavior();
      GridEdit.Hook.prototype.initCellHooks(this);
      this.applyStyle();
      this.initNode();
      this.toggleable = this.editable;
      this.editable = false;
      return this.renderValue();
    };
    CheckBoxCell.prototype.initNode = function() {
      var div;
      div = document.createElement("div");
      div.style.width = "1em";
      div.style.margin = "auto";
      this.span = document.createElement("span");
      div.appendChild(this.span);
      return this.element.appendChild(div);
    };
    CheckBoxCell.prototype.edit = function() {
      return false;
    };
    CheckBoxCell.prototype.initControl = function() {
      return this.toggle();
    };
    CheckBoxCell.prototype.renderControl = function() {
      return GridEdit.Utilities.prototype.clearActiveCells(this.table);
    };
    CheckBoxCell.prototype.isBeingEdited = function() {
      return false;
    };
    CheckBoxCell.prototype.toggle = function() {
      if (this.toggleable) {
        this.value(!this.value());
        return this.setValue(this.value());
      } else {
        return this.showUneditable();
      }
    };
    CheckBoxCell.prototype.renderValue = function() {
      var disabled;
      disabled = this.toggleable ? "" : "disabled";
      if (this.value()) {
        if (this.table.theme.inputs.checkbox.checkedClassName) {
          return this.span.className = this.table.theme.inputs.checkbox.checkedClassName;
        } else {
          return this.span.innerHTML = "<input type='checkbox' " + disabled + " checked />";
        }
      } else {
        if (this.table.theme.inputs.checkbox.uncheckedClassName) {
          return this.span.className = this.table.theme.inputs.checkbox.uncheckedClassName;
        } else {
          return this.span.innerHTML = "<input type='checkbox' " + disabled + " />";
        }
      }
    };
    CheckBoxCell.prototype.applyEventBehavior = function() {
      var cell;
      CheckBoxCell.__super__.applyEventBehavior.apply(this, arguments);
      cell = this;
      return this.element.onclick = function(e) {
        cell.table.contextMenu.hideBorders();
        return cell.toggle();
      };
    };
    CheckBoxCell.prototype.onSpaceKeyPress = function() {
      return this.toggle();
    };
    return CheckBoxCell;
  }(GridEdit.Cell);
  GridEdit.DateCell = function(superClass) {
    extend(DateCell, superClass);
    function DateCell(value, row1) {
      this.row = row1;
      DateCell.__super__.constructor.apply(this, arguments);
      this.type = "date";
      this.initialize();
      this;
    }
    DateCell.prototype.initNode = function() {
      return this.element.appendChild(document.createTextNode(this.toDateString(this.originalValue)));
    };
    DateCell.prototype.initControl = function() {
      var error;
      this.control = this.toDate();
      try {
        if (this.originalValue) {
          return this.control.valueAsDate = new Date(this.originalValue);
        }
      } catch (_error) {
        error = _error;
        return this.control.value = this.toDateString(new Date(this.originalValue));
      }
    };
    DateCell.prototype.formatValue = function(newValue) {
      var error;
      if (newValue.length > 0) {
        return this.toDateString(Date.parse(newValue));
      } else {
        if (newValue instanceof Date) {
          return this.toDateString(newValue);
        } else {
          if (newValue.length === 0) {
            try {
              this.control.valueAsDate = null;
            } catch (_error) {
              error = _error;
              this.control.value = "";
            }
            return "";
          }
        }
      }
    };
    DateCell.prototype.setValue = function(newValue) {
      this.source[this.valueKey] = this.toDateObject(newValue);
      return this.setControlValue();
    };
    DateCell.prototype.setControlValue = function() {
      var error;
      try {
        return this.control.valueAsDate = this.source[this.valueKey];
      } catch (_error) {
        error = _error;
        return this.control.value = this.source[this.valueKey];
      }
    };
    DateCell.prototype.renderValue = function() {
      return this.element.textContent = this.col.format(this.toDateString(this.value()));
    };
    DateCell.prototype.toDateObject = function(passedString) {
      var datePieces;
      if (passedString == null) {
        passedString = null;
      }
      if (passedString && passedString !== "") {
        datePieces = passedString.split("-");
        return new Date(datePieces[2], datePieces[0] - 1, datePieces[1]);
      } else {
        return null;
      }
    };
    DateCell.prototype.toDateString = function(passedDate) {
      var date;
      if (passedDate == null) {
        passedDate = null;
      }
      if (passedDate && passedDate !== "") {
        date = new Date(passedDate);
      } else {
        date = this.value() ? new Date(this.value()) : null;
      }
      if (date instanceof Date) {
        if (isNaN(date.getTime())) {
          return "";
        } else {
          return ("0" + (date.getUTCMonth() + 1)).slice(-2) + "-" + ("0" + date.getUTCDate()).slice(-2) + "-" + date.getUTCFullYear();
        }
      } else {
        return "";
      }
    };
    DateCell.prototype.toDate = function() {
      var input;
      input = document.createElement("input");
      input.type = "text";
      input.value = this.toDateString();
      return input;
    };
    DateCell.prototype.toDateInputString = function(passedDate) {
      var date;
      if (passedDate == null) {
        passedDate = null;
      }
      if (passedDate && passedDate !== "") {
        date = new Date(passedDate);
      } else {
        if (this.value()) {
          date = new Date(this.value());
        } else {
          null;
        }
      }
      if (date instanceof Date) {
        return date.getUTCFullYear() + "-" + ("0" + (date.getUTCMonth() + 1)).slice(-2) + "-" + ("0" + date.getUTCDate()).slice(-2);
      } else {
        return "";
      }
    };
    return DateCell;
  }(GridEdit.Cell);
  GridEdit.HTMLCell = function(superClass) {
    extend(HTMLCell, superClass);
    function HTMLCell(value, row1) {
      this.row = row1;
      HTMLCell.__super__.constructor.apply(this, arguments);
      this.type = "html";
      this.initialize();
      this;
    }
    HTMLCell.prototype.initNode = function() {
      this.htmlContent = this.col.defaultValue || this.originalValue || "";
      return this.element.appendChild(this.toFragment());
    };
    HTMLCell.prototype.setValue = function(newValue) {
      var node;
      this.htmlContent = newValue;
      node = this.toFragment();
      this.element.innerHTML = "";
      return this.element.appendChild(node);
    };
    HTMLCell.prototype.toFragment = function() {
      var element, fragment;
      element = document.createElement("div");
      fragment = document.createDocumentFragment();
      element.innerHTML = this.htmlContent;
      fragment.appendChild(element.firstChild || document.createTextNode(""));
      return fragment;
    };
    HTMLCell.prototype.renderValue = function() {
      return this.htmlContent;
    };
    return HTMLCell;
  }(GridEdit.Cell);
  GridEdit.SelectCell = function(superClass) {
    extend(SelectCell, superClass);
    function SelectCell(value, row1) {
      this.row = row1;
      SelectCell.__super__.constructor.apply(this, arguments);
      this.type = "select";
      this.initialize();
      this;
    }
    SelectCell.prototype.initNode = function() {
      var node;
      node = document.createTextNode(this.originalValue);
      return this.element.appendChild(node);
    };
    SelectCell.prototype.setControlValue = function() {
      var cell, choice, index, j, k, len, len1, option, ref, results, subchoice;
      cell = this;
      this.control.innerHTML = "";
      ref = this.meta.choices;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        choice = ref[j];
        option = document.createElement("option");
        if (choice instanceof Array) {
          for (index = k = 0, len1 = choice.length; k < len1; index = ++k) {
            subchoice = choice[index];
            if (index === 0) {
              option.value = subchoice;
            }
            if (index === 1) {
              option.text = subchoice;
            }
          }
        } else {
          option.value = option.text = choice;
        }
        if (cell.value() === choice) {
          option.selected = true;
        }
        results.push(this.control.add(option));
      }
      return results;
    };
    SelectCell.prototype.initControl = function() {
      var cell, select;
      cell = this;
      select = document.createElement("select");
      this.control = select;
      if (!this.meta.choices) {
        console.log("There is not a 'choices' key in cell " + this.address + " and you specified that it was of type 'select'");
      }
      this.setControlValue();
      select.classList.add(this.table.theme.inputs.select.className);
      return select.onchange = function(e) {
        return cell.edit(e.target.value);
      };
    };
    SelectCell.prototype.select = function() {
      return false;
    };
    SelectCell.prototype.onSpaceKeyPress = function() {
      var control;
      this.renderControl();
      control = this.control;
      return setTimeout(function() {
        var event;
        event = document.createEvent("MouseEvents");
        event.initMouseEvent("mousedown", true, true, window);
        return control.dispatchEvent(event);
      }, 0);
    };
    SelectCell.prototype.onKeyPress = function(key) {
      var control, i, j, len, option, ref, results, startsWith;
      this.onSpaceKeyPress();
      startsWith = new RegExp("^" + key, "i");
      control = this.control;
      ref = control.options;
      results = [];
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        option = ref[i];
        if (startsWith.test(option.value)) {
          control.selectedIndex = i;
          break;
        } else {
          results.push(void 0);
        }
      }
      return results;
    };
    return SelectCell;
  }(GridEdit.Cell);
  GridEdit.TextAreaCell = function(superClass) {
    extend(TextAreaCell, superClass);
    function TextAreaCell(value, row1) {
      this.row = row1;
      TextAreaCell.__super__.constructor.apply(this, arguments);
      this.type = "textarea";
      this.initialize();
      this;
    }
    TextAreaCell.prototype.initControl = function() {
      var cell, textarea;
      cell = this;
      textarea = document.createElement("textarea");
      textarea.classList.add(this.table.theme.inputs.textarea.className);
      return this.control = textarea;
    };
    return TextAreaCell;
  }(GridEdit.Cell);
  GridEdit.DMNStringCell = function(superClass) {
    extend(DMNStringCell, superClass);
    function DMNStringCell(value, row1, type) {
      this.row = row1;
      DMNStringCell.__super__.constructor.apply(this, arguments);
      this.type = type;
      this.initialize();
      this;
    }
    DMNStringCell.prototype.initControl = function() {
      var cell, textarea;
      cell = this;
      textarea = document.createElement(this.type);
      textarea.classList.add(this.table.theme.inputs.textarea.className);
      return this.control = textarea;
    };
    DMNStringCell.prototype.format = function(v) {
      if (!v) {
        v = this.col.defaultValue;
      }
      if (v && v.op) {
        return v.op + " " + v.expr;
      }
      return null;
    };
    DMNStringCell.prototype.initNode = function() {
      this.element.appendChild(document.createTextNode(this.format(this.originalValue)));
    };
    DMNStringCell.prototype.renderValue = function(value) {
      this.element.style.color = this.originalColor || "";
      return this.element.textContent = this.format(value);
    };
    DMNStringCell.prototype.setValue = function(newValue) {
      return this.source[this.valueKey] = newValue;
    };
    return DMNStringCell;
  }(GridEdit.Cell);
  GridEdit.GenericCell = function(superClass) {
    extend(GenericCell, superClass);
    function GenericCell(value, row1) {
      this.row = row1;
      GenericCell.__super__.constructor.apply(this, arguments);
      this.type = "generic";
      this.initialize();
      this;
    }
    return GenericCell;
  }(GridEdit.Cell);
  GridEdit.HandleCell = function() {
    function HandleCell(row1) {
      var node, row, table;
      this.row = row1;
      row = this.row;
      table = row.table;
      this.element = document.createElement("td");
      this.element.setAttribute("draggable", true);
      this.element.className = table.theme.cells.handleClassName;
      node = document.createElement("div");
      node.innerHTML = "<span></span><span></span><span></span>";
      this.element.appendChild(node);
      this.element.onclick = function(e) {
        var index;
        index = row.index;
        return row.table.selectRow(e, index);
      };
      this.element.ondragstart = function() {
        var gridChange, i, j, ref, ref1;
        row.cells[0].addToSelection();
        gridChange = new GridEdit.GridChange(table.activeCells);
        for (i = j = ref = gridChange.lowRow, ref1 = gridChange.highRow; ref <= ref1 ? j <= ref1 : j >= ref1; i = ref <= ref1 ? ++j : --j) {
          table.rows[i].select();
        }
        table.contextMenu.hideBorders();
        return table.draggingRow = gridChange;
      };
      this.element.ondragend = function() {
        var insertAtIndex, lastDragOverIndex, modifier, numRows, rowToMoveIndex;
        rowToMoveIndex = table.draggingRow.lowRow;
        numRows = table.draggingRow.highRow - table.draggingRow.lowRow + 1;
        lastDragOverIndex = table.lastDragOver.index;
        modifier = 0;
        if (lastDragOverIndex === 0) {
          if (!(table.lastDragOverIsBeforeFirstRow || rowToMoveIndex === 0)) {
            modifier++;
          }
        } else {
          if (rowToMoveIndex > lastDragOverIndex) {
            modifier++;
          }
        }
        insertAtIndex = lastDragOverIndex + modifier;
        table.lastDragOver.element.style.borderBottom = table.lastDragOver.oldBorderBottom;
        table.lastDragOver.element.style.borderTop = table.lastDragOver.oldBorderTop;
        table.lastDragOver.element.style.borderTop = table.lastDragOver.oldBorderTop;
        table.lastDragOver = null;
        if (insertAtIndex !== rowToMoveIndex) {
          return table.moveRows(rowToMoveIndex, insertAtIndex, numRows, true);
        }
      };
    }
    return HandleCell;
  }();
}).call(this);
(function() {
  GridEdit.GridChange = function() {
    function GridChange(cells, value) {
      var area, cell, change, colIndex, height, k, l, len, len1, ref, ref1, rowIndex, thisChange, useBlank, width;
      this.cells = cells;
      useBlank = value === "ge-blank";
      this.changes = [];
      this.table = this.cells[0].col.table;
      this.borderStyle = this.table.theme.cells.selectionBorderStyle;
      this.highRow = 0;
      this.highCol = 0;
      ref = this.cells;
      for (k = 0, len = ref.length; k < len; k++) {
        cell = ref[k];
        rowIndex = cell.address[0];
        colIndex = cell.address[1];
        thisChange = {row:rowIndex, col:colIndex, value:useBlank ? "" : value || cell.value()};
        if (this.firstCell) {
          if (thisChange.row < this.firstCell.row) {
            this.firstCell = thisChange;
          } else {
            if (thisChange.row === this.firstCell.row) {
              if (thisChange.col < this.firstCell.col) {
                this.firstCell = thisChange;
              }
            }
          }
        } else {
          this.firstCell = thisChange;
          this.lowRow = thisChange.row;
          this.lowCol = thisChange.col;
        }
        if (thisChange.row > this.highRow) {
          this.highRow = thisChange.row;
        }
        if (thisChange.col > this.highCol) {
          this.highCol = thisChange.col;
        }
        if (thisChange.row < this.lowRow) {
          this.lowRow = thisChange.row;
        }
        if (thisChange.col < this.lowCol) {
          this.lowCol = thisChange.col;
        }
        this.changes.push(thisChange);
      }
      ref1 = this.changes;
      for (l = 0, len1 = ref1.length; l < len1; l++) {
        change = ref1[l];
        change.rowVector = change.row - this.firstCell.row;
        change.colVector = change.col - this.firstCell.col;
      }
      width = this.highCol - this.lowCol + 1;
      height = this.highRow - this.lowRow + 1;
      area = width * height;
      this.scattered = this.cells.length !== area;
    }
    GridChange.prototype.applyTo = function(gridChange) {
      var copyHeight, copyValue, copyWidth, currentX, currentY, i, j, k, l, pasteHeight, pasteWidth, ref, ref1, repeatsHeight, repeatsWidth, x, y;
      copyValue = this.changes[0].value;
      if (gridChange.scattered) {
        gridChange.fill(copyValue);
        return "pasteGrid";
      } else {
        copyWidth = this.width();
        copyHeight = this.height();
        pasteWidth = gridChange.width();
        pasteHeight = gridChange.height();
        if (pasteWidth < copyWidth || pasteHeight < copyHeight) {
          x = gridChange.firstCell.row;
          y = gridChange.firstCell.col;
          this.apply(x, y);
          return "copyGrid";
        } else {
          repeatsWidth = parseInt(pasteWidth / copyWidth);
          repeatsHeight = parseInt(pasteHeight / copyHeight);
          x = gridChange.firstCell.row;
          y = gridChange.firstCell.col;
          for (i = k = 0, ref = repeatsHeight; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
            currentX = x + i * copyHeight;
            for (j = l = 0, ref1 = repeatsWidth; 0 <= ref1 ? l < ref1 : l > ref1; j = 0 <= ref1 ? ++l : --l) {
              currentY = y + j * copyWidth;
              this.apply(currentX, currentY);
            }
          }
        }
      }
      return "pasteGrid";
    };
    GridChange.prototype.copyValues = function() {
      var cell, change, k, len, ref, results, x, y;
      x = this.firstCell.row;
      y = this.firstCell.col;
      ref = this.changes;
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        change = ref[k];
        cell = this.table.getCell(x + change.rowVector, y + change.colVector);
        if (cell && cell.editable) {
          results.push(change.oldValue = cell.value());
        } else {
          results.push(void 0);
        }
      }
      return results;
    };
    GridChange.prototype.width = function() {
      return this.highCol - this.lowCol + 1;
    };
    GridChange.prototype.height = function() {
      return this.highRow - this.lowRow + 1;
    };
    GridChange.prototype.fill = function(value) {
      var cell, change, k, len, ref, results, x, y;
      x = this.firstCell.row;
      y = this.firstCell.col;
      ref = this.changes;
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        change = ref[k];
        cell = this.table.getCell(x + change.rowVector, y + change.colVector);
        if (cell && cell.editable) {
          change.oldValue = cell.value();
          results.push(cell.value(value, false));
        } else {
          results.push(change.oldValue = "");
        }
      }
      return results;
    };
    GridChange.prototype.apply = function(x, y) {
      var cell, change, k, len, ref, results;
      if (x === false || y === false) {
        x = this.firstCell.row;
        y = this.firstCell.col;
      }
      ref = this.changes;
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        change = ref[k];
        cell = this.table.getCell(x + change.rowVector, y + change.colVector);
        if (cell && cell.editable) {
          change.oldValue = cell.value();
          results.push(cell.value(change.value, false));
        } else {
          results.push(change.oldValue = "");
        }
      }
      return results;
    };
    GridChange.prototype.undo = function(x, y) {
      var cell, change, k, len, ref, results;
      if (x === false || y === false) {
        x = this.firstCell.row;
        y = this.firstCell.col;
      }
      ref = this.changes;
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        change = ref[k];
        cell = this.table.getCell(x + change.rowVector, y + change.colVector);
        if (cell && cell.editable) {
          results.push(cell.value(change.oldValue, false));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };
    GridChange.prototype.displayBorders = function() {
      var cell, k, len, ref, results;
      ref = this.cells;
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        cell = ref[k];
        results.push(this.addBorder(cell));
      }
      return results;
    };
    GridChange.prototype.removeBorders = function() {
      var cell, k, len, ref, results;
      ref = this.cells;
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        cell = ref[k];
        results.push(cell.element.style.border = "");
      }
      return results;
    };
    GridChange.prototype.addBorder = function(cell) {
      var colIndex, rowIndex;
      rowIndex = cell.address[0];
      colIndex = cell.address[1];
      if (this.scattered) {
        return cell.element.style.border = this.borderStyle;
      } else {
        if (this.firstCell.row === this.highRow) {
          cell.element.style.borderTop = this.borderStyle;
          cell.element.style.borderBottom = this.borderStyle;
        } else {
          if (rowIndex === this.lowRow) {
            cell.element.style.borderTop = this.borderStyle;
          } else {
            if (rowIndex === this.highRow) {
              cell.element.style.borderBottom = this.borderStyle;
            }
          }
        }
        if (this.firstCell.col === this.highCol) {
          cell.element.style.borderRight = this.borderStyle;
          return cell.element.style.borderLeft = this.borderStyle;
        } else {
          if (colIndex === this.lowCol) {
            return cell.element.style.borderLeft = this.borderStyle;
          } else {
            if (colIndex === this.highCol) {
              return cell.element.style.borderRight = this.borderStyle;
            }
          }
        }
      }
    };
    return GridChange;
  }();
}).call(this);
(function() {
  GridEdit.Theme = function() {
    function Theme(themeName, customTheme) {
      this.themeName = themeName;
      switch(this.themeName) {
        case "bootstrap":
          this.apply(this.bootstrap);
          break;
        default:
          this.themeName = "default";
          this.apply(this["default"]);
          break;
      }
      if (customTheme) {
        this.themeName = this.themeName + "-custom";
        this.apply(customTheme);
      }
    }
    Theme.prototype.apply = function(theme) {
      var apply, k, results, self, v;
      self = this;
      apply = function(target, obj) {
        var k, results, v;
        results = [];
        for (k in obj) {
          v = obj[k];
          if (typeof v === "object") {
            if (!target[k]) {
              target[k] = {};
            }
            results.push(apply(target[k], v));
          } else {
            results.push(target[k] = v);
          }
        }
        return results;
      };
      results = [];
      for (k in theme) {
        v = theme[k];
        if (typeof v === "object") {
          if (!self[k]) {
            self[k] = {};
          }
          results.push(apply(self[k], v));
        } else {
          results.push(self[k] = v);
        }
      }
      return results;
    };
    Theme.prototype["default"] = {bootstrap:false, cells:{activeColor:"#F1F1F1", uneditableColor:"#FFBBB3", handleClassName:"handle", selectionBorderStyle:"2px solid blue"}, borders:{dragBorderStyle:"3px solid rgb(160, 195, 240)"}, inputs:{textarea:{className:"grid-edit"}, select:{className:"grid-edit"}, checkbox:{checkedClassName:false, uncheckedClassName:false}}};
    Theme.prototype.bootstrap = {bootstrap:true, cells:{activeColor:"#F1F1F1", uneditableColor:"#FFBBB3", handleClassName:"handle", selectionBorderStyle:"2px solid blue"}, borders:{dragBorderStyle:"3px solid rgb(160, 195, 240)"}, inputs:{textarea:{className:"form-control"}, select:{className:"form-control"}, checkbox:{checkedClassName:"glyphicon glyphicon-check", uncheckedClassName:"glyphicon glyphicon-unchecked"}}};
    return Theme;
  }();
}).call(this);
(function() {
  GridEdit.Hook = function() {
    function Hook() {
    }
    Hook.prototype.run = function(obj, hookName) {
      var arg, functionArguments, i, j, len;
      if (obj[hookName]) {
        functionArguments = [];
        for (i = j = 0, len = arguments.length; j < len; i = ++j) {
          arg = arguments[i];
          if (i < 2) {
            continue;
          }
          functionArguments.push(arg);
        }
        return obj[hookName].apply(obj, functionArguments) !== false;
      } else {
        return true;
      }
    };
    Hook.prototype.initTableHooks = function(table) {
      var config;
      config = table.config;
      table.beforeMoveRow = config.beforeMoveRow;
      table.afterMoveRow = config.afterMoveRow;
      table.beforeMoveRows = config.beforeMoveRows;
      table.afterMoveRows = config.afterMoveRows;
      table.beforeAddRow = config.beforeAddRow;
      table.afterAddRow = config.afterAddRow;
      table.beforeAddRows = config.beforeAddRows;
      table.afterAddRows = config.afterAddRows;
      table.beforeRemoveRow = config.beforeRemoveRow;
      table.afterRemoveRow = config.afterRemoveRow;
      table.beforeRemoveRows = config.beforeRemoveRows;
      table.afterRemoveRows = config.afterRemoveRows;
      table.beforeInsertBelow = config.beforeInsertBelow;
      table.afterInsertBelow = config.afterInsertBelow;
      table.beforeInsertAbove = config.beforeInsertAbove;
      return table.afterInsertAbove = config.afterInsertAbove;
    };
    Hook.prototype.initContextMenuHooks = function(contextMenu) {
      var config;
      config = contextMenu.table.config;
      contextMenu.beforeContextMenuAction = config.beforeContextMenuAction;
      return contextMenu.afterContextMenuAction = config.afterContextMenuAction;
    };
    Hook.prototype.initCellHooks = function(cell) {
      var config;
      config = cell.table.config;
      cell.beforeEdit = config.beforeEdit;
      cell.afterEdit = config.afterEdit;
      cell.beforeActivate = config.beforeCellActivate;
      cell.afterActivate = config.afterCellActivate;
      cell.beforeControlInit = config.beforeControlInit;
      cell.afterControlInit = config.afterControlInit;
      cell.beforeControlHide = config.beforeControlHide;
      cell.afterControlHide = config.afterControlHide;
      cell.beforeNavigateTo = config.beforeCellNavigateTo;
      cell.onClick = config.onCellClick;
      return cell.onDblClick = config.onCellDblClick;
    };
    return Hook;
  }();
}).call(this);
Polymer({is:"dmn-editor", properties:{regkey:{type:String}, namespace:{type:String}}, behaviors:[TranslationsBehavior, RegistryBehavior, DialogBehavior, LobiboxBehavior, StyleScopeBehavior], observers:["editValueChanged(editValue)"], attached:function() {
  this._registryAttributes = {subject:"decision", namespace:this.namespace};
  this._registryKey = "/decisions";
  this._currentRegistryName = null;
  this.cols = [];
  this.rows = [];
  var ctrlOrCmd = /Mac/.test(navigator.platform) ? "Cmd" : "Ctrl";
  var ge = new GridEdit({initialize:true, cols:this.cols, rows:this.rows, tableClass:"dmnTable", element:this.$.gridedit, includeRowHandles:true, includeContextMenu:true, onCellClick:function(e) {
  }, contextMenuOrder:["undo", "redo", "insertInput", "insertOutput", "removeColumn", "removeRow"], contextMenuItems:{insertInput:{name:tr("dmn.insertInput"), shortCut:ctrlOrCmd + "+I", callback:this.insertInput.bind(this)}, insertOutput:{name:tr("dmn.insertOutput"), shortCut:ctrlOrCmd + "+O", callback:this.insertOutput.bind(this)}, removeColumn:{name:tr("dmn.removeColumn"), shortCut:ctrlOrCmd + "+R", callback:this.removeColumn.bind(this)}, removeRow:{name:tr("dmn.removeRow"), shortCut:ctrlOrCmd + 
  "+K", callback:this.removeRow.bind(this)}}});
  ge.addUndoAction("insert-column", function(obj) {
    console.log("UndoAction:insert-column:", obj);
    this.cols.splice(obj.index, 1);
    this.gridRebuild();
  }.bind(this));
  ge.addRedoAction("insert-column", function(obj) {
    console.log("RedoAction:insert-column:", obj);
    this.cols.splice(obj.index, 0, obj.col);
    this.gridRebuild();
  }.bind(this));
  ge.addUndoAction("remove-column", function(obj) {
    console.log("UndoAction:remove-column:", obj);
    this.cols.splice(obj.index, 0, obj.col);
    this.gridRebuild();
  }.bind(this));
  ge.addRedoAction("remove-column", function(obj) {
    console.log("RedoAction:remove-column:", obj);
    this.cols.splice(obj.index, 1);
    this.gridRebuild();
  }.bind(this));
  this.gridedit = ge;
  this.async(function() {
  }, 50);
}, onInputParamDialog:function(e) {
  this.$.dmnParamDialogId.close();
  this._insertInput(e.detail.index, e.detail.data);
}, addInput:function() {
  var a = _.filter(this.cols, function(col) {
    console.log("a:", a);
    return col.kind == "input";
  }) || [];
  this.$.dmnParamDialogId.open("input", a.length);
}, insertInput:function(index) {
  var menu = this.gridedit.contextMenu;
  var index = menu.getUpperLeftPasteCell().index + 1;
  this.$.dmnParamDialogId.open("input", index);
}, _insertInput:function(index, data) {
  console.log("insertInput.index:", index + "/data:", data);
  var type = "dmn-" + data.type;
  var defaultValue = {op:data.type == "list" ? "oneOf" : "=", expr:""};
  if ("boolean" == data.type) {
    type = "checkbox";
    defaultValue = false;
  }
  var col = {defaultValue:defaultValue, kind:"input", label:"Input -> " + (data.label || data.name) + ":" + data.type, valueKey:data.name, type:type, editable:true};
  this.gridedit.addToStack({type:"insert-column", index:index, col:col});
  this.cols.splice(index, 0, col);
  this.gridRebuild();
}, removeColumn:function(e) {
  var menu = this.gridedit.contextMenu;
  var index = menu.getUpperLeftPasteCell().index;
  var delCol = this.cols.splice(index, 1)[0];
  this.gridedit.addToStack({type:"remove-column", index:index, col:delCol});
  this.gridRebuild();
}, onOutputParamDialog:function(e) {
  this.$.dmnParamDialogId.close();
  this._insertOutput(e.detail.index, e.detail.data);
}, addOutput:function() {
  this.$.dmnParamDialogId.open("output", this.cols.length);
}, insertOutput:function(index) {
  var menu = this.gridedit.contextMenu;
  var index = menu.getUpperLeftPasteCell().index + 1;
  var len = _.filter(this.cols, function(col) {
    return col.kind == "input";
  }).length || 0;
  if (index < len) {
    index = len;
  }
  this.$.dmnParamDialogId.open("output", index);
}, _insertOutput:function(index, data) {
  console.log("insertOutput.index:", index + "/data:", data);
  var col = {defaultValue:"", kind:"output", label:"Output -> " + (data.label || data.name) + ":" + data.type, valueKey:data.name, type:"string", exprType:data.type, editable:true};
  this.gridedit.addToStack({type:"insert-column", index:index, col:col});
  this.cols.splice(index, 0, col);
  this.gridRebuild();
}, addRow:function() {
  this.gridedit.addRow(this.rows.length, true);
}, removeRow:function() {
  var rows = this.gridedit.activeCell();
  if (rows == null) {
    return;
  }
  if (rows.length > 1) {
    for (var i = 0; i < rows.length; i++) {
      this.gridedit.removeRow(rows[i].row.index, true);
    }
  } else {
    this.gridedit.removeRow(rows.row.index, true);
  }
}, gridRebuild:function() {
  this.gridedit.repopulate();
  this.gridedit.rebuild({cols:this.cols});
  console.log("gridRebuild.data:", JSON.stringify(this.gridedit.data(), null, 2));
  this.refreshResize();
}, resetAll:function() {
  var rows = this.gridedit.data();
  if (rows == null) {
    return;
  }
  for (var i = 0; i < rows.length; i++) {
    this.gridedit.removeRow(0, true);
  }
}, doTest:function() {
  this.async(function() {
    var decision = this.buildDecisionJson();
    if (decision.columns.conditions.length > 0) {
      this.$.dmnTestDialogId.open(decision);
    }
  }, 50);
}, getState:function() {
  var decision = this.buildDecisionJson();
  var rows = this.gridedit.data();
  var data = {decision:decision, meta:{rows:rows, cols:this.cols}};
  console.log("getState:", data);
  return data;
}, setState:function(state) {
  this.cols = state.meta.cols;
  var rows = state.meta.rows;
  var _rows = [];
  for (var i = 0; i < rows.length; i++) {
    var _row = {};
    for (var j = 0; j < this.cols.length; j++) {
      _row[this.cols[j].valueKey] = rows[i][j];
    }
    _rows.push(_row);
  }
  this.rows = _rows;
  this.gridedit.rebuild({initialize:true, cols:this.cols, rows:this.rows});
  this.initDragTable();
}, getList:function(expr) {
  return "['" + expr.split(/,| /).join("','") + "']";
}, refreshResize:function() {
  var table = this.$.gridedit.querySelector("table.dmnTable");
  $(".rc-handle-container", $(this.$.gridedit)).remove();
  this.async(function() {
    $(table).resizableColumns({});
  }, 100);
}, initDragTable:function() {
  this.refreshResize();
  return;
  var table = this.$.gridedit.querySelector("table.dmnTable");
  var self = this;
  $(table).dragtable({placeholder:"placeholder", helperCells:":not(.footerrow td)", stop:function() {
    self.refreshResize();
  }});
  this.refreshResize();
}, buildValue:function(kind, col, cell) {
  if (kind == "output") {
    return cell;
  }
  if (col.variableType == "boolean") {
    return col.variableName + " ==  " + cell;
  }
  var op = cell.op !== "=" ? cell.op : "==";
  var expr = cell.expr;
  if (col.realType == "date") {
    console.log("Date.conv:", moment(expr).valueOf());
    return col.variableName + " " + op + " " + moment(expr).valueOf();
  }
  if (col.variableType == "list") {
    var ex = this.getList(expr) + ".contains(" + col.variableName + ")";
    console.log("List.conv:", ex);
    return op == "oneOf" ? ex : "!" + ex;
  }
  if (col.variableType == "string") {
    expr = "'" + expr + "'";
    if (/^[a-z]/i.test(op)) {
      return col.variableName + "." + op + "(" + expr + ")";
    }
  }
  return col.variableName + " " + op + " " + expr;
}, buildDecisionJson:function() {
  var rows = this.gridedit.data();
  console.log("doSave.cols:", JSON.stringify(this.cols, null, 2));
  console.log("doSave.data:", JSON.stringify(rows, null, 2));
  var columns = {};
  var conditions = [];
  var actions = [];
  columns.conditions = conditions;
  columns.actions = actions;
  for (var i = 0; i < this.cols.length; i++) {
    var col = this.cols[i];
    var c = {};
    c.operation = "expr";
    if (col.type == "checkbox") {
      c.variableType = "boolean";
    } else {
      if (col.type == "dmn-date") {
        c.variableType = "long";
        c.realType = "date";
      } else {
        c.variableType = col.kind == "input" ? col.type.substring(4) : col.type;
      }
    }
    c.variableName = col.valueKey;
    c.data = [];
    if (col.kind == "input") {
      conditions.push(c);
    } else {
      c.variableType = col.exprType ? col.exprType : col.type;
      actions.push(c);
    }
    for (var j = 0; j < rows.length; j++) {
      var value = this.buildValue(col.kind, c, rows[j][i]);
      c.data.push(value);
    }
  }
  return {columns:columns};
}, ready:function() {
}});
(function() {
  Polymer({is:"paper-collapse-item", properties:{header:String, icon:String, src:String, opened:Boolean, _toggleIcon:{type:String, computed:"_computeToggleIcon(opened)"}}, _toggleOpened:function(e) {
    var cn = this.$.contentId.children;
    if (cn && cn.length) {
      this.opened = !this.opened;
    } else {
      this.opened = false;
    }
  }, _computeToggleIcon:function(opened) {
    return opened ? "icons:expand-less" : "icons:expand-more";
  }});
})();
Polymer({is:"fade-in-slide-from-right-animation", behaviors:[Polymer.NeonAnimationBehavior], configure:function(config) {
  var node = config.node;
  this._effect = new KeyframeEffect(node, [{"transform":"translateX(100%)", "opacity":"0"}, {"transform":"translateX(50%)", "opacity":"0"}, {"transform":"none", "opacity":"1"}], this.timingFromConfig(config));
  if (config.transformOrigin) {
    this.setPrefixedProperty(node, "transformOrigin", config.transformOrigin);
  } else {
    this.setPrefixedProperty(node, "transformOrigin", "0 50%");
  }
  return this._effect;
}});
Polymer({is:"fade-out-slide-right-animation", behaviors:[Polymer.NeonAnimationBehavior], configure:function(config) {
  var node = config.node;
  this._effect = new KeyframeEffect(node, [{"transform":"none", "opacity":"1"}, {"transform":"translateX(50%)", "opacity":"1"}, {"transform":"translateX(100%)", "opacity":"0"}], this.timingFromConfig(config));
  if (config.transformOrigin) {
    this.setPrefixedProperty(node, "transformOrigin", config.transformOrigin);
  } else {
    this.setPrefixedProperty(node, "transformOrigin", "0 50%");
  }
  return this._effect;
}});
Polymer({is:"fade-in-slide-from-left-animation", behaviors:[Polymer.NeonAnimationBehavior], configure:function(config) {
  var node = config.node;
  this._effect = new KeyframeEffect(node, [{"transform":"translateX(-100%)", "opacity":"0"}, {"transform":"translateX(-50%)", "opacity":"0"}, {"transform":"none", "opacity":"1"}], this.timingFromConfig(config));
  if (config.transformOrigin) {
    this.setPrefixedProperty(node, "transformOrigin", config.transformOrigin);
  } else {
    this.setPrefixedProperty(node, "transformOrigin", "0 50%");
  }
  return this._effect;
}});
Polymer({is:"fade-out-slide-left-animation", behaviors:[Polymer.NeonAnimationBehavior], configure:function(config) {
  var node = config.node;
  this._effect = new KeyframeEffect(node, [{"transform":"none", "opacity":"1"}, {"transform":"translateX(-50%)", "opacity":"0"}, {"transform":"translateX(-100%)", "opacity":"0"}], this.timingFromConfig(config));
  if (config.transformOrigin) {
    this.setPrefixedProperty(node, "transformOrigin", config.transformOrigin);
  } else {
    this.setPrefixedProperty(node, "transformOrigin", "0 50%");
  }
  return this._effect;
}});
window.Stepper = window.Stepper || {};
Stepper.StepLabelBehavior = {properties:{icon:{type:String, computed:"_computeIcon(saved, editable)"}, opened:{type:Boolean, reflectToAttribute:true}, selectable:{type:Boolean, reflectToAttribute:true}, editable:{type:Boolean, reflectToAttribute:true}, label:{type:String, notify:true}, optional:{type:Boolean, notify:true}, saved:{type:Boolean, reflectToAttribute:true}, index:{type:Number}, stepperData:{type:Object}}, _computeIcon:function(saved, editable) {
  return saved ? editable ? "editor:mode-edit" : "done" : "";
}, _computeIsIconBadge:function(icon) {
  return icon.length > 0;
}};
Polymer({is:"step-horizontal-label", behaviors:[Stepper.StepLabelBehavior], properties:{alternativeLabel:{type:Boolean, value:false, reflectToAttribute:true}}});
Polymer({is:"step-vertical-label", properties:{canSkip:{type:Boolean}}, behaviors:[Stepper.StepLabelBehavior]});
Polymer({is:"paper-step", behaviors:[Polymer.IronValidatableBehavior, Polymer.NeonAnimatableBehavior, Polymer.PaperItemBehavior, Polymer.PaperRippleBehavior], properties:{saved:{type:Boolean, value:false, notify:true, readOnly:true}, editable:{type:Boolean, value:false}, index:{type:Number, notify:true, readOnly:true}, _previousSaved:{type:Boolean, readOnly:true}, optional:{type:Boolean, value:false}, selectable:{type:Boolean, computed:"_computeSelectable(_stepperData.linear, saved, editable, _previousSaved)", 
reflectToAttribute:true, notify:true}, disabled:{computed:"_computeDisabled(selectable)"}, label:{type:String, value:""}, opened:{type:Boolean, value:false, notify:true}, animationConfig:{readOnly:true}, entryAnimation:{readOnly:true}, exitAnimation:{readOnly:true}, vertical:{type:Boolean, readOnly:true, reflectToAttribute:true}, horizontalHigherEntryAnimation:{type:String}, horizontalHigherExitAnimation:{type:String}, horizontalLowerEntryAnimation:{type:String}, horizontalLowerExitAnimation:{type:String}, 
_alternativeLabel:{type:Boolean, readOnly:true}, _optionalText:{type:Boolean, readOnly:true}, _attrForPrimaryButtonText:{type:String, readOnly:true}, _stepper:{type:Object, readOnly:true}, _stepperData:{type:Object, readOnly:true}, _canSkip:{type:Boolean, readOnly:true}, _hasBackStep:{type:Boolean, readOnly:true}}, listeners:{"paper-step-vertical-skip-tapped":"skip", "paper-step-vertical-back-tapped":"back", "paper-step-vertical-continue-tapped":"continue", "tap":"_tapHandler"}, observers:["_toggleClassPosition(index, _stepperData.stepNumber, vertical)", 
"_updateSlideshowViewportTop(optional, _alternativeLabel, vertical)", "_verticalChange(vertical)", "_focusedChanged(receivedFocusFromKeyboard)", "_labelElementChanged(_labelElement)"], _focusedChanged:function(receivedFocusFromKeyboard) {
  if (receivedFocusFromKeyboard) {
    this.ensureRipple();
    var badge = this._rippleContainer.$.badge;
    var badgePos = badge.getBoundingClientRect();
    var rippleX = badgePos.left + 12;
    var rippleY = badgePos.top + 12;
    this._ripple.downAction({detail:{x:rippleX, y:rippleY}});
  }
  if (this.hasRipple()) {
    this._ripple.holdDown = receivedFocusFromKeyboard;
  }
}, _tapHandler:function(e) {
  var rootTarget = Polymer.dom(e).rootTarget;
  if (rootTarget !== this && rootTarget !== this._rippleContainer) {
    e.stopImmediatePropagation();
  }
}, skip:function() {
  this._stepper.progress();
}, back:function() {
  this._stepper.back();
}, save:function() {
  if ((!this.saved || this.editable) && this.validate()) {
    if (this.saved) {
      this.fire("paper-step-updated");
    } else {
      this._setSaved(true);
      this.fire("paper-step-saved");
    }
    return true;
  }
  return false;
}, continue:function() {
  if (this.save()) {
    this._stepper.progress();
    return true;
  }
  return false;
}, _updateSlideshowViewportTop:function(optional, _alternativeLabel, vertical) {
  if (!vertical) {
    this.async(function() {
      this.$$("#slideshowViewport").style.top = "100px";
      this.fire("step-horizontal-label-resize");
    }, 1);
  }
}, _toggleClassPosition:function(index, stepNumber, vertical) {
  this.async(function() {
    var stepLabel = this.$$(vertical ? "#verticalStepLabel" : "#horizontalStepLabel");
    this.toggleClass("first-step", index == 1, stepLabel);
    this.toggleClass("last-step", index == stepNumber, stepLabel);
  });
}, _updateAnimationConfig:function() {
  var animatedNode = this.$$("#contentWrapper");
  this._setAnimationConfig({"higher-step-entry":{node:animatedNode, name:this.horizontalHigherEntryAnimation}, "higher-step-exit":{node:animatedNode, name:this.horizontalHigherExitAnimation}, "lower-step-entry":{node:animatedNode, name:this.horizontalLowerEntryAnimation}, "lower-step-exit":{node:animatedNode, name:this.horizontalLowerExitAnimation}});
}, _verticalChange:function(vertical) {
  this.async(function() {
    Polymer.dom(this.$$(vertical ? "#paperStepWrapper" : "#contentWrapper")).appendChild(this.$$("content") || this.create("content"));
    this._ripple = false;
    this._rippleContainer = this.$$(vertical ? "#verticalStepLabel" : "#horizontalStepLabel");
    if (!vertical) {
      this._updateAnimationConfig();
    }
  }.bind(this));
}, _computeSelectable:function(linear, saved, editable, previousSaved) {
  return (!linear || previousSaved) && (!saved || editable) || editable && saved;
}, _computeDisabled:function(selectable) {
  return !selectable;
}, _choosePrimaryButtonText:function(_attrForPrimaryButtonText) {
  return this._stepperData[_attrForPrimaryButtonText];
}, ensureRipple:function(optTriggeringEvent) {
  if (!this.hasRipple()) {
    this._ripple = this._createRipple();
    this._ripple.noink = this.noink;
    var rippleContainer = this._rippleContainer || this.root;
    if (rippleContainer) {
      Polymer.dom(rippleContainer.root).appendChild(this._ripple);
    }
    if (optTriggeringEvent) {
      var domContainer = Polymer.dom(this._rippleContainer || this);
      var target = Polymer.dom(optTriggeringEvent).rootTarget;
      if (domContainer.deepContains(target)) {
        this._ripple.uiDownAction(optTriggeringEvent);
      }
    }
  }
}});
"use strict";
Polymer({is:"paper-stepper", behaviors:[Polymer.IronMenuBehavior, Polymer.NeonAnimationRunnerBehavior, Polymer.IronResizableBehavior], properties:{opened:{type:Boolean, computed:"_computeOpened(_selectedIndex)", observer:"_openedChanged", notify:true, reflectToAttribute:true}, alternativeLabel:{type:Boolean, value:false}, vertical:{type:Boolean, value:false, notify:true, reflectToAttribute:true}, backText:{type:String, value:"BACK"}, finishText:{type:String, value:"FINISH"}, continueText:{type:String, 
value:"CONTINUE"}, skipText:{type:String, value:"SKIP"}, optionalText:{type:String, value:"Optional"}, updateText:{type:String, value:"UPDATE"}, linear:{type:Boolean, value:false}, completed:{type:Boolean, value:false, notify:true, computed:"_computeCompleted(stepNumber, savedStepNumber)"}, hasSkipButton:{type:Boolean, value:false}, hasBackButton:{type:Boolean, value:false}, stepNumber:{type:Number, notify:true, computed:"_computeStepNumber(items.length)"}, savedStepNumber:{type:Number, notify:true, 
readOnly:true}, selectedAttribute:{value:"opened", readOnly:true}, selectable:{value:"paper-step"}, mutli:{value:false, readOnly:true}, responsiveCheckFrequence:{type:Number, value:200}, animateInitialSelection:{type:Boolean, value:false}, horizontalHigherEntryAnimation:{type:String, value:"fade-in-slide-from-right-animation"}, horizontalHigherExitAnimation:{type:String, value:"fade-out-slide-right-animation"}, horizontalLowerEntryAnimation:{type:String, value:"fade-in-slide-from-left-animation"}, 
horizontalLowerExitAnimation:{type:String, value:"fade-out-slide-left-animation"}, _skipStepIndex:{type:Number, computed:"_compute_skipStepIndex(_selectedIndex)"}, _canSkip:{type:Boolean, notify:true, computed:"_isntNull(_skipStepIndex)"}, _backStepIndex:{type:Number, computed:"_compute_backStepIndex(_selectedIndex)"}, _hasBackStep:{type:Boolean, computed:"_isntNull(_backStepIndex)"}, _selectedIndex:{type:Number, observer:"_selectedIndexChanged", readOnly:true, value:-1}, _attrForSelectedStepPrimaryButtonText:{type:String, 
computed:"_compute__attrForSelectedStepPrimaryButtonText(_selectedIndex, stepNumber)"}}, _previousAnimatedStep:null, _previousSelected:null, keyBindings:{"left":"_onLeftKey", "right":"_onRightKey"}, listeners:{"iron-items-changed":"_initializeSteps", "paper-step-saved":"_stepSaved", "transitionend":"_transitionEnd", "step-horizontal-label-resize":"_updateStepperClosedMaxHeight", "iron-resize":"_resizeHandler", "neon-animation-finish":"_onNeonAnimationFinish"}, observers:["_forwardCanSkip(_canSkip, selectedItem)", 
"_forwardHasBackStep(_hasBackStep, selectedItem)", "_forwardVertical(vertical)", "_forwardAlternativeLabel(alternativeLabel)", "_forwardStepperData(linear, backText, optionalText, finishText, continueText, skipText, updateText, hasSkipButton, hasBackButton)"], attached:function() {
  this._responsiveCheck();
}, back:function() {
  this.selectIndex(this._backStepIndex);
}, continue:function() {
  if (this.selectedItem) {
    if (this.selectedItem.save()) {
      this.progress();
    }
  }
}, progress:function() {
  if (!this.stepNumber) {
    return false;
  }
  if (this.completed) {
    this.selected = null;
    return true;
  }
  for (var i = (this._selectedIndex + 1) % this.stepNumber; i != this._selectedIndex; i = (i + 1) % this.stepNumber) {
    if (this.items[i].selectable) {
      this.selectIndex(i);
      this.fire("paper-stepper-progressed");
      return true;
    }
  }
  return false;
}, reset:function() {
  this._setSavedStepNumber(0);
  this.selected = null;
  if (!this.items.length) {
    return;
  }
  this.items.map(function(step) {
    step._setSaved(false);
    step._set_previousSaved(false);
  });
  this.items[0]._set_previousSaved(true);
}, get _isRTL() {
  return window.getComputedStyle(this)["direction"] === "rtl";
}, _onLeftKey:function(event) {
  if (this._isRTL) {
    this._focusNext();
  } else {
    this._focusPrevious();
  }
  event.detail.keyboardEvent.preventDefault();
}, _onRightKey:function(event) {
  if (this._isRTL) {
    this._focusPrevious();
  } else {
    this._focusNext();
  }
  event.detail.keyboardEvent.preventDefault();
}, _selectSelected:function(selected) {
  var item = this._valueToItem(this.selected);
  if (item) {
    var selectable = item.selectable;
    if (selectable == undefined) {
      return;
    } else {
      if (!selectable) {
        if (this._previousSelected && this._previousSelected.selectable) {
          this.selected = this._valueForItem(this._previousSelected);
        } else {
        }
        this._previousSelected = null;
        return;
      }
    }
  }
  this._selection.select(item);
  this._previousSelected = item;
  this._set_selectedIndex(this.indexOf(item));
  if (this.fallbackSelection && this.items.length && this._selection.get() === undefined) {
    this.selected = this.fallbackSelection;
  }
}, _updateStepperClosedMaxHeight:function() {
  this.debounce("updateStepperClosedMaxHeight", function() {
    this.customStyle["--label-wrapper-height"] = this.$$("#content-wrapper").clientHeight + "px";
    this.updateStyles();
  });
}, _openedChanged:function(newValue, oldValue) {
  if (!this.vertical && oldValue != undefined) {
    this.toggleClass("collapsing", true);
  }
}, _transitionEnd:function(e) {
  if (e.propertyName == "max-height") {
    this.toggleClass("collapsing", false);
  }
}, _computeOpened:function(_selectedIndex) {
  return _selectedIndex >= 0;
}, _stepSaved:function(e) {
  var previousStep = this.items[this.indexOf(e.target) + 1];
  if (previousStep) {
    previousStep._set_previousSaved(true);
  }
  this._setSavedStepNumber(this.savedStepNumber + 1);
}, _forwardVertical:function(vertical) {
  if (this.stepNumber) {
    this.items.map(function(step) {
      step._setVertical(vertical);
    });
  }
  this.setAttribute("role", vertical ? "menu" : "menubar");
}, _forwardStepperData:function(linear, backText, optionalText, finishText, continueText, skipText, updateText, hasSkipButton, hasBackButton) {
  if (this.stepNumber) {
    this.items.map(function(step) {
      step._set_stepperData({linear:linear, backText:backText, optionalText:optionalText, finishText:finishText, continueText:continueText, skipText:skipText, updateText:updateText, hasSkipButton:hasSkipButton, hasBackButton:hasBackButton, stepNumber:this.stepNumber});
    }.bind(this));
  }
}, _forwardAlternativeLabel:function(alternativeLabel) {
  if (this.stepNumber) {
    this.items.map(function(step) {
      step._set_alternativeLabel(alternativeLabel);
    });
  }
}, _computeStepNumber:function(length) {
  return length;
}, _selectedIndexChanged:function(newValue, oldValue) {
  if (!this.vertical && newValue >= 0 && oldValue >= 0) {
    var oldStep = this.items[oldValue], newStep = this.items[newValue];
    if (newStep.classList.contains("neon-animating")) {
      this.cancelAnimation();
    }
    if (this._previousAnimatedStep && this._previousAnimatedStep.classList.contains("neon-animating")) {
      this.cancelAnimation();
      this.toggleClass("neon-animating", false, this._previousAnimatedStep);
    }
    var forward = newValue - oldValue > 0;
    this.animationConfig = {"new-step-entry":{animatable:newStep, type:forward ? newStep.horizontalHigherEntryAnimation && "higher-step-entry" : newStep.horizontalLowerEntryAnimation && "lower-step-entry"}, "old-step-exit":{animatable:oldStep, type:forward ? oldStep.horizontalLowerExitAnimation && "lower-step-exit" : oldStep.horizontalHigherExitAnimation && "higher-step-exit"}};
    if (this.animationConfig["new-step-entry"].type) {
      this.playAnimation("new-step-entry", {step:newStep});
      this.toggleClass("neon-animating", true, newStep);
    }
    if (this.animationConfig["old-step-exit"].type) {
      this.playAnimation("old-step-exit", {step:oldStep});
      this.toggleClass("neon-animating", true, oldStep);
    }
    this._previousAnimatedStep = oldStep;
  }
}, _onNeonAnimationFinish:function(event) {
  var step = event.detail.step;
  if (step) {
    this.toggleClass("neon-animating", false, step);
  }
}, _forwardCanSkip:function(_canSkip, selectedItem) {
  selectedItem._set_canSkip(_canSkip);
}, _forwardHasBackStep:function(_hasBackStep, selectedItem) {
  selectedItem._set_hasBackStep(_hasBackStep);
}, _compute__attrForSelectedStepPrimaryButtonText:function(selectedIndex) {
  if (selectedIndex < 0) {
    return null;
  }
  var _attrForPrimaryButtonText = this.selectedItem.saved ? "updateText" : this.stepNumber - this.savedStepNumber == 1 ? "finishText" : "continueText";
  this.selectedItem._set_attrForPrimaryButtonText(_attrForPrimaryButtonText);
  return _attrForPrimaryButtonText;
}, _isLastStep:function(sel, ind) {
  return this.stepNumber - this.savedStepNumber == 1 && sel == ind;
}, _initializeSteps:function() {
  var savedStepNumber = 0;
  var data = {linear:this.linear, backText:this.backText, optionalText:this.optionalText, finishText:this.finishText, continueText:this.continueText, skipText:this.skipText, updateText:this.updateText, hasSkipButton:this.hasSkipButton, hasBackButton:this.hasBackButton, stepNumber:this.stepNumber};
  this.items.map(function(step, i) {
    if (this.horizontalHigherEntryAnimation && !step.horizontalHigherEntryAnimation) {
      step.horizontalHigherEntryAnimation = this.horizontalHigherEntryAnimation;
    }
    if (this.horizontalHigherExitAnimation && !step.horizontalHigherExitAnimation) {
      step.horizontalHigherExitAnimation = this.horizontalHigherExitAnimation;
    }
    if (this.horizontalLowerEntryAnimation && !step.horizontalLowerEntryAnimation) {
      step.horizontalLowerEntryAnimation = this.horizontalLowerEntryAnimation;
    }
    if (this.horizontalLowerExitAnimation && !step.horizontalLowerExitAnimation) {
      step.horizontalLowerExitAnimation = this.horizontalLowerExitAnimation;
    }
    step._setIndex(i + 1);
    step._set_stepper(this);
    step._setVertical(this.vertical);
    step._set_alternativeLabel(this.alternativeLabel);
    step._set_stepperData(data);
    step._set_previousSaved(!i);
    if (step.saved) {
      savedStepNumber++;
    }
  }.bind(this));
  this._setSavedStepNumber(savedStepNumber);
  this._updateSelected();
}, _compute_skipStepIndex:function(_selectedIndex) {
  if (_selectedIndex >= 0 && !this.completed) {
    for (var i = (_selectedIndex + 1) % this.stepNumber; i != _selectedIndex; i = (i + 1) % this.stepNumber) {
      if (this.items[i].selectable && !this.items[i].saved) {
        return i;
      }
    }
  }
  return null;
}, _compute_backStepIndex:function(_selectedIndex) {
  if (_selectedIndex >= 0) {
    for (var i = _selectedIndex - 1; i >= 0; i--) {
      if (this.items[i].selectable) {
        return i;
      }
    }
  }
  return null;
}, _isntNull:function(n) {
  return n != null;
}, _computeCompleted:function(savedStepNumber, stepNumber) {
  var completed = stepNumber == savedStepNumber;
  if (completed) {
    this.fire("paper-stepper-completed");
    return true;
  }
  return false;
}, _choosePrimaryButtonText:function(_attrForSelectedStepPrimaryButtonText) {
  return this[_attrForSelectedStepPrimaryButtonText];
}, _resizeHandler:function() {
  this.debounce("paper-stepper-responsive-check", function() {
    this._responsiveCheck();
  }, this.responsiveCheckFrequence);
}, _responsiveCheck:function() {
  var verticalResponsiveWidth = this.$.verticalResponsiveWidth.clientWidth;
  if (verticalResponsiveWidth) {
    this.vertical = !(this.clientWidth > verticalResponsiveWidth);
  }
}});
(function() {
  function _baseUrl(url) {
    return url.match(/^(.*?)\/?([^\/]+\.[^\/]+)?$/)[1] + "/";
  }
  Polymer({is:"iron-component-page", properties:{src:{type:String, observer:"_srcChanged"}, docSrc:{type:String, observer:"_srcChanged"}, base:{type:String, value:function() {
    return this.ownerDocument.baseURI.replace(/\#.*$/, "");
  }}, active:{type:String, notify:true, value:""}, view:{type:String, value:"docs", notify:true}, transitive:{type:Boolean, value:false}, docElements:{type:Array, notify:true, readOnly:true, value:function() {
    return [];
  }}, docBehaviors:{type:Array, notify:true, readOnly:true, value:function() {
    return [];
  }}, docDemos:{type:Array, notify:true, readOnly:true}, scrollMode:{type:String, value:"waterfall"}, _activeDescriptor:Object, _fragmentPrefix:String, catalog:{type:Boolean, value:false, reflectToAttribute:true}, version:String, _analyzer:{type:Object, observer:"_analyzerChanged"}, _hydroDesc:{type:Object, observer:"_detectAnalyzer"}, _ajaxDesc:{type:Object, observer:"_detectAnalyzer"}, _loading:{type:Boolean, observer:"_loadingChanged"}, _hydroLoading:{type:Boolean, observer:"_detectLoading"}, 
  _ajaxLoading:{type:Boolean, observer:"_detectLoading"}, _demoUrl:{type:String, value:""}, _srcUrl:String}, observers:["_updateFrameSrc(view, base)", "_activeChanged(active, _analyzer)"], attached:function() {
    if (!this.catalog) {
      this._setActiveFromHash();
      this.listen(window, "hashchange", "_setActiveFromHash");
    }
  }, detached:function() {
    if (!this.catalog) {
      this.unlisten(window, "hashchange", "_setActiveFromHash");
    }
  }, ready:function() {
    var elements = this._loadJson();
    if (elements) {
      this.docElements = elements;
      this._loading = false;
    } else {
      if (!this.src && !this.catalog) {
        this._srcChanged();
      }
    }
  }, _getVisableElements:function(allElements) {
    var ret = [];
    for (var i = 0; i < allElements.length; i++) {
      var doc = allElements[i];
      console.log("is:", doc.is + " -> " + doc.show);
      if (doc.show) {
        ret.push({is:doc.is});
      }
    }
    return ret;
  }, _loadJson:function() {
    var textContent = "";
    Array.prototype.forEach.call(Polymer.dom(this).childNodes, function(node) {
      textContent = textContent + node.textContent;
    });
    textContent = textContent.trim();
    if (textContent === "") {
      return null;
    }
    try {
      var json = JSON.parse(textContent);
      if (!Array.isArray(json)) {
        return [];
      }
      return json;
    } catch (error) {
      console.error("Failure when parsing JSON:", textContent, error);
      throw error;
    }
  }, _setActiveFromHash:function(hash) {
    return;
    var hash = window.location.hash;
    if (hash) {
      var elementDelimiter = hash.indexOf(":");
      elementDelimiter = elementDelimiter == -1 ? hash.length : elementDelimiter;
      var el = hash.slice(1, elementDelimiter);
      if (this.active != el) {
        this.active = el;
      }
      this.$.viewer.scrollToAnchor(hash);
    }
  }, _srcChanged:function() {
    var srcUrl;
    if (this.docSrc) {
      if (!this.$.ajax.lastRequest || this.docSrc !== this.$.ajax.lastRequest.url && this.docSrc !== this._lastDocSrc) {
        this._ajaxLoading = true;
        this._ajaxDesc = null;
        this._activeDescriptor = null;
        this.$.ajax.generateRequest();
      }
      this._lastDocSrc = this.docSrc;
      return;
    } else {
      if (this.src) {
        srcUrl = (new URL(this.src, this.base)).toString();
      } else {
        var base = _baseUrl(this.base);
        srcUrl = (new URL(base.match(/([^\/]*)\/$/)[1] + ".html", base)).toString();
      }
    }
    var match = srcUrl.match(/([^\/\.]+)\.github\.io\/([^\/]+)\/?([^\/]*)$/);
    if (match) {
      srcUrl = "https://cdn.rawgit.com/" + match[1] + "/" + match[2] + "/master/" + match[3];
    }
    this._baseUrl = _baseUrl(srcUrl);
    this._srcUrl = srcUrl;
    if (!this._hydroLoading) {
      this.$.analyzer.analyze();
    }
  }, _updateFrameSrc:function(view) {
    if (!view || view.indexOf("demo:") !== 0) {
      return "about:blank";
    }
    var src = view.split(":")[1];
    var demoSrc = (new URL(src, this.base)).toString();
    var self = this;
    if (this._iframe) {
      Polymer.dom(this.$.demo).removeChild(this._iframe);
    }
    this._iframe = document.createElement("iframe");
    this._iframe.src = demoSrc;
    this._iframe.allowFullscreen = true;
    this._iframe.style.height = "0%";
    this._iframe.addEventListener("load", function() {
      var win = self._iframe.contentWindow;
      if (win.HTMLImports) {
        win.HTMLImports.whenReady(function() {
          if (win.Polymer) {
            win.Polymer.RenderStatus.afterNextRender(self, function() {
              self._iframe.style.height = "100%";
            });
          } else {
            self._iframe.style.height = "100%";
          }
        });
      } else {
        self._iframe.style.height = "100%";
      }
    });
    Polymer.dom(this.$.demo).appendChild(this._iframe);
  }, _getDefaultActive:function() {
    var matchedPage;
    var url = this._srcUrl || this.base;
    var mainFile = url.replace(_baseUrl(this.base), "");
    function findMatch(list) {
      for (var item, i = 0; i < list.length; i++) {
        item = list[i];
        if (item && item.contentHref && item.contentHref.indexOf(mainFile) > 0) {
          return item;
        }
      }
      return null;
    }
    matchedPage = findMatch(this.docElements) || findMatch(this.docBehaviors);
    if (matchedPage) {
      return matchedPage.is;
    } else {
      if (this.docElements.length > 0) {
        return this.docElements[0].is;
      } else {
        if (this.docBehaviors.length > 0) {
          return this.docBehaviors[0].is;
        }
      }
    }
    return null;
  }, _findDescriptor:function(name) {
    if (!this._analyzer) {
      return null;
    }
    var descriptor = this._analyzer.elementsByTagName[name];
    if (descriptor) {
      return descriptor;
    }
    for (var i = 0; i < this._analyzer.behaviors.length; i++) {
      if (this._analyzer.behaviors[i].is === name) {
        return this._analyzer.behaviors[i];
      }
    }
    return null;
  }, _activeChanged:function(active, analyzer) {
    if (active === "") {
      this.active = this._getDefaultActive();
      return;
    }
    this.async(function() {
      this.$.active.value = active;
    });
    if (analyzer && analyzer.elementsByTagName) {
      this.$.headerPanel.scroller.scrollTop = 0;
      this._activeDescriptor = this._findDescriptor(active);
      if (this._activeDescriptor) {
        var hasDemo;
        var demos = this._activeDescriptor.demos;
        if (this.view && demos && demos.length) {
          var parts = this.view.split(":");
          if (parts[0] == "demo") {
            if (parts[1]) {
              hasDemo = demos.some(function(d, i) {
                if (d.path == parts[1]) {
                  return true;
                }
              });
            }
            if (!hasDemo) {
              this.view = "demo:" + demos[0].path;
              hasDemo = true;
            }
          }
        }
        if (!hasDemo == undefined) {
          this.view = "docs";
        }
        if (this._activeDescriptor.is && !document.title) {
          document.title = this._activeDescriptor.is + " documentation";
        }
        if (this._activeDescriptor.is && !this.catalog) {
          this._fragmentPrefix = this._activeDescriptor.is + ":";
        } else {
          this._fragmentPrefix = "";
        }
        this.$.viewer.scrollToAnchor(window.location.hash);
      }
      this._setDocDemos(this._activeDescriptor ? this._activeDescriptor.demos : []);
    }
  }, _loadingChanged:function() {
    this.toggleClass("loaded", !this._loading);
  }, _detectLoading:function() {
    this._loading = this.docSrc ? this._ajaxLoading : this._hydroLoading;
  }, _analyzerChanged:function() {
    var analyzer = this._analyzer;
    this._setDocElements(analyzer && analyzer.elements ? analyzer.elements : []);
    this._setDocBehaviors(analyzer && analyzer.behaviors ? analyzer.behaviors : []);
    if (!this._findDescriptor(this.active)) {
      this.active = this._getDefaultActive();
    }
  }, _detectAnalyzer:function() {
    this._analyzer = this.docSrc ? this._ajaxDesc : this._hydroDesc;
  }, _handleMenuItemSelected:function(e) {
    if (e.target && e.target.value) {
      this.active = e.target.value;
    }
  }, _handleAjaxResponse:function(e, req) {
    this._ajaxLoading = false;
    this._ajaxLastUrl = req.url;
    this._ajaxDesc = req.response;
  }, _handleError:function(e) {
    this.fire("iron-component-page-error", e.detail);
  }, _handleComponentSelectedEvent:function(ev) {
    var descriptor = this._findDescriptor(ev.detail);
    if (!descriptor) {
      console.warn("Could not navigate to ", ev.detail);
    } else {
      this.active = ev.detail;
    }
  }, marshal:function() {
    var jsonText = JSON.stringify(this.docElements || [], null, "  ");
    return "<" + this.is + ">\n" + jsonText.replace(/</g, "&lt;").replace(/>/g, "&gt;") + "\n" + "</" + this.is + ">";
  }, _demoView:function(path) {
    return "demo:" + path;
  }, _viewType:function(view) {
    return view ? view.split(":")[0] : null;
  }});
})();

